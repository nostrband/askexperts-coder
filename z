=========================
type: file
file: package.json
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/package.json
include: always
{
  "name": "@welshman",
  "private": true,
  "version": "0.4.6",
  "workspaces": [
    "packages/*"
  ],
  "scripts": {
    "clean": "pnpm run -r clean",
    "build": "pnpm run -r build",
    "format": "eslint --fix .",
    "lint": "eslint .",
    "test": "vitest",
    "docs": "typedoc && vitepress build docs",
    "prepare": "husky"
  },
  "devDependencies": {
    "@eslint/js": "~9.23.0",
    "eslint": "~9.23.0",
    "eslint-config-prettier": "^10.1.1",
    "eslint-plugin-prettier": "~5.2.5",
    "fake-indexeddb": "^6.0.0",
    "globals": "~16.0.0",
    "happy-dom": "^17.4.4",
    "husky": "^9.1.7",
    "onchange": "^7.1.0",
    "prettier": "~3.5.3",
    "ts-node": "^10.9.2",
    "typedoc": "^0.28.2",
    "typedoc-plugin-markdown": "^4.6.1",
    "typedoc-vitepress-theme": "^1.1.2",
    "typescript": "~5.8.0",
    "typescript-eslint": "~8.29.0",
    "vitepress": "^1.6.3",
    "vitest": "^3.1.1"
  }
}


=========================
type: file
file: tsconfig.json
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/tsconfig.json
include: always
{
  "extends": "./tsconfig.build.json",

  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@welshman/*": ["packages/*/src"]
    },
    "noEmit": true
  }
}


=========================
type: file
file: README.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/README.md
include: always
# Welshman

A nostr toolkit focused on creating highly a configurable client system, extracted from the [Coracle](https://github.com/coracle-social/coracle) nostr client.

# Linking

If you're developing an application which requires changes to welshman, you'll need to use `npm link` to link the two. This is an annoying process, and is only supported if using `npm`.

- Clone welshman and the repository that depends on it
- Within each `package` directory in welshman, run `npm link`
- Within your application directory, link all welshman dependencies _simultaneously_ (or else only one will get linked. A command that does this is: `rm -rf node_modules; npm i; cat package.json|js '.dependencies|keys[]'|grep welshman|xargs npm link`.

If you run `npm install` in your application directory, you'll need to repeat the final step above. Finally, if you're using the `editor` module, you may run into some dependency version conflicts. I recommend editing the command above to exclude the editor.


=========================
type: file
file: docs/app/commands.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/app/commands.md
# Commands

Commands are functions which pull from app state to publish events on behalf of the user. Most are async and return a thunk

## Relay Management (NIP 65)

```typescript
removeRelay(url: string, mode: RelayMode): Promise<Thunk>
addRelay(url: string, mode: RelayMode): Promise<Thunk>
```

## Inbox Relay Management (NIP 17)

```typescript
removeInboxRelay(url: string): Promise<Thunk>
addInboxRelay(url: string): Promise<Thunk>
```

## Profile Management (NIP 01)

```typescript
setProfile(profile: Profile): Thunk
```

## Follow Management (NIP 02)

```typescript
unfollow(value: string): Promise<Thunk>
follow(tag: string[]): Promise<Thunk>
```

## Mute Management

```typescript
unmute(value: string): Promise<Thunk>
mutePublicly(tag: string[]): Promise<Thunk>
mutePrivately(tag: string[]): Promise<Thunk>
setMutes(options: {
  publicTags?: string[][]
  privateTags?: string[][]
}): Promise<Thunk>
```

## Pin Management

```typescript
unpin(value: string): Promise<Thunk>
pin(tag: string[]): Promise<Thunk>
```

## Wrapped Messages (NIP 59)

```typescript
type SendWrappedOptions = Omit<ThunkOptions, "event" | "relays"> & {
  template: EventTemplate
  pubkeys: string[]
}

sendWrapped(options: SendWrappedOptions): Promise<MergedThunk>
```

## Relay Management (NIP 86)

```typescript
manageRelay(url: string, request: ManagementRequest): Promise<Response>
```

## Room Management (NIP 29)

```typescript
createRoom(url: string, room: RoomMeta): Thunk
deleteRoom(url: string, room: RoomMeta): Thunk
editRoom(url: string, room: RoomMeta): Thunk
joinRoom(url: string, room: RoomMeta): Thunk
leaveRoom(url: string, room: RoomMeta): Thunk
```


=========================
type: file
file: docs/app/context.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/app/context.md
# Application Context

The `@welshman/app` package uses a global context system to configure a few core behaviors.

## Dufflepud

[Dufflepud](https://github.com/coracle-social/dufflepud) is a utility server that can retrieve NIP 05 profiles, zappers, relay metadata, link previews, etc. It's not necessary for using welshman, but can improve things by bypassing CORS.

```typescript
import {appContext} from '@welshman/app'

appContext.dufflepudUrl = 'https://my-dufflepud-instance.com'
```


=========================
type: file
file: docs/app/index.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/app/index.md
# @welshman/app

[![version](https://badgen.net/npm/v/@welshman/app)](https://npmjs.com/package/@welshman/app)

A comprehensive framework for building nostr clients, powering production applications like [Coracle](https://coracle.social) and [Flotilla](https://flotilla.social). It provides a complete toolkit for managing events, subscriptions, user data, and relay connections.

## What's Included

- **Repository** - Event storage and query capabilities
- **Router** - Intelligent relay selection for optimal network access
- **Feed Controller** - Manages feed loading
- **Session Management** - User identity and key management
- **Event Actions** - High-level operations like reacting, replying, etc.
- **Profile Management** - User profile handling and metadata
- **Relay Directory** - Discovery and management of relays
- **Web of Trust** - Utilities for building webs of trust

## Quick Example

```typescript
import {getNip07} from '@welshman/signer'
import {load, request, RequestEvent, defaultSocketPolicies, makeSocketPolicyAuth, Socket} from '@welshman/net'
import {StampedEvent, TrustedEvent, makeEvent, NOTE} from '@welshman/util'
import {pubkey, signer, publishThunk} from '@welshman/app'

// Log in via NIP 07
addSession({method: 'nip07', pubkey: await getNip07().getPubkey()})

// Enable automatic authentication to relays
defaultSocketPolicies.push(
  makeSocketPolicyAuth({
    sign: (event: StampedEvent) => signer.get()?.sign(event),
    shouldAuth: (socket: Socket) => true,
  }),
)

// This will fetch the user's profile automatically, and return a store that updates
// automatically. Several different stores exist that are ready to go, including handles,
// zappers, relaySelections, relays, follows, mutes.
const profile = deriveProfile(pubkey.get())

// Publish is done using thunks, which optimistically publish to the local database, deferring
// signing and publishing for instant user feedback. Progress is reported as relays accept/reject the event
// Events are automatically signed using the current session
const thunk = publishThunk({
  relays: Router.get().FromUser().getUrls(),
  event: makeEvent(NOTE, {content: "hi"}),
  delay: 3000,
})

// Thunks can be aborted until after `delay`, allowing for soft-undo
thunk.controller.abort()

// Some commands are included
const thunk = follow('97c70a44366a6535c145b333f973ea86dfdc2d7a99da618c40c64705ad98e322')

// Load events as a promise
const events = await load({
  relays: Router.get().ForUser().getUrls(),
  filters: [{kinds: [NOTE],
}])

// Or use `request` for more fine-grained subscription control
const abortController = new AbortController()

request({
  signal: abortController.signal,
  relays: Router.get().ForUser().getUrls(),
  filters: [{kinds: [NOTE],
  onEvent: (event: TrustedEvent) => {
    console.log(event)
  },
}])

// Close the request
abortController.abort()
```

## Installation

```bash
npm install @welshman/app
```


=========================
type: file
file: docs/app/making-requests.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/app/making-requests.md
# Making Requests

Welshman extends Nostr's base subscription model with intelligent caching, repository integration, and configurable behaviors.

## Key Concepts

- **Local Repository**: Events are automatically cached and tracked
- **Cache Intelligence**: Smart decisions about when to use cached data
- **Relay Integration**: Works with the router for optimal relay selection
- **Configurable Behavior**: Control caching and timeouts

## Request and Load

The base functionality for subscription management is implemented in `@welshman/net`. Please refer to [the documentation](/net) for that module for details.

## Collections and Loaders

The `collection` utility creates stores that handle caching, loading, and indexing of Nostr data. It provides a consistent pattern for managing entities that need to be fetched from the network and cached locally.

```typescript
const {
  indexStore,    // Map of all items by key
  deriveItem,    // Get reactive item by key
  loadItem       // Trigger network load
} = collection({
  name: "storeName",      // For persistence
  store: writable([]),    // Base store
  getKey: item => item.id // How to index items
  load: async (key) => {  // Network loader
    // Load logic here
  }
})
```

### Deriving Events

The best way to create collections is by deriving their contents from the app `repository` using `deriveEvents` from `@welshman/store`. For more control, use `deriveEventsMapped`.

```typescript
import {deriveEventsMapped} from "@welshman/store"

export const notes = deriveEvents<TrustedEvent>(repository, {filters: [{kinds: [NOTE]}]})
```

A collection could then be created by passing the `notes` store to `collection`.

### Available Collections

Several common collections are built-in and ready for use:

```typescript
// Profiles
profiles → profilesByPubkey → deriveProfile → loadProfile

// Lists
follows → followsByPubkey → deriveFollows → loadFollows
mutes → mutesByPubkey → deriveMutes → loadMutes
pins → pinsByPubkey → derivePins → loadPins

// Relays
relays → relaysByUrl → deriveRelay → loadRelay
relaySelections → relaySelectionsByPubkey → deriveRelaySelections → loadRelaySelections
inboxRelaySelections → inboxRelaySelectionsByPubkey → deriveInboxRelaySelections → loadInboxRelaySelections

// Identity
handles → handlesByNip05 → deriveHandle → loadHandle
zappers → zappersByLnurl → deriveZapper → loadZapper
```

### Example - Loading and Displaying Profiles

```typescript
import {get} from 'svelte/store'
import {displayProfile} from '@welshman/util'
import {deriveProfile, deriveProfileDisplay} from '@welshman/app'

// Subscribe to profile changes - this will automatically load the profile in the background
const profile = deriveProfile(pubkey)

// Display with fallback
const name = displayProfile(get(profile), 'unknown')

// Better: use built-in deriveProfileDisplay utility
const name = deriveProfileDisplay(pubkey)
```

### User-Specific Collections

Several modules provide user-specific derived stores that automatically load data for the currently signed-in user:

```typescript
import { userProfile, userFollows, userMutes, userPins } from '@welshman/app'

userProfile.subscribe(profile => {
  // Current user's profile data
})

userFollows.subscribe(follows => {
  // Current user's follow list
})
```

### Repository Integration

All events from subscriptions are automatically:

- Saved to the repository
- Tracked to their source relay
- Checked against deletion status

The repository serves as an intelligent cache layer, making subsequent queries for the same data faster.

## Feeds

A high-level feed loader utility is also provided, which combines application state with utilities from `@welshman/net` and `@welshman/feeds`.

```typescript
import {NOTE} from '@welshman/util'
import {makeKindFeed} from '@welshman/feeds'
import {createFeedController} from '@welshman/app'

const abortController = new AbortController()

let done = false

const ctrl = createFeedController({
  feed: makeKindFeed(NOTE),
  useWindowing: true,
  signal: abortController.signal,
  onEvent: e => {
    console.log(e)
  },
  onExhausted: () => {
    done = true
  },
})

// Load some notes
ctrl.load(100)

// Cancel any pending requests
abortController.abort()
```


=========================
type: file
file: docs/app/publishing-events.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/app/publishing-events.md
# Thunks

Thunks provide optimistic updates for event publishing. They immediately update the local repository while handling the actual signing and publishing asynchronously, making the UI feel more responsive.

## Overview

A thunk:

- Updates local state immediately
- Handles event signing in the background using the current session
- Tracks publish status per relay
- Supports soft-undo via abort
- Can be delayed/cancelled
- Tracks successful publishes

## Basic Usage

```typescript
import {publishThunk} from '@welshman/app'
import {createEvent, NOTE} from '@welshman/util'

const publish = async (content: string) => {
  // Get optimal relays for publishing
  const relays = ctx.app.router
    .FromUser()
    .getUrls()

  // Create and publish thunk
  const thunk = await publishThunk({
    event: createEvent(NOTE, {content}),
    relays,
    delay: 3000, // 3s window for abort
  })

  // Track publish status
  thunk.status.subscribe(statuses => {
    for (const [url, {status, message}] of Object.entries(statuses)) {
      console.log(`${url}: ${status} ${message}`)
    }
  })

  // Can abort within delay window
  setTimeout(() => {
    if (userWantsToCancel) {
      thunk.controller.abort()
    }
  }, 1000)

  // Wait for completion
  await thunk.result
}
```

## Built in commands

Several thunk factories are provided for common or more complicated scenarios like updating lists:

- `removeRelay(url: string, mode: RelayMode)`
- `addRelay(url: string, mode: RelayMode)`
- `removeInboxRelay(url: string)`
- `addInboxRelay(url: string)`
- `setProfile(profile: Profile)`
- `unfollow(value: string)`
- `follow(tag: string[])`
- `unmute(value: string)`
- `mute(tag: string[])`
- `unpin(value: string)`
- `pin(tag: string[])`
- `sendWrapped({template, pubkeys, ...options}: SendWrappedOptions)`
- `manageRelay(url: string, request: ManagementRequest)`
- `createRoom(url: string, room: RoomMeta)`
- `deleteRoom(url: string, room: RoomMeta)`
- `editRoom(url: string, room: RoomMeta)`
- `joinRoom(url: string, room: RoomMeta)`
- `leaveRoom(url: string, room: RoomMeta)`


=========================
type: file
file: docs/app/relay-selection.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/app/relay-selection.md
# Router

The Welshman router can be used to enable the `outbox model` in your Nostr application. It handles relay selection for reading, writing, and discovering events while considering relay quality, user preferences, and network conditions.

## Overview

The router provides scenarios for common **Nostr** operations:

- Reading user profiles
- Publishing events
- Following threads
- Handling DMs
- Searching content

Each scenario considers:

- User's relay preferences (NIP-65)
- Event hints in tags
- Relay quality scores
- Fallback policies
- Connection status

## Basic Usage

```typescript
import {routerContext, addMaximalFallbacks, Router} from '@welshman/app'

// Set up global router options
routerContext.getDefaultRelays = () => ["wss://relay.damus.io/", "wss://nos.lol/"]

// Router can be used directly with options, or via a singleton with global options
const router = Router.get()

// Get relays for reading a profile
const readRelays = router.ForPubkey(pubkey).getUrls()

// Get relays for broadcasting events by the current user
const writeRelays = router.FromUser().getUrls()

// Get relays for a quote
const quoteRelays = Router.get()
  .Quote(parentEvent, idOrAddress, relayHints)
  .policy(addMaximalFallbacks)
  .getUrls()

```

## Router Features

- Smart relay selection based on relay monitoring
- Quality scoring of relays
- Fallback strategies
- Handling of special relay types (.onion, local)
- NIP-65 support

The router is central to efficient nostr operations, ensuring events reach their intended audience while minimizing unnecessary network traffic.


=========================
type: file
file: docs/app/session.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/app/session.md
# Session Management

The session system provides a unified way to handle different authentication methods:

- NIP-01 via Secret Key
- NIP-07 via Browser Extension
- NIP-46 via Bunker URL or Nostrconnect
- NIP-55 via Android Signer Application
- Read-only pubkey login

## Overview

Sessions are stored in local storage and can be:

- Persisted across page reloads
- Used with multiple accounts
- Switched dynamically
- Backed by different signing methods

## NIP 01 Example

The simplest type of login is NIP 01, although it's generally a bad idea to be handling user keys. NIP 46, 44, or 07 login are preferable. However, NIP 01 can be useful for supporting signup, local profiles, or ephemeral keys.

```typescript
import {makeSecret} from '@welshman/signer'
import {loginWithNip01} from '@welshman/app'

loginWithNip01(makeSecret())
```

## NIP 07 Example

A simple way to sign in for desktop browser users is using [NIP 07](https://github.com/nostr-protocol/nips/blob/master/07.md). This method is easy to implement, but should be used sparingly, since not all users will be using a browser with a nostr signing extension installed.

```typescript
import {Nip07Signer} from '@welshman/signer'
import {loginWithNip07} from '@welshman/app'

const signer = new Nip07Signer()

signer.getPubkey().then(pubkey => {
  if (pubkey) {
    loginWithNip07(pubkey)
  } else {
    // User extension does not exist or did not respond
  }
})
```

## NIP-46 Authentication

The best default signing scheme is [NIP 46](https://github.com/nostr-protocol/nips/blob/master/46.md), AKA "Nostr Connect". This supports multiple handshakes depending on desired UX, and can support advanced use cases like secure enclaves, self-hosted keys, and FROST multisig.

The simpler `bunker://` handshake is done by asking the user to provide a bunker URL, either by QR code, or by pasting it manually into your application.

```typescript
import {Nip46Broker, makeSecret} from "@welshman/signer"
import {loginWithNip46, nip46Perms} from "@welshman/app"
import {isKeyValid} from "src/util/nostr"

// Make a client secret - this is distinct from the user's private key, and is used
// for communicating securely with the remote signer
const clientSecret = makeSecret()

// Ask the user to input their bunker URL
const bunkerUrl = prompt("Please enter your bunker url")

// Pase the bunker url
const {signerPubkey, connectSecret, relays} = Nip46Broker.parseBunkerUrl(bunkerUrl)

if (!isKeyValid(signerPubkey)) {
  alert("Sorry, but that's an invalid public key.")
} else if (relays.length === 0) {
  alert("That connection string doesn't have any relays.")
} else {
  // Open up a connection with the signer
  const broker = Nip46Broker.get({relays, clientSecret, signerPubkey})

  // Send a connect request with the default permissions
  const result = await broker.connect(connectSecret, nip46Perms)

  // Make sure to check the connect secret to prevent hijacking
  if (result === connectSecret) {
    // Get the user's public key
    const pubkey = await broker.getPublicKey()

    if (!pubkey) {
      alert("Failed to initialize session")
    } else {
      loginWithNip46(pubkey, clientSecret, signerPubkey, relays)
    }
  }
}
```

Alternatively, you can provide the user with a `nostrconnect://` URL which they can copy or scan with their signer. This is a better UX for users using a signer on their mobile phone.

```typescript
import {Nip46Broker, makeSecret} from "@welshman/signer"
import {loginWithNip46, nip46Perms} from "@welshman/app"

// Create a client secret
const clientSecret = makeSecret()

// Stop listening if the user cancels login
const abortController = new AbortController()

// Customize to use relays the signer can send responses to
const relays = ['wss://relay.nsec.app/']

// Create a broker
const broker = Nip46Broker.get({clientSecret, relays})

// Create a nostrconnect:// url
const nostrconnect = await broker.makeNostrconnectUrl({
  name: "My App",
  url: window.origin,
  image: window.origin + '/logo.png',
  perms: nip46Perms,
})

// Share it with the user. Displaying a QR code is particularly helpful
alert("To connect, paste this URL into your signer: " + nostrconnect)

// Listen for the response
let response
try {
  response = await broker.waitForNostrconnect(nostrconnect, abortController.signal)
} catch (errorResponse: any) {
  if (errorResponse?.error) {
    alert(`Received error from signer: ${errorResponse.error}`)
  } else if (errorResponse) {
    console.error(errorResponse)
  }
}

// If we got a response, the broker is already connected and we can log in
if (response) {
  const pubkey = await broker.getPublicKey()

  if (!pubkey) {
    alert("Failed to initialize session")
  } else {
    loginWithNip46(pubkey, clientSecret, response.event.pubkey, relays)
  }
}
```

## NIP-55 Authentication

For the best UX on Android, use [NIP 55](https://github.com/nostr-protocol/nips/blob/master/55.md). Note that this only works for web applications that have been compiled to native Android applications using [CapacitorJS](https://capacitorjs.com/) and [nostr-signer-capacitor-plugin](https://github.com/chebizarro/nostr-signer-capacitor-plugin).

```typescript
import {getNip55, Nip55Signer, loginWithNip55} from "@welshman/signer"

// Query for installed apps that implement nip 55 signing
getNip55().then(signerApps => {
  // We'll choose the first one and auto-login, but in most cases you'll want to offer a choice
  if (signerApps.length > 0) {
    const signer = new Nip55Signer(signerApps[0].packageName)
    const pubkey = await signer.getPubkey()

    if (pubkey) {
      loginWithNip55(pubkey, app.packageName)
    }
  }
})
```

## Read-only session

A fun feature of nostr is that you can log in as other people, and see what nostr is like from their perspective (minus encrypted data or course).

```typescript
import {loginWithPubkey} from "@welshman/signer"

// Log in as hodlbod
loginWithPubkey("97c70a44366a6535c145b333f973ea86dfdc2d7a99da618c40c64705ad98e322")
```

## Using the current session

```typescript
import {signer, session} from '@welshman/app'
import {createEvent, NOTE} from '@welshman/util'

// Print the current session - be aware the private key is stored in memory, be very
// careful about how you handle session objects!
console.log(session.get())

// Current session's signer is always ready to use
const event = await signer.get().sign(
  createEvent(NOTE, {content: "Hello Nostr!"})
)

// hodlbod's pubkey
const otherPubkey = "97c70a44366a6535c145b333f973ea86dfdc2d7a99da618c40c64705ad98e322"

// Encrypt content for private notes
const ciphertext = await signer.get().nip44.encrypt(otherPubkey, "Secret message")

// Decrypt automatically detects encryption version
const plaintext = await decrypt(signer, otherPubkey, ciphertext)
```

## Multiple sessions

It's possible to support multiple concurrent sessions by simply calling `addSession` multiple times. This will update `sessions`, and set `pubkey` to the most recently added session. You can then switch between sessions by calling `pubkey.set` with a valid session pubkey, and delete sessions using `dropSession(pubkey)`.


=========================
type: file
file: docs/app/storage.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/app/storage.md
# Storage

The storage system provides IndexedDB persistence for stores and repositories.

Initialize this early in your application lifecycle to ensure data consistency.

```typescript
import {initStorage, defaultStorageAdapters} from '@welshman/app'

// Use default storage adapters, which track important metadata events,
// relays, handles, zappers, etc.
await initStorage("my-db", 1, {
  ...defaultStorageAdapters,
  custom: {
    keyPath: "key",
    init: async () => console.log(await getAll("custom")),
    sync: () => {
      // Set up a listener for changes, using bulkPut to save records.
      // Return an unsubscribe function for cleanup
    },
  },
})
```

The storage system:

- Persists data across page reloads
- Throttles writes for performance
- Syncs bidirectionally
- Supports custom adapters

Initialize storage before making any subscriptions or loading data to ensure proper caching behavior.


=========================
type: file
file: docs/app/tags.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/app/tags.md
# Tag Utilities

The tag utilities provide helper functions for creating properly formatted Nostr event tags with correct relay hints and metadata.

These are especially useful when creating events that reference other events or users.

## Tag Creators

### Pubkey Tags

```typescript
import {tagPubkey} from '@welshman/app'

// Create a p-tag with relay hint and profile name
const tag = tagPubkey(authorPubkey)
// => ["p", pubkey, "wss://relay.example.com", "username"]
```


### Event Reference Tags

```typescript
import {
  tagEvent,              // Basic event reference
  tagEventForQuote,      // For quoting events
  tagEventForReply,      // For reply threads
  tagEventForComment,    // For NIP-22 comments
  tagEventForReaction    // For reactions
} from '@welshman/app'

// Real world example: Creating a reply
const createReply = async (parent: TrustedEvent, content: string) => {
  // Get proper tags for a reply, including:
  // - All referenced pubkeys
  // - Root/reply markers
  // - Inherited mentions
  // - Relay hints
  const tags = tagEventForReply(parent)

  return publishThunk({
    // Use relay hints from tags
    relays: Router.get().PublishEvent(event).getUrls()
    event: await signer.get().sign(createEvent(NOTE, {content, tags})),
  })
}
```


=========================
type: file
file: docs/app/user.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/app/user.md
# User Data Loading

The User Data module provides utilities for loading and managing user-specific data like profiles, follows, mutes, pins, and relay selections. It includes both reactive stores and manual loading functions.

## Types

### UserDataLoader
```typescript
type UserDataLoader = (pubkey: string, relays?: string[], force?: boolean) => unknown
```

Function type for loading user data with optional relay specification and force refresh.

### MakeUserDataOptions
```typescript
type MakeUserDataOptions<T> = {
  mapStore: Readable<Map<string, T>>
  loadItem: UserDataLoader
}
```

Configuration for creating user data stores.

## User Data Stores

These reactive stores automatically load and cache user data:

```typescript
// User profile
export const userProfile: Store<Profile | undefined>

// User follows list
export const userFollows: Store<List | undefined>

// User mutes list  
export const userMutes: Store<List | undefined>

// User pins list
export const userPins: Store<List | undefined>

// User relay selections
export const userRelaySelections: Store<List | undefined>

// User inbox relay selections
export const userInboxRelaySelections: Store<List | undefined>

// User blossom servers
export const userBlossomServers: Store<List | undefined>
```

## Manual Loading Functions

These functions allow manual loading of user data with optional relay specification and force refresh:

```typescript
// Load user profile
function loadUserProfile(relays?: string[], force?: boolean): Promise<void>

// Load user follows
function loadUserFollows(relays?: string[], force?: boolean): Promise<void>

// Load user mutes
function loadUserMutes(relays?: string[], force?: boolean): Promise<void>

// Load user pins
function loadUserPins(relays?: string[], force?: boolean): Promise<void>

// Load user relay selections
function loadUserRelaySelections(relays?: string[], force?: boolean): Promise<void>

// Load user inbox relay selections
function loadUserInboxRelaySelections(relays?: string[], force?: boolean): Promise<void>

// Load user blossom servers
function loadUserBlossomServers(relays?: string[], force?: boolean): Promise<void>
```

## Usage Examples

### Using Reactive Stores
```typescript
import { userProfile, userFollows } from '@welshman/app'

// Subscribe to user profile changes
userProfile.subscribe(profile => {
  if (profile) {
    console.log('User profile:', profile)
  }
})

// Get current follows list
const follows = userFollows.get()
```

### Manual Loading
```typescript
import { loadUserMutes, loadUserRelaySelections } from '@welshman/app'

// Load user mutes from specific relays
await loadUserMutes(['wss://relay1.com', 'wss://relay2.com'])

// Force refresh user relay selections
await loadUserRelaySelections([], true)

// Load from default relays
await loadUserProfile()
```


=========================
type: file
file: docs/app/wot.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/app/wot.md
# Web of Trust (WOT)

Welshman provides utilities for implementing a Web of Trust system within Nostr applications. This system analyzes social connections (follows and mutes) to build a reputation graph that can be used for content filtering, user scoring, and discovery.

## Core Concepts

- **Follow Trust**: Users gain positive reputation when followed by those in your network
- **Mute Distrust**: Users lose reputation when muted by those in your network
- **WOT Graph**: A reactive weighted directed graph representing trust relationships
- **Contextual Scoring**: Reputation scores that adapt based on user's social graph

## API Reference

### Social Graph Navigation

```typescript
// Get users followed by a specific pubkey
getFollows(pubkey: string): string[]

// Get users who have muted a specific pubkey
getMutes(pubkey: string): string[]

// Get followers of a specific pubkey
getFollowers(pubkey: string): string[]

// Get users who have muted a specific pubkey
getMuters(pubkey: string): string[]

// Get the extended network (follows-of-follows) for a pubkey
getNetwork(pubkey: string): string[]
```

### Trust Analysis

```typescript
// Get follows of a user who also follow a target
getFollowsWhoFollow(pubkey: string, target: string): string[]

// Get follows of a user who have muted a target
getFollowsWhoMute(pubkey: string, target: string): string[]

// Calculate trust score between users
getWotScore(pubkey: string, target: string): number
```

### Reactive Stores

```typescript
// Map of follower lists by pubkey
followersByPubkey: Readable<Map<string, Set<string>>>

// Map of muter lists by pubkey
mutersByPubkey: Readable<Map<string, Set<string>>>

// The full WOT graph with scores (pubkey → score)
wotGraph: Readable<Map<string, number>>

// The maximum WOT score in the graph
maxWot: Readable<number>

// Derive the WOT score for a specific user
deriveUserWotScore(targetPubkey: string): Readable<number>
```


=========================
type: file
file: docs/content/index.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/content/index.md
# @welshman/content

[![version](https://badgen.net/npm/v/@welshman/content)](https://npmjs.com/package/@welshman/content)

A content processing library designed specifically for Nostr applications. It provides a simple system for parsing, processing, and rendering Nostr content.

## What's Included

- **Parsing**: Utilities for parsing nostr event content, as well as truncating and building image grids.
- **Rendering**: Basic rendering support for parsed nostr event content.

## Installation

```
npm install @welshman/content
```


=========================
type: file
file: docs/content/parser.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/content/parser.md
# Content Parser

The content parser system in `@welshman/content` provides utilities for parsing Nostr content into structured elements.

## Core Types

### ParsedType Enum

Defines all supported content types:
- `Address` - naddr references to parameterized replaceable events
- `Cashu` - Cashu token strings
- `Code` - Code blocks and inline code
- `Ellipsis` - Truncation indicators
- `Emoji` - Custom emoji references
- `Event` - Event references (note/nevent)
- `Invoice` - Lightning invoices
- `Link` - HTTP/HTTPS URLs
- `LinkGrid` - Collections of adjacent links
- `Newline` - Line breaks
- `Profile` - Profile references (npub/nprofile)
- `Text` - Plain text content
- `Topic` - Hashtags

## Main Functions

### parse(options)

Main parsing function that processes content into structured elements:

```typescript
parse({content?: string, tags?: string[][]}) => Parsed[]
```

Takes content string and optional tags array, returns array of parsed elements. Uses tags for emoji lookup and imeta information.

### truncate(content, options)

Truncates parsed content to specified length limits:

```typescript
truncate(content: Parsed[], {
  minLength?: number,     // 500 - minimum before truncating
  maxLength?: number,     // 700 - maximum total length
  mediaLength?: number,   // 200 - assumed size for media
  entityLength?: number   // 30 - assumed size for entities
}) => Parsed[]
```

### reduceLinks(content)

Combines adjacent links into `LinkGrid` elements for better presentation:

```typescript
reduceLinks(content: Parsed[]) => Parsed[]
```

## Type Guards

Utility functions to check parsed element types:
- `isAddress(parsed)`, `isCashu(parsed)`, `isCode(parsed)`, etc.
- `isImage(parsed)` - special check for image links

## Utilities

- `urlIsMedia(url)` - Checks if URL points to media file
- `fromNostrURI(s)` - Removes nostr: protocol prefix

## Example Usage

```typescript
import { parse, truncate, reduceLinks } from '@welshman/content'

const content = `Check out this cool #nostr client!
https://github.com/coracle-social/welshman
https://welshman.coracle.social
Visit npub1jlrs53pkdfjnts29kveljul2sm0actt6n8dxrrzqcersttvcuv3qdjynqn for more info`

// Parse the content into structured elements
const parsed = parse({ content })

// Combine adjacent links into grids
const withLinkGrids = reduceLinks(parsed)

// Truncate to reasonable length for preview
const truncated = truncate(withLinkGrids, {
  minLength: 100,
  maxLength: 200
})

// Result contains structured elements:
// - Text: "Check out this cool "
// - Topic: "nostr"
// - Text: " client!\n"
// - LinkGrid: [github.com/..., welshman.coracle.social]
// - Text: "Visit "
// - Profile: npub1jlrs53pkdfjnts29kveljul2sm0actt6n8dxrrzqcersttvcuv3qdjynqn
// - Text: " for more info"
```


=========================
type: file
file: docs/content/render.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/content/render.md
# Content Renderer

The renderer system in `@welshman/content` provides utilities for converting parsed content into text or HTML output. It includes customizable rendering options and specialized handlers for each content type.

## Render Options

```typescript
type RenderOptions = {
  // String to use for newlines
  newline: string

  // Base URL for Nostr entities
  entityBase: string

  // Custom link rendering
  renderLink: (href: string, display: string) => string

  // Custom entity rendering
  renderEntity: (entity: string) => string

  // Custom function for creating an element
  createElement: (tag: string) => any
}
```

## Built-in Renderers

- `makeTextRenderer` - renders an array of `Parsed` elements as text
- `makeHtmlRenderer` - renders an array of `Parsed` elements as HTML

## Main Functions

- `render(parsed, renderer)` - Renders single or multiple parsed elements
- `renderAsText(parsed, options)` - Convenience function for text rendering
- `renderAsHtml(parsed, options)` - Convenience function for HTML rendering

## Example Usage

```typescript
import { parse, renderAsHtml } from '@welshman/content'

const content = `Check out this cool #nostr client!
Visit npub1jlrs53pkdfjnts29kveljul2sm0actt6n8dxrrzqcersttvcuv3qdjynqn for more info
https://github.com/coracle-social/welshman`

// Parse the content
const parsed = parse({ content })

// Render as HTML with custom options
const html = renderAsHtml(parsed, {
  entityBase: 'https://njump.me/',
  renderEntity: (entity) => entity.slice(0, 12) + '...',
  renderLink: (href, display) => `<a href="${href}" class="custom-link">${display}</a>`
}).toString()

// Result:
// Check out this cool #nostr client!<br>
// Visit <a href="https://njump.me/nprofile1...">npub1jlrs53p...</a> for more info<br>
// <a href="https://github.com/coracle-social/welshman" class="custom-link">github.com/coracle-social/welshman</a>
```


=========================
type: file
file: docs/editor/index.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/editor/index.md
# @welshman/editor

[![version](https://badgen.net/npm/v/@welshman/editor)](https://npmjs.com/package/@welshman/editor)

`@welshman/editor` provides a comprehensive Nostr-ready text editor, built on top of [nostr-editor](https://github.com/cesardeazevedo/nostr-editor).

This package powers the editors of [Coracle](https://coracle.social) and [Flotilla](https://flotilla.social).

## Installation

```bash
npm install @welshman/editor
```

## Example

```typescript
import {get} from "svelte/store"
import type {Writable} from "svelte/store"
import type {NodeViewProps} from "@tiptap/core"
import {Router} from "@welshman/router"
import {removeNil} from "@welshman/lib"
import type {FileAttributes} from "@welshman/editor"
import {Editor, MentionSuggestion, WelshmanExtension} from "@welshman/editor"
import {profileSearch, deriveProfileDisplay} from "@welshman/app"

export const MentionNodeView = ({node}: NodeViewProps) => {
  const dom = document.createElement("span")
  const display = deriveProfileDisplay(node.attrs.pubkey, removeNil([url]))

  dom.classList.add("tiptap-object")

  const unsubDisplay = display.subscribe($display => {
    dom.textContent = "@" + $display
  })

  return {
    dom,
    destroy: () => {
      unsubDisplay()
    },
    selectNode() {
      dom.classList.add("tiptap-active")
    },
    deselectNode() {
      dom.classList.remove("tiptap-active")
    },
  }
}

export const makeEditor = async ({
  content = "",
  submit,
  uploading,
  charCount,
  wordCount,
}: {
  content?: string
  submit: () => void
  uploading?: Writable<boolean>
  charCount?: Writable<number>
  wordCount?: Writable<number>
}) => {
  return new Editor({
    content, // Initial content, either a string or editor JSON
    autofocus: true,
    element: document.createElement("div"),
    extensions: [
      WelshmanExtension.configure({
        submit,
        extensions: {
          placeholder: {
            config: {
              placeholder: "What's up?",
            },
          },
          breakOrSubmit: {
            config: {
              aggressive: true, // If this is a chat-type interface
            },
          },
          fileUpload: {
            config: {
              upload: async (attrs: FileAttributes) => {
                const server = "https://cdn.satellite.earth"

                try {
                  let {uploaded, url, ...task} = await uploadFile(server, attrs.file)

                  if (!uploaded) {
                    return {error: "Server refused to process the file"}
                  }

                  // Always append file extension if missing
                  if (new URL(url).pathname.split(".").length === 1) {
                    url += "." + attrs.file.type.split("/")[1]
                  }

                  const result = {...task, url, tags: []}

                  return {result}
                } catch (e) {
                  return {error: e.toString()}
                }
              },
              onDrop() {
                uploading?.set(true)
              },
              onComplete() {
                uploading?.set(false)
              },
              onUploadError(currentEditor, task) {
                currentEditor.commands.removeFailedUploads()
                alert("Failed to upload file")
                uploading?.set(false)
              },
            },
          },
          nprofile: {
            extend: {
              addNodeView: () => MentionNodeView,
              addProseMirrorPlugins() {
                return [
                  MentionSuggestion({
                    editor: (this as any).editor,
                    search: (term: string) => get(profileSearch).searchValues(term),
                    getRelays: (pubkey: string) => Router.get().FromPubkeys([pubkey]).getUrls(),
                    createSuggestion: (value: string) => {
                      const target = document.createElement("div")

                      target.textContent = value

                      return target
                    },
                  }),
                ]
              },
            },
          },
        },
      }),
    ],
    onUpdate({editor}) {
      wordCount?.set(editor.storage.wordCount.words)
      charCount?.set(editor.storage.wordCount.chars)
    },
  })
}

// Create an editor
const editor = makeEditor({
  submit: async () => {
    const ed = await editor
    const content = ed.getText({blockSeparator: "\n"}).trim()
    const tags = ed.storage.nostr.getEditorTags()
    const event = makeEvent(NOTE, {content, tags})

    await publish({event, relays: [/* ... */]})

    ed.chain().clearContent().run()
  },
})

// This is how you trigger file uploading
const uploadFiles = () => editor.then(ed => ed.chain().selectFiles().run())
```


=========================
type: file
file: docs/feeds/compiler.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/feeds/compiler.md
# Feed Compiler

The `FeedCompiler` class transforms feed definitions into optimized `RequestItem[]` arrays containing filters and relay selections for efficient event fetching.

## Types

```typescript
export type FeedCompilerOptions = {
  signer?: ISigner
  signal?: AbortSignal
  context?: AdapterContext
  getPubkeysForScope: (scope: Scope) => string[]
  getPubkeysForWOTRange: (minWOT: number, maxWOT: number) => string[]
}
```

## FeedCompiler Class

```typescript
export class FeedCompiler {
  constructor(readonly options: FeedCompilerOptions)

  // Check if a feed can be compiled
  canCompile(feed: Feed): boolean

  // Compile a feed into request items
  async compile(feed: Feed): Promise<RequestItem[]>
}
```

## Compilation Logic

### Basic Feed Types

- **ID feeds** → `{filters: [{ids: [...]}]}`
- **Kind feeds** → `{filters: [{kinds: [...]}]}`
- **Author feeds** → `{filters: [{authors: [...]}]}`
- **Tag feeds** → `{filters: [{[key]: [...values]}]}`
- **Address feeds** → Converts to ID filters using `getIdFilters()`
- **Relay feeds** → `{relays: [...urls]}`
- **Global feeds** → `{filters: [{}]}`

### Time-based Feeds

- **CreatedAt feeds** → Processes `since`/`until` with optional relative timestamps
- **Scope feeds** → Resolves to author filters using `getPubkeysForScope()`
- **WOT feeds** → Resolves to author filters using `getPubkeysForWOTRange()`
- **Search feeds** → `{filters: [{search: "term"}]}`

### Complex Feed Types

- **DVM feeds** → Requests DVM responses and converts result tags to feeds
- **List feeds** → Fetches list events and converts their tags to feeds
- **Label feeds** → Fetches label events (kind 1985) and converts tags to feeds

### Set Operations

- **Union feeds** → Merges all sub-feed results, optimizing by relay
- **Intersection feeds** → Finds overlapping filters and relays across sub-feeds

## Usage

```typescript
import { FeedCompiler, makeAuthorFeed, makeKindFeed } from '@welshman/feeds'

const compiler = new FeedCompiler({
  getPubkeysForScope: (scope) => [...], // Your scope resolution logic
  getPubkeysForWOTRange: (min, max) => [...], // Your WOT logic
  context: adapterContext,
  signal: abortSignal
})

// Compile a simple feed
const feed = makeAuthorFeed("pubkey1", "pubkey2")
const requests = await compiler.compile(feed)
// => [{filters: [{authors: ["pubkey1", "pubkey2"]}]}]

// Check if feed can be compiled
if (compiler.canCompile(feed)) {
  const requests = await compiler.compile(feed)
}
```


=========================
type: file
file: docs/feeds/controller.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/feeds/controller.md
# Feed Controller

The `FeedController` class manages feed execution with advanced loading strategies including pagination, windowing, and set operations. It compiles feeds into requests and handles event streaming with deduplication.

## Types

```typescript
export type FeedControllerOptions = FeedCompilerOptions & {
  feed: Feed
  tracker?: Tracker
  onEvent?: (event: TrustedEvent) => void
  onExhausted?: () => void
  useWindowing?: boolean
}
```

## FeedController Class

```typescript
export class FeedController {
  compiler: FeedCompiler

  constructor(readonly options: FeedControllerOptions)

  // Get compiled request items (memoized)
  getRequestItems(): Promise<RequestItem[] | undefined>

  // Get loader function (memoized)
  getLoader(): Promise<(limit: number) => Promise<void>>

  // Load events with specified limit
  load(limit: number): Promise<void>

  // Get listener function (memoized)
  getListener(): Promise<() => Promise<void>>

  // Listen for new events in the feed
  listen(): Promise<void>
}
```

## Loading Strategies

### Request-based Loading

For feeds that can be compiled to `RequestItem[]`:
- **Pagination**: Automatically handles `since`/`until` windowing
- **Deduplication**: Prevents duplicate events across multiple requests
- **Exhaustion tracking**: Detects when all requests are exhausted

### Set Operation Loading

For feeds requiring special handling:

#### Union Feeds
- Loads events from all sub-feeds in parallel
- Deduplicates events by ID across sub-feeds
- Signals exhaustion when all sub-feeds are exhausted

#### Intersection Feeds
- Loads events from all sub-feeds in parallel
- Only emits events that appear in ALL sub-feeds
- Uses count tracking to determine intersection

#### Difference Feeds
- Loads events from first feed (included) and remaining feeds (excluded)
- Emits events from first feed that don't appear in other feeds
- Maintains skip set for excluded events

## Windowing Strategy

When `useWindowing: true`:
- **Initial window**: Starts from recent events with estimated delta
- **Exponential backoff**: Increases window size when few events found
- **Timeline traversal**: Moves backward through time systematically
- **Performance optimization**: Gets recent events first

Windowing is best used when you don't trust relays to give you results ordered by `created_at` descending. Windowing should not be used when treating relays as algorithm feeds.

## Usage

```typescript
import { FeedController, makeAuthorFeed } from '@welshman/feeds'

const controller = new FeedController({
  feed: makeAuthorFeed("pubkey1", "pubkey2"),
  useWindowing: true,
  onEvent: (event) => console.log('New event:', event.id),
  onExhausted: () => console.log('No more events'),
  getPubkeysForScope: (scope) => [...],
  getPubkeysForWOTRange: (min, max) => [...]
})

// Load first batch of events
await controller.load(50)

// Load more events
await controller.load(50)

// Listen for new events
const unlisten = controller.listen()

// Unsubscribe from listener
unlisten()
```


=========================
type: file
file: docs/feeds/core.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/feeds/core.md
# Feed Core Types

Core type definitions for the feed system, providing structured ways to query and filter Nostr events.

## Feed Types

```typescript
export enum FeedType {
  Address = "address",
  Author = "author", 
  CreatedAt = "created_at",
  DVM = "dvm",
  Difference = "difference",
  ID = "id",
  Intersection = "intersection",
  Global = "global",
  Kind = "kind",
  List = "list",
  Label = "label",
  WOT = "wot",
  Relay = "relay",
  Scope = "scope",
  Search = "search",
  Tag = "tag",
  Union = "union",
}

export enum Scope {
  Followers = "followers",
  Follows = "follows",
  Network = "network",
  Self = "self",
}
```

## Item Types

```typescript
export type DVMItem = {
  kind: number
  tags?: string[][]
  relays?: string[]
  mappings?: TagFeedMapping[]
}

export type ListItem = {
  addresses: string[]
  mappings?: TagFeedMapping[]
}

export type LabelItem = {
  relays?: string[]
  authors?: string[]
  [key: `#${string}`]: string[]
  mappings?: TagFeedMapping[]
}

export type WOTItem = {
  min?: number
  max?: number
}

export type CreatedAtItem = {
  since?: number
  until?: number
  relative?: string[]
}

export type RequestItem = {
  relays?: string[]
  filters?: Filter[]
}
```

## Feed Definitions

```typescript
export type AddressFeed = [type: FeedType.Address, ...addresses: string[]]
export type AuthorFeed = [type: FeedType.Author, ...pubkeys: string[]]
export type CreatedAtFeed = [type: FeedType.CreatedAt, ...items: CreatedAtItem[]]
export type DVMFeed = [type: FeedType.DVM, ...items: DVMItem[]]
export type DifferenceFeed = [type: FeedType.Difference, ...feeds: Feed[]]
export type IDFeed = [type: FeedType.ID, ...ids: string[]]
export type IntersectionFeed = [type: FeedType.Intersection, ...feeds: Feed[]]
export type GlobalFeed = [type: FeedType.Global, ...feeds: Feed[]]
export type KindFeed = [type: FeedType.Kind, ...kinds: number[]]
export type ListFeed = [type: FeedType.List, ...items: ListItem[]]
export type LabelFeed = [type: FeedType.Label, ...items: LabelItem[]]
export type WOTFeed = [type: FeedType.WOT, ...items: WOTItem[]]
export type RelayFeed = [type: FeedType.Relay, ...urls: string[]]
export type ScopeFeed = [type: FeedType.Scope, ...scopes: Scope[]]
export type SearchFeed = [type: FeedType.Search, ...searches: string[]]
export type TagFeed = [type: FeedType.Tag, key: string, ...values: string[]]
export type UnionFeed = [type: FeedType.Union, ...feeds: Feed[]]

export type Feed = /* union of all feed types */
```


=========================
type: file
file: docs/feeds/index.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/feeds/index.md
# @welshman/feeds

[![version](https://badgen.net/npm/v/@welshman/feeds)](https://npmjs.com/package/@welshman/feeds)

A package for building and executing dynamic Nostr feeds which provides a declarative way to define complex feed compositions using set operations (union, intersection, difference) and various filtering mechanisms.

Read the spec on [the NIPs repository](https://github.com/nostr-protocol/nips/blob/af4329986cae9b0ef625a01c8cefd5e802ca6895/fe.md).

## What's Included

- **Feed Core** - Declarative feed definition with composable operations
- **Feed Compiler** - Transforms feed definitions into optimized relay requests
- **Feed Controller** - Manages feed execution and event loading
- **Feed Utils** - Helper functions for creating and manipulating feeds
- **Feed Types** - Supports authors, kinds, tags, DVMs, lists, WOT, and more

## Quick Example

```javascript
// Define a feed using set operations
const feed = intersectionFeed(
  unionFeed(
    dvmFeed({
      kind: 5300,
      pubkey: '19b78ccfa7c5e31e6bacbb3f2a1703f64b62017702e584440bf29a7e16263e8c',
    }),
    listFeed("10003:19ba654f26afd4930fd3d51baf4e26f1413b7aeec7190cd6c0cdf4d2f14cec6b:"),
  )
  wotFeed({min: 0.1}),
  scopeFeed("global"),
)

// Create a controller, providing required context via FeedOptions
const controller = new FeedController({
  feed,
  request,
  requestDVM,
  getPubkeysForScope,
  getPubkeysForWOTRange,
  onEvent: event => console.log("Event", event),
  onExhausted: () => console.log("Exhausted"),
})

// Load notes using the feed
const events = await controller.load(10)
```

## Installation

```bash
npm install @welshman/feeds
```


=========================
type: file
file: docs/feeds/utils.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/feeds/utils.md
# Feed Utilities

The utils module provides helper functions for creating, type-checking, and manipulating feed definitions. It includes factory functions, type guards, feed transformation utilities, and feed traversal tools.

## Feed Factory Functions

Create strongly-typed feed definitions:

```typescript
// Basic Feeds
const authors = makeAuthorFeed("pubkey1", "pubkey2")
const kinds = makeKindFeed(1, 6)
const search = makeSearchFeed("bitcoin", "nostr")
const global = makeGlobalFeed()

// Time-based Feeds
const recent = makeCreatedAtFeed({
  since: Date.now() - 86400000,
  relative: ["since"]
})

// Advanced Feeds
const dvm = makeDVMFeed({
  kind: 5300,
  mappings: [["p", [FeedType.Author]]]
})

const list = makeListFeed({
  addresses: ["list_id"],
  mappings: [["t", [FeedType.Tag, "#t"]]]
})

// Set Operations
const union = makeUnionFeed(authors, kinds)
const intersection = makeIntersectionFeed(authors, recent)
const difference = makeDifferenceFeed(global, authors)
```

## Type Guards

Check feed types safely:

```typescript
const feed: Feed = makeDVMFeed({ kind: 5300 })

if (isDVMFeed(feed)) {
  // feed is now typed as DVMFeed
  const [item] = getFeedArgs(feed)
  const kind = item.kind
}

if (hasSubFeeds(feed)) {
  // feed is now typed as UnionFeed | IntersectionFeed | DifferenceFeed
  const subFeeds = getFeedArgs(feed)
}
```

## Feed Transformations

### Tag to Feed Conversion

```typescript
// Default tag mappings
const defaultTagFeedMappings: TagFeedMapping[] = [
  ["a", [FeedType.Address]],   // address tags
  ["e", [FeedType.ID]],        // event references
  ["p", [FeedType.Author]],    // people/pubkeys
  ["r", [FeedType.Relay]],     // relay URLs
  ["t", [FeedType.Tag, "#t"]], // hashtags
]

// Convert event tags to feeds
const tags = [["p", "pubkey1"], ["t", "bitcoin"]]
const feeds = feedsFromTags(tags)
// => [[FeedType.Author, "pubkey1"], [FeedType.Tag, "#t", "bitcoin"]]

// Convert tags to a single intersection feed
const feed = feedFromTags(tags)
// => [FeedType.Intersection, [FeedType.Author, "pubkey1"], [FeedType.Tag, "#t", "bitcoin"]]
```

### Filter to Feed Conversion

```typescript
// Convert a single filter to feeds
const filter = {
  kinds: [1],
  authors: ["pubkey1"],
  "#t": ["bitcoin"],
  since: 1234567890
}

const feeds = feedsFromFilter(filter)
// => [
//   [FeedType.CreatedAt, { since: 1234567890 }],
//   [FeedType.Kind, 1],
//   [FeedType.Author, "pubkey1"],
//   [FeedType.Tag, "#t", "bitcoin"]
// ]

// Convert a filter to an intersection feed
const feed = feedFromFilter(filter)

// Convert multiple filters to a union feed
const feeds = feedFromFilters([filter1, filter2])
```

## Feed Traversal

Walk through a feed tree and visit each node:

```typescript
const feed = makeIntersectionFeed(
  makeAuthorFeed("pubkey1"),
  makeUnionFeed(
    makeKindFeed(1),
    makeTagFeed("#t", "bitcoin")
  )
)

walkFeed(feed, (node) => {
  console.log(`Visiting feed of type: ${node[0]}`)
})
```

Find a specific feed in a feed tree:

```typescript
const feed = makeIntersectionFeed(
  makeAuthorFeed("pubkey1"),
  makeUnionFeed(
    makeKindFeed(1),
    makeTagFeed("#t", "bitcoin")
  )
)

// Find a feed matching a specific condition
const bitcoinTagFeed = findFeed(feed, (f) =>
  isTagFeed(f) && getFeedArgs(f)[1] === "bitcoin"
)
```

## Feed Simplification

Flatten nested feeds of the same type:

```typescript
// Simplifies nested feeds of the same type
export declare const simplifyFeed: (feed: Feed) => Feed

// Example: flatten nested union feeds
const nested = makeUnionFeed(
  makeAuthorFeed("pubkey1"),
  makeUnionFeed(makeKindFeed(1), makeKindFeed(6))
)

const simplified = simplifyFeed(nested)
// Result: [FeedType.Union, [FeedType.Author, "pubkey1"], [FeedType.Kind, 1], [FeedType.Kind, 6]]
```

## Type Extraction

Get typed arguments from feeds:

```typescript
function getFeedArgs(feed: IntersectionFeed): Feed[]
function getFeedArgs(feed: AuthorFeed): string[]
function getFeedArgs(feed: CreatedAtFeed): CreatedAtItem[]
function getFeedArgs(feed: WOTFeed): WOTItem[]
// ... and so on for each feed type

const feed = makeAuthorFeed("pubkey1", "pubkey2")
const pubkeys = getFeedArgs(feed) // => ["pubkey1", "pubkey2"]
```

## Best Practices

1. Use factory functions instead of raw arrays:
   ```typescript
   // Good
   const feed = makeAuthorFeed("pubkey1")

   // Avoid
   const feed = [FeedType.Author, "pubkey1"]
   ```

2. Use type guards for safe type narrowing:
   ```typescript
   if (isAuthorFeed(feed)) {
     const pubkeys = getFeedArgs(feed) // Properly typed
   }
   ```

3. Use feed transformations for dynamic feed creation:
   ```typescript
   // Convert event tags to feeds
   const feeds = feedsFromTags(event.tags)

   // Convert filters to feeds
   const feed = feedFromFilter(filter)
   ```

4. Use feed traversal for analysis or transformation:
   ```typescript
   const kinds = new Set<number>()
   walkFeed(feed, (node) => {
     if (isKindFeed(node)) {
       getFeedArgs(node).forEach(k => kinds.add(k))
     }
   })
   ```


=========================
type: file
file: docs/getting-started.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/getting-started.md
# Getting Started

Welshman is modular - install only what you need:


```bash
# Core nostr utilities (events, filters, tags)
npm i @welshman/util

# In-memory event store and relay adapter
npm i @welshman/relay

# Networking and relay management
npm i @welshman/net

# Event signing and encryption
npm i @welshman/signer

# Dynamic feed compilation
npm i @welshman/feeds

# Content parsing and rendering
npm i @welshman/content

# Rich text editor component
npm i @welshman/editor

# Svelte stores and state management
npm i @welshman/store

# Complete application framework
npm i @welshman/app
```

Choose packages based on your needs:

- Building a conventional client? Use the framework:
  ```bash
  npm i @welshman/app
  ```

- Prefer to put things together yourself? Start with:
  ```bash
  npm i @welshman/util @welshman/net @welshman/signer
  ```

- Just parsing and rendering content? Include:
  ```bash
  npm i @welshman/content
  ```

Each package is independent but integrates seamlessly. All packages are framework-agnostic, but work best with Svelte due to svelte stores being a common pattern for state management.


=========================
type: file
file: docs/index.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/index.md
---
# https://vitepress.dev/reference/default-theme-home-page
layout: home

hero:
  name: "Welshman"
  text: Nostr building blocks for the web
  tagline: A series of independent libraries for managing every aspect of your Nostr application.
  actions:
    - theme: brand
      text: What is Welshman?
      link: /what-is-welshman
    - theme: alt
      text: Quickstart
      link: /getting-started
    - theme: alt
      text: Github
      link: https://github.com/coracle-social/welshman

features:
  - title: "@welshman/app"
    details: Batteries-included framework for building nostr clients.
    link: "/app"
  - title: "@welshman/util"
    details: Core Nostr utilities for events, filters, and data structures.
    link: "/util"
  - title: "@welshman/net"
    details: Networking layer for Nostr with relay connection management and message status handling.
    link: "/net"
  - title: "@welshman/signer"
    details: Implementations of various nostr signing methods (NIP-01, NIP-07, NIP-46, NIP-55).
    link: "/signer"
  - title: "@welshman/relay"
    details: In-memory relay and event store.
    link: "/relay"
  - title: "@welshman/router"
    details: Tools for relay selection.
    link: "/router"
  - title: "@welshman/content"
    details: Parser and renderer for nostr notes with customizable formatting options.
    link: "/content"
  - title: "@welshman/editor"
    details: Rich text editor with support for mentions and embeds.
    link: "/editor"
  - title: "@welshman/feeds"
    details: Dynamic feed compiler and loader with filtering and composition.
    link: "/feeds"
  - title: "@welshman/store"
    details: Svelte store utilities optimized for nostr state management.
    link: "/store"
  - title: "@welshman/lib"
    details: General-purpose utility functions.
    link: "/lib"
---


=========================
type: file
file: docs/lib/deferred.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/lib/deferred.md
# Deferred Promises

The `Deferred` module provides utilities for creating promises with exposed resolve/reject functions and typed error handling. This is particularly useful for managing asynchronous operations where you need external control over promise resolution.

## API

```typescript
// Creates a Deferred promise
export declare const defer: <T, E = T>() => Deferred<T, E>;

// Promise with exposed resolve/reject functions and typed error
export type Deferred<T, E = T> = CustomPromise<T, E> & {
  resolve: (arg: T) => void;
  reject: (arg: E) => void;
};

// Creates a Promise with strongly typed error
export declare function makePromise<T, E>(
  executor: (resolve: (value: T | PromiseLike<T>) => void, reject: (reason: E) => void) => void,
): CustomPromise<T, E>;
```

## Example

```typescript
import { defer } from '@welshman/lib';

// Create a deferred promise
const deferred = defer<string>();

// Resolve it externally
setTimeout(() => {
  deferred.resolve('Hello, world!');
}, 1000);

// Use it like a regular promise
deferred.then(value => {
  console.log(value); // "Hello, world!"
});
```


=========================
type: file
file: docs/lib/emitter.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/lib/emitter.md
# Event Emitter

The `Emitter` class extends Node.js EventEmitter to automatically emit all events to `'*'` listeners in addition to specific event listeners.

## API

```typescript
// Extended EventEmitter that also emits all events to '*' listeners
export declare class Emitter extends EventEmitter {
  // Emits an event to listeners and to '*' listeners
  emit(type: string, ...args: any[]): boolean;
}
```

## Example

```typescript
import { Emitter } from '@welshman/lib';

const emitter = new Emitter();

// Listen for specific events
emitter.on('message', (data) => {
  console.log('Message:', data);
});

// Listen for all events with '*'
emitter.on('*', (eventType, ...args) => {
  console.log('Event:', eventType, args);
});

// Emit an event - triggers both listeners
emitter.emit('message', 'Hello world');
// Output:
// Event: message ['Hello world']
// Message: Hello world
```

=========================
type: file
file: docs/lib/index.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/lib/index.md
# @welshman/lib

[![version](https://badgen.net/npm/v/@welshman/lib)](https://npmjs.com/package/@welshman/lib)

A lightweight TypeScript utility library with zero dependencies, providing essential tools for modern JavaScript development.

## What's Included

- **Utility Functions** - Helpers for arrays, objects, strings, and more
- **Deferred Promises** - Create promises with exposed resolve/reject methods
- **LRU Cache** - Efficient caching with automatic eviction policies
- **URL Normalization** - A utility function for normalizing URLs
- **Task Queue** - Process tasks asynchronously with batching and throttling

## Installation

```bash
npm install @welshman/lib
```


=========================
type: file
file: docs/lib/lru.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/lib/lru.md
# LRU Cache

A LRU (Least Recently Used) Cache implementation provides efficient caching with automatic eviction of least recently used items when the cache reaches its maximum size.

## API

```typescript
// LRU cache implementation
export declare class LRUCache<T, U> {
  constructor(maxSize?: number);
  has(k: T): boolean;
  get(k: T): U | undefined;
  set(k: T, v: U): void;
  pop(k: T): U | undefined;
}

// Creates a memoized function with LRU caching
export declare function cached<T, V, Args extends any[]>(options: {
  maxSize: number;
  getKey: (args: Args) => T;
  getValue: (args: Args) => V;
}): ((...args: Args) => V) & { cache: LRUCache<T, V>; pop: (...args: Args) => V };

// Creates a simple memoized function with default settings
export declare function simpleCache<V, Args extends any[]>(getValue: (args: Args) => V): (...args: Args) => V;
```

## Example

```typescript
import { LRUCache } from '@welshman/lib';

// Create cache with max size of 3
const cache = new LRUCache<string, number>(3);

// Add items
cache.set('a', 1);
cache.set('b', 2);
cache.set('c', 3);

console.log(cache.get('a')); // 1

// Adding 'd' will evict 'b' (least recently used)
cache.set('d', 4);

console.log(cache.has('b')); // false
console.log(cache.has('a')); // true (recently accessed)
```


=========================
type: file
file: docs/lib/normalize-url.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/lib/normalize-url.md
# URL Normalization

A `normalizeUrl` function borrowed from [sindresorhus/normalize-url](https://github.com/sindresorhus/normalize-url) is included for convenience.

## API

```typescript
export type Options = {
  // Default protocol to prepend
	readonly defaultProtocol?: 'https' | 'http'

	// Prepends `defaultProtocol` to the URL if it's protocol-relative.
	readonly normalizeProtocol?: boolean

	// Normalizes HTTPS URLs to HTTP.
	readonly forceHttp?: boolean

	// Normalizes HTTP URLs to HTTPS.
	readonly forceHttps?: boolean

	// Strip the [authentication](https://en.wikipedia.org/wiki/Basic_access_authentication) part of a URL.
	readonly stripAuthentication?: boolean

	// Removes hash from the URL.
	readonly stripHash?: boolean

	// Remove the protocol from the URL: `http://sindresorhus.com` → `sindresorhus.com`.
	readonly stripProtocol?: boolean

	// Strip the [text fragment](https://web.dev/text-fragments/) part of the URL
	readonly stripTextFragment?: boolean

	// Removes `www.` from the URL.
	readonly stripWWW?: boolean

	// Removes query parameters that matches any of the provided strings or regexes.
	readonly removeQueryParameters?: ReadonlyArray<RegExp | string> | boolean

	// Keeps only query parameters that matches any of the provided strings or regexes.
	readonly keepQueryParameters?: ReadonlyArray<RegExp | string>

	// Removes trailing slash.
	readonly removeTrailingSlash?: boolean

	// Remove a sole `/` pathname in the output. This option is independent of `removeTrailingSlash`.
	readonly removeSingleSlash?: boolean

	// Removes the default directory index file from path that matches any of the provided strings or regexes.
	readonly removeDirectoryIndex?: boolean | ReadonlyArray<RegExp | string>

	// Removes an explicit port number from the URL.
	readonly removeExplicitPort?: boolean

	// Sorts the query parameters alphabetically by key.
	readonly sortQueryParameters?: boolean
}
```

## Example

```typescript
normalizeUrl('example')
//=> 'http://example'

normalizeUrl('sindresorhus.com/about.html#contact', {stripHash: true});
//=> 'http://sindresorhus.com/about.html'
```


=========================
type: file
file: docs/lib/task-queue.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/lib/task-queue.md
# Task Queue

The `TaskQueue` class provides a simple queue processing system with batched operations and throttling. It's designed to handle asynchronous operations efficiently while maintaining control over processing rates and resource usage.

## API

```typescript
// Task queue options
export type TaskQueueOptions<Item> = {
  batchSize: number;
  processItem: (item: Item) => unknown;
};

// Task queue implementation
export declare class TaskQueue<Item> {
  constructor(options: TaskQueueOptions<Item>);
  push(item: Item): void;
  remove(item: Item): void;
  subscribe(subscriber: (item: Item) => void): () => void;
  process(): Promise<void>;
  stop(): void;
  start(): void;
  clear(): void;
}
```

## Example

```typescript
import { TaskQueue } from '@welshman/lib';

// Create a task queue that processes 3 items at a time
const queue = new TaskQueue({
  batchSize: 3,
  processItem: async (message: string) => {
    console.log('Processing:', message);
    // Simulate async work
    await new Promise(resolve => setTimeout(resolve, 100));
  }
});

// Add items to the queue
queue.push('Message 1');
queue.push('Message 2');
queue.push('Message 3');
queue.push('Message 4');

// Items will be processed in batches of 3
// Output: "Processing: Message 1", "Processing: Message 2", "Processing: Message 3"
// Then: "Processing: Message 4"
```


=========================
type: file
file: docs/lib/tools.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/lib/tools.md
# Utility Functions

The `Tools` module provides a comprehensive collection of utility functions for common programming tasks. It includes functions for array manipulation, object handling, type checking, math operations, and more.

## Working with types

Utility types for TypeScript development:

```typescript
// Override properties of type T with properties from type R
export type Override<T, R> = Omit<T, keyof R> & R;

// Make specific properties of type T optional
export type MakeOptional<T, K extends keyof T> = Override<T, Partial<Pick<T, K>>>;
```

Examples:
```typescript
interface User {
  id: string;
  name: string;
  email: string;
  age: number;
}

// Override the id to be a number instead
type UserWithNumericId = Override<User, { id: number }>;
// Result: { id: number; name: string; email: string; age: number; }

// Make email and age optional
type PartialUser = MakeOptional<User, 'email' | 'age'>;
// Result: { id: string; name: string; email?: string; age?: number; }
```

## Basic functional programming utilities

```typescript
// Null or undefined
export type Nil = null | undefined;

// Check whether something is null or undefined
export declare const isNil: <T>(x: T, ...args: unknown[]) => boolean;

// Check whether something is not null or undefined
export declare const isNotNil: <T>(x: T, ...args: unknown[]) => x is (T & null) | (T & {}) | (T & undefined);

// Assert that a nullable type is not null or undefined
export declare const assertNotNil: <T>(x: T, ...args: unknown[]) => NonNullable<T>;

// Function that does nothing and returns undefined
export declare const noop: (...args: unknown[]) => undefined;

// Returns the input value unchanged
export declare const identity: <T>(x: T, ...args: unknown[]) => T;

// Creates a function that always returns the same value
export declare const always: <T>(x: T, ...args: unknown[]) => () => T;

// Returns the logical NOT of a value
export declare const not: (x: any, ...args: unknown[]) => boolean;

// Deep equality comparison
export declare const equals: (a: any, b: any) => boolean;
```

## Numbers

```typescript
// Converts string or number to number
export declare const ensureNumber: (x: number | string) => number;

// Converts a `number | undefined` to a number, defaulting to 0
export declare const num: (x: number | undefined) => number;

// Adds two numbers, handling undefined values
export declare const add: (x: number | undefined, y: number | undefined) => number;

// Subtracts two numbers, handling undefined values
export declare const sub: (x: number | undefined, y: number | undefined) => number;

// Multiplies two numbers, handling undefined values
export declare const mul: (x: number | undefined, y: number | undefined) => number;

// Divides two numbers, handling undefined values
export declare const div: (x: number | undefined, y: number) => number;

// Increments a number by 1, handling undefined values
export declare const inc: (x: number | undefined) => number;

// Decrements a number by 1, handling undefined values
export declare const dec: (x: number | undefined) => number;

// Less than comparison, handling undefined values
export declare const lt: (x: number | undefined, y: number | undefined) => boolean;

// Less than or equal comparison, handling undefined values
export declare const lte: (x: number | undefined, y: number | undefined) => boolean;

// Greater than comparison, handling undefined values
export declare const gt: (x: number | undefined, y: number | undefined) => boolean;

// Greater than or equal comparison, handling undefined values
export declare const gte: (x: number | undefined, y: number | undefined) => boolean;

// Returns maximum value in array, handling undefined values
export declare const max: (xs: (number | undefined)[]) => number;

// Returns minimum value in array, handling undefined values
export declare const min: (xs: (number | undefined)[]) => number;

// Returns sum of array values, handling undefined values
export declare const sum: (xs: (number | undefined)[]) => number;

// Returns average of array values, handling undefined values
export declare const avg: (xs: (number | undefined)[]) => number;

// Checks if a number is between two values (exclusive)
export declare const between: ([low, high]: [number, number], n: number) => boolean;

// Checks if a number is between two values (inclusive)
export declare const within: ([low, high]: [number, number], n: number) => boolean;

// Constrains number between min and max values
export declare const clamp: ([min, max]: [number, number], n: number) => number;

// Round a number to the nearest float precision
export declare const round: (precision: number, x: number) => number;
```

## Timestamps

```typescript
// One minute in seconds
export declare const MINUTE = 60;

// One hour in seconds
export declare const HOUR: number;

// One day in seconds
export declare const DAY: number;

// One week in seconds
export declare const WEEK: number;

// One month in seconds (approximate)
export declare const MONTH: number;

// One quarter in seconds (approximate)
export declare const QUARTER: number;

// One year in seconds (approximate)
export declare const YEAR: number;

// User's default locale
export declare const LOCALE: string;

// User's default timezone
export declare const TIMEZONE: string;

// Multiplies time unit by count
export declare const int: (unit: number, count?: number) => number;

// Returns current Unix timestamp in seconds
export declare const now: () => number;

// Returns Unix timestamp from specified time ago
export declare const ago: (unit: number, count?: number) => number;

// Converts seconds to milliseconds
export declare const ms: (seconds: number) => number;

// Converts seconds to date
export declare const secondsToDate: (seconds: number) => Date;

// Converts date object to seconds
export declare const dateToSeconds: (date: Date) => number;

// Creates a local date from a date string
export declare const createLocalDate: (dateString: any, timezone?: string) => Date;
/** Formatter for date+time */
export declare const dateTimeFormatter: Intl.DateTimeFormat;

// Formats seconds as a datetime
export declare const formatTimestamp: (seconds: number) => string;
/** Formatter for date */
export declare const dateFormatter: Intl.DateTimeFormat;

// Formats seconds as a date
export declare const formatTimestampAsDate: (ts: number) => string;
/** Formatter for time */
export declare const timeFormatter: Intl.DateTimeFormat;

// Formats seconds as a time
export declare const formatTimestampAsTime: (ts: number) => string;

// Formats seconds as a relative date (x minutes ago)
export declare const formatTimestampRelative: (ts: number) => string;
```

## Sequences

```typescript
// Returns the first element of an array
export declare const first: <T>(xs: Iterable<T>, ...args: unknown[]) => T | undefined;

// Returns the first element of the first array in a nested array
export declare const ffirst: <T>(xs: Iterable<Iterable<T>>, ...args: unknown[]) => T | undefined;

// Returns the last element of an array
export declare const last: <T>(xs: Iterable<T>, ...args: unknown[]) => T;

// Returns array with first n elements removed
export declare const drop: <T>(n: number, xs: Iterable<T>) => T[];

// Returns first n elements of array
export declare const take: <T>(n: number, xs: Iterable<T>) => T[];

// Concatenates multiple arrays, filtering out null/undefined
export declare const concat: <T>(...xs: T[][]) => T[];

// Appends element to array
export declare const append: <T>(x: T, xs: T[]) => T[];

// Creates union of two arrays
export declare const union: <T>(a: T[], b: T[]) => T[];

// Returns elements common to both arrays
export declare const intersection: <T>(a: T[], b: T[]) => T[];

// Returns elements in first array not present in second
export declare const difference: <T>(a: T[], b: T[]) => T[];

// Removes all instances of an element from array
export declare const remove: <T>(a: T, xs: T[]) => T[];

// Removes element at index
export declare const removeAt: <T>(i: number, xs: T[]) => T[];

// Returns elements from second array not present in first
export declare const without: <T>(a: T[], b: T[]) => T[];

// Toggles presence of element in array
export declare const toggle: <T>(x: T, xs: T[]) => T[];

// Generates sequence of numbers from a to b
export declare function range(a: number, b: number, step?: number): Generator<number, void, unknown>;

// Yields indexed items
export declare function enumerate<T>(items: T[]): Generator<[number, T], void, unknown>;

// Returns a function that gets property value from object
export declare const pluck: <T>(k: string, xs: Record<string, unknown>[]) => T[];

// Creates object from array of key-value pairs
export declare const fromPairs: <T>(pairs: [k?: string, v?: T, ...args: unknown[]][]) => Record<string, T>;

// Flattens array of arrays into single array
export declare const flatten: <T>(xs: T[][]) => T[];

// Splits array into two arrays based on predicate
export declare const partition: <T>(f: (x: T) => boolean, xs: T[]) => T[][];

// Returns array with duplicate elements removed
export declare const uniq: <T>(xs: T[]) => T[];

// Returns array with elements unique by key function
export declare const uniqBy: <T>(f: (x: T) => any, xs: T[]) => T[];

// Returns sorted copy of array
export declare const sort: <T>(xs: T[]) => T[];

// Returns array sorted by key function
export declare const sortBy: <T>(f: (x: T) => any, xs: T[]) => T[];

// Groups array elements by key function
export declare const groupBy: <T, K>(f: (x: T) => K, xs: T[]) => Map<K, T[]>;

// Creates map from array using key function
export declare const indexBy: <T, K>(f: (x: T) => K, xs: T[]) => Map<K, T>;

// Counts array elements by key function
export declare const countBy: <T, K>(f: (x: T) => K, xs: T[]) => Map<K, number>;

// Creates array of specified length using generator function
export declare const initArray: <T>(n: number, f: () => T) => T[];

// Splits array into chunks of specified length
export declare const chunk: <T>(chunkLength: number, xs: T[]) => T[][];

// Splits array into specified number of chunks
export declare const chunks: <T>(n: number, xs: T[]) => T[][];

// Splits array into two parts at index
export declare const splitAt: <T>(n: number, xs: T[]) => T[][];

// Inserts element into array at index
export declare const insertAt: <T>(n: number, x: T, xs: T[]) => T[];

// Replaces array element at index
export declare const replaceAt: <T>(n: number, x: T, xs: T[]) => T[];

// Returns random element from array
export declare const choice: <T>(xs: T[]) => T;

// Returns shuffled copy of iterable
export declare const shuffle: <T>(xs: Iterable<T>) => T[];

// Returns n random elements from array
export declare const sample: <T>(n: number, xs: T[]) => T[];

// Checks if value is iterable
export declare const isIterable: (x: any) => boolean;

// Ensures value is iterable by wrapping in array if needed
export declare const toIterable: (x: any) => any;

// Ensures value is array by wrapping if needed
export declare const ensurePlural: <T>(x: T | T[]) => T[];

// Ensures values are not undefined
export declare const removeNil: <T>(xs: T[]) => (T & {})[];

// Returns a list of overlapping pairs of elements in xs
export declare const overlappingPairs: <T>(xs: T[]) => T[][];
```

## Objects

```typescript
// Checks if value is a plain object
export declare const isPojo: (obj: any) => boolean;

// Creates new object with only specified keys
export declare const pick: <T extends Obj>(ks: string[], x: T) => T;

// Creates new object with specified keys removed
export declare const omit: <T extends Obj>(ks: string[], x: T) => T;

// Creates new object excluding entries with specified values
export declare const omitVals: <T extends Obj>(xs: any[], x: T) => T;

// Filters object values based on predicate
export declare const filterVals: <T extends Record<string, any>>(f: (v: any) => boolean, x: T) => T;

// Creates new object with transformed keys
export declare const mapKeys: <T extends Obj>(f: (v: string) => string, x: T) => T;

// Creates new object with transformed values
export declare const mapVals: <V, U>(f: (v: V) => U, x: Record<string, V>) => Record<string, U>;

// Merges two objects, with left object taking precedence
export declare const mergeLeft: <T extends Obj>(a: T, b: T) => T;

// Merges two objects, with right object taking precedence
export declare const mergeRight: <T extends Obj>(a: T, b: T) => T;

// Deep merge two objects, prioritizing the first argument.
export declare const deepMergeLeft: (a: Obj, b: Obj) => Obj<any>;

// Deep merge two objects, prioritizing the second argument.
export declare const deepMergeRight: (a: Obj, b: Obj) => Obj<any>;

// Switches on key in object, with default fallback
export declare const switcher: <T>(k: string, m: Record<string, T>) => T;
```

## Combinators

```typescript
// Returns a function that returns the boolean negation of the given function
export declare const complement: <T extends unknown[]>(f: (...args: T) => any) => (...args: T) => boolean;

// Safely executes function and handles errors
export declare const tryCatch: <T>(f: () => T, onError?: (e: Error) => void) => T | undefined;

// Creates function that only executes once
export declare const once: (f: (...args: any) => void) => (...args: any) => void;

// Calls a function
export declare const call: <T>(f: () => T, ...args: unknown[]) => T;

// Memoizes function results based on arguments
export declare const memoize: <T>(f: (...args: any[]) => T) => (...args: any[]) => T;

// Executes a function if the value is defined
export declare const ifLet: <T>(x: T | undefined, f: (x: T) => void) => void;
```

## Randomness

```typescript
// Generates random integer between min and max (inclusive)
export declare const randomInt: (min?: number, max?: number) => number;

// Generates random string ID
export declare const randomId: () => string;
```

## Async

```typescript
// Creates a promise that resolves after specified time
export declare const sleep: (t: number) => Promise<unknown>;

// Creates a microtask that yields to other tasks in the event loop
export declare const yieldThread: () => any;

// Poll options for condition checking
type PollOptions = {
  signal: AbortSignal;
  condition: () => boolean;
  interval?: number;
};

// Creates a promise that resolves after condition completes or timeout
export declare const poll: (options: PollOptions) => Promise<void>;

// Creates throttled version of function
export declare const throttle: <F extends (...args: any[]) => any>(ms: number, f: F) => F | ((...thisArgs: Parameters<F>) => void);

// Creates throttled function that returns cached value
export declare const throttleWithValue: <T>(ms: number, f: () => T) => () => T;

// Creates batching function that collects items
export declare const batch: <T>(t: number, f: (xs: T[]) => void) => (x: T) => void;

// Creates batching function that returns results
export declare const batcher: <T, U>(t: number, execute: (request: T[]) => U[] | Promise<U[]>) => (request: T) => Promise<U>;

// Returns a promise that resolves after some proportion of promises complete
export declare const race: (threshold: number, promises: Promise<unknown>[]) => Promise<void>;
```

## URLs

```typescript
// Removes protocol (http://, https://, etc) from URL
export declare const stripProtocol: (url: string) => string;

// Formats URL for display by removing protocol, www, and trailing slash
export declare const displayUrl: (url: string) => string;

// Extracts and formats domain from URL
export declare const displayDomain: (url: string) => string;
```

## JSON, localStorage, fetch, event emitters, etc

```typescript
// Safely parses JSON string
export declare const parseJson: (json: string | undefined) => any;

// Gets and parses JSON from localStorage
export declare const getJson: (k: string) => any;

// Stringifies and stores value in localStorage
export declare const setJson: (k: string, v: any) => void;

// Options for fetch requests
type FetchOpts = {
    method?: string;
    headers?: Record<string, string | boolean>;
    body?: string | FormData;
};

// Fetches JSON from URL with options
export declare const fetchJson: (url: string, opts?: FetchOpts) => Promise<any>;

// Posts JSON data to URL
export declare const postJson: <T>(url: string, data: T, opts?: FetchOpts) => Promise<any>;

// Uploads file to URL
export declare const uploadFile: (url: string, file: File) => Promise<any>;

// A generic type-safe event listener function that works with event emitters.
export declare const on: <EventMap extends Record<string | symbol, any[]>, E extends keyof EventMap>(target: {
    on(event: E, listener: (...args: EventMap[E]) => any): any;
    off(event: E, listener: (...args: EventMap[E]) => any): any;
}, eventName: E, callback: (...args: EventMap[E]) => void) => (() => void);
```

## Strings

```typescript
// Truncates string to length, breaking at word boundaries
export declare const ellipsize: (s: string, l: number, suffix?: string) => string;

// Displays a list of items with oxford commas and a chosen conjunction
export declare const displayList: <T>(xs: T[], conj?: string, n?: number) => string;

// Generates a hash string from input string
export declare const hash: (s: string) => string;
```

## Curried utilities for working with collections

```typescript
// Returns a function that gets the nth element of an array
export declare const nth: (i: number) => <T>(xs: T[], ...args: unknown[]) => T;

// Returns a function that checks if nth element equals value
export declare const nthEq: (i: number, v: any) => (xs: any[], ...args: unknown[]) => boolean;

// Returns a function that checks if nth element does not equal value
export declare const nthNe: (i: number, v: any) => (xs: any[], ...args: unknown[]) => boolean;

// Returns a function that checks if key/value pairs of x match all pairs in spec
export declare const spec: (values: Obj | Array<any>) => (x: Obj | Array<any>, ...args: unknown[]) => boolean;

// Returns a function that checks equality with value
export declare const eq: <T>(v: T) => (x: T) => boolean;

// Returns a function that checks inequality with value
export declare const ne: <T>(v: T) => (x: T) => boolean;

// Returns a function that gets property value from object
export declare const prop: <T>(k: string) => (x: Record<string, unknown>) => T;

// Returns a function that adds/updates a property on object
export declare const assoc: <K extends string, T, U>(k: K, v: T) => (o: U) => U & Record<K, T>;

// Returns a function that removes a property on object
export declare const dissoc: <K extends string, T extends Obj>(k: K) => (o: T) => T;

// Returns a function that checks whether a value is in the given sequence
export declare const member: <T>(xs: Iterable<T>) => (x: T) => boolean;
```

## Sets

```typescript
// Adds value to Set at key in object
export declare const addToKey: <T>(m: Record<string, Set<T>>, k: string, v: T) => void;

// Pushes value to array at key in object
export declare const pushToKey: <T>(m: Record<string, T[]>, k: string, v: T) => void;
```

## Maps

```typescript
// Adds value to Set at key in Map
export declare const addToMapKey: <K, T>(m: Map<K, Set<T>>, k: K, v: T) => void;

// Pushes value to array at key in Map
export declare const pushToMapKey: <K, T>(m: Map<K, T[]>, k: K, v: T) => void;
```

## Bech32 <-> hex encoding

```typescript
// Converts hex string to bech32 format
export declare const hexToBech32: (prefix: string, hex: string) => `${Lowercase<string>}1${string}`;

// Converts bech32 string to hex format
export declare const bech32ToHex: (b32: string) => string;

// Converts an array buffer to hex format
export declare const bytesToHex: (buffer: ArrayBuffer) => string;

// Converts a hex string to a Uint8Array buffer
export declare const hexToBytes: (hex: string) => Uint8Array;

// Computes SHA-256 hash of binary data
export declare const sha256: (data: ArrayBuffer | Uint8Array) => Promise<string>;
```

## Text encoding

```typescript
// TextEncoder instance for encoding strings to bytes
export declare const textEncoder: TextEncoder;

// TextDecoder instance for decoding bytes to strings
export declare const textDecoder: TextDecoder;
```



=========================
type: file
file: docs/net/adapter.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/net/adapter.md
# Adapter

Adapters provide a unified interface for communicating with relays. Adapters aren't meant to be used directly, but as an injection point for custom logic.

## Core Classes

### `AbstractAdapter`

Base class for all adapters. Handles events and cleanup.

- `send(message)` - Send message to relay
- `cleanup()` - Clean up resources
- Emits `AdapterEvent.Receive` when messages arrive

### Built-in Adapters

- `SocketAdapter(socket)` - WebSocket relay connections
- `LocalAdapter(relay)` - Local in-memory relays
- `MockAdapter(url, sendHandler)` - Testing with manual control

### Factory

`getAdapter(url, context?)` creates the appropriate adapter:

```typescript
const adapter = getAdapter('wss://relay.example.com')
adapter.on(AdapterEvent.Receive, (message, url) => {
  console.log('Received:', message)
})
adapter.send(['REQ', 'sub1', {}])
adapter.cleanup()
```

## Custom Adapter Example

Custom adapters can be created against any target:

```typescript
class IPFSAdapter extends AbstractAdapter {
  constructor(private url string) {
    super()

    // Set up an IPFS connection here
  }

  get urls() { return [this.url] }
  get sockets() { return [] }

  send(message: ClientMessage) {
    // Handle messages as if the ipfs backend was a relay
  }
}
```

Custom adapters can also be provided to several net utilities, including `publish` and `request`:

```typescript
request({
  relays: ['ipfs://QmTy8w65yBXgyfG2ZBg5TrfB2hPjrDQH3RCQFJGkARStJb'],
  filters: [{kinds: [1]}],
  context: {
    getAdapter: (url: string) => {
      // getAdapter optionally returns an adapter. If none is returned, the stock adapters will be used.
      if (url.startsWith('ipfs://')) {
        return new IPFSAdapter(url)
      }
    },
  },
})
```


=========================
type: file
file: docs/net/auth.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/net/auth.md
# Auth

Handles NIP-42 relay authentication flow.

## Core Classes

### `AuthState`

Manages authentication state for a socket connection.

**Status Values:**
- `AuthStatus.None` - No authentication required/attempted
- `AuthStatus.Requested` - Relay requested authentication
- `AuthStatus.PendingSignature` - Waiting for user to sign auth event
- `AuthStatus.DeniedSignature` - User denied signing
- `AuthStatus.PendingResponse` - Waiting for relay response
- `AuthStatus.Forbidden` - Authentication failed
- `AuthStatus.Ok` - Authentication successful

**Methods:**
- `doAuth(sign)` - Authenticate with the relay using provided signing function
- `attemptAuth(sign)` - Attempt authentication with timeout handling
- `retryAuth(sign)` - Retry authentication by resetting state and attempting auth again
- `cleanup()` - Clean up event listeners

**Events:**
- `AuthStateEvent.Status` - Emitted when authentication status changes

## Example

```typescript
const authState = new AuthState(socket)

// Listen for auth status changes
authState.on(AuthStateEvent.Status, (status) => {
  console.log('Auth status:', status)
})

// Attempt authentication when relay requests it
await authState.attemptAuth(async (template) => {
  return await signer.signEvent(template)
})

// Retry authentication if needed
await authState.retryAuth(async (template) => {
  return await signer.signEvent(template)
})
```


=========================
type: file
file: docs/net/context.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/net/context.md
# Context

Provides global configuration and dependencies for the net package.

## NetContext

Configuration object that defines how the net package operates:

- `pool: Pool` - Socket connection pool
- `repository: Repository` - Event storage and retrieval
- `isEventValid: (event, url) => boolean` - Event validation function
- `isEventDeleted: (event, url) => boolean` - Event deletion check
- `getAdapter?: (url, context) => AbstractAdapter` - Custom adapter factory

## Default Context

The `netContext` global provides sensible defaults:

- Uses singleton pool and repository instances
- Validates events using `verifyEvent`
- Checks deletions via repository
- No custom adapter factory

## Example

```typescript
import {netContext} from '@welshman/net'

// Override event validation
netContext.isEventValid: (event, url) => {
  return event.kind < 30000 && verifyEvent(event)
}

// Use in requests
request({
  filters: [{kinds: [1]}],
  relays: ['wss://relay.example.com'],
  context: {
    ...netContext,
    // Request-specific overrides
  }
})
```


=========================
type: file
file: docs/net/diff.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/net/diff.md
# Diff

Efficient event synchronization using NIP-77 Negentropy protocol.

## Core Classes

### `Difference`

Handles negentropy synchronization with a single relay for a single filter.

**Events:**
- `DifferenceEvent.Message` - Emitted with `{have, need}` arrays and relay URL
- `DifferenceEvent.Error` - Emitted when sync fails
- `DifferenceEvent.Close` - Emitted when sync completes

**Methods:**
- `close()` - Stop synchronization and cleanup

## Functions

### `diff(options)`

Check what events each relay has or needs compared to local events.

**Returns:** Array of `{relay, have, need}` objects - `have` are events the relay has that you don't, `need` are events you have that the relay doesn't.

### `pull(options)`

Fetch missing events after comparing with relays.

**Returns:** Array of retrieved events.

### `push(options)`

Publish local events that relays are missing.

## Example

```typescript
// Check what events each relay has/needs
const results = await diff({
  relays: ['wss://relay1.com', 'wss://relay2.com'],
  filters: [{kinds: [1], authors: ['pubkey...']}],
  events: localEvents
})

// Pull events that relays have but we don't
const newEvents = await pull({
  relays: ['wss://relay1.com'],
  filters: [{kinds: [1]}],
  events: localEvents
})
```


=========================
type: file
file: docs/net/index.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/net/index.md
# @welshman/net

[![version](https://badgen.net/npm/v/@welshman/net)](https://npmjs.com/package/@welshman/net)

Core networking layer for nostr applications, handling relay connections, message management, and event delivery.

## What's Included

- **Connection Management** - WebSocket lifecycle and relay connections
- **Subscription System** - Event filtering and subscription handling
- **Publishing Tools** - Event broadcasting with status tracking
- **Sync Utilities** - NIP-77 (negentropy) event synchronization
- **Connection Pool** - Shared relay connection management
- **Custom Adapters** - Flexible adapter layer to support queries against any target
- **Event Tracking** - Monitor which relays have seen events
- **Socket policies** - Default and customizable policies for NIP 42 AUTH, reconnects, etc


=========================
type: file
file: docs/net/message.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/net/message.md
# Message

Type definitions and utilities for Nostr protocol messages.

## Relay Message Types

**Enums:**
- `RelayMessageType.Auth` - Authentication challenge
- `RelayMessageType.Closed` - Subscription closed
- `RelayMessageType.Eose` - End of stored events
- `RelayMessageType.Event` - Event data
- `RelayMessageType.NegErr` - Negentropy error
- `RelayMessageType.NegMsg` - Negentropy message
- `RelayMessageType.Ok` - Command result

**Type Definitions:**
- `RelayMessage` - Base relay message type
- `RelayAuth`, `RelayClosed`, `RelayEose`, `RelayEvent`, `RelayNegErr`, `RelayNegMsg`, `RelayOk` - Specific message types
- `RelayAuthPayload`, `RelayClosedPayload`, etc. - Payload types for each message

**Type Guards:**
- `isRelayAuth()`, `isRelayClosed()`, `isRelayEose()`, `isRelayEvent()`, `isRelayNegErr()`, `isRelayNegMsg()`, `isRelayOk()`

## Client Message Types

**Enums:**
- `ClientMessageType.Auth` - Authentication response
- `ClientMessageType.Close` - Close subscription
- `ClientMessageType.Event` - Publish event
- `ClientMessageType.NegClose` - Close negentropy
- `ClientMessageType.NegOpen` - Open negentropy
- `ClientMessageType.Req` - Request subscription

**Type Definitions:**
- `ClientMessage` - Base client message type
- `ClientAuth`, `ClientClose`, `ClientEvent`, `ClientNegClose`, `ClientNegOpen`, `ClientReq` - Specific message types
- `ClientAuthPayload`, `ClientClosePayload`, etc. - Payload types for each message

**Type Guards:**
- `isClientAuth()`, `isClientClose()`, `isClientEvent()`, `isClientNegClose()`, `isClientNegOpen()`, `isClientReq()`

## Example

```typescript
// Handle incoming relay message
const handleMessage = (message: RelayMessage) => {
  if (isRelayEvent(message)) {
    const [type, subId, event] = message
    console.log('Event:', event.id)
  }
}
```


=========================
type: file
file: docs/net/policy.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/net/policy.md
# Policy

Socket policies provide automated behavior for socket connections. They are intended to be applied on socket creation via `makeSocket` or `PoolOptions.makeSocket`.

## Types

### SocketPolicy
```typescript
type SocketPolicy = (socket: Socket) => Unsubscriber
```

The contract for socket policies. Takes a Socket object and returns a cleanup function that should be called when the policy is no longer needed.

## Built-in Policies

### `socketPolicyAuthBuffer`

Buffers messages during authentication flow and replays them after successful auth.

### `socketPolicyConnectOnSend`

Auto-connects closed sockets when messages are sent (with error cooldown).

### `socketPolicyCloseInactive`

Closes sockets after 30 seconds of inactivity and reopens sockets that have pending requests or publishes.

## Custom Auth Policy

### `makeSocketPolicyAuth(options)`

Creates a policy that handles authentication challenges.

**Options:**
- `sign: (event) => Promise<SignedEvent>` - Signing function
- `shouldAuth?: (socket) => boolean` - Optional auth condition

## Default Policies

`defaultSocketPolicies` includes all built-in policies except auth (which requires configuration).

It's common to include the following code in order to enable automatic authentication on all connections:

```typescript
defaultSocketPolicies.push(
  makeSocketPolicyAuth({
    sign: (event: StampedEvent) => signer.sign(event),
    shouldAuth: (socket: Socket) => true,
  }),
)
```

## Example

It's possible to create custom policies simply by defining a function which returns a cleanup function:

```typescript
import {on} from "@welshman/lib"
import {SocketEvent, Socket, SocketStatus} from "@welshman/net"

const logStatusChangePolicy = (socket: Socket) => {
  const unsubscribe = on(socket, SocketEvent.Status, (newStatus: SocketStatus) => {
    console.log(socket.url, newStatus)
  })

  return unsubscribe
}
```


=========================
type: file
file: docs/net/pool.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/net/pool.md
# Pool

The Pool class manages a collection of websocket connections to relay servers, providing connection pooling and lifecycle management.

## Classes

### Pool

A connection pool that creates and manages Socket instances for different relay URLs.

**Methods:**
- `static get()` - Returns the singleton pool instance
- `has(url)` - Checks if a socket exists for the given URL
- `get(url)` - Gets or creates a socket for the given URL
- `subscribe(callback)` - Subscribes to new socket creation events
- `remove(url)` - Removes and cleans up a socket
- `clear()` - Removes all sockets from the pool

## Functions

### makeSocket(url, policies)

Creates a new Socket instance with the given URL and applies default policies.

## Example

```typescript
import {Pool} from "@welshman/net"

// Get the singleton - Pool can also be instantiated directly if you want multiple pools
const pool = Pool.get()

// Get a socket for a relay
const socket = pool.get("wss://relay.example.com")

// Subscribe to new socket creation
const unsubscribe = pool.subscribe((socket) => {
  console.log("New socket created:", socket.url)
})

// Clean up
pool.remove("wss://relay.example.com")
```


=========================
type: file
file: docs/net/publish.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/net/publish.md
# Publish

Utilities for publishing events to Nostr relays with status tracking and callback handling.

## Enums

### PublishStatus

Status values for publish operations:
- `Sending` - Event is being sent
- `Pending` - Waiting for relay response
- `Success` - Event published successfully
- `Failure` - Event rejected by relay
- `Timeout` - Request timed out
- `Aborted` - Request was aborted

## Functions

### publishOne(options)

Publishes an event to a single relay and returns a promise that resolves with the publish status.

**Options:**
- `event` - The signed event to publish
- `relay` - Relay URL
- `signal?` - AbortSignal for cancellation
- `timeout?` - Timeout in milliseconds (default: 10000)
- `context?` - Adapter context
- Callback functions: `onSuccess`, `onFailure`, `onPending`, `onTimeout`, `onAborted`, `onComplete`

### publish(options)

Publishes an event to multiple relays in parallel and returns a status object mapping relay URLs to their publish status.

## Example

```typescript
import {publish, PublishStatus} from "@welshman/net"

const event = {
  // ... signed event
}

const statusByRelay = await publish({
  event,
  relays: ["wss://relay1.com", "wss://relay2.com"],
  timeout: 5000,
  onSuccess: (detail, relay) => console.log(`Published to ${relay}`),
  onFailure: (detail, relay) => console.log(`Failed on ${relay}: ${detail}`)
})

console.log(statusByRelay) // { "wss://relay1.com": "success", "wss://relay2.com": "failure" }
```

=========================
type: file
file: docs/net/request.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/net/request.md
# Request

Utilities for requesting events from Nostr relays with filtering, deduplication, and batching capabilities.

## Functions

### requestOne(options)

Requests events from a single relay using the given filters. Returns a promise that resolves with deduplicated events.

**Options:**
- `relay` - Relay URL
- `filters` - Array of Nostr filters
- `signal?` - AbortSignal for cancellation
- `tracker?` - Event tracker for deduplication
- `context?` - Adapter context
- `autoClose?` - Auto-close subscription after EOSE
- Validation functions: `isEventValid`, `isEventDeleted`
- Callback functions: `onEvent`, `onDeleted`, `onInvalid`, `onFiltered`, `onDuplicate`, `onDisconnect`, `onEose`, `onClose`

### request(options)

Requests events from multiple relays in parallel. Returns a promise that resolves with all events from all relays.

**Options:**
- `relays` - Array of relay URLs
- `filters` - Array of Nostr filters
- `threshold?` - Fraction of relays that must close before completing (default: 1)
- All other options from `requestOne`

### makeLoader(options)

Creates a batched loader function that delays and combines requests for efficiency.

**Options:**
- `delay` - Batch delay in milliseconds
- `timeout?` - Request timeout
- `threshold?` - Relay completion threshold
- Validation functions and context options

### load(filters, relays, options)

Pre-configured loader with 200ms delay, 3s timeout, and 0.5 threshold.

## Example

```typescript
import {request, load} from "@welshman/net"

// Simple request - without autoClose or a signal this will continue to stream indefinitely.
// Default policies (see policy.ts) will also re-send the subscription when sockets reconnect
const events = await request({
  relays: ["wss://relay1.com", "wss://relay2.com"],
  filters: [{kinds: [1], limit: 10}],
  onEvent: (event, url) => console.log(`Event from ${url}:`, event.id)
})

// Batched loading (more efficient for multiple requests)
const profileEvents = await load({
  relays: ["wss://relay1.com"],
  filters: [{kinds: [0], authors: ["pubkey1", "pubkey2"]}]
})
```


=========================
type: file
file: docs/net/socket.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/net/socket.md
# Socket

WebSocket wrapper for Nostr relay connections with status tracking, queuing, and authentication support. Not intended to be used directly, instead access sockets through the `Pool` interface.

## Enums

### SocketStatus

Connection status values:
- `Open` - Socket is connected and ready
- `Opening` - Socket is connecting
- `Closing` - Socket is closing
- `Closed` - Socket is closed
- `Error` - Socket encountered an error

### SocketEvent

Event types emitted by the socket:
- `Error` - Socket error occurred
- `Status` - Status changed
- `Send` - Message sent to relay
- `Sending` - Message queued for sending
- `Receive` - Message received from relay
- `Receiving` - Message queued for processing

## Classes

### Socket

WebSocket connection to a Nostr relay with queuing and authentication.

**Properties:**
- `url` - Relay URL
- `status` - Current socket status
- `auth` - Authentication state

**Methods:**
- `open()` - Opens the WebSocket connection
- `attemptToOpen()` - Opens connection if not already open
- `close()` - Closes the connection
- `cleanup()` - Closes connection and removes all listeners
- `send(message)` - Queues a message to send

## Example

```typescript
import {Socket, SocketEvent, SocketStatus} from "@welshman/net"

const socket = new Socket("wss://relay.example.com")

socket.on(SocketEvent.Status, (status, url) => {
  console.log(`Socket ${url} status: ${status}`)
})

socket.on(SocketEvent.Receive, (message, url) => {
  console.log("Received:", message)
})

socket.open()
socket.send(["REQ", "sub-id", {kinds: [1], limit: 10}])
socket.cleanup()
```


=========================
type: file
file: docs/net/tracker.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/net/tracker.md
# Tracker

Event tracker for managing which events have been seen from which relays, used for deduplication across multiple relay connections.

## Classes

### Tracker

Tracks the relationship between event IDs and relay URLs to prevent duplicate processing.

**Properties:**
- `relaysById` - Map of event IDs to sets of relay URLs
- `idsByRelay` - Map of relay URLs to sets of event IDs

**Methods:**
- `getIds(relay)` - Gets all event IDs seen from a relay
- `getRelays(eventId)` - Gets all relays that have sent an event
- `hasRelay(eventId, relay)` - Checks if an event was seen from a relay
- `addRelay(eventId, relay)` - Records that an event was seen from a relay
- `removeRelay(eventId, relay)` - Removes the event-relay association
- `track(eventId, relay)` - Tracks an event and returns true if already seen
- `copy(eventId1, eventId2)` - Copies relay associations from one event to another
- `load(relaysById)` - Loads tracker state from a map
- `clear()` - Clears all tracked data

**Events:**
- `add` - Emitted when event-relay association is added
- `remove` - Emitted when event-relay association is removed
- `load` - Emitted when tracker state is loaded
- `clear` - Emitted when tracker is cleared

## Example

```typescript
import {Tracker} from "@welshman/net"

const tracker = new Tracker()

// Track events from different relays
const isDuplicate1 = tracker.track("event123", "wss://relay1.com") // false
const isDuplicate2 = tracker.track("event123", "wss://relay2.com") // false
const isDuplicate3 = tracker.track("event123", "wss://relay1.com") // true (duplicate)

// Check which relays have sent an event
const relays = tracker.getRelays("event123") // Set(["wss://relay1.com", "wss://relay2.com"])
```

If you're not using `@welshman/app`, you might want to track relays for all events that come through:

```typescript
import {Pool, Tracker, SocketEvent, isRelayEvent} from "@welshman/net"
import {isEphemeralKind, isDVMKind, verifyEvent} from "@welshman/util"
import {Repository} from "@welshman/relay"

const tracker = new Tracker()
const repository = new Repository()

Pool.get().subscribe(socket => {
  socket.on(SocketEvent.Receive, message => {
    if (isRelayEvent(message)) {
      const event = message[2]

      if (!isEphemeralKind(event.kind) && !isDVMKind(event.kind) && verifyEvent(event)) {
        tracker.track(event.id, socket.url)
        repository.publish(event)
      }
    }
  })
})
```


=========================
type: file
file: docs/relay/index.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/relay/index.md
# @welshman/relay

[![version](https://badgen.net/npm/v/@welshman/relay)](https://npmjs.com/package/@welshman/relay)

A few utilites for storing nostr events in memory.

## What's Included

- **Event Store** - A Repository class which stores events in memory
- **Relay Adapter** - A LocalRelay class which adapts nostr messages to the repository

## Quick Example

```typescript
import {Repository, LocalRelay} from "@welshman/relay"

// Create an in-memory event repository
const repository = Repository.get()

// Publish events directly to the repository
const textNote = {
  id: "event123",
  pubkey: "author-pubkey",
  created_at: Math.floor(Date.now() / 1000),
  kind: 1,
  tags: [],
  content: "Hello, world!",
  sig: "signature"
}

repository.publish(textNote)

// Query events using filters
const recentNotes = repository.query([{kinds: [1], limit: 10}])
console.log(`Found ${recentNotes.length} text notes`)

// Listen for repository updates
repository.on("update", ({added, removed}) => {
  console.log(`Added ${added.length} events, removed ${removed.size} events`)
})

// Create a local relay that adapts Nostr messages to the repository
const relay = new LocalRelay(repository)

// Listen for relay messages
relay.on("EVENT", (subId, event) => {
  console.log(`Received event ${event.id} for subscription ${subId}`)
})

relay.on("OK", (eventId, success, message) => {
  console.log(`Event ${eventId} ${success ? "accepted" : "rejected"}: ${message}`)
})

// Use relay protocol to publish and subscribe
relay.send("EVENT", {
  id: "event456",
  pubkey: "another-author",
  created_at: Math.floor(Date.now() / 1000),
  kind: 1,
  tags: [["t", "welshman"]],
  content: "Using LocalRelay!",
  sig: "signature"
})

// Subscribe to events with hashtag
relay.send("REQ", "tagged", {kinds: [1], "#t": ["welshman"]})
```

## Installation

```bash
npm install @welshman/relay
```


=========================
type: file
file: docs/router/index.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/router/index.md
# @welshman/router

[![version](https://badgen.net/npm/v/@welshman/router)](https://npmjs.com/package/@welshman/router)

Utilities for selecting nostr relays.

## What's Included

- **Router** - A configurable router class usable as a singleton which provides common relay selection scenarios.
- **RouterScenario** - A scenario class which scores relays based on policy.
- **getFilterSelections** - A high-level utility for inferring relay selections from filters.
- **Fallback Policies** - Functions to determine how many fallback relays to add.

## Quick Example

```typescript
import {Router, addMaximalFallbacks, getFilterSelections} from '@welshman/router'

// Configure the global router instance
Router.configure({
  getDefaultRelays: () => ['wss://relay.example.com/'],
  getPubkeyRelays: (pubkey, mode) => ['wss://myrelay.example.com/'],
  getIndexerRelays: () => ['wss://indexer.example.com/'],
  getUserPubkey: () => 'user-pubkey',
  getRelayQuality: (url) => 0.8,
  getLimit: () => 5
})

const router = Router.get()

// Get relays for reading events from specific pubkeys
const readRelays = router.FromPubkeys(['pubkey1', 'pubkey2']).getUrls()

// Get relays for publishing an event (author's outbox + mentions' inboxes)
const publishRelays = router.PublishEvent(event).getUrls()

// Try hard to find a quoted note with maximal fallbacks
const searchRelays = router
  .Quote(event, quotedEventId, hints)
  .allowLocal(true)
  .allowOnion(true)
  .allowInsecure(true)
  .policy(addMaximalFallbacks)
  .limit(10)
  .getUrls()

// Automatically select relays based on filters
const relaysAndFilters = getFilterSelections([
  {kinds: [1], authors: ['pubkey1', 'pubkey2']},
  {kinds: [0], search: 'bitcoin'}
])
```

## Installation

```bash
npm install @welshman/router
```

## Core Concepts

### Router

The main class for relay selection. Configure it once with your relay discovery functions, then use scenario methods to select relays for different purposes.

**Configuration Options:**
- `getUserPubkey()` - Returns the current user's pubkey
- `getPubkeyRelays(pubkey, mode)` - Returns relays for a pubkey ("read", "write", or "inbox")
- `getDefaultRelays()` - Returns fallback relays
- `getIndexerRelays()` - Returns relays that index profiles and relay lists
- `getSearchRelays()` - Returns relays that support NIP-50 search
- `getRelayQuality(url)` - Returns quality score (0-1) for a relay
- `getLimit()` - Returns maximum number of relays to select

**Scenario Methods:**
- `FromRelays(relays)` - Use specific relays
- `ForUser()` / `FromUser()` / `UserInbox()` - User's read/write/inbox relays
- `ForPubkey(pubkey)` / `FromPubkey(pubkey)` / `PubkeyInbox(pubkey)` - Pubkey's relays
- `ForPubkeys(pubkeys)` / `FromPubkeys(pubkeys)` - Multiple pubkeys' relays
- `Event(event)` - Relays for an event's author
- `PublishEvent(event)` - Relays for publishing (author + mentions)
- `Quote(event, id, hints)` - Relays for finding a quoted event
- `Search()` / `Index()` / `Default()` - Special relay types

### RouterScenario

Represents a relay selection with scoring and filtering options.

**Methods:**
- `getUrls()` - Returns selected relay URLs
- `getUrl()` - Returns first selected relay URL
- `limit(n)` - Limit number of relays
- `weight(scale)` - Scale selection weight
- `policy(fallbackPolicy)` - Set fallback policy
- `allowLocal(bool)` / `allowOnion(bool)` / `allowInsecure(bool)` - Filter relay types

### Fallback Policies

Functions that determine how many fallback relays to add:
- `addNoFallbacks` - Never add fallbacks
- `addMinimalFallbacks` - Add 1 fallback if no relays found
- `addMaximalFallbacks` - Fill up to the limit with fallbacks

### Filter Selection

`getFilterSelections(filters)` automatically chooses appropriate relays based on filter content:
- Search filters → search relays
- Wrap events → user's inbox
- Profile/relay kinds → indexer relays  
- Author filters → authors' relays
- Everything else → user's relays (low weight)

Returns `RelaysAndFilters[]` with optimized relay-filter combinations.


=========================
type: file
file: docs/signer/index.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/signer/index.md
# @welshman/signer

[![version](https://badgen.net/npm/v/@welshman/signer)](https://npmjs.com/package/@welshman/signer)

A Nostr signer implementation that supports multiple authentication methods and encryption standards.

## What's Included

- **ISigner Interface** - Unified API across all authentication methods
- **NIP-01 Signer** - Core implementation using key-pair cryptography
- **NIP-07 Signer** - Browser extension support (nos2x, Alby, etc.)
- **NIP-46 Signer** - Remote signing with Nostr Connect protocol
- **NIP-55 Signer** - Native app integration via Capacitor
- **NIP-59 Utils** - Gift Wrap protocol for secure event encryption

## Quick Example

```typescript
import { makeEvent } from '@welshman/util'
import { ISigner, Nip01Signer, makeSecret } from '@welshman/signer'

const signer: ISigner = new Nip01Signer(makeSecret())

signer.sign(makeEvent(1)).then(signedEvent => console.log(signedEvent))
```

## Installation

```bash
npm install @welshman/signer
```


=========================
type: file
file: docs/signer/isigner.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/signer/isigner.md
# ISigner Interface

A basic interface that each signer must implement.
It includes methods for signing messages, verifying signatures, and encrypting/decrypting data.


```typescript
interface ISigner {
  // Core signing functionality
  sign: (event: StampedEvent) => Promise<SignedEvent>
  getPubkey: () => Promise<string>

  // Encryption capabilities
  nip04: {
    encrypt: (pubkey: string, message: string) => Promise<string>
    decrypt: (pubkey: string, message: string) => Promise<string>
  }
  nip44: {
    encrypt: (pubkey: string, message: string) => Promise<string>
    decrypt: (pubkey: string, message: string) => Promise<string>
  }
}
```


=========================
type: file
file: docs/signer/nip-01.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/signer/nip-01.md
# NIP-01 Signer

The `Nip01Signer` class implements the `ISigner` interface and extends it with additional static utility methods:

```typescript
class Nip01Signer implements ISigner {
  // Constructor
  constructor(private secret: string)

  // ISigner implementation
  sign: (event: StampedEvent) => Promise<SignedEvent>
  getPubkey: () => Promise<string>
  nip04: { encrypt, decrypt }
  nip44: { encrypt, decrypt }

  // Additional static utility methods
  static fromSecret(secret: string): Nip01Signer
  static ephemeral(): Nip01Signer
}
```

### Additional Methods

The NIP-01 implementation extends the base interface with two static utility methods:

- `static fromSecret(secret: string)`: Alternative constructor for creating a signer from an existing private key
- `static ephemeral()`: Creates a new signer with a randomly generated private key

### Usage Example

```typescript
import { ISigner } from './interfaces'
import { Nip01Signer } from './signers/nip01'

// Using the standard interface
const signer: ISigner = new Nip01Signer(mySecret)

// Using NIP-01 specific utilities
const ephemeralSigner = Nip01Signer.ephemeral()
const fromExistingKey = Nip01Signer.fromSecret(mySecret)
```


=========================
type: file
file: docs/signer/nip-07.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/signer/nip-07.md
# NIP-07 Signer

The `Nip07Signer` implements the `ISigner` interface by delegating signing operations to a NIP-07 compatible browser extension (like nos2x or Alby). It provides a way to interact with user's keys that are securely stored in their browser extension.

## Browser Detection

```typescript
import { getNip07 } from '@welshman/signer'

// Check if a NIP-07 provider is available
if (getNip07()) {
  // Browser has a compatible extension installed
}
```

## Usage

```typescript
import { Nip07Signer } from '@welshman/signer'

// Create a new signer instance
const signer = new Nip07Signer()

// The extension will prompt the user for permission
// when operations are performed
```


## Complete Example

```typescript
import { Nip07Signer, getNip07 } from '@welshman/signer'
import { createEvent, NOTE } from '@welshman/util'

async function example() {
  // Check for NIP-07 provider
  if (!getNip07()) {
    throw new Error('No NIP-07 provider found. Please install a Nostr browser extension.')
  }

  // Create signer
  const signer = new Nip07Signer()

  try {
    // Get public key (will prompt user)
    const pubkey = await signer.getPubkey()
    console.log('Public key:', pubkey)

    // Create and sign an event (will prompt user)
    const event = createEvent(NOTE, {
      content: "Hello via browser extension!",
      tags: [["t", "test"]]
    })
    const signedEvent = await signer.sign(event)
    console.log('Signed event:', signedEvent)

    // Encrypt a message (will prompt user)
    const recipientPubkey = "..."
    const encrypted = await signer.nip44.encrypt(recipientPubkey, "Secret message")
    console.log('Encrypted message:', encrypted)
  } catch (error) {
    // Handle user rejection or other errors
    console.error('Operation failed:', error)
  }
}
```

## Request Serialization
The signer implements a lock mechanism to prevent concurrent calls to the extension:

```typescript
class Nip07Signer implements ISigner {
  #lock = Promise.resolve()

  #then = async <T>(f: (ext: Nip07) => T | Promise<T>) => {
    const promise = this.#lock.then(() => {
      const ext = getNip07()
      if (!ext) throw new Error("Nip07 is not enabled")
      return f(ext)
    })

    // Reset lock after completion or error
    this.#lock = promise.then(
      () => undefined,
      () => undefined
    )

    return promise
  }
}
```


=========================
type: file
file: docs/signer/nip-46.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/signer/nip-46.md
# NIP-46 (Nostr Connect) Signer

The `Nip46Signer` implements remote signing capabilities through the Nostr Connect protocol (NIP-46). It allows applications to delegate signing operations to a remote signer (like a Nostr Bunker), providing enhanced security by keeping private keys separate from the application.

## Architecture

The implementation consists of two main classes:
- `Nip46Broker`: Handles the communication with the remote signer
- `Nip46Signer`: Implements the `ISigner` interface using the broker

## Example

```typescript
import {
  makeSecret,
  Nip46Broker,
  Nip46Signer
} from '@welshman/signer'
import { createEvent, NOTE } from '@welshman/util'

async function connectToRemoteSigner() {
  // Initial setup
  const clientSecret = makeSecret()
  const relays = ['wss://relay.example.com']
  const broker = Nip46Broker.get({ relays, clientSecret })
  const signer = new Nip46Signer(broker)

  // Generate connection URL
  const ncUrl = await broker.makeNostrconnectUrl({
    name: "My App",
    description: "Testing remote signing"
  })

  // Show URL to user (e.g., as QR code)
  displayQRCode(ncUrl)

  try {
    // Wait for connection
    const response = await broker.waitForNostrconnect(
      ncUrl,
      new AbortController()
    )

    // Store signer info for later
    const bunkerUrl = broker.getBunkerUrl()
    localStorage.setItem('bunkerUrl', bunkerUrl)

    // Use the signer
    const event = createEvent(NOTE, {
      content: "Signed with remote signer!",
      tags: [["t", "test"]]
    })
    const signed = await signer.sign(event)

    return signed
  } catch (error) {
    if (error?.error) {
      console.warn(`Signer error: ${error.error}`)
    }
    throw error
  }
}

// Reconnecting with saved bunker URL
async function reconnect() {
  const bunkerUrl = localStorage.getItem('bunkerUrl')
  if (!bunkerUrl) return null

  const {
    signerPubkey,
    connectSecret,
    relays
  } = Nip46Broker.parseBunkerUrl(bunkerUrl)

  const broker = Nip46Broker.get({
    relays,
    clientSecret: makeSecret(),
    signerPubkey,
    connectSecret
  })

  return new Nip46Signer(broker)
}
```

## Nip46Broker API

### Constructor and Factory

```typescript
// Recommended: use the singleton factory
const broker = Nip46Broker.get({
  relays: string[],
  clientSecret: string,
  connectSecret?: string,
  signerPubkey?: string,
  algorithm?: "nip04" | "nip44"
})

// Direct instantiation (not recommended)
new Nip46Broker(params)
```

### Connection Methods

```typescript
// Generate a nostrconnect:// URL for the remote signer
broker.makeNostrconnectUrl(metadata: Record<string, string>): Promise<string>

// Wait for connection approval
broker.waitForNostrconnect(
  url: string,
  abort?: AbortController
): Promise<Nip46ResponseWithResult>

// Get bunker URL for later reconnection
broker.getBunkerUrl(): string

// Parse a bunker URL
Nip46Broker.parseBunkerUrl(url: string): {
  signerPubkey: string,
  connectSecret: string,
  relays: string[]
}
```

## Nip46Signer Usage

```typescript
const signer = new Nip46Signer(broker)

// All ISigner operations are available
const pubkey = await signer.getPubkey()
const signed = await signer.sign(event)
const encrypted = await signer.nip44.encrypt(pubkey, "message")
const decrypted = await signer.nip44.decrypt(pubkey, encrypted)
```


=========================
type: file
file: docs/signer/nip-55.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/signer/nip-55.md
# NIP-55 (Native App) Signer

The `Nip55Signer` implements the `ISigner` interface by communicating with native mobile signing applications through the Capacitor plugin system. This implementation is particularly useful for mobile applications that want to leverage native Nostr signing capabilities.

## Prerequisites

The signer requires the Capacitor plugin to be installed:

```bash
npm install nostr-signer-capacitor-plugin
```

## Getting Started

```typescript
import { Nip55Signer, getNip55 } from '@welshman/signer'

// Check for available signing apps
const apps = await getNip55()
if (apps.length > 0) {
  const signer = new Nip55Signer(apps[0].packageName)
}
```

## API Reference

### Detecting Available Signers

```typescript
// Returns information about installed signing apps
getNip55(): Promise<AppInfo[]>

interface AppInfo {
  name: string
  packageName: string
  // Other app-specific information
}
```

### Constructor

```typescript
constructor(packageName: string)
```
Creates a new signer instance that will communicate with the specified native app.
- `packageName`: The package identifier of the native signing app

### ISigner implementation

The `Nip55Signer` class implements the [`ISigner`](/signer/) interface

```typescript
class Nip55Signer implements ISigner {
  // Constructor
  constructor(private secret: string)

  // ISigner implementation
  sign: (event: StampedEvent) => Promise<SignedEvent>
  getPubkey: () => Promise<string>
  nip04: { encrypt, decrypt }
  nip44: { encrypt, decrypt }
}
```


## Complete Example

```typescript
import { Nip55Signer, getNip55 } from '@welshman/signer'
import { createEvent, NOTE } from '@welshman/util'

async function example() {
  try {
    // Get available signing apps
    const apps = await getNip55()
    if (apps.length === 0) {
      throw new Error('No native signing apps available')
    }

    // Create signer with first available app
    const signer = new Nip55Signer(apps[0].packageName)

    // Get public key
    const pubkey = await signer.getPubkey()
    console.log('Public key:', pubkey)

    // Sign an event
    const event = createEvent(NOTE, {
      content: "Hello from native app!",
      tags: [["t", "test"]]
    })
    const signedEvent = await signer.sign(event)
    console.log('Signed event:', signedEvent)

    // Encrypt a message
    const encrypted = await signer.nip44.encrypt(
      recipientPubkey,
      "Secret message"
    )
    console.log('Encrypted:', encrypted)

  } catch (error) {
    console.error('Native signer error:', error)
  }
}
```

## Implementation Details

### Request Serialization

The signer implements a lock mechanism to prevent concurrent requests:

```typescript
class Nip55Signer implements ISigner {
  #lock = Promise.resolve()
  #plugin = NostrSignerPlugin
  #packageName: string
  #packageNameSet = false

  #then = async <T>(f: (signer: typeof NostrSignerPlugin) => Promise<T>) => {
    const promise = this.#lock.then(async () => {
      if (!this.#packageNameSet) {
        await this.#initialize()
      }
      return f(this.#plugin)
    })

    this.#lock = promise.then(() => Promise.resolve())

    return promise
  }
}
```

### Public Key Caching

The signer caches the public key to minimize native app interactions:

```typescript
class Nip55Signer {
  #npub?: string
  #publicKey?: string

  getPubkey = async (): Promise<string> => {
    return this.#then(async signer => {
      if (!this.#publicKey || !this.#npub) {
        const {npub} = await signer.getPublicKey()
        this.#npub = npub
        const {data} = decode(npub)
        this.#publicKey = data as string
      }
      return this.#publicKey
    })
  }
}
```


## Platform Support

- iOS: Requires compatible signing app
- Android: Requires compatible signing app
- Operations availability depends on native app implementation
- Some features might be platform-specific


=========================
type: file
file: docs/signer/nip-59.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/signer/nip-59.md
# NIP-59 (Gift Wrap) Implementation

The `Nip59` class provides utilities for implementing the Gift Wrap protocol (NIP-59), allowing secure event wrapping and unwrapping. This implementation works with any signer that supports encryption, making it versatile for different authentication methods.

## Key Features

- Event wrapping (encryption) for specific recipients
- Event unwrapping (decryption) of received wrapped events
- Automatic ephemeral wrapper generation
- Caching of previously unwrapped events
- Compatible with all signer implementations

## Basic Usage

```typescript
import { Nip59 } from '@welshman/signer'
import { createEvent, DIRECT_MESSAGE } from '@welshman/util'

// Create a NIP-59 instance from any signer
const nip59 = Nip59.fromSigner(mySigner)

// Wrap an event
const rumor = await nip59.wrap(
  recipientPubkey,
  createEvent(DIRECT_MESSAGE, {
    content: "Secret message",
    tags: [["p", recipientPubkey]]
  })
)

// The wrapped event to publish
const wrappedEvent = rumor.wrap

// Unwrap a received event
const unwrapped = await nip59.unwrap(receivedWrappedEvent)
```

### Wrapping Process

The wrapping process involves multiple steps:

1. Create the rumor (original event)
2. Create the seal (encrypted rumor)
3. Create the wrap (encrypted seal)

```typescript
export const wrap = async (
  signer: ISigner,
  wrapper: ISigner,
  pubkey: string,
  template: StampedEvent,
  tags: string[][] = []
) => {
  const rumor = await getRumor(signer, template)
  const seal = await getSeal(signer, pubkey, rumor)
  const wrap = await getWrap(wrapper, pubkey, seal, tags)

  return Object.assign(rumor, {wrap})
}
```

## API Reference

### Constructor & Factory Methods

```typescript
class Nip59 {
  // Constructor
  constructor(signer: ISigner, wrapper?: ISigner)

  // Factory Methods
  static fromSigner(signer: ISigner): Nip59
  static fromSecret(secret: string): Nip59

  // Instance Methods

  /**
   * Wraps an event for a specific recipient
   * @param pubkey Recipient's public key
   * @param template The event to wrap
   * @param tags Additional tags for the wrap event (optional)
   * @returns Promise<UnwrappedEvent> Original event and its wrapped version
   */
  wrap(
    pubkey: string,
    template: StampedEvent,
    tags?: string[][]
  ): Promise<UnwrappedEvent>

  /**
   * Unwraps a received wrapped event
   * @param event The wrapped event to decrypt
   * @returns Promise<UnwrappedEvent> The original unwrapped event
   */
  unwrap(event: SignedEvent): Promise<UnwrappedEvent>

  /**
   * Creates a new instance with a specific wrapper signer
   * @param wrapper Signer to use for wrapping events
   * @returns Nip59 New instance with the specified wrapper
   */
  withWrapper(wrapper: ISigner): Nip59
}
```

## Detailed Examples

### Basic Wrapping & Unwrapping

```typescript
import { Nip59, Nip01Signer } from '@welshman/signer'
import { createEvent, DIRECT_MESSAGE } from '@welshman/util'

async function example() {
  // Create NIP-59 instance
  const signer = new Nip01Signer(mySecret)
  const nip59 = Nip59.fromSigner(signer)

  // Create and wrap an event
  const event = createEvent(DIRECT_MESSAGE, {
    content: "Secret message",
    tags: [["p", recipientPubkey]]
  })

  const rumor = await nip59.wrap(recipientPubkey, event)

  // rumor contains:
  // - The original event (rumor)
  // - The wrapped version to publish (rumor.wrap)

  // Later, unwrap a received event
  const unwrapped = await nip59.unwrap(receivedEvent)
}
```

### Custom Wrapper Signer

```typescript
import { Nip59, Nip01Signer } from '@welshman/signer'

// Create with specific wrapper
const nip59 = new Nip59(
  mainSigner,
  Nip01Signer.ephemeral() // Custom wrapper
)

// Or add wrapper to existing instance
const nip59WithWrapper = nip59.withWrapper(
  Nip01Signer.ephemeral()
)
```


=========================
type: file
file: docs/store/collection.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/store/collection.md
# Collection

Utilities for creating reactive collections with automatic loading, caching, and staleness management using Svelte stores.

## Functions

### collection(options)

Creates a reactive collection that automatically loads missing items and manages freshness.

**Options:**
- `name` - Collection name for freshness tracking
- `store` - Readable store containing array of items
- `getKey` - Function to extract unique key from items
- `load` - Async function to load missing items

**Returns:**
- `indexStore` - Derived store with items indexed by key
- `deriveItem(key, relays)` - Creates a derived store for a specific item
- `loadItem(key, relays)` - Manually loads an item
- `onItem(callback)` - Subscribe to individual item updates

### makeCachedLoader(options)

Creates a cached loader function with staleness checking and exponential backoff.

**Options:**
- `name` - Loader name for freshness tracking
- `indexStore` - Store containing indexed items
- `load` - Async function to load items
- `subscribers` - Array of item update subscribers

### Freshness Management

- `getFreshness(ns, key)` - Get last update timestamp for an item
- `setFreshnessImmediate(update)` - Immediately update freshness
- `setFreshnessThrottled(update)` - Throttled freshness updates

## Example

```typescript
import {writable} from 'svelte/store'
import {derived, readable} from "svelte/store"
import {readProfile, PROFILE, PublishedProfile} from "@welshman/util"
import {Repository} from "@welshman/relay"
import {deriveEventsMapped, collection, withGetter} from "@welshman/store"

const repository = new Repository()

export const profiles = writable([])

export const {
  indexStore: profilesByPubkey,
  deriveItem: deriveProfile,
  loadItem: loadProfile,
} = collection({
  name: "profiles",
  store: profiles,
  getKey: profile => profile.event.pubkey,
  load: (pubkey: string) => // Load the user's profile
})

// Get a reactive store for a specific profile
const hints = [/* optional relay hints to load from */]
const userProfile = deriveProfile("user-pubkey", hints)

// Subscribe to profile updates
userProfile.subscribe(profile => {
  console.log("Profile updated:", profile)
})
```


=========================
type: file
file: docs/store/custom.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/store/custom.md
# Custom Store

Utility for creating custom Svelte stores with start/stop lifecycle and optional throttling.

## Functions

### custom(start, options)

Creates a custom store that starts when first subscribed and stops when last subscriber unsubscribes.

**Parameters:**
- `start` - Function called when first subscriber is added. Receives a `set` function and should return an unsubscriber function
- `options` - Optional configuration object

**Options:**
- `throttle` - Throttle subscriber notifications (milliseconds)
- `onUpdate` - Callback function called when store value is set

**Returns:** WritableWithGetter store with `get()`, `set()`, `update()`, and `subscribe()` methods

## Example

```typescript
import {custom} from "@welshman/store"

// Create a store that tracks window width
const windowWidth = custom(
  set => {
    const updateWidth = () => set(window.innerWidth)

    // Set initial value
    updateWidth()

    // Listen for resize events
    window.addEventListener('resize', updateWidth)

    // Return cleanup function
    return () => window.removeEventListener('resize', updateWidth)
  },
  {
    throttle: 100, // Throttle updates to every 100ms
    onUpdate: (width) => console.log(`Window width: ${width}px`)
  }
)

// Subscribe to changes
const unsubscribe = windowWidth.subscribe(width => {
  console.log("Width changed:", width)
})

// Get current value
console.log("Current width:", windowWidth.get())

// Clean up
unsubscribe()
```


=========================
type: file
file: docs/store/getter.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/store/getter.md
# Getter

Utilities for adding synchronous `get()` methods to Svelte stores, allowing immediate value access without subscribing. Note that this has performance implications, since it will activate a subscription that will never get unsubscribed. Do not use this on stores that require complex calculations, or which are created and destroyed.

## Functions

### getter(store)

Creates a getter function that returns the current value of a store.

**Parameters:**
- `store` - Any readable Svelte store

**Returns:** Function that returns the current store value

### withGetter(store)

Enhances a store by adding a synchronous `get()` method.

**Parameters:**
- `store` - Readable or writable Svelte store

**Returns:** Store with added `get()` method

## Types

- `ReadableWithGetter<T>` - Readable store with `get()` method
- `WritableWithGetter<T>` - Writable store with `get()` method

## Example

```typescript
import {writable, derived} from "svelte/store"
import {withGetter, getter} from "@welshman/store"

// Create enhanced stores with getter methods
const count = withGetter(writable(0))
const doubled = withGetter(derived(count, $count => $count * 2))

// Access values synchronously without subscribing
console.log(count.get()) // 0
console.log(doubled.get()) // 0

// Update the store
count.set(5)

// Get updated values immediately
console.log(count.get()) // 5
console.log(doubled.get()) // 10

// Alternative: create getter function separately
const regularStore = writable(42)
const getValue = getter(regularStore)
console.log(getValue()) // 42
```


=========================
type: file
file: docs/store/index.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/store/index.md
# @welshman/store

[![version](https://badgen.net/npm/v/@welshman/store)](https://npmjs.com/package/@welshman/store)

A utility package providing welshman-specific svelte store functionality and utilities for managing state. While it's primarily built for use with Svelte's store system, the concepts could be valuable for developers familiar with reactive programming patterns like RxJS.

## What's Included

- **Basic Utilities** - Enhanced stores with persistence, throttling, and getter methods
- **Event-Based Stores** - Specialized stores for working with nostr events and repositories
- **Custom Adapters** - Two-way data transformation with maintained reactivity
- **Persistence Layer** - Automatic localStorage synchronization
- **Performance Optimizations** - Throttled updates and efficient subscription management

## Quick Example

```typescript
import {Repository, NAMED_PEOPLE, TrustedEvent, PublishedList, readList} from '@welshman/util'
import {deriveEventsMapped} from '@welshman/store'

const repository = new Repository()

// Create a store that performantly maps matching events in the repository to List objects
const lists = deriveEventsMapped<PublishedList>(repository, {
  filters: [{kinds: [NAMED_PEOPLE]}],
  eventToItem: (event: TrustedEvent) => (event.tags.length > 1 ? readList(event) : null),
  itemToEvent: (list: PublishedList) => list.event,
})
```

## Installation

```bash
npm install @welshman/store
```


=========================
type: file
file: docs/store/repository.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/store/repository.md
# Repository

Reactive Svelte stores for querying and mapping events from a Repository with automatic updates.

## Functions

### deriveEventsMapped(repository, options)

Creates a reactive store that maps events to custom items and keeps them synchronized with repository updates.

**Options:**
- `filters` - Array of Nostr filters to query events
- `eventToItem` - Function to transform events to items (can return Promise)
- `itemToEvent` - Function to extract the event from an item
- `throttle?` - Throttle updates (milliseconds, default: 0)
- `includeDeleted?` - Include deleted events (default: false)

### deriveEvents(repository, options)

Creates a reactive store of events without transformation.

**Options:**
- `filters` - Array of Nostr filters
- `throttle?` - Throttle updates
- `includeDeleted?` - Include deleted events

### deriveEvent(repository, idOrAddress)

Creates a reactive store for a single event by ID or address.

### deriveIsDeleted(repository, event)

Creates a reactive store that tracks whether an event is deleted.

### deriveIsDeletedByAddress(repository, event)

Creates a reactive store that tracks whether an event is deleted by address.

## Example

```typescript
import {Repository} from "@welshman/relay"
import {deriveEventsMapped, deriveEvents} from "@welshman/store"
import {readProfile, PROFILE} from "@welshman/util"

const repository = new Repository()

// Reactive store of text notes
const textNotes = deriveEvents(repository, {
  filters: [{kinds: [1], limit: 100}],
  throttle: 100
})

// Reactive store of profiles mapped to custom objects
const profiles = deriveEventsMapped(repository, {
  filters: [{kinds: [PROFILE]}],
  eventToItem: event => readProfile(event),
  itemToEvent: profile => profile.event,
  includeDeleted: false
})

// Subscribe to updates
textNotes.subscribe(notes => {
  console.log(`Found ${notes.length} text notes`)
})

profiles.subscribe(profiles => {
  console.log(`Found ${profiles.length} profiles`)
})

// Add some events to the repository
repository.publish(someTextNoteEvent)
repository.publish(someProfileEvent)
```

=========================
type: file
file: docs/store/synced.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/store/synced.md
# Synced Store

Utility for creating Svelte stores that automatically persist to and restore from storage providers.

## Functions

### synced(config)

Creates a writable store that synchronizes with a storage provider using JSON serialization.

**Parameters:**
- `config` - Configuration object containing:
  - `key` - Storage key to store the value under
  - `storage` - Storage provider implementing the StorageProvider interface
  - `defaultValue` - Default value if nothing exists in storage

**Returns:** `Synced<T>` - A writable Svelte store with a `ready` promise that resolves when initial storage loading completes

The store automatically:
- Loads initial value from storage asynchronously on creation
- Saves any changes back to storage
- Falls back to defaultValue if storage is empty or invalid
- Provides a `ready` promise that resolves when initial loading is complete

## Storage Provider Interface

```typescript
interface StorageProvider {
  get: (key: string) => Promise<any>
  set: (key: string, value: any) => Promise<void>
}
```

## Example

```typescript
import {synced, localStorageProvider} from "@welshman/store"

// Create a store that persists user preferences using localStorage
const userPreferences = synced({
  key: "user-prefs",
  storage: localStorageProvider,
  defaultValue: {
    theme: "dark",
    notifications: true,
    language: "en"
  }
})

// Wait for initial loading to complete if needed
await userPreferences.ready

// Use like any writable store
userPreferences.subscribe(prefs => {
  console.log("Preferences:", prefs)
})

// Update the store - automatically saves to storage
userPreferences.update(prefs => ({
  ...prefs,
  theme: "light"
}))
```


=========================
type: file
file: docs/store/throttle.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/store/throttle.md
# Throttled Store

Utility for wrapping Svelte stores to throttle subscriber notifications, reducing update frequency for performance.

## Functions

### throttled(delay, store)

Creates a throttled version of a store that limits how often subscribers are notified.

**Parameters:**
- `delay` - Throttle delay in milliseconds (0 disables throttling)
- `store` - Any readable Svelte store

**Returns:** Store with throttled subscription behavior

When `delay` is 0, returns the original store unchanged. Otherwise, wraps the store so that subscribers receive updates at most once per delay period.

## Example

```typescript
import {writable} from "svelte/store"
import {throttled} from "@welshman/store"

// Create a regular store that updates frequently
const fastStore = writable(0)

// Create a throttled version that only notifies every 100ms
const slowStore = throttled(100, fastStore)

// Subscribe to both stores
fastStore.subscribe(value => console.log("Fast:", value))
slowStore.subscribe(value => console.log("Slow:", value))

// Rapidly update the store
let count = 0
const interval = setInterval(() => {
  fastStore.set(++count)

  if (count >= 10) {
    clearInterval(interval)
  }
}, 10) // Update every 10ms

// Output:
// Fast: 1, Fast: 2, Fast: 3, ... (every update)
// Slow: 1, Slow: 5, Slow: 10 (throttled to ~100ms intervals)
```


=========================
type: file
file: docs/util/address.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/util/address.md
# Nostr Address

The Address module provides utilities for working with Nostr Addresses (NIP-19 naddr format) and handles the conversion between different address formats. Addresses are used to reference addressable events (kinds 10000-39999) in a format that includes kind, pubkey, and identifier.

## API

```typescript
// Address class for handling addressable events
export declare class Address {
  constructor(
    kind: number,
    pubkey: string,
    identifier: string,
    relays?: string[]
  );

  // Check if string is a valid address format
  static isAddress(address: string): boolean;

  // Parse address from string format "kind:pubkey:identifier"
  static from(address: string, relays?: string[]): Address;

  // Parse address from naddr (NIP-19 format)
  static fromNaddr(naddr: string): Address;

  // Create address from addressable event
  static fromEvent(event: AddressableEvent, relays?: string[]): Address;

  // Convert to string format "kind:pubkey:identifier"
  toString(): string;

  // Convert to naddr (NIP-19 format)
  toNaddr(): string;
}

// Utility function to get address string from event
export declare const getAddress: (e: AddressableEvent) => string;
```

## Examples

### Creating and parsing addresses

```typescript
import { Address } from '@welshman/util';

// Create address from components
const address = new Address(
  30023,
  '27067f0efd1b9ffc6d71672a1b69a4e5ac3b8ce3cc8428b06849448e38d69389',
  'my-article',
  ['wss://relay.example.com']
);

// Parse from string format
const parsed = Address.from('30023:27067f0efd1b9ffc6d71672a1b69a4e5ac3b8ce3cc8428b06849448e38d69389:my-article');
console.log(parsed.kind); // 30023
console.log(parsed.identifier); // 'my-article'

// Check if string is valid address
const isValid = Address.isAddress('30023:27067f0efd1b9ffc6d71672a1b69a4e5ac3b8ce3cc8428b06849448e38d69389:my-article'); // true
const isInvalid = Address.isAddress('invalid-format'); // false
```

### Converting between formats

```typescript
import { Address } from '@welshman/util';

const address = new Address(30023, '27067f0efd1b9ffc6d71672a1b69a4e5ac3b8ce3cc8428b06849448e38d69389', 'my-article');

// Convert to string format
const addressString = address.toString();
console.log(addressString); // '30023:27067f0efd1b9ffc6d71672a1b69a4e5ac3b8ce3cc8428b06849448e38d69389:my-article'

// Convert to naddr format (NIP-19)
const naddr = address.toNaddr();
console.log(naddr); // 'naddr1...'

// Parse back from naddr
const fromNaddr = Address.fromNaddr(naddr);
console.log(fromNaddr.kind); // 30023
```

### Working with events

```typescript
import { Address, getAddress } from '@welshman/util';

const event = {
  kind: 30023,
  pubkey: '27067f0efd1b9ffc6d71672a1b69a4e5ac3b8ce3cc8428b06849448e38d69389',
  tags: [
    ['d', 'my-article'],
    ['title', 'My Article Title']
  ]
};

// Create address from event
const address = Address.fromEvent(event, ['wss://relay.example.com']);
console.log(address.identifier); // 'my-article'

// Get address string directly
const addressString = getAddress(event);
console.log(addressString); // '30023:27067f0efd1b9ffc6d71672a1b69a4e5ac3b8ce3cc8428b06849448e38d69389:my-article'
```


=========================
type: file
file: docs/util/blossom.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/util/blossom.md
# Blossom

Client library for interacting with Blossom media servers. Provides utilities for authentication, blob operations, and file encryption.

## Types

```typescript
export type BlossomAuthAction = "get" | "upload" | "list" | "delete"

export type BlossomAuthEventOpts = {
  action: BlossomAuthAction
  server: string
  hashes?: string[]
  expiration?: number
  content?: string
}

export type BlossomServer = {
  url: string
  pubkey?: string
}

export type BlossomErrorResponse = {
  message: string
  reason?: string
}

export interface EncryptedFile {
  key: string
  nonce: string
  ciphertext: Uint8Array
  algorithm: string
}
```

## Authentication

```typescript
// Creates a Blossom auth event for server operations
export declare const makeBlossomAuthEvent: (opts: BlossomAuthEventOpts) => Event
```

## Blob Operations

```typescript
// Builds URL for accessing a blob
export declare const buildBlobUrl: (server: string, sha256: string, extension?: string) => string

// Checks if a blob exists on server
export declare const checkBlobExists: (server: string, sha256: string, options?: { authEvent?: SignedEvent }) => Promise<{exists: boolean; size?: number}>

// Downloads blob from server
export declare const getBlob: (server: string, sha256: string, options?: { authEvent?: SignedEvent; range?: {start: number; end?: number} }) => Promise<Response>

// Uploads blob to server
export declare const uploadBlob: (server: string, blob: Blob | ArrayBuffer, options?: { authEvent?: SignedEvent }) => Promise<Response>

// Deletes blob from server
export declare const deleteBlob: (server: string, sha256: string, options?: { authEvent?: SignedEvent }) => Promise<Response>

// Lists blobs for a pubkey
export declare const listBlobs: (server: string, pubkey: string, options?: { authEvent?: SignedEvent; since?: number; until?: number }) => Promise<Response>
```

## File Encryption

```typescript
// Encrypts a file using AES-GCM
export declare function encryptFile(file: Blob): Promise<EncryptedFile>

// Decrypts an encrypted file
export declare function decryptFile(encryptedFile: EncryptedFile): Promise<Uint8Array>
```

## Example

```typescript
import { uploadBlob, makeBlossomAuthEvent } from '@welshman/util'

// Create auth event for upload
const authEvent = makeBlossomAuthEvent({
  action: "upload",
  server: "https://blossom.example.com"
})

// Sign the auth event with your signer
const signedAuthEvent = await signer.signEvent(authEvent)

// Upload a file
const file = new File(["Hello world"], "hello.txt", { type: "text/plain" })
const response = await uploadBlob("https://blossom.example.com", file, {
  authEvent: signedAuthEvent
})
```


=========================
type: file
file: docs/util/encryptable.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/util/encryptable.md
# Encryptable

The Encryptable module provides utilities for handling encrypted Nostr events, allowing you to merge plaintext updates into events and encrypt them before publishing.

## API

```typescript
// Encryption function type
export type Encrypt = (x: string) => Promise<string>;

// Partial event content for updates
export type EncryptableUpdates = Partial<EventContent>;

// Event with attached plaintext data
export type DecryptedEvent = TrustedEvent & {
  plaintext: EncryptableUpdates;
};

// Creates a DecryptedEvent by attaching plaintext to an event
export declare const asDecryptedEvent: (
  event: TrustedEvent,
  plaintext?: EncryptableUpdates
) => DecryptedEvent;

// Encryptable class for handling encrypted events
export declare class Encryptable<T extends EventTemplate> {
  constructor(
    event: Partial<T>,
    updates: EncryptableUpdates
  );

  // Encrypts updates and merges them into the event
  reconcile(encrypt: Encrypt): Promise<T>;
}
```

## Examples

### Basic Usage

```typescript
import { Encryptable } from '@welshman/util';

// Create encryptable with plaintext updates
const encryptable = new Encryptable(
  { kind: 10000 }, // Base event template
  { content: "secret mute list data" } // Plaintext content to encrypt
);

// Encrypt and get final event
const encryptFn = async (text: string) => {
  // Your encryption logic here
  return await encrypt(text);
};

const event = await encryptable.reconcile(encryptFn);
// event.content is now encrypted
```

### Encrypting Tags

```typescript
import { Encryptable } from '@welshman/util';

// Encrypt both content and tag values
const encryptable = new Encryptable(
  { kind: 10000, tags: [] },
  {
    content: JSON.stringify(['pubkey1', 'pubkey2']),
    tags: [['p', 'sensitive-pubkey'], ['e', 'sensitive-event-id']]
  }
);

// The reconcile method encrypts tag values at index 1
const event = await encryptable.reconcile(encryptFn);
// event.tags[0] = ['p', 'encrypted-pubkey']
// event.tags[1] = ['e', 'encrypted-event-id']
```

### Working with Decrypted Events

```typescript
import { asDecryptedEvent } from '@welshman/util';

// Add plaintext data to an event for reference
const event = { kind: 10000, content: "encrypted...", tags: [] };
const plaintext = { content: "original content", tags: [['p', 'pubkey']] };

const decryptedEvent = asDecryptedEvent(event, plaintext);
console.log(decryptedEvent.plaintext.content); // "original content"
```


=========================
type: file
file: docs/util/events.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/util/events.md
# Nostr Events

The Events module provides type definitions and utilities for working with Nostr events, including creation, validation, and manipulation functions.

## API

### Event Types

```typescript
// Base event content structure
export type EventContent = {
  tags: string[][];
  content: string;
};

// Event template with kind
export type EventTemplate = EventContent & {
  kind: number;
};

// Event with timestamp
export type StampedEvent = EventTemplate & {
  created_at: number;
};

// Event with author
export type OwnedEvent = StampedEvent & {
  pubkey: string;
};

// Event with ID
export type HashedEvent = OwnedEvent & {
  id: string;
};

// Signed event
export type SignedEvent = HashedEvent & {
  sig: string;
};

// Wrapped event (NIP-59)
export type UnwrappedEvent = HashedEvent & {
  wrap: SignedEvent;
};

// Event that can be either signed or wrapped
export type TrustedEvent = HashedEvent & {
  sig?: string;
  wrap?: SignedEvent;
};
```

### Event Creation

```typescript
// Options for creating events
export type MakeEventOpts = {
  content?: string;
  tags?: string[][];
  created_at?: number;
};

// Creates a stamped event template
export declare const makeEvent: (kind: number, opts?: MakeEventOpts) => StampedEvent;
```

### Type Guards

```typescript
export declare const isEventTemplate: (e: EventTemplate) => e is EventTemplate;
export declare const isStampedEvent: (e: StampedEvent) => e is StampedEvent;
export declare const isOwnedEvent: (e: OwnedEvent) => e is OwnedEvent;
export declare const isHashedEvent: (e: HashedEvent) => e is HashedEvent;
export declare const isSignedEvent: (e: TrustedEvent) => e is SignedEvent;
export declare const isUnwrappedEvent: (e: TrustedEvent) => e is UnwrappedEvent;
export declare const isTrustedEvent: (e: TrustedEvent) => e is TrustedEvent;
```

### Event Utilities

```typescript
// Event validation and signatures
export declare const verifyEvent: (event: TrustedEvent) => boolean;

// Event properties
export declare const getIdentifier: (e: EventTemplate) => string | undefined;
export declare const getIdOrAddress: (e: HashedEvent) => string;
export declare const getIdAndAddress: (e: HashedEvent) => string[];

// Event type checking
export declare const isEphemeral: (e: EventTemplate) => boolean;
export declare const isReplaceable: (e: EventTemplate) => boolean;
export declare const isPlainReplaceable: (e: EventTemplate) => boolean;
export declare const isParameterizedReplaceable: (e: EventTemplate) => boolean;

// Thread and reply handling
// Note: getAncestors handles comments (kind 1111) differently from regular notes
export declare const getAncestors: (event: EventTemplate) => { roots: string[]; replies: string[] };
export declare const getParentIdsAndAddrs: (event: EventTemplate) => string[];
export declare const getParentIdOrAddr: (event: EventTemplate) => string | undefined;
export declare const getParentId: (event: EventTemplate) => string | undefined;
export declare const getParentAddr: (event: EventTemplate) => string | undefined;
export declare const isChildOf: (child: EventTemplate, parent: HashedEvent) => boolean;
```

## Threading Protocols

The `getAncestors` function handles two different threading protocols:

### Regular Notes (NIP-10)
For regular notes and most event kinds, threading follows [NIP-10](https://github.com/nostr-protocol/nips/blob/master/10.md):
- Uses `e` and `a` tags with optional markers (`root`, `reply`, `mention`)
- Positional rules apply when markers are absent:
  - First `e`/`a` tag = root
  - Last `e`/`a` tag = reply target
  - Middle tags = mentions

### Comments (NIP-22)
For comments (kind 1111), threading follows [NIP-22](https://github.com/nostr-protocol/nips/blob/master/22.md):
- Uses uppercase tags (`E`, `A`, `P`, `K`) for root references
- Uses lowercase tags (`e`, `a`, `p`, `k`) for reply references
- No positional rules - explicit tag types determine relationship

All `getParent*` functions and `isChildOf` include this logic, automatically handling both protocols based on event kind.

## Examples

### Creating Events

```typescript
import { makeEvent, NOTE, LONG_FORM } from '@welshman/util';

// Create a basic note
const note = makeEvent(NOTE, {
  content: "Hello Nostr!",
  tags: [["t", "nostr"]]
});

// Create a long-form article with custom timestamp
const article = makeEvent(LONG_FORM, {
  content: "# My Article\n\nThis is my article content...",
  tags: [["d", "my-article"], ["title", "My Article"]],
  created_at: 1234567890
});
```

### Event Properties

```typescript
import { getIdentifier, getIdOrAddress, LONG_FORM } from '@welshman/util';

const article = makeEvent(LONG_FORM, {
  content: "Article content...",
  tags: [["d", "my-unique-id"]]
});

// Get the identifier (d tag value)
const identifier = getIdentifier(article); // "my-unique-id"

// For a hashed event, get ID or address
const reference = getIdOrAddress(hashedArticle);
// Returns address for replaceable events, ID for others
```

### Working with Threads

```typescript
import { getAncestors, isChildOf, NOTE, COMMENT } from '@welshman/util';

// Regular note reply (NIP-10)
const noteReply = makeEvent(NOTE, {
  content: "This is a reply to a note",
  tags: [
    ["e", "root-event-id", "", "root"],
    ["e", "parent-event-id", "", "reply"]
  ]
});

// Comment reply (NIP-22)
const commentReply = makeEvent(COMMENT, {
  content: "This is a reply comment",
  tags: [
    ["E", "root-event-id"],  // uppercase = root reference
    ["e", "parent-event-id"] // lowercase = reply reference
  ]
});

// Both work the same way
const noteAncestors = getAncestors(noteReply);
const commentAncestors = getAncestors(commentReply);

console.log('Note roots:', noteAncestors.roots);     // ["root-event-id"]
console.log('Note replies:', noteAncestors.replies); // ["parent-event-id"]

console.log('Comment roots:', commentAncestors.roots);     // ["root-event-id"] 
console.log('Comment replies:', commentAncestors.replies); // ["parent-event-id"]

// Parent checking works for both protocols
if (isChildOf(noteReply, parentEvent)) {
  console.log('Note is a reply');
}
if (isChildOf(commentReply, parentEvent)) {
  console.log('Comment is a reply');
}
```


=========================
type: file
file: docs/util/filters.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/util/filters.md
# Filters

The Filters module provides utilities for creating, manipulating, and matching Nostr event filters. It includes support for filter operations, optimization, and time-based filtering.

## API

### Filter Matching

```typescript
// Check if an event matches a filter
export declare const matchFilter: <E extends HashedEvent>(filter: Filter, event: E) => boolean;

// Check if an event matches any filter in array
export declare const matchFilters: <E extends HashedEvent>(filters: Filter[], event: E) => boolean;
```

### Filter Operations

```typescript
// Get a compact string representation of a filter
export declare const getFilterId: (filter: Filter) => string;

// Combine multiple filters into minimal filter set
export declare const unionFilters: (filters: Filter[]) => Filter[];

// Create intersection of filter groups
export declare const intersectFilters: (groups: Filter[][]) => Filter[];

// Trim large filter arrays to avoid relay limits
export declare const trimFilter: (filter: Filter) => Filter;
export declare const trimFilters: (filters: Filter[]) => Filter[];
```

### Specialized Filter Creation

```typescript
// Create filters for finding events by ID or address
export declare const getIdFilters: (idsOrAddresses: string[]) => Filter[];

// Create filters for finding replies to events
export declare const getReplyFilters: (events: TrustedEvent[], filter?: Filter) => Filter[];

// Add repost filters (kinds 6, 16) to existing filters
export declare const addRepostFilters: (filters: Filter[]) => Filter[];
```

### Filter Analysis

```typescript
// Calculate filter generality (0 = specific, 1 = very general)
export declare const getFilterGenerality: (filter: Filter) => number;

// Estimate time delta for filter results
export declare const guessFilterDelta: (filters: Filter[], max?: number) => number;

// Get expected result count for ID-based filters
export declare const getFilterResultCardinality: (filter: Filter) => number | undefined;
```

## Examples

### Basic Filter Matching

```typescript
import { matchFilter, matchFilters, NOTE, LONG_FORM } from '@welshman/util';

const event = {
  id: 'abc123...',
  kind: 1,
  pubkey: 'def456...',
  created_at: 1234567890,
  content: 'Hello Nostr!',
  tags: [['t', 'nostr']]
};

// Single filter matching
const filter = { kinds: [NOTE], authors: ['def456...'] };
const matches = matchFilter(filter, event); // true

// Multiple filter matching
const filters = [
  { kinds: [NOTE] },
  { kinds: [LONG_FORM], authors: ['def456...'] }
];
const matchesAny = matchFilters(filters, event); // true (matches first filter)
```

### Creating Filters for IDs and Addresses

```typescript
import { getIdFilters } from '@welshman/util';

// Mix of event IDs and addresses
const references = [
  'abc123...', // event ID
  '30023:def456...:my-article', // address
  'ghi789...', // another event ID
];

const filters = getIdFilters(references);
// Returns: [
//   { ids: ['abc123...', 'ghi789...'] },
//   { kinds: [30023], authors: ['def456...'], '#d': ['my-article'] }
// ]
```

### Finding Replies

```typescript
import { getReplyFilters } from '@welshman/util';

const originalEvents = [
  { id: 'abc123...', kind: 1, /* ... */ },
  { id: 'def456...', kind: 30023, /* ... */ }
];

// Find all replies to these events
const replyFilters = getReplyFilters(originalEvents);
// Returns filters with #e and #a tags pointing to the original events

// Add additional constraints
const recentReplies = getReplyFilters(originalEvents, {
  since: Math.floor(Date.now() / 1000) - 3600 // last hour
});
```

### Filter Operations

```typescript
import { unionFilters, intersectFilters, trimFilters } from '@welshman/util';

// Combine overlapping filters
const filters = [
  { kinds: [1], authors: ['abc...'] },
  { kinds: [1], authors: ['def...'] },
  { kinds: [6], authors: ['abc...'] }
];

const combined = unionFilters(filters);
// Results in more efficient filter set

// Intersect filter groups
const group1 = [{ kinds: [1, 6] }];
const group2 = [{ authors: ['abc...', 'def...'] }];
const intersection = intersectFilters([group1, group2]);
// Returns: [{ kinds: [1, 6], authors: ['abc...', 'def...'] }]

// Trim oversized filters
const largeFilters = [{ authors: new Array(2000).fill('pubkey') }];
const trimmed = trimFilters(largeFilters);
// Limits arrays to 1000 items max
```

### Adding Repost Support

```typescript
import { addRepostFilters, NOTE, LONG_FORM } from '@welshman/util';

const baseFilters = [
  { kinds: [NOTE] },
  { kinds: [LONG_FORM], authors: ['abc...'] }
];

const withReposts = addRepostFilters(baseFilters);
// Automatically adds:
// - kind 6 filters for note reposts
// - kind 16 filters with #k tags for other reposts
```

### Filter Analysis

```typescript
import { getFilterGenerality, guessFilterDelta, getFilterResultCardinality } from '@welshman/util';

const specificFilter = { ids: ['abc123...'] };
const generalFilter = { kinds: [1] };

console.log(getFilterGenerality(specificFilter)); // 0 (very specific)
console.log(getFilterGenerality(generalFilter)); // 1 (very general)

// Estimate appropriate time window
const filters = [{ authors: ['abc...', 'def...'] }];
const deltaSeconds = guessFilterDelta(filters); // ~21600 (6 hours)

// Check expected result count
const idFilter = { ids: ['abc...', 'def...', 'ghi...'] };
const resultCount = getFilterResultCardinality(idFilter); // 3
```


=========================
type: file
file: docs/util/handlers.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/util/handlers.md
# Handlers (NIP-89)

The Handlers module provides functionality for working with handler recommendations and information (NIP-89).
Handlers are events that describe which kinds a given application can display.

This module provides utilities for transforming these events into structured handler objects that applications can easily process.


## Types

### Handler Definition

```typescript
type Handler = {
  kind: number          // Event kind this handler can process
  name: string          // Display name of the handler
  about: string         // Description
  image: string         // Icon or image URL
  identifier: string    // Unique identifier (d-tag)
  event: TrustedEvent   // Original handler event
  website?: string      // Optional website URL
  lud16?: string        // Optional Lightning address
  nip05?: string        // Optional NIP-05 identifier
}
```

## Core Functions

### Reading Handlers
```typescript
function readHandlers(event: TrustedEvent): Handler[]

// Example
const handlers = readHandlers(handlerEvent)
handlers.forEach(handler => {
  console.log(`Handler for kind ${handler.kind}: ${handler.name}`)
})
```

### Handler Identification
```typescript
function getHandlerKey(handler: Handler): string
// Returns "kind:address" format

function getHandlerAddress(event: TrustedEvent): string | undefined
// Gets handler address from event tags
```

### Display Formatting
```typescript
function displayHandler(
  handler?: Handler,
  fallback = ""
): string
```

## Usage Examples

### Reading Handler Information
```typescript
const event = {
  kind: 31990, // Handler Information kind
  content: JSON.stringify({
    name: "Note Viewer",
    about: "Displays text notes with formatting",
    image: "https://example.com/icon.png"
  }),
  tags: [
    ['k', '1'], // Handles kind 1 (text notes)
    ['d', 'note-viewer']
  ]
}

const handlers = readHandlers(event)
// Returns array of handlers defined in the event
```

### Working with Handlers
```typescript
// Get unique handler identifier
const key = getHandlerKey(handler)
// => "1:30023:note-viewer" (kind:pubkey:identifier)

// Display handler name
const name = displayHandler(handler, "Unknown Handler")
// => "Note Viewer" or fallback if handler undefined

// Get handler address
const address = getHandlerAddress(event)
// Returns address from tags with 'web' marker or first address
```

## Complete Example

```typescript
// Process handler information event
function processHandlerEvent(event: TrustedEvent) {
  // Read all handlers from event
  const handlers = readHandlers(event)

  // Process each handler
  handlers.forEach(handler => {
    // Generate unique key
    const key = getHandlerKey(handler)

    // Store handler information
    handlerRegistry.set(key, {
      name: handler.name,
      kind: handler.kind,
      about: handler.about,
      image: handler.image,
      website: handler.website,
      address: getHandlerAddress(handler.event)
    })
  })
}

// Find handler for event kind
function findHandler(kind: number): Handler | undefined {
  return Array.from(handlerRegistry.values())
    .find(h => h.kind === kind)
}

// Display handler information
function renderHandler(handler: Handler) {
  return {
    title: displayHandler(handler, "Unknown"),
    description: handler.about,
    icon: handler.image,
    website: handler.website || null
  }
}
```


=========================
type: file
file: docs/util/index.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/util/index.md
# @welshman/util

[![version](https://badgen.net/npm/v/@welshman/util)](https://npmjs.com/package/@welshman/util)

A utility package for Nostr application development, providing essential tools and types for working with Nostr events, addresses, profiles, and more.

## What's Included

- **Event Management**: Create, validate, and process Nostr events
- **Repository**: In-memory event storage with querying and indexing
- **Filters**: Advanced event filtering and subscription management
- **Profiles**: User profile handling and formatting
- **Lists**: Public and private list management
- **Zaps**: Lightning Network payment integration
- **Tags**: Comprehensive tag parsing and manipulation
- **Addresses**: NIP-19 address handling
- **Relays**: Relay URL handling, event dispatching and in-memory storage

## Installation

```
npm install @welshman/util
```


=========================
type: file
file: docs/util/kinds.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/util/kinds.md
# Event Kinds

This module provides a comprehensive collection of Nostr event kind definitions and utilities.
It includes standard NIP event kinds as well as commonly used application-specific kinds.


## Kind Type Checkers

```typescript
// Check if kind is ephemeral (should not be stored)
export const isEphemeralKind = (kind: number): boolean

// Check if kind is replaceable (only latest event matters)
export const isReplaceableKind = (kind: number): boolean

// Check if kind is plain replaceable (no parameters)
export const isPlainReplaceableKind = (kind: number): boolean

// Check if kind is parameterized replaceable
export const isParameterizedReplaceableKind = (kind: number): boolean
```

## Usage Examples

### Checking Event Types
```typescript
import { isReplaceableKind, PROFILE, NOTE } from '@welshman/util'

// Profile events are replaceable
isReplaceableKind(PROFILE) // => true

// Notes are not replaceable
isReplaceableKind(NOTE) // => false
```

### Working with DVMs
```typescript
import {
  DVM_REQUEST_TEXT_SUMMARY,
  DVM_RESPONSE_TEXT_SUMMARY,
  isDVMKind
} from '@welshman/util'

// Create DVM request
const request = {
  kind: DVM_REQUEST_TEXT_SUMMARY,
  content: "Text to summarize"
}

// Check for DVM events
isDVMKind(event.kind) // => true for kinds 5000-7000
```

### Handling Replaceable Events
```typescript
import {
  isReplaceableKind,
  PROFILE,
  LONG_FORM
} from '@welshman/util'

function handleEvent(event) {
  if (isReplaceableKind(event.kind)) {
    // Only keep latest version
    replaceExistingEvent(event)
  } else {
    // Keep all versions
    storeNewEvent(event)
  }
}
```


=========================
type: file
file: docs/util/links.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/util/links.md
# Links

A small module for handling Nostr URI manipulation.

## Core Functions

### fromNostrURI
```typescript
function fromNostrURI(s: string): string

// Examples
fromNostrURI('nostr:npub1...') // => 'npub1...'
fromNostrURI('nostr://npub1...') // => 'npub1...'
fromNostrURI('note1...') // => 'note1...'
```
Removes the `nostr:` or `nostr://` protocol prefix from a Nostr URI.

### toNostrURI
```typescript
function toNostrURI(s: string): string

// Examples
toNostrURI('npub1...') // => 'nostr:npub1...'
toNostrURI('nostr:npub1...') // => 'nostr:npub1...' (unchanged)
```
Ensures a string has the `nostr:` protocol prefix.


=========================
type: file
file: docs/util/list.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/util/list.md
# Lists

The Lists module provides utilities for working with Nostr lists, including both public and private lists (like bookmarks, mute lists, etc.). It handles list creation, encryption, and manipulation.

## Core Types

### List Parameters
```typescript
interface ListParams {
  kind: number      // List kind (e.g., 10000 for mutes)
}
```

### List Structure
```typescript
interface List extends ListParams {
  publicTags: string[][]   // Publicly visible tags
  privateTags: string[][]  // Encrypted tags
  event?: DecryptedEvent   // Original event if list exists
}
```

### Published List
```typescript
interface PublishedList extends List {
  event: DecryptedEvent    // Required event for published lists
}
```

## List Creation

### Create New List
```typescript
function makeList(list: ListParams & Partial<List>): List

// Example
const muteList = makeList({
  kind: 10000,
  publicTags: [['d', 'mutes']],
  privateTags: [['p', 'pubkey1'], ['p', 'pubkey2']]
})
```

### Read Existing List
```typescript
function readList(event: DecryptedEvent): PublishedList

// Example
const list = readList(decryptedEvent)
```

## List Operations

### Get All Tags
```typescript
function getListTags(list: List | undefined): string[][]

// Example
const allTags = getListTags(list) // Combines public and private tags
```

### Remove Items
```typescript
// Remove by predicate
function removeFromListByPredicate(
  list: List,
  pred: (t: string[]) => boolean
): Encryptable

// Remove by value
function removeFromList(
  list: List,
  value: string
): Encryptable
```

### Add Items
```typescript
// Add public items
function addToListPublicly(
  list: List,
  ...tags: string[][]
): Encryptable

// Add private items
function addToListPrivately(
  list: List,
  ...tags: string[][]
): Encryptable

// Update list with new tags
function updateList(
  list: List,
  options: {publicTags?: string[][], privateTags?: string[][]}
): Encryptable
```

## Usage Examples

### Creating a Private List
```typescript
// Create new mute list
const muteList = makeList({
  kind: 10000,
  publicTags: [
    ['d', 'mutes'],
    ['name', 'My Mute List']
  ]
})

// Add items privately
const updated = addToListPrivately(
  muteList,
  ['p', 'pubkey1'],
  ['p', 'pubkey2']
)

// Add new items publicly
const addItems = addToListPublicly(
  list,
  ['p', 'pubkey3'],
  ['p', 'pubkey4']
)

// Encrypt and publish
const encrypted = await updated.reconcile(encrypt)
```

### Reading and Updating Lists
```typescript
// Read existing list
const list = readList(decryptedEvent)

// Remove item
const removeItem = removeFromList(list, 'pubkey1')

// Remove by predicate
const noMentions = removeFromListByPredicate(
  list,
  tag => tag[0] === 'p'
)
```

### Working with Tags
```typescript
// Get all list tags
const tags = getListTags(list)
```


=========================
type: file
file: docs/util/nip42.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/util/nip42.md
# NIP-42

Utilities for NIP-42 relay authentication, allowing clients to authenticate with relays that require it.

## Functions

### makeRelayAuth(url, challenge)

Creates a CLIENT_AUTH event (kind 22242) for relay authentication as specified in NIP-42.

**Parameters:**
- `url` - The relay URL to authenticate with
- `challenge` - The challenge string provided by the relay

**Returns:** Unsigned event object with relay and challenge tags

## Example

```typescript
import {makeRelayAuth} from "@welshman/util"

// Create auth event when relay sends AUTH challenge
const authEvent = makeRelayAuth(
  "wss://relay.example.com",
  "challenge-string-from-relay"
)

// Sign the event with your signer
const signedAuth = await signer.sign(authEvent)
```


=========================
type: file
file: docs/util/nip86.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/util/nip86.md
# NIP-86 Relay Management

Implementation of NIP-86 for managing Nostr relays through authenticated RPC requests.

## Types

```typescript
export enum ManagementMethod {
  SupportedMethods = "supportedmethods",
  BanPubkey = "banpubkey",
  AllowPubkey = "allowpubkey",
  ListBannedPubkeys = "listbannedpubkeys",
  ListAllowedPubkeys = "listallowedpubkeys",
  ListEventsNeedingModeration = "listeventsneedingmoderation",
  AllowEvent = "allowevent",
  BanEvent = "banevent",
  ListBannedEvents = "listbannedevents",
  ChangeRelayName = "changerelayname",
  ChangeRelayDescription = "changerelaydescription",
  ChangeRelayIcon = "changerelayicon",
  AllowKind = "allowkind",
  DisallowKind = "disallowkind",
  ListAllowedKinds = "listallowedkinds",
  BlockIp = "blockip",
  UnblockIp = "unblockip",
  ListBlockedIps = "listblockedips",
}

export type ManagementRequest = {
  method: ManagementMethod
  params: string[]
}
```

## Functions

```typescript
// Sends a management request to a relay
export declare const sendManagementRequest: (url: string, request: ManagementRequest, authEvent: SignedEvent) => Promise<any>
```

## Example

```typescript
import { sendManagementRequest, ManagementMethod, makeHttpAuth } from '@welshman/util'

// Set up our url and params
const url = "https://relay.example.com/"
const payload = {method: ManagementMethod.SupportedMethods, params: []}

// Create auth event for the management endpoint
const authEvent = await makeHttpAuth(url, "POST", JSON.stringify(payload))
const signedAuthEvent = await signer.signEvent(authEvent)

// Get a list of supported methods
const response = await sendManagementRequest(url, payload, signedAuthEvent)
```


=========================
type: file
file: docs/util/nip98.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/util/nip98.md
# NIP-98 HTTP Auth

Implementation of NIP-98 HTTP Authentication for authenticating HTTP requests with Nostr events.

## Functions

```typescript
// Creates an HTTP auth event for authenticating requests
export declare const makeHttpAuth: (url: string, method?: string, body?: string) => Promise<Event>

// Creates Authorization header from signed HTTP auth event
export declare const makeHttpAuthHeader: (event: SignedEvent) => string
```

## Example

```typescript
import { makeHttpAuth, makeHttpAuthHeader } from '@welshman/util'

const url = "https://api.example.com/upload"
const method = "POST"
const body = {data: "example"}

// Create HTTP auth event
const authEvent = await makeHttpAuth(url, method, JSON.stringify(body))

// Sign the auth event
const signedEvent = await signer.signEvent(authEvent)

// Create Authorization header
const authHeader = makeHttpAuthHeader(signedEvent)

// Use in fetch request
const response = await fetch(url, {
  body,
  method,
  headers: {
    "Authorization": authHeader,
    "Content-Type": "application/json"
  },
})
```


=========================
type: file
file: docs/util/profile.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/util/profile.md
# Profile

The Profile module provides utilities for handling Nostr user profiles (kind 0 events), including profile creation, reading, and display formatting.

## Core Types

### Profile Structure
```typescript
interface Profile {
  name?: string             // Display name
  nip05?: string            // NIP-05 verification
  lud06?: string            // Legacy Lightning address
  lud16?: string            // Lightning address
  lnurl?: string            // Lightning URL
  about?: string            // Bio/description
  banner?: string           // Banner image URL
  picture?: string          // Profile picture URL
  website?: string          // Website URL
  display_name?: string     // Alternative display name
  event?: TrustedEvent      // Original profile event
}
```

### Published Profile
```typescript
interface PublishedProfile extends Omit<Profile, "event"> {
  event: TrustedEvent       // Required event for published profiles
}
```

## Core Functions

### Profile Creation & Reading
```typescript
// Create new profile
function makeProfile(profile: Partial<Profile>): Profile

// Read profile from event
function readProfile(event: TrustedEvent): PublishedProfile

// Create profile event
function createProfile(profile: Profile): EventTemplate

// Edit existing profile
function editProfile(profile: PublishedProfile): EventTemplate
```

### Display Formatting
```typescript
// Format pubkey for display
function displayPubkey(pubkey: string): string

// Format profile name for display
function displayProfile(
  profile?: Profile,
  fallback = ""
): string

// Check if profile has name
function profileHasName(profile?: Profile): boolean
```

## Usage Examples

### Creating New Profile
```typescript
// Create basic profile
const profile = makeProfile({
  name: "Alice",
  about: "Nostr user",
  picture: "https://example.com/avatar.jpg",
  lud16: "alice@getalby.com"
})

// Create profile event
const profileEvent = createProfile(profile)
```

### Reading Profile
```typescript
// Read profile from event
const profile = readProfile(profileEvent)

// Access profile data
console.log(profile.name)
console.log(profile.about)
console.log(profile.lnurl) // Auto-generated from lud16/lud06
```

### Displaying Profile
```typescript
// Display profile name
const name = displayProfile(profile, "Anonymous")

// Display pubkey
const shortPubkey = displayPubkey(profile.event.pubkey)
// => "npub1abc...xyz"

// Check for name
if (profileHasName(profile)) {
  showName(profile)
} else {
  showPubkey(profile)
}
```

### Updating Profile
```typescript
// Edit existing profile
const profileEvent = editProfile({
  ...existingProfile,
  name: "New Name",
  about: "Updated bio"
})
```


=========================
type: file
file: docs/util/relay.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/util/relay.md
# Relay

The `Relay` module provides utilities for working with Nostr relays, including URL normalization, validation, and relay profile handling.

## API

### Types and Enums

```typescript
// Relay operation modes
export enum RelayMode {
  Read = "read",
  Write = "write",
  Inbox = "inbox"
}

// Relay information from NIP-11
export type RelayProfile = {
  url: string;
  icon?: string;
  banner?: string;
  name?: string;
  pubkey?: string;
  contact?: string;
  software?: string;
  version?: string;
  negentropy?: number;
  description?: string;
  supported_nips?: number[];
  limitation?: {
    min_pow_difficulty?: number;
    payment_required?: boolean;
    auth_required?: boolean;
  };
};
```

### URL Validation

```typescript
// Check if URL is a valid relay URL
export declare const isRelayUrl: (url: string) => boolean;

// Check if URL is an onion (Tor) address
export declare const isOnionUrl: (url: string) => boolean;

// Check if URL is a local address
export declare const isLocalUrl: (url: string) => boolean;

// Check if URL contains an IP address
export declare const isIPAddress: (url: string) => boolean;

// Check if URL is safe to share publicly
export declare const isShareableRelayUrl: (url: string) => boolean;
```

### URL Normalization

```typescript
// Normalize relay URL to standard format
export declare const normalizeRelayUrl: (url: string) => string;

// Format URL for display (remove protocol, trailing slash)
export declare const displayRelayUrl: (url: string) => string;
```

### Relay Profile

```typescript
// Get display name for relay profile
export declare const displayRelayProfile: (profile?: RelayProfile, fallback?: string) => string;
```


=========================
type: file
file: docs/util/tags.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/util/tags.md
# Tags

The Tags module provides comprehensive utilities for working with Nostr event tags, including helpers for extracting, validating, and manipulating different types of tags.

## Core Functions

### Basic Tag Operations
```typescript
// Get tags by type(s)
getTags(types: string | string[], tags: string[][]): string[][]

// Get single tag by type(s)
getTag(types: string | string[], tags: string[][]): string[] | undefined

// Get tag values
getTagValues(types: string | string[], tags: string[][]): string[]

// Get single tag value
getTagValue(types: string | string[], tags: string[][]): string | undefined
```

## Tag Type Extractors

### Event References
```typescript
// Get 'e' tags (event references)
getEventTags(tags: string[][]): string[][]
getEventTagValues(tags: string[][]): string[]

// Get 'a' tags (event addresses)
getAddressTags(tags: string[][]): string[][]
getAddressTagValues(tags: string[][]): string[]
```

### Profile References
```typescript
// Get 'p' tags (pubkey references)
getPubkeyTags(tags: string[][]): string[][]
getPubkeyTagValues(tags: string[][]): string[]
```

### Topics and Relays
```typescript
// Get 't' tags (topics/hashtags)
getTopicTags(tags: string[][]): string[][]
getTopicTagValues(tags: string[][]): string[]

// Get 'r' and 'relay' tags
getRelayTags(tags: string[][]): string[][]
getRelayTagValues(tags: string[][]): string[]
```

### Groups and Kinds
```typescript
// Get group tags
getGroupTags(tags: string[][]): string[][]
getGroupTagValues(tags: string[][]): string[]

// Get 'k' tags (kind references)
getKindTags(tags: string[][]): string[][]
getKindTagValues(tags: string[][]): number[]
```

## Thread Management

### Comment Tags
```typescript
// Get root and reply references
getCommentTags(tags: string[][]): {
  roots: string[][],
  replies: string[][]
}

getCommentTagValues(tags: string[][]): {
  roots: string[],
  replies: string[]
}
```

### Reply Tags
```typescript
// Get detailed reply structure
getReplyTags(tags: string[][]): {
  roots: string[][],     // Thread roots
  replies: string[][],   // Direct replies
  mentions: string[][]   // Mentions
}

getReplyTagValues(tags: string[][]): {
  roots: string[],
  replies: string[],
  mentions: string[]
}
```

## Utility Functions

```typescript
// Remove duplicate tags
uniqTags(tags: string[][]): string[][]

// Parse imeta tags into array of tag arrays
tagsFromIMeta(imeta: string[]): string[][]
```

## Example

```typescript
// Get specific tag types
const pubkeys = getPubkeyTagValues(event.tags)
const topics = getTopicTagValues(event.tags)
const relays = getRelayTagValues(event.tags)

// Get multiple tag types
const refs = getTags(['p', 'e'], event.tags)

// Get single tag
const topic = getTagValue('t', event.tags)
```


=========================
type: file
file: docs/util/zaps.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/util/zaps.md
# Zaps

The Zaps module provides utilities for working with Lightning Network payments (zaps) in Nostr, following [NIP-57](https://github.com/nostr-protocol/nips/blob/master/57.md). It includes LNURL handling, invoice amount parsing, and zap validation.

## Protocol Overview

Zaps enable Lightning Network payments to be associated with Nostr events through a standardized flow:

1. **Zap Request** (kind 9734): Client creates a request specifying the amount and target
2. **Lightning Invoice**: LNURL service generates an invoice with the request embedded
3. **Zap Receipt** (kind 9735): Zapper publishes proof of payment to Nostr

## API

### Types

```typescript
// Zapper service information
export type Zapper = {
  lnurl: string;
  pubkey?: string;
  callback?: string;
  minSendable?: number;
  maxSendable?: number;
  nostrPubkey?: string;
  allowsNostr?: boolean;
};

// Complete zap with request and receipt
export type Zap = {
  request: TrustedEvent;  // kind 9734 (zap request)
  response: TrustedEvent; // kind 9735 (zap receipt)
  invoiceAmount: number;  // amount in millisatoshis
};
```

### Lightning Network Utilities

```typescript
// Convert human-readable amount to millisatoshis
export declare const hrpToMillisat: (hrpString: string) => bigint;

// Extract amount from BOLT11 lightning invoice
export declare const getInvoiceAmount: (bolt11: string) => number;

// Convert lightning address or URL to LNURL
export declare const getLnUrl: (address: string) => string | null;
```

### Zap Validation

```typescript
// Create validated Zap from zap receipt event
export declare const zapFromEvent: (response: TrustedEvent, zapper?: Zapper) => Zap | null;
```

## Examples

### Converting Lightning Addresses

```typescript
import { getLnUrl } from '@welshman/util';

// Lightning address (LUD-16)
const lnurl1 = getLnUrl('satoshi@getalby.com');
console.log(lnurl1); // 'lnurl1...' (encoded URL)

// Regular URL
const lnurl2 = getLnUrl('https://getalby.com/.well-known/lnurlp/satoshi');
console.log(lnurl2); // 'lnurl1...' (encoded URL)

// Already encoded LNURL
const lnurl3 = getLnUrl('lnurl1dp68gurn8ghj7mr0vdskc6r0wd6z7mrww4excttsv9un7um9wdekjmmw84jxywf5x43rvv35xgmr2enrxanr2cfcvsmnwe3jxcukvde48qukgdec89snwde3vfjxvepjxpjnjvtpxd3kvdnxx5crxwpjvyunsephsz36jf');
console.log(lnurl3); // 'lnurl1...' (same as input)

// Invalid address
const invalid = getLnUrl('not-a-valid-address');
console.log(invalid); // null
```

### Parsing Invoice Amounts

```typescript
import { getInvoiceAmount, hrpToMillisat } from '@welshman/util';

// Extract amount from BOLT11 invoice
const invoice = 'lnbc1500n1...'; // 1500 nanosats = 1.5 sats
const amount = getInvoiceAmount(invoice);
console.log(amount); // 1500 (millisatoshis)

// Convert human-readable amounts
console.log(hrpToMillisat('1000')); // 100000000000n (1000 BTC in millisats)
console.log(hrpToMillisat('1000m')); // 100000000n (1000 mBTC = 1 BTC in millisats)
console.log(hrpToMillisat('1000u')); // 100000n (1000 µBTC = 1 mBTC in millisats)
console.log(hrpToMillisat('1000n')); // 100n (1000 nBTC = 1000 sats in millisats)
console.log(hrpToMillisat('1000p')); // 0.1n (1000 pBTC = 1 msat, but must be divisible by 10)
```

### Validating Zaps

```typescript
import { zapFromEvent, ZAP_RESPONSE } from '@welshman/util';

// Zapper service configuration
const zapper: Zapper = {
  lnurl: 'lnurl1dp68gurn8ghj7mr0vdskc6r0wd6z7mrww4excttsv9un7um9wdekjmmw84jxywf5x43rvv35xgmr2enrxanr2cfcvsmnwe3jxcukvde48qukgdec89snwde3vfjxvepjxpjnjvtpxd3kvdnxx5crxwpjvyunsephsz36jf',
  nostrPubkey: 'zapper-pubkey-hex',
  allowsNostr: true,
  minSendable: 1000,
  maxSendable: 10000000
};

// Zap receipt event (kind 9735)
const zapReceipt = {
  kind: ZAP_RESPONSE,
  pubkey: 'zapper-pubkey-hex',
  tags: [
    ['bolt11', 'lnbc1500n1...'],
    ['description', '{"kind":9734,"pubkey":"sender-pubkey","tags":[["p","recipient-pubkey"],["amount","1500"],["relays","wss://relay.com"]],"content":"Great post!","created_at":1234567890}'],
    ['p', 'recipient-pubkey']
  ],
  // ... other event fields
};

// Validate the zap
const validZap = zapFromEvent(zapReceipt, zapper);

if (validZap) {
  console.log('Amount:', validZap.invoiceAmount); // 1500 millisats
  console.log('Request:', validZap.request.content); // "Great post!"
  console.log('Recipient:', validZap.request.tags.find(t => t[0] === 'p')?.[1]);
} else {
  console.log('Invalid zap - failed validation');
}
```

### Complete Zap Flow Example

```typescript
import { getLnUrl, zapFromEvent, makeEvent, ZAP_REQUEST } from '@welshman/util';

// Step 1: Get LNURL from lightning address
const lightningAddress = 'satoshi@getalby.com';
const lnurl = getLnUrl(lightningAddress);

if (!lnurl) {
  throw new Error('Invalid lightning address');
}

// Step 2: Create zap request (kind 9734)
const zapRequest = makeEvent(ZAP_REQUEST, {
  content: 'Amazing content!',
  tags: [
    ['p', 'recipient-pubkey-hex'], // recipient
    ['amount', '5000'], // 5000 millisats = 5 sats
    ['lnurl', lnurl],
    ['relays', 'wss://relay.damus.io', 'wss://relay.snort.social']
  ]
});

// Step 3: Send to LNURL service (implementation specific)
// The service will generate an invoice with the zap request in description

// Step 4: Pay the invoice (using Lightning wallet)

// Step 5: Validate received zap receipt
const zapperInfo = {
  lnurl,
  nostrPubkey: 'zapper-service-pubkey',
  allowsNostr: true
};

// When zap receipt arrives (kind 9735)
function handleZapReceipt(zapReceipt: TrustedEvent) {
  const validatedZap = zapFromEvent(zapReceipt, zapperInfo);

  if (validatedZap) {
    console.log(`Received ${validatedZap.invoiceAmount} msat zap!`);
    console.log(`Message: ${validatedZap.request.content}`);
    return validatedZap;
  } else {
    console.log('Invalid zap receipt');
    return null;
  }
}
```

### Zap Validation Rules

The `zapFromEvent` function validates several aspects of a zap according to NIP-57:

```typescript
import { zapFromEvent } from '@welshman/util';

// Validation checks performed:
// 1. Invoice amount matches requested amount (if specified)
// 2. Zap request is properly embedded in invoice description
// 3. Zapper pubkey matches the expected zapper service
// 4. LNURL matches the expected service (if provided in request)
// 5. Self-zaps are filtered out (sender != zapper)

const zapReceipt = {
  // ... zap receipt event
};

const zapper = {
  nostrPubkey: 'expected-zapper-pubkey',
  lnurl: 'expected-lnurl'
};

const validZap = zapFromEvent(zapReceipt, zapper);

// Returns null if any validation fails:
// - Malformed bolt11 invoice
// - Amount mismatch
// - Wrong zapper pubkey
// - LNURL mismatch
// - Self-zap detection
```


=========================
type: file
file: docs/what-is-welshman.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/docs/what-is-welshman.md
---
outline: deep
---

# What is Welshman?

Welshman is a production-grade nostr toolkit powering [Coracle](https://coracle.social) and [Flotilla](https://flotilla.social).

Built as independent, opt-in packages, it lets you choose exactly what you need - from basic utilities handling to a batteries-included application framework.

Need just a content parser? Grab @welshman/content. Building a complex client? Start with @welshman/app and add more packages as you grow.

Each module is battle-tested in production, and designed to work together.


=========================
type: file
file: packages/lib/src/normalize-url/readme.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/normalize-url/readme.md
# normalize-url [![Coverage Status](https://codecov.io/gh/sindresorhus/normalize-url/branch/main/graph/badge.svg)](https://codecov.io/gh/sindresorhus/normalize-url)

> [Normalize](https://en.wikipedia.org/wiki/URL_normalization) a URL

Useful when you need to display, store, deduplicate, sort, compare, etc, URLs.

**Note:** This package does **not** do URL sanitization. [Garbage in, garbage out.](https://en.wikipedia.org/wiki/Garbage_in,_garbage_out) If you use this in a server context and accept URLs as user input, it's up to you to protect against invalid URLs, [path traversal attacks](https://owasp.org/www-community/attacks/Path_Traversal), etc.

## Install

```sh
npm install normalize-url
```

*If you need Safari support, use version 4: `npm i normalize-url@4`*

## Usage

```js
import normalizeUrl from 'normalize-url';

normalizeUrl('sindresorhus.com');
//=> 'http://sindresorhus.com'

normalizeUrl('//www.sindresorhus.com:80/../baz?b=bar&a=foo');
//=> 'http://sindresorhus.com/baz?a=foo&b=bar'
```

## API

### normalizeUrl(url, options?)

URLs with custom protocols are not normalized and just passed through by default. Supported protocols are: `https`, `http`, `file`, and `data`.

#### url

Type: `string`

URL to normalize, including [data URL](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs).

#### options

Type: `object`

##### defaultProtocol

Type: `string`\
Default: `'http'`\
Values: `'https' | 'http'`

##### normalizeProtocol

Type: `boolean`\
Default: `true`

Prepend `defaultProtocol` to the URL if it's protocol-relative.

```js
normalizeUrl('//sindresorhus.com');
//=> 'http://sindresorhus.com'

normalizeUrl('//sindresorhus.com', {normalizeProtocol: false});
//=> '//sindresorhus.com'
```

##### forceHttp

Type: `boolean`\
Default: `false`

Normalize HTTPS to HTTP.

```js
normalizeUrl('https://sindresorhus.com');
//=> 'https://sindresorhus.com'

normalizeUrl('https://sindresorhus.com', {forceHttp: true});
//=> 'http://sindresorhus.com'
```

##### forceHttps

Type: `boolean`\
Default: `false`

Normalize HTTP to HTTPS.

```js
normalizeUrl('http://sindresorhus.com');
//=> 'http://sindresorhus.com'

normalizeUrl('http://sindresorhus.com', {forceHttps: true});
//=> 'https://sindresorhus.com'
```

This option cannot be used with the `forceHttp` option at the same time.

##### stripAuthentication

Type: `boolean`\
Default: `true`

Strip the [authentication](https://en.wikipedia.org/wiki/Basic_access_authentication) part of the URL.

```js
normalizeUrl('user:password@sindresorhus.com');
//=> 'https://sindresorhus.com'

normalizeUrl('user:password@sindresorhus.com', {stripAuthentication: false});
//=> 'https://user:password@sindresorhus.com'
```

##### stripHash

Type: `boolean`\
Default: `false`

Strip the hash part of the URL.

```js
normalizeUrl('sindresorhus.com/about.html#contact');
//=> 'http://sindresorhus.com/about.html#contact'

normalizeUrl('sindresorhus.com/about.html#contact', {stripHash: true});
//=> 'http://sindresorhus.com/about.html'
```

##### stripProtocol

Type: `boolean`\
Default: `false`

Remove the protocol from the URL: `http://sindresorhus.com` → `sindresorhus.com`.

It will only remove `https://` and `http://` protocols.

```js
normalizeUrl('https://sindresorhus.com');
//=> 'https://sindresorhus.com'

normalizeUrl('https://sindresorhus.com', {stripProtocol: true});
//=> 'sindresorhus.com'
```

##### stripTextFragment

Type: `boolean`\
Default: `true`

Strip the [text fragment](https://web.dev/text-fragments/) part of the URL.

**Note:** The text fragment will always be removed if the `stripHash` option is set to `true`, as the hash contains the text fragment.

```js
normalizeUrl('http://sindresorhus.com/about.html#:~:text=hello');
//=> 'http://sindresorhus.com/about.html#'

normalizeUrl('http://sindresorhus.com/about.html#section:~:text=hello');
//=> 'http://sindresorhus.com/about.html#section'

normalizeUrl('http://sindresorhus.com/about.html#:~:text=hello', {stripTextFragment: false});
//=> 'http://sindresorhus.com/about.html#:~:text=hello'

normalizeUrl('http://sindresorhus.com/about.html#section:~:text=hello', {stripTextFragment: false});
//=> 'http://sindresorhus.com/about.html#section:~:text=hello'
```

##### stripWWW

Type: `boolean`\
Default: `true`

Remove `www.` from the URL.

```js
normalizeUrl('http://www.sindresorhus.com');
//=> 'http://sindresorhus.com'

normalizeUrl('http://www.sindresorhus.com', {stripWWW: false});
//=> 'http://www.sindresorhus.com'
```

##### removeQueryParameters

Type: `Array<RegExp | string> | boolean`\
Default: `[/^utm_\w+/i]`

Remove query parameters that matches any of the provided strings or regexes.

```js
normalizeUrl('www.sindresorhus.com?foo=bar&ref=test_ref', {
	removeQueryParameters: ['ref']
});
//=> 'http://sindresorhus.com/?foo=bar'
```

If a boolean is provided, `true` will remove all the query parameters.

```js
normalizeUrl('www.sindresorhus.com?foo=bar', {
	removeQueryParameters: true
});
//=> 'http://sindresorhus.com'
```

`false` will not remove any query parameter.

```js
normalizeUrl('www.sindresorhus.com?foo=bar&utm_medium=test&ref=test_ref', {
	removeQueryParameters: false
});
//=> 'http://www.sindresorhus.com/?foo=bar&ref=test_ref&utm_medium=test'
```

##### keepQueryParameters

Type: `Array<RegExp | string>`\
Default: `undefined`

Keeps only query parameters that matches any of the provided strings or regexes.

**Note:** It overrides the `removeQueryParameters` option.

```js
normalizeUrl('https://sindresorhus.com?foo=bar&ref=unicorn', {
	keepQueryParameters: ['ref']
});
//=> 'https://sindresorhus.com/?ref=unicorn'
```

##### removeTrailingSlash

Type: `boolean`\
Default: `true`

Remove trailing slash.

**Note:** Trailing slash is always removed if the URL doesn't have a pathname unless the `removeSingleSlash` option is set to `false`.

```js
normalizeUrl('http://sindresorhus.com/redirect/');
//=> 'http://sindresorhus.com/redirect'

normalizeUrl('http://sindresorhus.com/redirect/', {removeTrailingSlash: false});
//=> 'http://sindresorhus.com/redirect/'

normalizeUrl('http://sindresorhus.com/', {removeTrailingSlash: false});
//=> 'http://sindresorhus.com'
```

##### removeSingleSlash

Type: `boolean`\
Default: `true`

Remove a sole `/` pathname in the output. This option is independent of `removeTrailingSlash`.

```js
normalizeUrl('https://sindresorhus.com/');
//=> 'https://sindresorhus.com'

normalizeUrl('https://sindresorhus.com/', {removeSingleSlash: false});
//=> 'https://sindresorhus.com/'
```

##### removeDirectoryIndex

Type: `boolean | Array<RegExp | string>`\
Default: `false`

Removes the default directory index file from path that matches any of the provided strings or regexes. When `true`, the regex `/^index\.[a-z]+$/` is used.

```js
normalizeUrl('www.sindresorhus.com/foo/default.php', {
	removeDirectoryIndex: [/^default\.[a-z]+$/]
});
//=> 'http://sindresorhus.com/foo'
```

##### removeExplicitPort

Type: `boolean`\
Default: `false`

Removes an explicit port number from the URL.

Port 443 is always removed from HTTPS URLs and 80 is always removed from HTTP URLs regardless of this option.

```js
normalizeUrl('sindresorhus.com:123', {
	removeExplicitPort: true
});
//=> 'http://sindresorhus.com'
```

##### sortQueryParameters

Type: `boolean`\
Default: `true`

Sorts the query parameters alphabetically by key.

```js
normalizeUrl('www.sindresorhus.com?b=two&a=one&c=three', {
	sortQueryParameters: false
});
//=> 'http://sindresorhus.com/?b=two&a=one&c=three'
```

## Related

- [compare-urls](https://github.com/sindresorhus/compare-urls) - Compare URLs by first normalizing them

---

<div align="center">
	<b>
		<a href="https://tidelift.com/subscription/pkg/npm-normalize-url?utm_source=npm-normalize-url&utm_medium=referral&utm_campaign=readme">Get professional support for this package with a Tidelift subscription</a>
	</b>
	<br>
	<sub>
		Tidelift helps make open source sustainable for maintainers while giving companies<br>assurances about security, maintenance, and licensing for their dependencies.
	</sub>
</div>


=========================
type: project_files
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/

include: always
welshman/
├── .husky
│   └── pre-commit
├── docs
│   ├── .vitepress
│   │   └── config.mts
│   ├── app
│   │   ├── commands.md
│   │   ├── context.md
│   │   ├── index.md
│   │   ├── making-requests.md
│   │   ├── publishing-events.md
│   │   ├── relay-selection.md
│   │   ├── session.md
│   │   ├── storage.md
│   │   ├── tags.md
│   │   ├── user.md
│   │   └── wot.md
│   ├── assets
│   │   ├── hierarchy.js
│   │   ├── highlight.css
│   │   ├── icons.js
│   │   ├── icons.svg
│   │   ├── main.js
│   │   ├── navigation.js
│   │   ├── search.js
│   │   └── style.css
│   ├── content
│   │   ├── index.md
│   │   ├── parser.md
│   │   └── render.md
│   ├── editor
│   │   └── index.md
│   ├── feeds
│   │   ├── compiler.md
│   │   ├── controller.md
│   │   ├── core.md
│   │   ├── index.md
│   │   └── utils.md
│   ├── lib
│   │   ├── deferred.md
│   │   ├── emitter.md
│   │   ├── index.md
│   │   ├── lru.md
│   │   ├── normalize-url.md
│   │   ├── task-queue.md
│   │   └── tools.md
│   ├── net
│   │   ├── adapter.md
│   │   ├── auth.md
│   │   ├── context.md
│   │   ├── diff.md
│   │   ├── index.md
│   │   ├── message.md
│   │   ├── policy.md
│   │   ├── pool.md
│   │   ├── publish.md
│   │   ├── request.md
│   │   ├── socket.md
│   │   └── tracker.md
│   ├── relay
│   │   └── index.md
│   ├── router
│   │   └── index.md
│   ├── signer
│   │   ├── index.md
│   │   ├── isigner.md
│   │   ├── nip-01.md
│   │   ├── nip-07.md
│   │   ├── nip-46.md
│   │   ├── nip-55.md
│   │   └── nip-59.md
│   ├── store
│   │   ├── collection.md
│   │   ├── custom.md
│   │   ├── getter.md
│   │   ├── index.md
│   │   ├── repository.md
│   │   ├── synced.md
│   │   └── throttle.md
│   ├── util
│   │   ├── address.md
│   │   ├── blossom.md
│   │   ├── encryptable.md
│   │   ├── events.md
│   │   ├── filters.md
│   │   ├── handlers.md
│   │   ├── index.md
│   │   ├── kinds.md
│   │   ├── links.md
│   │   ├── list.md
│   │   ├── nip42.md
│   │   ├── nip86.md
│   │   ├── nip98.md
│   │   ├── profile.md
│   │   ├── relay.md
│   │   ├── tags.md
│   │   └── zaps.md
│   ├── .nojekyll
│   ├── getting-started.md
│   ├── index.md
│   └── what-is-welshman.md
├── packages
│   ├── app
│   │   ├── __tests__
│   │   │   ├── tags.test.ts
│   │   │   └── thunk.test.ts
│   │   ├── src
│   │   │   ├── blossom.ts
│   │   │   ├── commands.ts
│   │   │   ├── context.ts
│   │   │   ├── core.ts
│   │   │   ├── feeds.ts
│   │   │   ├── follows.ts
│   │   │   ├── handles.ts
│   │   │   ├── inboxRelaySelections.ts
│   │   │   ├── index.ts
│   │   │   ├── mutes.ts
│   │   │   ├── pins.ts
│   │   │   ├── plaintext.ts
│   │   │   ├── profiles.ts
│   │   │   ├── relays.ts
│   │   │   ├── relaySelections.ts
│   │   │   ├── search.ts
│   │   │   ├── session.ts
│   │   │   ├── storage.ts
│   │   │   ├── storageAdapters.ts
│   │   │   ├── sync.ts
│   │   │   ├── tags.ts
│   │   │   ├── thunk.ts
│   │   │   ├── topics.ts
│   │   │   ├── user.ts
│   │   │   ├── wot.ts
│   │   │   └── zappers.ts
│   │   ├── .eslintignore
│   │   ├── package.json
│   │   ├── tsconfig.build.json
│   │   ├── tsconfig.json
│   │   └── typedoc.json
│   ├── content
│   │   ├── __tests__
│   │   │   ├── content.test.ts
│   │   │   ├── renderer.test.ts
│   │   │   └── truncate.test.ts
│   │   ├── src
│   │   │   ├── index.ts
│   │   │   ├── parser.ts
│   │   │   └── render.ts
│   │   ├── .eslintignore
│   │   ├── package.json
│   │   ├── tsconfig.build.json
│   │   ├── tsconfig.json
│   │   └── typedoc.json
│   ├── editor
│   │   ├── src
│   │   │   ├── extensions
│   │   │   │   ├── BreakOrSubmit.ts
│   │   │   │   ├── CodeInline.ts
│   │   │   │   ├── index.ts
│   │   │   │   ├── Welshman.ts
│   │   │   │   └── WordCount.ts
│   │   │   ├── nodeviews
│   │   │   │   ├── Bolt11NodeView.ts
│   │   │   │   ├── EventNodeView.ts
│   │   │   │   ├── index.ts
│   │   │   │   ├── MediaNodeView.ts
│   │   │   │   └── MentionNodeView.ts
│   │   │   ├── plugins
│   │   │   │   ├── index.ts
│   │   │   │   └── TippySuggestion.ts
│   │   │   ├── index.css
│   │   │   └── index.ts
│   │   ├── .eslintignore
│   │   ├── package.json
│   │   ├── tsconfig.build.json
│   │   └── tsconfig.json
│   ├── feeds
│   │   ├── src
│   │   │   ├── compiler.ts
│   │   │   ├── controller.ts
│   │   │   ├── core.ts
│   │   │   ├── display.ts
│   │   │   ├── index.ts
│   │   │   ├── request.ts
│   │   │   ├── utils.ts
│   │   │   └── validate.ts
│   │   ├── .eslintignore
│   │   ├── package.json
│   │   ├── tsconfig.build.json
│   │   ├── tsconfig.json
│   │   └── typedoc.json
│   ├── lib
│   │   ├── __tests__
│   │   │   ├── Deferred.test.ts
│   │   │   ├── Emitter.test.ts
│   │   │   ├── LRUCache.test.ts
│   │   │   └── Tools.test.ts
│   │   ├── src
│   │   │   ├── normalize-url
│   │   │   │   ├── index.ts
│   │   │   │   ├── license
│   │   │   │   └── readme.md
│   │   │   ├── Deferred.ts
│   │   │   ├── Emitter.ts
│   │   │   ├── index.ts
│   │   │   ├── LRUCache.ts
│   │   │   ├── TaskQueue.ts
│   │   │   └── Tools.ts
│   │   ├── .eslintignore
│   │   ├── package.json
│   │   ├── tsconfig.build.json
│   │   ├── tsconfig.json
│   │   └── typedoc.json
│   ├── net
│   │   ├── __tests__
│   │   │   ├── adapter.test.ts
│   │   │   ├── auth.test.ts
│   │   │   ├── policy.test.ts
│   │   │   ├── pool.test.ts
│   │   │   ├── publish.test.ts
│   │   │   ├── request.test.ts
│   │   │   ├── socket.test.ts
│   │   │   └── Tracker.test.ts
│   │   ├── src
│   │   │   ├── adapter.ts
│   │   │   ├── auth.ts
│   │   │   ├── context.ts
│   │   │   ├── diff.ts
│   │   │   ├── index.ts
│   │   │   ├── message.ts
│   │   │   ├── negentropy.ts
│   │   │   ├── policy.ts
│   │   │   ├── pool.ts
│   │   │   ├── publish.ts
│   │   │   ├── request.ts
│   │   │   ├── socket.ts
│   │   │   ├── tracker.ts
│   │   │   └── util.ts
│   │   ├── .eslintignore
│   │   ├── package.json
│   │   ├── tsconfig.build.json
│   │   ├── tsconfig.json
│   │   └── typedoc.json
│   ├── relay
│   │   ├── __tests__
│   │   │   ├── relay.test.ts
│   │   │   └── repository.test.ts
│   │   ├── src
│   │   │   ├── index.ts
│   │   │   ├── relay.ts
│   │   │   └── repository.ts
│   │   ├── .eslintignore
│   │   ├── package.json
│   │   ├── tsconfig.build.json
│   │   ├── tsconfig.json
│   │   └── typedoc.json
│   ├── router
│   │   ├── src
│   │   │   └── index.ts
│   │   ├── .eslintignore
│   │   ├── package.json
│   │   ├── tsconfig.build.json
│   │   ├── tsconfig.json
│   │   └── typedoc.json
│   ├── signer
│   │   ├── __tests__
│   │   │   ├── common.ts
│   │   │   ├── nip01.test.ts
│   │   │   ├── nip07.test.ts
│   │   │   └── nip55.test.ts
│   │   ├── src
│   │   │   ├── signers
│   │   │   │   ├── nip01.ts
│   │   │   │   ├── nip07.ts
│   │   │   │   ├── nip46.ts
│   │   │   │   └── nip55.ts
│   │   │   ├── index.ts
│   │   │   ├── nip59.ts
│   │   │   └── util.ts
│   │   ├── .eslintignore
│   │   ├── package.json
│   │   ├── tsconfig.build.json
│   │   ├── tsconfig.json
│   │   └── typedoc.json
│   ├── store
│   │   ├── __tests__
│   │   │   ├── collection.test.ts
│   │   │   └── index.test.ts
│   │   ├── src
│   │   │   ├── collection.ts
│   │   │   ├── custom.ts
│   │   │   ├── getter.ts
│   │   │   ├── index.ts
│   │   │   ├── repository.ts
│   │   │   ├── synced.ts
│   │   │   └── throttle.ts
│   │   ├── .eslintignore
│   │   ├── package.json
│   │   ├── tsconfig.build.json
│   │   ├── tsconfig.json
│   │   └── typedoc.json
│   └── util
│       ├── __tests__
│       │   ├── Address.test.ts
│       │   ├── Encryptable.test.ts
│       │   ├── Events.test.ts
│       │   ├── Filters.test.ts
│       │   ├── Handler.test.ts
│       │   ├── List.test.ts
│       │   ├── Profile.test.ts
│       │   ├── Tags.test.ts
│       │   └── Zaps.test.ts
│       ├── src
│       │   ├── Address.ts
│       │   ├── Blossom.ts
│       │   ├── Encryptable.ts
│       │   ├── Events.ts
│       │   ├── Filters.ts
│       │   ├── Handler.ts
│       │   ├── index.ts
│       │   ├── Kinds.ts
│       │   ├── Links.ts
│       │   ├── List.ts
│       │   ├── Nip42.ts
│       │   ├── Nip86.ts
│       │   ├── Nip98.ts
│       │   ├── Profile.ts
│       │   ├── Relay.ts
│       │   ├── Room.ts
│       │   ├── Tags.ts
│       │   ├── Wallet.ts
│       │   └── Zaps.ts
│       ├── .eslintignore
│       ├── package.json
│       ├── tsconfig.build.json
│       ├── tsconfig.json
│       └── typedoc.json
├── scripts
│   ├── bump.sh
│   ├── bump.ts
│   └── tsconfig.json
├── .ackrc
├── .editorconfig
├── .fdignore
├── .nvmrc
├── .prettierrc
├── eslint.config.mjs
├── LICENSE
├── package.json
├── pnpm-lock.yaml
├── pnpm-workspace.yaml
├── README.md
├── renovate.json
├── tsconfig.build.json
├── tsconfig.json
├── typedoc.json
├── vitest.config.ts
├── vitest.setup.ts
└── watch.sh


=========================
type: file
workspace: packages/app
file: packages/app/package.json
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/package.json
include: always
{
  "name": "@welshman/app",
  "version": "0.4.6",
  "author": "hodlbod",
  "license": "MIT",
  "description": "A collection of svelte stores for use in building nostr client applications.",
  "publishConfig": {
    "access": "public"
  },
  "type": "module",
  "main": "dist/app/src/index.js",
  "types": "dist/app/src/index.d.ts",
  "files": [
    "dist"
  ],
  "scripts": {
    "build": "pnpm run clean && pnpm run compile --force",
    "clean": "rimraf ./dist",
    "compile": "tsc -b tsconfig.build.json",
    "prepublishOnly": "pnpm run build"
  },
  "dependencies": {
    "@types/throttle-debounce": "^5.0.2",
    "@welshman/feeds": "workspace:*",
    "@welshman/lib": "workspace:*",
    "@welshman/relay": "workspace:*",
    "@welshman/router": "workspace:*",
    "@welshman/net": "workspace:*",
    "@welshman/signer": "workspace:*",
    "@welshman/store": "workspace:*",
    "@welshman/util": "workspace:*",
    "fuse.js": "^7.0.0",
    "idb": "^8.0.0",
    "svelte": "^4.2.18",
    "throttle-debounce": "^5.0.2"
  },
  "devDependencies": {
    "rimraf": "~6.0.0",
    "typescript": "~5.8.0"
  }
}


=========================
type: file
workspace: packages/app
file: packages/app/tsconfig.json
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/tsconfig.json
include: always
{
  "extends": "../../tsconfig.json"
}


=========================
workspace: packages/app
file: packages/app/src/core.ts
lines: 6:6
id: 292512b08fe98fba82307bb7706458de8248cd55a81e24a4897a587fbed9b695
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/core.ts#L6

declaration:
repository = Repository.get()

summary:
A singleton instance of the Repository class from the @welshman/relay package. This exported constant provides access to a shared repository instance throughout the application.

details:
This variable is initialized by calling the static `get()` method of the Repository class, suggesting it implements a singleton pattern. The repository likely stores and manages data that can be accessed and modified from different parts of the application.

related: Repository

import/access examples:
import { repository } from '@welshman/app';
import { repository } from '@welshman/app/core';


=========================
workspace: packages/app
file: packages/app/src/core.ts
lines: 8:8
id: 910f2c4ce54fc32c710ba7f330c32855c66feaa889886fab4393a4ba69857caa
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/core.ts#L8

declaration:
relay = new LocalRelay(repository)

summary:
A global instance of `LocalRelay` that is initialized with the application's repository. This relay provides a local communication channel for the application's data flow, allowing components to interact with the repository.

details:
This is a simple instantiation of a `LocalRelay` class from the `@welshman/relay` package, using the global repository instance as its parameter. The relay is exported as a constant, making it available throughout the application as a singleton instance for local data relay operations.

related: LocalRelay

import/access examples:
import { relay } from '@welshman/app';
import { relay } from '@welshman/app/core';


=========================
workspace: packages/app
file: packages/app/src/core.ts
lines: 10:10
id: afa491b87793294d36f56c4791edce5d13f5dde4c9ac15cae17805be6b22fd35
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/core.ts#L10

declaration:
tracker = new Tracker()

summary:
A global instance of the Tracker class from the @welshman/net package. This tracker is exported and can be used to track relays or other trackable entities in the application.

details:
This is a simple instantiation of the Tracker class with no configuration parameters. The tracker is created as a global singleton that can be imported and used throughout the application. It's later used in the makeTrackerStore function to create a reactive store that updates when the tracker changes.

related: Tracker

import/access examples:
import { tracker } from '@welshman/app';
import { tracker } from '@welshman/app/core';


=========================
workspace: packages/app
file: packages/app/src/core.ts
lines: 14:31
id: e4eec0ad6e0be0972a34d699b3f09a036aab52cace32ce4ddf9769c7237d0cf9
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/core.ts#L14

declaration:
makeRepositoryStore = ({throttle: t = 300}: {throttle?: number} = {}) =>
  custom(
    setter => {
      let onUpdate = () => setter(repository)

      if (t) {
        onUpdate = throttle(t, onUpdate)
      }

      onUpdate()
      repository.on("update", onUpdate)

      return () => repository.off("update", onUpdate)
    },
    {
      onUpdate: (other: Repository) => repository.load(other.dump()),
    },
  )

summary:
Creates a custom store that wraps a Repository instance. The store updates when the repository changes and allows for throttling these updates to improve performance. The function accepts an optional configuration object with a throttle parameter (default: 300ms).

details:
This function creates a reactive store using the custom store factory from @welshman/store. It works by:

1. Setting up an update handler that calls the store's setter with the repository instance
2. Optionally throttling this update handler based on the provided throttle value
3. Triggering an initial update
4. Subscribing to the repository's "update" event
5. Returning a cleanup function that unsubscribes from the repository

The store also includes an onUpdate handler that can load data from another Repository instance into the current one, enabling two-way data binding.

related: custom

import/access examples:
import { makeRepositoryStore } from '@welshman/app';
import { makeRepositoryStore } from '@welshman/app/core';


=========================
workspace: packages/app
file: packages/app/src/core.ts
lines: 33:58
id: bb6f997d227fc68d5906c36d8b05b0dccc6cd6b4e8c6956dab897084da55f9ee
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/core.ts#L33

declaration:
makeTrackerStore = ({throttle: t = 300}: {throttle?: number} = {}) =>
  custom(
    setter => {
      let onUpdate = () => setter(tracker)

      if (t) {
        onUpdate = throttle(t, onUpdate)
      }

      onUpdate()
      tracker.on("add", onUpdate)
      tracker.on("remove", onUpdate)
      tracker.on("load", onUpdate)
      tracker.on("clear", onUpdate)

      return () => {
        tracker.off("add", onUpdate)
        tracker.off("remove", onUpdate)
        tracker.off("load", onUpdate)
        tracker.off("clear", onUpdate)
      }
    },
    {
      onUpdate: (other: Tracker) => tracker.load(other.relaysById),
    },
  )

summary:
Creates a custom store that wraps a Tracker instance. The store updates whenever the tracker emits 'add', 'remove', 'load', or 'clear' events. Updates can be throttled to improve performance. The function accepts an optional configuration object with a throttle parameter (default: 300ms).

details:
Implementation creates a reactive wrapper around the global tracker instance using the custom store factory. It:

1. Sets up an update function that passes the tracker to the store's setter
2. Applies throttling to the update function if the throttle parameter is provided
3. Subscribes to all tracker events ('add', 'remove', 'load', 'clear') to trigger updates
4. Returns a cleanup function that removes all event listeners
5. Provides an onUpdate handler that loads data from another tracker instance when the store is updated externally

The implementation ensures that any changes to the tracker are reflected in the store with appropriate throttling to prevent excessive updates.

related: custom

import/access examples:
import { makeTrackerStore } from '@welshman/app';
import { makeTrackerStore } from '@welshman/app/core';


=========================
workspace: packages/app
file: packages/app/src/relaySelections.ts
lines: 15:15
id: ad320ab60759bccbe0ba1d2913d32bed4c771f6ce0af8aeee69e7434580380bb
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/relaySelections.ts#L15

declaration:
export type LoadUsingOutboxOptions = Omit<LoadOptions, "relays">

summary:
A type alias that represents options for loading data using an outbox. It extends the LoadOptions type from @welshman/net by omitting the 'relays' property, as relay selection is handled automatically based on the provided filters.

details:
This type alias is used to simplify the interface for the loadUsingOutbox function, allowing callers to specify all load options except for relays, which will be determined dynamically based on the authors specified in the filters.

import/access examples:
import type { LoadUsingOutboxOptions } from '@welshman/app';
import type { LoadUsingOutboxOptions } from '@welshman/app/relaySelections';


=========================
workspace: packages/app
file: packages/app/src/relaySelections.ts
lines: 17:22
id: e847c6f1ed53b2ae3438fa7dcb77e00d09c753b43ebc6585e3a789b1ce25b4a6
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/relaySelections.ts#L17

declaration:
loadUsingOutbox = batcher(200, (optionses: LoadUsingOutboxOptions[]) => {
  const pubkeys = optionses.flatMap(o => o.filters.flatMap(f => f.authors || []))
  const relays = Router.get().FromPubkeys(pubkeys).getUrls()

  return optionses.map(options => load({...options, relays}))
})

summary:
A batched function that loads data using outbox relays. It takes an array of LoadUsingOutboxOptions objects (similar to LoadOptions but without 'relays' property), extracts pubkeys from the filters, determines appropriate relays for those pubkeys, and then loads data from those relays for each options object.

details:
Implementation details:
1. Uses the 'batcher' utility with a 200ms delay to group multiple calls together for efficiency
2. Extracts all author pubkeys from the filters in each options object
3. Uses Router.get().FromPubkeys() to determine the appropriate relay URLs for the collected pubkeys
4. Maps over the original options array, calling the 'load' function for each item with the original options plus the determined relays
5. The batching approach helps reduce network overhead by consolidating multiple requests that occur within the 200ms window

related: batcher

import/access examples:
import { loadUsingOutbox } from '@welshman/app';
import { loadUsingOutbox } from '@welshman/app/relaySelections';


=========================
workspace: packages/app
file: packages/app/src/relaySelections.ts
lines: 24:30
id: b8913ed5f7169aa01e10ed33db697d6fc027d57166735adddcc5bd3a45901e99
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/relaySelections.ts#L24

declaration:
makeOutboxLoader =
  (kind: number, filter: Filter = {}) =>
  (pubkey: string, relays: string[]) => {
    const filters = [{...filter, authors: [pubkey], kinds: [kind]}]

    return Promise.all([load({relays, filters}), loadUsingOutbox({filters})])
  }

summary:
A function that creates a loader for outbox events of a specific kind. It takes a kind number and an optional filter object, and returns a function that accepts a pubkey and relays array. The returned function loads events from both specified relays and from relays determined by the outbox mechanism.

details:
This function is a higher-order function that creates specialized event loaders for the Nostr protocol. It works by:

1. Taking a kind parameter (Nostr event type) and an optional filter object
2. Returning a function that accepts a pubkey and array of relay URLs
3. When the returned function is called, it:
   - Creates a filter that combines the original filter with the pubkey and kind
   - Makes two parallel load requests:
     a. One to the explicitly provided relays
     b. Another using the loadUsingOutbox function which determines relays based on pubkeys
   - Returns a Promise that resolves when both load operations complete

This implementation enables efficient event loading by querying both specific relays and dynamically determined relays based on the author's outbox information.

import/access examples:
import { makeOutboxLoader } from '@welshman/app';
import { makeOutboxLoader } from '@welshman/app/relaySelections';


=========================
workspace: packages/app
file: packages/app/src/relaySelections.ts
lines: 32:42
id: c51e74817217328c53f395a2440ebc259bc0207b207ae64c883ae232902552a1
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/relaySelections.ts#L32

declaration:
makeOutboxLoaderWithIndexers =
  (kind: number, filter: Filter = {}) =>
  (pubkey: string, relays: string[]) => {
    const filters = [{...filter, authors: [pubkey], kinds: [kind]}]

    return Promise.all([
      load({relays, filters}),
      loadUsingOutbox({filters}),
      load({relays: Router.get().Index().getUrls(), filters}),
    ])
  }

summary:
A function that creates a loader for fetching events from multiple sources including specified relays, outbox, and indexers. It takes a kind number and an optional filter, and returns a function that accepts a pubkey and relays array. The returned function fetches events matching the criteria from all three sources in parallel.

details:
This function is a higher-order function that:
1. Takes event kind and optional filter parameters
2. Returns another function that takes pubkey and relays parameters
3. The inner function constructs a filter combining the input filter with author and kind constraints
4. It then uses Promise.all to concurrently fetch events from three sources:
   - Directly from the specified relays
   - Using the outbox loader (which finds relays based on pubkeys)
   - From indexer relays obtained through the Router's Index functionality

This approach maximizes event discovery by querying multiple relay sources simultaneously.

import/access examples:
import { makeOutboxLoaderWithIndexers } from '@welshman/app';
import { makeOutboxLoaderWithIndexers } from '@welshman/app/relaySelections';


=========================
workspace: packages/app
file: packages/app/src/relaySelections.ts
lines: 44:48
id: da825859a50e2eeb822a05eb4e7f9d715db0785836a02a858b20e496a781b6f0
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/relaySelections.ts#L44

declaration:
relaySelections = deriveEventsMapped<PublishedList>(repository, {
  filters: [{kinds: [RELAYS]}],
  itemToEvent: item => item.event,
  eventToItem: (event: TrustedEvent) => readList(asDecryptedEvent(event)),
})

summary:
A derived store that maps events from the repository to PublishedList objects. It filters events with the RELAYS kind and transforms them using the readList and asDecryptedEvent functions. This store is used to track and manage relay selections for users in the system.

details:
This variable is created using the deriveEventsMapped function, which creates a derived store from the repository. The implementation:

1. Filters events from the repository that have the RELAYS kind
2. Provides transformation functions:
   - itemToEvent: Extracts the event property from a PublishedList item
   - eventToItem: Converts a TrustedEvent to a PublishedList by first decrypting the event with asDecryptedEvent and then parsing it with readList

This store serves as the foundation for the collection defined later in the file that organizes relay selections by pubkey.

related: deriveEventsMapped

import/access examples:
import { relaySelections } from '@welshman/app';
import { relaySelections } from '@welshman/app/relaySelections';


=========================
workspace: packages/app
file: packages/app/src/relaySelections.ts
lines: 50:59
id: 56b2a817b85325388662ccc34b72bb990fb2a78959acde93276a8f292770e088
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/relaySelections.ts#L50

declaration:
{
  indexStore: relaySelectionsByPubkey,
  deriveItem: deriveRelaySelections,
  loadItem: loadRelaySelections,
} = collection({
  name: "relaySelections",
  store: relaySelections,
  getKey: relaySelections => relaySelections.event.pubkey,
  load: makeOutboxLoaderWithIndexers(RELAYS),
})

summary:
An object destructuring assignment that extracts three properties from a collection configuration: `relaySelectionsByPubkey` (an index store), `deriveRelaySelections` (a function to derive items), and `loadRelaySelections` (a function to load items). The collection is configured with the name 'relaySelections', uses the relaySelections store, keys items by the pubkey of their events, and loads data using the makeOutboxLoaderWithIndexers function with the RELAYS constant.

details:
This code is part of a system for managing relay selections in what appears to be a Nostr-related application. The implementation:

1. Uses the `collection()` function from '@welshman/store' to create a collection of relay selections
2. The collection is configured with:
   - A name ('relaySelections')
   - The relaySelections store defined earlier in the file
   - A key function that extracts the pubkey from the event
   - A load function created by makeOutboxLoaderWithIndexers for RELAYS kind events
3. The destructuring assignment extracts three important components:
   - relaySelectionsByPubkey: An indexed store for quick lookups by pubkey
   - deriveRelaySelections: A function to derive relay selections
   - loadRelaySelections: A function to load relay selections

This is part of a larger system for handling relay selections across different pubkeys, with optimized loading strategies that use both direct relay connections and outbox-based routing.

import/access examples:
import { relaySelectionsByPubkey } from '@welshman/app';
import { relaySelectionsByPubkey } from '@welshman/app/relaySelections';


=========================
workspace: packages/app
file: packages/app/src/relaySelections.ts
lines: 50:59
id: 56b2a817b85325388662ccc34b72bb990fb2a78959acde93276a8f292770e088
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/relaySelections.ts#L50

declaration:
{
  indexStore: relaySelectionsByPubkey,
  deriveItem: deriveRelaySelections,
  loadItem: loadRelaySelections,
} = collection({
  name: "relaySelections",
  store: relaySelections,
  getKey: relaySelections => relaySelections.event.pubkey,
  load: makeOutboxLoaderWithIndexers(RELAYS),
})

summary:
An object destructuring assignment that extracts three properties from a collection configuration: `relaySelectionsByPubkey` (an index store), `deriveRelaySelections` (a function to derive items), and `loadRelaySelections` (a function to load items). The collection is configured with the name 'relaySelections', uses the relaySelections store, keys items by the pubkey of their events, and loads data using the makeOutboxLoaderWithIndexers function with the RELAYS constant.

details:
This code is part of a system for managing relay selections in what appears to be a Nostr-related application. The implementation:

1. Uses the `collection()` function from '@welshman/store' to create a collection of relay selections
2. The collection is configured with:
   - A name ('relaySelections')
   - The relaySelections store defined earlier in the file
   - A key function that extracts the pubkey from the event
   - A load function created by makeOutboxLoaderWithIndexers for RELAYS kind events
3. The destructuring assignment extracts three important components:
   - relaySelectionsByPubkey: An indexed store for quick lookups by pubkey
   - deriveRelaySelections: A function to derive relay selections
   - loadRelaySelections: A function to load relay selections

This is part of a larger system for handling relay selections across different pubkeys, with optimized loading strategies that use both direct relay connections and outbox-based routing.

import/access examples:
import { relaySelectionsByPubkey } from '@welshman/app';
import { relaySelectionsByPubkey } from '@welshman/app/relaySelections';


=========================
workspace: packages/app
file: packages/app/src/relaySelections.ts
lines: 50:59
id: 56b2a817b85325388662ccc34b72bb990fb2a78959acde93276a8f292770e088
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/relaySelections.ts#L50

declaration:
{
  indexStore: relaySelectionsByPubkey,
  deriveItem: deriveRelaySelections,
  loadItem: loadRelaySelections,
} = collection({
  name: "relaySelections",
  store: relaySelections,
  getKey: relaySelections => relaySelections.event.pubkey,
  load: makeOutboxLoaderWithIndexers(RELAYS),
})

summary:
An object destructuring assignment that extracts three properties from a collection configuration: `relaySelectionsByPubkey` (an index store), `deriveRelaySelections` (a function to derive items), and `loadRelaySelections` (a function to load items). The collection is configured with the name 'relaySelections', uses the relaySelections store, keys items by the pubkey of their events, and loads data using the makeOutboxLoaderWithIndexers function with the RELAYS constant.

details:
This code is part of a system for managing relay selections in what appears to be a Nostr-related application. The implementation:

1. Uses the `collection()` function from '@welshman/store' to create a collection of relay selections
2. The collection is configured with:
   - A name ('relaySelections')
   - The relaySelections store defined earlier in the file
   - A key function that extracts the pubkey from the event
   - A load function created by makeOutboxLoaderWithIndexers for RELAYS kind events
3. The destructuring assignment extracts three important components:
   - relaySelectionsByPubkey: An indexed store for quick lookups by pubkey
   - deriveRelaySelections: A function to derive relay selections
   - loadRelaySelections: A function to load relay selections

This is part of a larger system for handling relay selections across different pubkeys, with optimized loading strategies that use both direct relay connections and outbox-based routing.

import/access examples:
import { relaySelectionsByPubkey } from '@welshman/app';
import { relaySelectionsByPubkey } from '@welshman/app/relaySelections';


=========================
workspace: packages/app
file: packages/app/src/profiles.ts
lines: 8:14
id: 8ef80f9440cffd8cad2dc358a69945fe6a737810fd528c2881d8a2ce0d91ffc6
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/profiles.ts#L8

declaration:
profiles = withGetter(
  deriveEventsMapped<PublishedProfile>(repository, {
    filters: [{kinds: [PROFILE]}],
    eventToItem: readProfile,
    itemToEvent: item => item.event,
  }),
)

summary:
A store that contains published profile events. It uses `deriveEventsMapped` to transform repository events into `PublishedProfile` objects, filtering for profile kind events. The store is enhanced with a getter function using `withGetter`.

details:
This variable creates a reactive store for Nostr profile events by:
1. Using `deriveEventsMapped` to subscribe to the main repository
2. Filtering only for events with kind PROFILE
3. Converting raw events to PublishedProfile objects using the readProfile utility
4. Providing a way to convert back from items to events
5. Enhancing the store with a getter function via withGetter

The implementation leverages Svelte's reactive store system and appears to be part of a larger Nostr client application.

related: withGetter

import/access examples:
import { profiles } from '@welshman/app';
import { profiles } from '@welshman/app/profiles';


=========================
workspace: packages/app
file: packages/app/src/profiles.ts
lines: 16:25
id: 83ec4cfb1ce13bec8f4e7e6cde178bb4e12bcf8622fd4658f23a4a454f0ad420
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/profiles.ts#L16

declaration:
{
  indexStore: profilesByPubkey,
  deriveItem: deriveProfile,
  loadItem: loadProfile,
} = collection({
  name: "profiles",
  store: profiles,
  getKey: profile => profile.event.pubkey,
  load: makeOutboxLoaderWithIndexers(PROFILE),
})

summary:
An object destructuring assignment that extracts three components from a collection of profiles: `profilesByPubkey` (an index store for quick profile lookup by public key), `deriveProfile` (a function to derive a profile for a specific pubkey), and `loadProfile` (a function to load a profile for a specific pubkey). The collection is configured with the name 'profiles', uses the profiles store, indexes profiles by their public key, and loads profiles using the outbox loader with indexers for PROFILE kind events.

details:
This code creates a collection of user profiles with specialized access methods by calling the `collection()` function with configuration parameters. The implementation:
1. Uses the `profiles` store as the data source
2. Names the collection 'profiles' for identification
3. Defines a key extraction function that gets the pubkey from profile events
4. Sets up loading functionality using `makeOutboxLoaderWithIndexers` specifically for PROFILE kind events
5. Returns an object with three components that are destructured into exported variables:
   - `profilesByPubkey`: An index store that maps public keys to profile data
   - `deriveProfile`: A function to derive/subscribe to a specific profile
   - `loadProfile`: A function to trigger loading of a specific profile

import/access examples:
import { profilesByPubkey } from '@welshman/app';
import { profilesByPubkey } from '@welshman/app/profiles';


=========================
workspace: packages/app
file: packages/app/src/profiles.ts
lines: 16:25
id: 83ec4cfb1ce13bec8f4e7e6cde178bb4e12bcf8622fd4658f23a4a454f0ad420
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/profiles.ts#L16

declaration:
{
  indexStore: profilesByPubkey,
  deriveItem: deriveProfile,
  loadItem: loadProfile,
} = collection({
  name: "profiles",
  store: profiles,
  getKey: profile => profile.event.pubkey,
  load: makeOutboxLoaderWithIndexers(PROFILE),
})

summary:
An object destructuring assignment that extracts three components from a collection of profiles: `profilesByPubkey` (an index store for quick profile lookup by public key), `deriveProfile` (a function to derive a profile for a specific pubkey), and `loadProfile` (a function to load a profile for a specific pubkey). The collection is configured with the name 'profiles', uses the profiles store, indexes profiles by their public key, and loads profiles using the outbox loader with indexers for PROFILE kind events.

details:
This code creates a collection of user profiles with specialized access methods by calling the `collection()` function with configuration parameters. The implementation:
1. Uses the `profiles` store as the data source
2. Names the collection 'profiles' for identification
3. Defines a key extraction function that gets the pubkey from profile events
4. Sets up loading functionality using `makeOutboxLoaderWithIndexers` specifically for PROFILE kind events
5. Returns an object with three components that are destructured into exported variables:
   - `profilesByPubkey`: An index store that maps public keys to profile data
   - `deriveProfile`: A function to derive/subscribe to a specific profile
   - `loadProfile`: A function to trigger loading of a specific profile

import/access examples:
import { profilesByPubkey } from '@welshman/app';
import { profilesByPubkey } from '@welshman/app/profiles';


=========================
workspace: packages/app
file: packages/app/src/profiles.ts
lines: 16:25
id: 83ec4cfb1ce13bec8f4e7e6cde178bb4e12bcf8622fd4658f23a4a454f0ad420
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/profiles.ts#L16

declaration:
{
  indexStore: profilesByPubkey,
  deriveItem: deriveProfile,
  loadItem: loadProfile,
} = collection({
  name: "profiles",
  store: profiles,
  getKey: profile => profile.event.pubkey,
  load: makeOutboxLoaderWithIndexers(PROFILE),
})

summary:
An object destructuring assignment that extracts three components from a collection of profiles: `profilesByPubkey` (an index store for quick profile lookup by public key), `deriveProfile` (a function to derive a profile for a specific pubkey), and `loadProfile` (a function to load a profile for a specific pubkey). The collection is configured with the name 'profiles', uses the profiles store, indexes profiles by their public key, and loads profiles using the outbox loader with indexers for PROFILE kind events.

details:
This code creates a collection of user profiles with specialized access methods by calling the `collection()` function with configuration parameters. The implementation:
1. Uses the `profiles` store as the data source
2. Names the collection 'profiles' for identification
3. Defines a key extraction function that gets the pubkey from profile events
4. Sets up loading functionality using `makeOutboxLoaderWithIndexers` specifically for PROFILE kind events
5. Returns an object with three components that are destructured into exported variables:
   - `profilesByPubkey`: An index store that maps public keys to profile data
   - `deriveProfile`: A function to derive/subscribe to a specific profile
   - `loadProfile`: A function to trigger loading of a specific profile

import/access examples:
import { profilesByPubkey } from '@welshman/app';
import { profilesByPubkey } from '@welshman/app/profiles';


=========================
workspace: packages/app
file: packages/app/src/profiles.ts
lines: 27:28
id: f2ef88447b5c387fd8f5802c2d951aff08cd2620990741c43bda92782ee339bc
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/profiles.ts#L27

declaration:
displayProfileByPubkey = (pubkey: string | undefined) =>
  pubkey ? displayProfile(profilesByPubkey.get().get(pubkey), displayPubkey(pubkey)) : ""

summary:
A function that takes an optional pubkey string and returns a formatted display string for the profile associated with that pubkey. If no pubkey is provided, it returns an empty string.

details:
This function works by:
1. Checking if a pubkey was provided (if not, returns empty string)
2. If pubkey exists, it:
   - Uses profilesByPubkey.get() to access the current state of the profiles collection
   - Attempts to get the profile for the specific pubkey
   - Calls displayProfile with the retrieved profile and a formatted version of the pubkey (via displayPubkey)
   - The displayProfile function likely formats the profile information into a human-readable string

This is a simple utility function that provides a convenient way to get a displayable representation of a user profile based on their public key.

related: displayProfile

import/access examples:
import { displayProfileByPubkey } from '@welshman/app';
import { displayProfileByPubkey } from '@welshman/app/profiles';


=========================
workspace: packages/app
file: packages/app/src/profiles.ts
lines: 30:35
id: 2903013b946d054cd18ed321df59de33b8a1a7f0f63af3c56a779edc45204715
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/profiles.ts#L30

declaration:
deriveProfileDisplay = (pubkey: string | undefined, relays: string[] = []) =>
  pubkey
    ? derived(deriveProfile(pubkey, relays), $profile =>
        displayProfile($profile, displayPubkey(pubkey)),
      )
    : readable("")

summary:
A function that creates a derived store for displaying a user profile. It takes a pubkey (string or undefined) and an optional array of relays, and returns a readable store containing a formatted display string of the profile. If no pubkey is provided, it returns a readable store with an empty string.

details:
The implementation works by:
1. First checking if a pubkey was provided
2. If pubkey exists, it creates a derived store using Svelte's 'derived' function that:
   - Uses 'deriveProfile' to get the profile data for the given pubkey and relays
   - Transforms the profile data using 'displayProfile' combined with 'displayPubkey'
3. If no pubkey is provided, it returns a readable store with an empty string

The function leverages the profile collection system defined earlier in the file and utility functions from '@welshman/util' for formatting the display.

related: derived,readable

import/access examples:
import { deriveProfileDisplay } from '@welshman/app';
import { deriveProfileDisplay } from '@welshman/app/profiles';


=========================
workspace: packages/app
file: packages/app/src/session.ts
lines: 16:23
id: 9bffaa289a49b78626f1bab2b4f9984354efe18084d0b38c94b021e2a45a6a98
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/session.ts#L16

declaration:
export enum SessionMethod {
  Nip01 = "nip01",
  Nip07 = "nip07",
  Nip46 = "nip46",
  Nip55 = "nip55",
  Pubkey = "pubkey",
  Anonymous = "anonymous",
}

summary:
An enumeration that defines the different authentication methods for sessions in the application. It includes various Nostr Improvement Proposal (NIP) methods: Nip01 (private key), Nip07 (browser extension), Nip46 (remote signing), Nip55 (NIP-55 signer), as well as Pubkey (read-only) and Anonymous methods.

details:
This enum serves as a type discriminator for the different session types in the application. It's used throughout the codebase to determine the authentication method of a session and to enable type narrowing through type guards like `isNip01Session`, `isNip07Session`, etc. The enum values are string literals that match the method names, which makes them more readable in debugging and storage contexts.

import/access examples:
import { SessionMethod } from '@welshman/app';
import { SessionMethod } from '@welshman/app/session';


=========================
workspace: packages/app
file: packages/app/src/session.ts
lines: 25:29
id: 4dadf0e322232e41ee6928e9a7af63acda8c2aeea0a0df0e8b1d18795867a552
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/session.ts#L25

declaration:
export type SessionNip01 = {
  method: SessionMethod.Nip01
  pubkey: string
  secret: string
}

summary:
SessionNip01 is a TypeScript type alias that represents a session using the NIP-01 authentication method. It contains three properties: 'method' which is fixed to SessionMethod.Nip01, 'pubkey' which is a string representing the user's public key, and 'secret' which is a string containing the private key or secret used for authentication.

details:
This type is part of a session management system that supports multiple authentication methods for Nostr protocol. The SessionNip01 specifically represents a session where the user has provided their private key directly (NIP-01 method). The pubkey is derived from the secret using the getPubkey function as seen in the makeNip01Session factory function on line 114.

related: Nip01

import/access examples:
import type { SessionNip01 } from '@welshman/app';
import type { SessionNip01 } from '@welshman/app/session';


=========================
workspace: packages/app
file: packages/app/src/session.ts
lines: 31:34
id: b84676cb4ffc07d047942345e730bfb1dc77b5f59ce10ac3749fd87de1eb7e05
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/session.ts#L31

declaration:
export type SessionNip07 = {
  method: SessionMethod.Nip07
  pubkey: string
}

summary:
SessionNip07 is a TypeScript type alias that represents a session using the NIP-07 authentication method. It contains two properties: 'method' which is fixed to SessionMethod.Nip07 enum value, and 'pubkey' which is a string representing the user's public key. This type is used to define the structure for NIP-07 based authentication sessions in the application.

details:
This type is part of a broader session management system in the application. It's one of several session types (along with Nip01, Nip46, Nip55, Pubkey, and Anonymous) that are used to represent different authentication methods. The NIP-07 method specifically refers to browser extension-based authentication where the extension provides the public key but handles signing operations itself (like with browser extensions such as nos2x or Alby).

related: Nip07

import/access examples:
import type { SessionNip07 } from '@welshman/app';
import type { SessionNip07 } from '@welshman/app/session';


=========================
workspace: packages/app
file: packages/app/src/session.ts
lines: 36:44
id: 67234c94739e5abc8da2051e63ecaefccf8fbf5595d4a5ac6d501d9142bddf61
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/session.ts#L36

declaration:
export type SessionNip46 = {
  method: SessionMethod.Nip46
  pubkey: string
  secret: string
  handler: {
    pubkey: string
    relays: string[]
  }
}

summary:
SessionNip46 is a TypeScript type alias that represents a session using the NIP-46 authentication method. It contains information needed for a NIP-46 connection including the public key of the user, a secret key for the client, and handler information with the signer's public key and relay URLs.

details:
This type is part of a session management system that supports multiple authentication methods for Nostr applications. The SessionNip46 type specifically defines the structure for NIP-46 remote signing sessions with the following fields:
1. method: Fixed as SessionMethod.Nip46 to identify this session type
2. pubkey: The user's public key
3. secret: The client's secret key used for secure communication
4. handler: An object containing:
   - pubkey: The public key of the remote signer
   - relays: An array of relay URLs for communication with the signer

This type is used in various session management functions like makeNip46Session, loginWithNip46, and in the getSigner function to create appropriate signers.

related: Nip46

import/access examples:
import type { SessionNip46 } from '@welshman/app';
import type { SessionNip46 } from '@welshman/app/session';


=========================
workspace: packages/app
file: packages/app/src/session.ts
lines: 46:50
id: 0bbebe5909a3c6a61b89e505a7c9f9d57c0b2afee9d3003d9fd81a30c6911f54
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/session.ts#L46

declaration:
export type SessionNip55 = {
  method: SessionMethod.Nip55
  pubkey: string
  signer: string
}

summary:
SessionNip55 is a TypeScript type alias that represents a session using the NIP-55 authentication method. It contains three properties: 'method' which is fixed to SessionMethod.Nip55, 'pubkey' which stores the user's public key as a string, and 'signer' which contains a string identifier for the signer service.

details:
This type is part of a session management system that supports multiple authentication methods for Nostr applications. The SessionNip55 type specifically represents sessions authenticated via NIP-55, which appears to be a signing method that delegates signing operations to an external service identified by the 'signer' string. It's used in the type union 'SessionAnyMethod' and has a corresponding type guard function 'isNip55Session' to check if a session object conforms to this type.

related: Nip55

import/access examples:
import type { SessionNip55 } from '@welshman/app';
import type { SessionNip55 } from '@welshman/app/session';


=========================
workspace: packages/app
file: packages/app/src/session.ts
lines: 52:55
id: fde02b010c8d742877f9f4b88d1045bf35fcb06bed29f0d1d4b11d8aac1d8d8b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/session.ts#L52

declaration:
export type SessionPubkey = {
  method: SessionMethod.Pubkey
  pubkey: string
}

summary:
SessionPubkey is a TypeScript type alias that represents a session using the Pubkey authentication method. It contains two properties: 'method' which is set to SessionMethod.Pubkey, and 'pubkey' which is a string containing the user's public key. This type is used to represent read-only sessions where a user can view public data associated with a specific pubkey without having signing capabilities.

details:
This type is part of a session management system that supports multiple authentication methods. SessionPubkey is one of the simpler session types that only requires a public key without any signing capabilities. It's used in the session store and can be created using the `makePubkeySession` factory function. The type is also used with the `isPubkeySession` type guard to determine if a session object is specifically a pubkey-only session.

related: Pubkey

import/access examples:
import type { SessionPubkey } from '@welshman/app';
import type { SessionPubkey } from '@welshman/app/session';


=========================
workspace: packages/app
file: packages/app/src/session.ts
lines: 57:59
id: e2ff890e171b820b4659b9b2566c39295d605fe0d312cdce72764a7c28fd8a84
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/session.ts#L57

declaration:
export type SessionAnonymous = {
  method: SessionMethod.Anonymous
}

summary:
SessionAnonymous is a TypeScript type alias that represents an anonymous session in the application. It is a simple type that only contains a method property with the value SessionMethod.Anonymous, indicating that the session is anonymous and doesn't have an associated public key or authentication credentials.

details:
This type is part of a union type system for different session authentication methods in the application. It represents the simplest form of session with no authentication information attached. Unlike other session types (like Nip01, Nip07, etc.), this type doesn't include a pubkey or any authentication credentials, making it suitable for unauthenticated or guest access scenarios.

related: Anonymous

import/access examples:
import type { SessionAnonymous } from '@welshman/app';
import type { SessionAnonymous } from '@welshman/app/session';


=========================
workspace: packages/app
file: packages/app/src/session.ts
lines: 61:67
id: f03905fcf112c5912c65bec5621dbe081f5cfcd5dfb9244037745da2f682a4d4
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/session.ts#L61

declaration:
export type SessionAnyMethod =
  | SessionNip01
  | SessionNip07
  | SessionNip46
  | SessionNip55
  | SessionPubkey
  | SessionAnonymous

summary:
A type alias that represents any of the session methods available in the application. It is a union type that includes SessionNip01, SessionNip07, SessionNip46, SessionNip55, SessionPubkey, and SessionAnonymous. This type is used to define the base structure for all session types in the application.

details:
This type alias serves as a central union type that consolidates all the different session method types defined in the file. Each session type represents a different authentication method (NIP-01, NIP-07, NIP-46, NIP-55, pubkey, or anonymous) with their specific properties. The union type allows functions to accept any of these session types as parameters, enabling polymorphic behavior across different authentication methods while maintaining type safety.

related: SessionNip01,SessionNip07,SessionNip46,SessionNip55,SessionPubkey,SessionAnonymous

import/access examples:
import type { SessionAnyMethod } from '@welshman/app';
import type { SessionAnyMethod } from '@welshman/app/session';


=========================
workspace: packages/app
file: packages/app/src/session.ts
lines: 69:69
id: f7bdcea12c779eb1d52f71a2a5363a010a2184ab14c5601f814b6ddbd87af770
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/session.ts#L69

declaration:
export type Session = SessionAnyMethod & {wallet?: Wallet} & Record<string, any>

summary:
The `Session` type represents a user session in the application, combining different authentication methods with optional wallet information. It extends `SessionAnyMethod` (which can be one of several authentication types like Nip01, Nip07, etc.) and includes an optional wallet property plus any additional properties through `Record<string, any>`.

details:
This type serves as a core data structure for the session management system. It combines:
1. Authentication method-specific data (via the `SessionAnyMethod` union type)
2. An optional wallet property of type `Wallet`
3. An extensible record allowing for additional properties

The type is designed to be flexible enough to accommodate different authentication methods while maintaining a consistent structure for session management throughout the application.

related: SessionAnyMethod

import/access examples:
import type { Session } from '@welshman/app';
import type { Session } from '@welshman/app/session';


=========================
workspace: packages/app
file: packages/app/src/session.ts
lines: 71:71
id: f938b5b6d38f9079401a9d013feaadcf4c24c844a4a4309720ea2dc5dd5ef3b9
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/session.ts#L71

declaration:
pubkey = withGetter(writable<string | undefined>(undefined))

summary:
A Svelte store that holds the current user's public key. It's a writable store enhanced with a getter method, initialized with an undefined value. This store is used to track the currently active session's public key.

details:
This variable is created using the `withGetter` function from `@welshman/store` which wraps a Svelte `writable` store to add a getter method. The store is initialized with `undefined` and is designed to hold either a string (representing a public key) or undefined (when no session is active). It's a core part of the session management system, working in conjunction with the `sessions` store to track the currently active user.

related: withGetter

import/access examples:
import { pubkey } from '@welshman/app';
import { pubkey } from '@welshman/app/session';


=========================
workspace: packages/app
file: packages/app/src/session.ts
lines: 73:73
id: 5c1d290a11ffd507745bbe173fc56b579792a60a34c6cf09d7429adeeeeaf090
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/session.ts#L73

declaration:
sessions = withGetter(writable<Record<string, Session>>({}))

summary:
A Svelte store that manages a record of user sessions. It provides a reactive way to store and access multiple sessions, where each session is identified by a user's public key. The store is enhanced with a getter method for direct access to the current value without subscribing.

details:
This variable is implemented using the `withGetter` utility from `@welshman/store` which wraps a Svelte `writable` store. The store is initialized with an empty object that will hold session records in a key-value format where:

1. Keys are user public keys (strings)
2. Values are Session objects (with various authentication methods)

The `withGetter` enhancement allows accessing the current store value synchronously via a `.get()` method without having to subscribe to the store, which is useful for one-off reads of the session data.

related: withGetter

import/access examples:
import { sessions } from '@welshman/app';
import { sessions } from '@welshman/app/session';


=========================
workspace: packages/app
file: packages/app/src/session.ts
lines: 75:77
id: b1d4fe45a880ee4878e2dfde9b0c8179fae17052438854eae98289dd42bc82be
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/session.ts#L75

declaration:
session = withGetter(
  derived([pubkey, sessions], ([$pubkey, $sessions]) => ($pubkey ? $sessions[$pubkey] : undefined)),
)

summary:
A derived Svelte store that represents the current active session. It combines the `pubkey` and `sessions` stores to provide the session data for the currently selected public key. Returns `undefined` if no public key is selected.

details:
This variable is implemented using the `withGetter` utility (likely adding a getter method to the store) and Svelte's `derived` store. It creates a reactive store that automatically updates whenever either the `pubkey` or `sessions` stores change. The derivation function checks if a public key is selected ($pubkey) and if so, returns the corresponding session from the sessions store ($sessions[$pubkey]). If no public key is selected, it returns undefined.

related: withGetter

import/access examples:
import { session } from '@welshman/app';
import { session } from '@welshman/app/session';


=========================
workspace: packages/app
file: packages/app/src/session.ts
lines: 79:79
id: 1e926013aa71e04cdc1cd66f7b667402658d0ef6a86d0dd4b782894e9d468531
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/session.ts#L79

declaration:
getSession = (pubkey: string) => sessions.get()[pubkey]

summary:
A function that retrieves a session object for a given pubkey from the sessions store. It takes a pubkey string as input and returns the corresponding Session object if it exists.

details:
This is a simple accessor function that retrieves a session from the sessions store using the provided pubkey as a key. It uses the `get()` method on the sessions store (which is a Svelte writable store with a getter) to access the current state of all sessions, then indexes into that object with the pubkey to return the specific session.

related: sessions

import/access examples:
import { getSession } from '@welshman/app';
import { getSession } from '@welshman/app/session';


=========================
workspace: packages/app
file: packages/app/src/session.ts
lines: 81:84
id: f5d29b4af4b280aa27696c56af0eb0cc2bdccf1852c01b6bcad37888b6ac30e9
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/session.ts#L81

declaration:
addSession = (session: Session) => {
  sessions.update(assoc(session.pubkey, session))
  pubkey.set(session.pubkey)
}

summary:
Adds a new session to the sessions store and sets the current pubkey to the session's pubkey. This function is used to register a new authentication session in the application.

details:
The implementation does two things:
1. Updates the sessions store by associating the new session with its pubkey using the assoc utility function
2. Sets the current active pubkey to the pubkey of the newly added session

This effectively makes the newly added session the active one in the application.

related: Session

import/access examples:
import { addSession } from '@welshman/app';
import { addSession } from '@welshman/app/session';


=========================
workspace: packages/app
file: packages/app/src/session.ts
lines: 86:90
id: 3664a6f05a2233b649716d9d20672132e29fb923dcf3ef93e9d341f4c794b901
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/session.ts#L86

declaration:
putSession = (session: Session) => {
  if (!equals(getSession(session.pubkey), session)) {
    sessions.update(assoc(session.pubkey, session))
  }
}

summary:
Updates a session in the sessions store if it differs from the existing session with the same pubkey. Takes a Session object as input and doesn't return a value.

details:
The implementation compares the provided session with any existing session that has the same pubkey using the equals function. If they're different, it updates the sessions store by associating the new session with its pubkey using the assoc function. This is a simple update operation that only performs the update when necessary to avoid unnecessary store updates.

related: Session

import/access examples:
import { putSession } from '@welshman/app';
import { putSession } from '@welshman/app/session';


=========================
workspace: packages/app
file: packages/app/src/session.ts
lines: 92:93
id: 83462141aaf7a67a020a6c349f123606a6f87686bdec05c998997f2d331d51e4
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/session.ts#L92

declaration:
updateSession = (pubkey: string, f: (session: Session) => Session) =>
  putSession(f(getSession(pubkey)))

summary:
The `updateSession` function updates a session for a given pubkey by applying a transformation function. It takes a pubkey string and a function that transforms a Session object, then applies that function to the current session and updates it in the store.

details:
This function is a utility that combines two other session management functions:
1. It first retrieves the current session using `getSession(pubkey)`
2. It then applies the provided transformation function `f` to that session
3. Finally, it persists the updated session using `putSession`

The implementation is concise and follows a functional programming pattern, where the transformation function allows for flexible modifications to the session while abstracting away the retrieval and persistence logic.

related: __function,putSession,Session

import/access examples:
import { updateSession } from '@welshman/app';
import { updateSession } from '@welshman/app/session';


=========================
workspace: packages/app
file: packages/app/src/session.ts
lines: 95:104
id: 3762da5861ac81731514f33ab82ba56c7bdfd006b8082b6a99a5f3a8d46cd67b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/session.ts#L95

declaration:
dropSession = (_pubkey: string) => {
  const $signer = getSigner.pop(getSession(_pubkey))

  if ($signer instanceof Nip46Signer) {
    $signer.broker.cleanup()
  }

  pubkey.update($pubkey => ($pubkey === _pubkey ? undefined : $pubkey))
  sessions.update($sessions => omit([_pubkey], $sessions))
}

summary:
Removes a session associated with a given public key. This function cleans up any resources associated with the session, particularly for NIP-46 signers, and updates the global session state by removing the session and potentially clearing the current pubkey if it matches the one being dropped.

details:
Implementation details:
1. Retrieves and removes the signer associated with the session using `getSigner.pop()`
2. Performs special cleanup for NIP-46 signers by calling `broker.cleanup()` if applicable
3. Updates the global pubkey store, setting it to undefined if it matches the pubkey being dropped
4. Updates the sessions store by removing the entry for the specified pubkey using the `omit` utility function

import/access examples:
import { dropSession } from '@welshman/app';
import { dropSession } from '@welshman/app/session';


=========================
workspace: packages/app
file: packages/app/src/session.ts
lines: 106:110
id: 06b234130cd714e7ade77aa19be5e9e4c499389395c424de434eeb48aad7d729
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/session.ts#L106

declaration:
clearSessions = () => {
  for (const pubkey of Object.keys(sessions.get())) {
    dropSession(pubkey)
  }
}

summary:
Clears all active sessions by iterating through all stored sessions and dropping them one by one. This function effectively logs out all users from the application.

details:
The implementation iterates through all keys (pubkeys) in the sessions store using Object.keys(sessions.get()), and for each pubkey it calls the dropSession function. The dropSession function handles the cleanup of any resources associated with the session (particularly for NIP-46 sessions which need broker cleanup), removes the session from the sessions store, and updates the current pubkey if needed.

import/access examples:
import { clearSessions } from '@welshman/app';
import { clearSessions } from '@welshman/app/session';


=========================
workspace: packages/app
file: packages/app/src/session.ts
lines: 114:118
id: 670e77958056d8962612b2b06b16896af578dee6ca5618c877d6629d77395937
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/session.ts#L114

declaration:
makeNip01Session = (secret: string): SessionNip01 => ({
  method: SessionMethod.Nip01,
  secret,
  pubkey: getPubkey(secret),
})

summary:
Creates a NIP‑01 session object. Takes a secret (private key) string, derives the corresponding public key using `getPubkey`, and returns a `SessionNip01` containing the method identifier, the original secret, and the derived pubkey. No side‑effects; the function is pure and can be used to build a session before adding it to the store via `addSession` or similar helpers.

details:
The exported constant `makeNip01Session` is an arrow function that returns an object literal matching the `SessionNip01` type. It simply:
1. Receives the `secret` argument.
2. Calls `getPubkey(secret)` (imported from `@welshman/signer`) to compute the public key.
3. Constructs and returns `{ method: SessionMethod.Nip01, secret, pubkey }`.
The implementation relies only on the `getPubkey` utility; there are no additional computations, side‑effects, or async behavior. It is a thin factory used by login utilities such as `loginWithNip01`.


related: SessionNip01

import/access examples:
import { makeNip01Session } from '@welshman/app';
import { makeNip01Session } from '@welshman/app/session';


=========================
workspace: packages/app
file: packages/app/src/session.ts
lines: 120:123
id: 8d9343379d044a189324b56d3dd7ea40c1de0f8603595782765b1b5daedd7b34
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/session.ts#L120

declaration:
makeNip07Session = (pubkey: string): SessionNip07 => ({
  method: SessionMethod.Nip07,
  pubkey,
})

summary:
Creates a new NIP-07 session object with the specified public key. This function is used to generate a session configuration for interacting with NIP-07 compatible wallets (browser extensions). Returns a SessionNip07 object containing the method type and the user's public key.

details:
The implementation is straightforward - it's a factory function that takes a pubkey string parameter and returns a simple object literal with two properties: the method field set to SessionMethod.Nip07 enum value, and the pubkey field set to the provided public key. This is a pure function with no side effects or complex logic.

related: SessionNip07

import/access examples:
import { makeNip07Session } from '@welshman/app';
import { makeNip07Session } from '@welshman/app/session';


=========================
workspace: packages/app
file: packages/app/src/session.ts
lines: 125:135
id: cbc2f58bf97b5c4c0e19ecc9f85ae2c2fedc4dda156933b98ba49a13400de393
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/session.ts#L125

declaration:
makeNip46Session = (
  pubkey: string,
  clientSecret: string,
  signerPubkey: string,
  relays: string[],
): SessionNip46 => ({
  method: SessionMethod.Nip46,
  pubkey,
  secret: clientSecret,
  handler: {pubkey: signerPubkey, relays},
})

summary:
Creates a new NIP-46 session object with the specified parameters. This function takes a user's public key, a client secret, a signer's public key, and an array of relay URLs, and returns a SessionNip46 object that can be used for authentication and signing operations using the NIP-46 protocol.

details:
The implementation is straightforward - it creates and returns a SessionNip46 object with the following structure:
1. Sets the method to SessionMethod.Nip46
2. Assigns the user's pubkey
3. Stores the client secret
4. Creates a handler object containing the signer's public key and relay URLs

This function doesn't perform any validation or processing of the inputs, it simply constructs the session object with the provided parameters.

related: SessionNip46

import/access examples:
import { makeNip46Session } from '@welshman/app';
import { makeNip46Session } from '@welshman/app/session';


=========================
workspace: packages/app
file: packages/app/src/session.ts
lines: 137:141
id: ba8caf52f849b97b4f1f61d4cd9d97e1b4c1456936ff19798b693b4a417cf5bc
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/session.ts#L137

declaration:
makeNip55Session = (pubkey: string, signer: string): SessionNip55 => ({
  method: SessionMethod.Nip55,
  pubkey,
  signer,
})

summary:
Creates a new NIP-55 session object with the specified public key and signer. This function takes a user's public key and a signer identifier string and returns a properly formatted SessionNip55 object that can be used for authentication and signing operations in the application.

details:
The implementation is straightforward - it returns a simple object literal with three properties:
1. `method` - set to the enum value `SessionMethod.Nip55` to identify this as a NIP-55 session
2. `pubkey` - the user's public key passed as an argument
3. `signer` - the signer identifier string passed as an argument

The function uses a concise arrow function syntax with an implicit return of the object literal.

related: SessionNip55

import/access examples:
import { makeNip55Session } from '@welshman/app';
import { makeNip55Session } from '@welshman/app/session';


=========================
workspace: packages/app
file: packages/app/src/session.ts
lines: 143:146
id: cca1110f7b2b1349439d7c59d0850aa47faced7127cfbd7e38c66f1fe20566c5
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/session.ts#L143

declaration:
makePubkeySession = (pubkey: string): SessionPubkey => ({
  method: SessionMethod.Pubkey,
  pubkey,
})

summary:
Creates a new session object of type SessionPubkey with the provided public key. This function is used to create a read-only session that only contains a public key without signing capabilities.

details:
The implementation is straightforward - it returns an object literal with two properties:
1. `method` set to the enum value `SessionMethod.Pubkey` to identify this as a pubkey-only session
2. `pubkey` set to the provided public key string

This is a simple factory function that creates a minimal session object for read-only operations.

related: SessionPubkey

import/access examples:
import { makePubkeySession } from '@welshman/app';
import { makePubkeySession } from '@welshman/app/session';


=========================
workspace: packages/app
file: packages/app/src/session.ts
lines: 150:151
id: 46ec4c5849eaf116b3792caf6d7f5e79da9612815df20cfb136657779d705028
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/session.ts#L150

declaration:
isNip01Session = (session?: Session): session is SessionNip01 =>
  session?.method === SessionMethod.Nip01

summary:
A type guard function that checks if a given session is of type SessionNip01. It takes an optional Session parameter and returns a boolean indicating whether the session is a NIP-01 session. The function also acts as a type predicate, narrowing the type of the session parameter to SessionNip01 when it returns true.

details:
The implementation is straightforward - it checks if the session exists and if its method property equals SessionMethod.Nip01. This is a simple type guard that uses TypeScript's type predicate feature (session is SessionNip01) to help with type narrowing in conditional blocks.

related: method,SessionMethod,Nip01,Session

import/access examples:
import { isNip01Session } from '@welshman/app';
import { isNip01Session } from '@welshman/app/session';


=========================
workspace: packages/app
file: packages/app/src/session.ts
lines: 153:154
id: 8ce5336f34bc2ea0a333690a06464383c3d6e0cf3ca7f8c5866eefc8624a7b82
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/session.ts#L153

declaration:
isNip07Session = (session?: Session): session is SessionNip07 =>
  session?.method === SessionMethod.Nip07

summary:
A type guard function that checks if a given session is of type SessionNip07. It returns true if the session's method property equals SessionMethod.Nip07, confirming the session is a NIP-07 session (browser extension-based authentication). Returns false otherwise.

details:
The implementation is a simple arrow function that uses optional chaining (?.) to safely access the method property of the potentially undefined session parameter, then compares it with the SessionMethod.Nip07 enum value. This is a standard TypeScript type predicate function that narrows the type of the session parameter to SessionNip07 when it returns true.

related: method,SessionMethod,Nip07,Session

import/access examples:
import { isNip07Session } from '@welshman/app';
import { isNip07Session } from '@welshman/app/session';


=========================
workspace: packages/app
file: packages/app/src/session.ts
lines: 156:157
id: db18468f615fa7a19913abf665674ff99eab0a9fbd02bbf4b44a7cd8f6787361
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/session.ts#L156

declaration:
isNip46Session = (session?: Session): session is SessionNip46 =>
  session?.method === SessionMethod.Nip46

summary:
A type guard function that checks if a given session is of type SessionNip46. It returns a boolean indicating whether the session uses the NIP-46 authentication method.

details:
This is a simple type predicate function that checks if the provided session object has a 'method' property equal to SessionMethod.Nip46. It uses the optional chaining operator (?.) to safely access the method property even if the session is undefined. The function serves as a TypeScript type guard, narrowing the type of the session parameter to SessionNip46 when the function returns true.

related: method,SessionMethod,Nip46,Session

import/access examples:
import { isNip46Session } from '@welshman/app';
import { isNip46Session } from '@welshman/app/session';


=========================
workspace: packages/app
file: packages/app/src/session.ts
lines: 159:160
id: 512d378ffabf656209e3200fe984210ec5d4dba6c6ec21c39b2af71f161a1199
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/session.ts#L159

declaration:
isNip55Session = (session?: Session): session is SessionNip55 =>
  session?.method === SessionMethod.Nip55

summary:
A type guard function that checks if a given session is of type SessionNip55. It returns a boolean indicating whether the session uses the NIP-55 authentication method.

details:
The implementation is a simple arrow function that takes an optional Session parameter and returns a type predicate. It checks if the session's method property equals SessionMethod.Nip55. This is a straightforward type guard that helps with TypeScript type narrowing when working with different session types.

related: method,SessionMethod,Nip55,Session

import/access examples:
import { isNip55Session } from '@welshman/app';
import { isNip55Session } from '@welshman/app/session';


=========================
workspace: packages/app
file: packages/app/src/session.ts
lines: 162:163
id: 6b31877bf1e10f0fdd37711cac5b7533478d0c4934637b221d72b3b2df5fd960
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/session.ts#L162

declaration:
isPubkeySession = (session?: Session): session is SessionPubkey =>
  session?.method === SessionMethod.Pubkey

summary:
A type guard function that checks if a given session is of type SessionPubkey. It returns a boolean indicating whether the session's method is SessionMethod.Pubkey, and also serves as a TypeScript type predicate, narrowing the type of the session parameter to SessionPubkey when the function returns true.

details:
The implementation is straightforward - it checks if the optional session parameter exists and if its method property equals SessionMethod.Pubkey. This is a simple type guard that uses the optional chaining operator (?.) to safely access the method property even if session is undefined.

related: method,SessionMethod,Pubkey,Session

import/access examples:
import { isPubkeySession } from '@welshman/app';
import { isPubkeySession } from '@welshman/app/session';


=========================
workspace: packages/app
file: packages/app/src/session.ts
lines: 167:167
id: 357a4e9e875d03220c101f7e987c3f8b9bdf74610fb8e4e7622780332fd7929b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/session.ts#L167

declaration:
loginWithNip01 = (secret: string) => addSession(makeNip01Session(secret))

summary:
A function that logs in a user with a NIP-01 session by providing a secret key. It creates a new NIP-01 session and adds it to the session store.

details:
This function is a simple wrapper that combines two operations:
1. It calls `makeNip01Session(secret)` to create a session object with the NIP-01 method type
2. It then passes this session to `addSession()` which adds the session to the store and sets it as the current active session

The implementation is straightforward - it's a one-liner that chains these two operations together.

related: __function,addSession

import/access examples:
import { loginWithNip01 } from '@welshman/app';
import { loginWithNip01 } from '@welshman/app/session';


=========================
workspace: packages/app
file: packages/app/src/session.ts
lines: 169:169
id: 7342e594d9120f64764f44c1e23333783a268e5735196f3e91134be061d99f2d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/session.ts#L169

declaration:
loginWithNip07 = (pubkey: string) => addSession(makeNip07Session(pubkey))

summary:
Logs in a user using the NIP‑07 method. Accepts a public key string, creates a NIP‑07 session object and adds it to the global session store, also setting the active pubkey. Returns nothing (void).

details:
The function is a thin wrapper around two internal helpers:
1. `makeNip07Session(pubkey)` – a factory that returns a `SessionNip07` object `{ method: SessionMethod.Nip07, pubkey }`.
2. `addSession(session)` – updates the `sessions` Svelte store with the new session (using `assoc` to merge it) and sets the `pubkey` store to the session’s pubkey, making it the current active session.
Thus `loginWithNip07` simply creates the session object and registers it in the application‑wide session state. No other side effects are performed.

related: __function,addSession

import/access examples:
import { loginWithNip07 } from '@welshman/app';
import { loginWithNip07 } from '@welshman/app/session';


=========================
workspace: packages/app
file: packages/app/src/session.ts
lines: 171:176
id: 5e57c79ff95a6181895176ec003c2fbf58c0dacb97f666a22b38b6814daab571
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/session.ts#L171

declaration:
loginWithNip46 = (
  pubkey: string,
  clientSecret: string,
  signerPubkey: string,
  relays: string[],
) => addSession(makeNip46Session(pubkey, clientSecret, signerPubkey, relays))

summary:
A function that creates and adds a NIP-46 session to the application's session management system. It takes a user's public key, a client secret, a signer's public key, and an array of relay URLs as parameters. This function enables login functionality using the NIP-46 protocol, which allows for remote signing capabilities.

details:
The implementation is straightforward:
1. It calls `makeNip46Session()` with the provided parameters to create a SessionNip46 object
2. Then passes that session object to `addSession()` which adds it to the application's session store and sets it as the current active session
3. The function leverages the NIP-46 protocol which enables remote signing capabilities through relay servers
4. This is part of a larger session management system that supports multiple authentication methods (NIP-01, NIP-07, NIP-46, NIP-55, etc.)

related: __function,addSession

import/access examples:
import { loginWithNip46 } from '@welshman/app';
import { loginWithNip46 } from '@welshman/app/session';


=========================
workspace: packages/app
file: packages/app/src/session.ts
lines: 178:179
id: 4b85bf13588fd32f02587cb507676af6371778e5119aa90ff3178c6a3de53463
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/session.ts#L178

declaration:
loginWithNip55 = (pubkey: string, signer: string) =>
  addSession(makeNip55Session(pubkey, signer))

summary:
loginWithNip55(pubkey: string, signer: string) → void

Public function that logs a user in using the Nip55 signing method. It creates a Nip55 session object (containing the method identifier, the user’s public key and the signer identifier) via the `makeNip55Session` factory and then adds that session to the global session store with `addSession`. The added session becomes the active session, causing the `pubkey` store to be updated to the supplied public key. No value is returned (the underlying `addSession` returns `void`).

details:
The implementation is a thin wrapper:
1. Calls `makeNip55Session(pubkey, signer)` which returns `{ method: SessionMethod.Nip55, pubkey, signer }`.
2. Passes the resulting session object to `addSession`.
3. `addSession` updates the `sessions` writable store using `assoc(session.pubkey, session)` to insert or replace the session entry, then sets the `pubkey` writable store to the new session’s public key, making it the active session.
4. No additional logic, error handling, or side‑effects are performed beyond the store updates performed by `addSession`.


related: __function,addSession

import/access examples:
import { loginWithNip55 } from '@welshman/app';
import { loginWithNip55 } from '@welshman/app/session';


=========================
workspace: packages/app
file: packages/app/src/session.ts
lines: 181:181
id: 8e309f4cadeecf0f45065cd5803c6a4dfbcea7d1a50e9f770e50c728e7ebb5dc
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/session.ts#L181

declaration:
loginWithPubkey = (pubkey: string) => addSession(makePubkeySession(pubkey))

summary:
A function that creates a new session using a public key and adds it to the session store. This function allows users to log in with just a public key, without any signing capabilities.

details:
The implementation is straightforward - it takes a pubkey string parameter, creates a new pubkey-based session using the makePubkeySession helper function, and then adds this session to the global session store using the addSession function. This creates a read-only session that can be used to identify a user but cannot sign events.

related: __function,addSession

import/access examples:
import { loginWithPubkey } from '@welshman/app';
import { loginWithPubkey } from '@welshman/app/session';


=========================
workspace: packages/app
file: packages/app/src/session.ts
lines: 185:185
id: c342d8b344c85d877c0b9bbde0bc3a2155a48cb679c717adfaf81a5fcf215d85
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/session.ts#L185

declaration:
nip46Perms = "sign_event:22242,nip04_encrypt,nip04_decrypt,nip44_encrypt,nip44_decrypt"

summary:
A constant string that defines the permissions required for NIP-46 (Nostr Connect) operations. It includes permissions for signing events of type 22242, as well as NIP-04 and NIP-44 encryption and decryption capabilities.

details:
This constant is a simple string value that contains a comma-separated list of permission identifiers used in the Nostr protocol's NIP-46 implementation. The permissions include:
1. sign_event:22242 - Permission to sign events of type 22242
2. nip04_encrypt - Permission to encrypt data using NIP-04 protocol
3. nip04_decrypt - Permission to decrypt data using NIP-04 protocol
4. nip44_encrypt - Permission to encrypt data using NIP-44 protocol
5. nip44_decrypt - Permission to decrypt data using NIP-44 protocol

This constant is likely used when establishing connections with NIP-46 signers to specify what operations the application is requesting permission to perform.

import/access examples:
import { nip46Perms } from '@welshman/app';
import { nip46Perms } from '@welshman/app/session';


=========================
workspace: packages/app
file: packages/app/src/session.ts
lines: 187:191
id: f565c19a2b733c06825198a5bb4375dd6a42f727c4beea4bbcca196f4c719c80
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/session.ts#L187

declaration:
export enum SignerLogEntryStatus {
  Pending = "pending",
  Success = "success",
  Failure = "failure",
}

summary:
The `SignerLogEntryStatus` enum represents the possible states of a signer log entry in the application's authentication system. It defines three status values: 'pending' for operations in progress, 'success' for completed operations, and 'failure' for operations that encountered errors.

details:
This enum is used in conjunction with the `SignerLogEntry` type and the `signerLog` store to track and display the status of cryptographic signing operations. It's part of a logging mechanism that monitors the progress and outcome of signing operations performed by various signers (NIP-01, NIP-07, NIP-46, NIP-55). The enum values are used when creating, updating, and displaying log entries during the wrapping of signer operations in the `wrapSigner` function.

import/access examples:
import { SignerLogEntryStatus } from '@welshman/app';
import { SignerLogEntryStatus } from '@welshman/app/session';


=========================
workspace: packages/app
file: packages/app/src/session.ts
lines: 193:198
id: 62aae0f87c7557721bca04a6a6b522090fff5e553204ca0728a4ca672dfe1ad7
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/session.ts#L193

declaration:
export type SignerLogEntry = {
  id: string
  method: string
  status: SignerLogEntryStatus
  duration: number
}

summary:
SignerLogEntry is a TypeScript type that represents an entry in a signer log. It tracks the status and performance of signing operations. The type contains four properties: 'id' (a unique identifier for the log entry), 'method' (the signing method used), 'status' (the current state of the signing operation - pending, success, or failure), and 'duration' (the time taken to complete the operation in milliseconds).

details:
This type is used in conjunction with the signerLog store and the wrapSigner function in the session management system. When a signing operation is performed through a wrapped signer, a log entry is created with a pending status, then updated to success or failure when the operation completes, along with the duration it took. This provides a way to track and monitor signing operations for debugging and performance analysis purposes.

related: SignerLogEntryStatus

import/access examples:
import type { SignerLogEntry } from '@welshman/app';
import type { SignerLogEntry } from '@welshman/app/session';


=========================
workspace: packages/app
file: packages/app/src/session.ts
lines: 200:200
id: 73b672e65a0445588425a39dccff623783f49c01cd740cd4e8ca1165112acbc9
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/session.ts#L200

declaration:
signerLog = withGetter(writable<SignerLogEntry[]>([]))

summary:
A Svelte store that tracks and logs operations performed by signers in the application. It uses the `withGetter` wrapper around a writable store to maintain an array of `SignerLogEntry` objects, which record information about signing operations including their ID, method, status (pending, success, or failure), and duration.

details:
The implementation creates a Svelte store using `writable<SignerLogEntry[]>([])` to initialize an empty array of signer log entries. It then wraps this store with `withGetter` which likely adds a getter method to access the store's value without subscribing. This store is used by the `wrapSigner` function to track the execution of signer operations, recording their status and timing information.

related: withGetter

import/access examples:
import { signerLog } from '@welshman/app';
import { signerLog } from '@welshman/app/session';


=========================
workspace: packages/app
file: packages/app/src/session.ts
lines: 202:234
id: ca3065efabc04683b53565c7c2c1bb00585d026b8c9e73b5b11c3c5ecbafd37f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/session.ts#L202

declaration:
wrapSigner = (signer: ISigner) =>
  new WrappedSigner(signer, async <T>(method: string, thunk: () => Promise<T>) => {
    const id = randomId()
    const now = Date.now()

    signerLog.update(log =>
      append({id, method, status: SignerLogEntryStatus.Pending, duration: 0}, log),
    )

    try {
      const result = await thunk()

      signerLog.update(log =>
        log.map(x =>
          x.id === id
            ? {...x, status: SignerLogEntryStatus.Success, duration: Date.now() - now}
            : x,
        ),
      )

      return result
    } catch (error: any) {
      signerLog.update(log =>
        log.map(x =>
          x.id === id
            ? {...x, status: SignerLogEntryStatus.Failure, duration: Date.now() - now}
            : x,
        ),
      )

      throw error
    }
  })

summary:
A function that wraps an ISigner instance with logging functionality. It takes a signer object and returns a new WrappedSigner that logs the execution of signer methods, tracking their status (pending, success, failure) and duration.

details:
The implementation creates a WrappedSigner that intercepts signer method calls by:

1. Generating a unique ID for each operation using randomId()
2. Recording the start time with Date.now()
3. Adding a pending entry to the signerLog store with the operation details
4. Executing the provided thunk function which contains the actual signer operation
5. Upon completion:
   - On success: updates the log entry with success status and duration
   - On failure: updates the log entry with failure status and duration before re-throwing the error

The function provides a way to monitor and track signer operations for debugging and UI feedback purposes.

related: WrappedSigner

import/access examples:
import { wrapSigner } from '@welshman/app';
import { wrapSigner } from '@welshman/app/session';


=========================
workspace: packages/app
file: packages/app/src/session.ts
lines: 236:254
id: 4ae7c054258518835cb8406683712ad8c3024e4f83e7dd200ae090b304ddef04
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/session.ts#L236

declaration:
getSigner = cached({
  maxSize: 100,
  getKey: ([session]: [Session | undefined]) => `${session?.method}:${session?.pubkey}`,
  getValue: ([session]: [Session | undefined]) => {
    if (isNip07Session(session)) return wrapSigner(new Nip07Signer())
    if (isNip01Session(session)) return wrapSigner(new Nip01Signer(session.secret))
    if (isNip55Session(session)) return wrapSigner(new Nip55Signer(session.signer))
    if (isNip46Session(session)) {
      const {
        secret: clientSecret,
        handler: {relays, pubkey: signerPubkey},
      } = session
      const broker = new Nip46Broker({clientSecret, signerPubkey, relays})
      const signer = new Nip46Signer(broker)

      return wrapSigner(signer)
    }
  },
})

summary:
A cached function that creates and returns a wrapped signer based on the provided session. It supports different types of signers (NIP-07, NIP-01, NIP-55, NIP-46) depending on the session type. The function caches results with a maximum cache size of 100 entries, using a composite key of session method and pubkey.

details:
Implementation details:
1. Uses the `cached` utility to memoize signer instances with a maximum cache size of 100.
2. Generates cache keys by combining the session method and pubkey in format `${method}:${pubkey}`.
3. The getValue function determines which signer implementation to create based on session type:
   - For NIP-07 sessions: Creates a wrapped Nip07Signer
   - For NIP-01 sessions: Creates a wrapped Nip01Signer with the session secret
   - For NIP-55 sessions: Creates a wrapped Nip55Signer with the session signer
   - For NIP-46 sessions: Creates a Nip46Broker with client secret, signer pubkey and relays, then creates a wrapped Nip46Signer with that broker
4. All signers are wrapped using the wrapSigner utility which adds logging functionality.
5. Returns undefined for unsupported session types.

related: cached

import/access examples:
import { getSigner } from '@welshman/app';
import { getSigner } from '@welshman/app/session';


=========================
workspace: packages/app
file: packages/app/src/session.ts
lines: 256:256
id: 02c01241d0ce38c4b88e8062e050efdd0a8e03a9c7a2bac3084cb204ee1909a2
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/session.ts#L256

declaration:
signer = withGetter(derived(session, getSigner))

summary:
A derived Svelte store that provides access to the current session's signer. It uses the `session` store and the `getSigner` function to create a wrapped signer instance based on the current session type. The store includes a getter method for direct access to the current value.

details:
This variable is implemented as a Svelte store created using the `withGetter` utility (which adds a synchronous getter method) and the `derived` function from Svelte. It derives its value from the `session` store by passing the current session to the `getSigner` function.

The implementation relies on the caching mechanism of `getSigner` to efficiently manage signer instances. When the session changes, this store will automatically update with the appropriate signer for the current session type (Nip01, Nip07, Nip46, Nip55, etc.).

The store provides a convenient way to access signing functionality throughout the application without needing to manually determine which signer implementation to use based on the session type.

related: withGetter

import/access examples:
import { signer } from '@welshman/app';
import { signer } from '@welshman/app/session';


=========================
workspace: packages/app
file: packages/app/src/session.ts
lines: 258:267
id: d85e6940ea52cc9179129d71301a3fd82f29bb9109492fc3ff140f1bfe841286
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/session.ts#L258

declaration:
nip44EncryptToSelf = (payload: string) => {
  const $pubkey = pubkey.get()
  const $signer = signer.get()

  if (!$signer) {
    throw new Error("Unable to encrypt to self without valid signer")
  }

  return $signer.nip44.encrypt($pubkey!, payload)
}

summary:
A function that encrypts a payload using NIP-44 encryption to the current user's public key. It takes a string payload as input and returns the encrypted result. Requires an active session with a valid signer.

details:
The implementation:
1. Retrieves the current user's public key using `pubkey.get()`
2. Gets the current signer instance using `signer.get()`
3. Performs validation to ensure a signer exists, throwing an error if not
4. Uses the signer's NIP-44 encryption functionality to encrypt the payload to the user's own public key
5. The non-null assertion operator (!) is used on $pubkey since the function assumes a valid pubkey exists when a signer is present

import/access examples:
import { nip44EncryptToSelf } from '@welshman/app';
import { nip44EncryptToSelf } from '@welshman/app/session';


=========================
workspace: packages/app
file: packages/app/src/tags.ts
lines: 14:19
id: 6f7b732db09a503e6f6c608b4845962dbf426ef6ef74ec4355563c6f89b59e4d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/tags.ts#L14

declaration:
tagZapSplit = (pubkey: string, split = 1) => [
  "zap",
  pubkey,
  Router.get().FromPubkey(pubkey).getUrl() || "",
  String(split),
]

summary:
Creates a 'zap' tag array for a given pubkey with an optional split parameter. The tag includes the 'zap' identifier, the pubkey, a URL associated with the pubkey, and the split value as a string. This function is used for creating zap-related tags in Nostr events.

details:
The function creates a 4-element array with:
1. The literal string "zap" as the tag identifier
2. The provided pubkey
3. A URL for the pubkey obtained from the Router, falling back to an empty string if no URL is available
4. The split value converted to a string (defaults to 1 if not provided)

The implementation uses Router.get().FromPubkey() to retrieve a URL associated with the pubkey.

related: Router

import/access examples:
import { tagZapSplit } from '@welshman/app';
import { tagZapSplit } from '@welshman/app/tags';


=========================
workspace: packages/app
file: packages/app/src/tags.ts
lines: 21:26
id: 6b19a53eb97025da22bc16d8adaefd73e74efc5c57fd78f236ac6e0c7b8c332b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/tags.ts#L21

declaration:
tagPubkey = (pubkey: string, ...args: unknown[]) => [
  "p",
  pubkey,
  Router.get().FromPubkey(pubkey).getUrl() || "",
  displayProfileByPubkey(pubkey),
]

summary:
Creates a 'p' tag array for a given pubkey, used in Nostr events to reference users. The tag includes the pubkey, a URL for the user's profile, and the display name of the profile. Additional arguments can be passed but are not used in the current implementation.

details:
This function constructs a Nostr 'p' tag array with four elements:
1. The literal string "p" (indicating a pubkey reference)
2. The pubkey string itself
3. A URL for the pubkey's profile, obtained from the Router singleton, or an empty string if no URL is available
4. The display name for the profile, retrieved via the displayProfileByPubkey function

The function accepts additional arguments via rest parameters (...args) but doesn't use them in the current implementation.

related: Router,__function,displayProfileByPubkey

import/access examples:
import { tagPubkey } from '@welshman/app';
import { tagPubkey } from '@welshman/app/tags';


=========================
workspace: packages/app
file: packages/app/src/tags.ts
lines: 28:37
id: 592aade0410b19f8d2e845fb6301c247c87f51eb18102df90220a34fbfc4a566
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/tags.ts#L28

declaration:
tagEvent = (event: TrustedEvent, mark = "") => {
  const url = Router.get().Event(event).getUrl() || ""
  const tags = [["e", event.id, url, mark, event.pubkey]]

  if (isReplaceable(event)) {
    tags.push(["a", getAddress(event), url, mark, event.pubkey])
  }

  return tags
}

summary:
Creates an array of tags for a given event. The function generates an 'e' tag with the event ID, URL, optional mark, and pubkey. If the event is replaceable, it also adds an 'a' tag with the event's address. This is useful for referencing events in Nostr protocol.

details:
The implementation:
1. Gets the URL for the event using Router.get().Event(event).getUrl()
2. Creates an initial tags array with an 'e' tag containing [event.id, url, mark, event.pubkey]
3. Checks if the event is replaceable using isReplaceable(event)
4. If replaceable, adds an 'a' tag with [getAddress(event), url, mark, event.pubkey]
5. Returns the complete tags array

The function handles both regular and replaceable events, ensuring proper tagging according to Nostr protocol standards.

import/access examples:
import { tagEvent } from '@welshman/app';
import { tagEvent } from '@welshman/app/tags';


=========================
workspace: packages/app
file: packages/app/src/tags.ts
lines: 39:40
id: f60364084337d18869f922f828ffa389241862371bba9e08916708458bdf8aae
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/tags.ts#L39

declaration:
tagEventPubkeys = (event: TrustedEvent) =>
  uniq(remove(pubkey.get()!, [event.pubkey, ...getPubkeyTagValues(event.tags)])).map(tagPubkey)

summary:
A function that extracts unique pubkeys from an event, excluding the current user's pubkey, and formats them as 'p' tags. It takes a TrustedEvent as input and returns an array of pubkey tags.

details:
This function works by:
1. Getting the current user's pubkey via `pubkey.get()`
2. Creating an array containing the event's pubkey and all pubkeys from the event's tags using `getPubkeyTagValues`
3. Removing the current user's pubkey from this list using the `remove` utility
4. Ensuring the list contains only unique values with the `uniq` utility
5. Mapping each remaining pubkey through the `tagPubkey` function to create properly formatted 'p' tags

related: uniq

import/access examples:
import { tagEventPubkeys } from '@welshman/app';
import { tagEventPubkeys } from '@welshman/app/tags';


=========================
workspace: packages/app
file: packages/app/src/tags.ts
lines: 42:47
id: 9550d01d2425b00b643776ed05613801efe1b7186a405d8d5cbc735024332baa
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/tags.ts#L42

declaration:
tagEventForQuote = (event: TrustedEvent) => [
  "q",
  event.id,
  Router.get().Event(event).getUrl() || "",
  event.pubkey,
]

summary:
Creates a 'q' tag array for quoting a Nostr event. The function takes a TrustedEvent object and returns an array with the format ['q', eventId, eventUrl, pubkey] that can be used in a Nostr event to reference another event as a quote.

details:
This function creates a tag array specifically for quoting another Nostr event. It:
1. Takes a TrustedEvent parameter
2. Returns an array with four elements:
   - 'q' as the tag type (indicating a quote)
   - The event ID from the input event
   - The URL for the event (obtained via Router.get().Event(event).getUrl() with an empty string fallback)
   - The public key of the event author

The implementation is straightforward with no complex logic.

related: Router

import/access examples:
import { tagEventForQuote } from '@welshman/app';
import { tagEventForQuote } from '@welshman/app/tags';


=========================
workspace: packages/app
file: packages/app/src/tags.ts
lines: 49:95
id: 52d8440b63560821eb7ccfb4edc044056e0085daa80e735d8c920b9d80c39153
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/tags.ts#L49

declaration:
tagEventForReply = (event: TrustedEvent) => {
  const tags = tagEventPubkeys(event)

  // Based on NIP 10 legacy tags, order is root, mentions, reply
  const {roots, replies, mentions} = getReplyTags(event.tags)

  // Root comes first
  if (roots.length > 0) {
    for (const t of roots) {
      tags.push([...t.slice(0, 2), Router.get().EventRoots(event).getUrl() || "", "root"])
    }
  } else {
    for (const t of replies) {
      tags.push([...t.slice(0, 2), Router.get().EventParents(event).getUrl() || "", "root"])
    }
  }

  // Inherit mentions
  for (const t of mentions) {
    if (!tags.some(nthEq(1, t[1]))) {
      tags.push([...t.slice(0, 3), "mention"])
    }
  }

  // Inherit replies if they weren't already included
  if (roots.length > 0) {
    for (const t of replies) {
      if (!tags.some(nthEq(1, t[1]))) {
        tags.push([...t.slice(0, 3), "mention"])
      }
    }
  }

  // Finally, tag the event itself
  const mark = replies.length > 0 ? "reply" : "root"
  const hint = Router.get().Event(event).getUrl() || ""

  // e-tag the event
  tags.push(["e", event.id, hint, mark, event.pubkey])

  // a-tag the event
  if (isReplaceable(event)) {
    tags.push(["a", getAddress(event), hint, mark, event.pubkey])
  }

  return tags
}

summary:
Creates a set of tags for replying to a Nostr event according to NIP-10 standards. Takes a TrustedEvent as input and returns an array of tag arrays that properly reference the original event, its roots, mentions, and participants. The tags follow the proper ordering (root, mentions, reply) and include routing hints for client navigation.

details:
The implementation works by:

1. Starting with tags for all pubkeys in the event (excluding the current user's pubkey)
2. Processing reply tags from the original event using getReplyTags to extract roots, replies, and mentions
3. Adding root tags first - either from explicit root tags or from reply tags if no roots exist
4. Adding mention tags from the original event, avoiding duplicates
5. Adding reply tags as mentions if they weren't already included and roots exist
6. Finally tagging the event itself with either 'reply' or 'root' marker depending on context
7. Adding an 'a' tag if the event is replaceable

The function uses Router.get() to generate proper URL hints for client navigation and employs helper functions like nthEq to check for duplicate tags.

import/access examples:
import { tagEventForReply } from '@welshman/app';
import { tagEventForReply } from '@welshman/app/tags';


=========================
workspace: packages/app
file: packages/app/src/tags.ts
lines: 97:130
id: 0e17f85f627c1b68131601dd76177a55973b30cdbd4ed386926cb8976b5e847d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/tags.ts#L97

declaration:
tagEventForComment = (event: TrustedEvent) => {
  const pubkeyHint = Router.get().FromPubkey(event.pubkey).getUrl() || ""
  const eventHint = Router.get().Event(event).getUrl() || ""
  const address = getAddress(event)
  const seenRoots = new Set<string>()
  const tags: string[][] = []

  for (const [t, ...tag] of event.tags) {
    if (["K", "E", "A", "I", "P"].includes(t)) {
      tags.push([t, ...tag])
      seenRoots.add(t)
    }
  }

  if (seenRoots.size === 0) {
    tags.push(["K", String(event.kind)])
    tags.push(["P", event.pubkey, pubkeyHint])
    tags.push(["E", event.id, eventHint, event.pubkey])

    if (isReplaceableKind(event.kind)) {
      tags.push(["A", address, eventHint, event.pubkey])
    }
  }

  tags.push(["k", String(event.kind)])
  tags.push(["p", event.pubkey, pubkeyHint])
  tags.push(["e", event.id, eventHint, event.pubkey])

  if (isReplaceableKind(event.kind)) {
    tags.push(["a", address, eventHint, event.pubkey])
  }

  return tags
}

summary:
Creates an array of tags for commenting on a Nostr event. Takes a TrustedEvent as input and returns a two-dimensional string array containing properly formatted tags for commenting on the event. The function preserves existing root tags (K, E, A, I, P) from the original event and adds additional tags with lowercase variants (k, p, e, a) to properly reference the event and its author.

details:
The implementation:

1. Gets URL hints for the event author and the event itself using Router
2. Gets the event address using getAddress utility
3. Creates a Set to track seen root tags and initializes an empty tags array
4. Processes the event's existing tags:
   - Preserves uppercase root tags (K, E, A, I, P) and tracks them in seenRoots
5. If no root tags were found (seenRoots is empty):
   - Adds uppercase tags for the event kind (K), author (P), event ID (E)
   - Adds an address tag (A) if the event is replaceable
6. Always adds lowercase tags for the event kind (k), author (p), event ID (e)
7. Adds an address tag (a) if the event is replaceable
8. Returns the complete tags array

import/access examples:
import { tagEventForComment } from '@welshman/app';
import { tagEventForComment } from '@welshman/app/tags';


=========================
workspace: packages/app
file: packages/app/src/tags.ts
lines: 132:149
id: 6c56651760143016cfe976debff537f6607670b8f3225009c654c483c3a69696
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/tags.ts#L132

declaration:
tagEventForReaction = (event: TrustedEvent) => {
  const hint = Router.get().Event(event).getUrl() || ""
  const tags: string[][] = []

  // Mention the event's author
  if (event.pubkey !== pubkey.get()) {
    tags.push(tagPubkey(event.pubkey))
  }

  tags.push(["k", String(event.kind)])
  tags.push(["e", event.id, hint])

  if (isReplaceable(event)) {
    tags.push(["a", getAddress(event), hint])
  }

  return tags
}

summary:
Creates an array of tags for a reaction to a Nostr event. It takes a TrustedEvent as input and returns an array of string arrays representing tags. The tags include the event's kind, ID, and address (if replaceable), along with a mention of the event's author if it's not the current user.

details:
The function builds tags for reacting to a Nostr event by:
1. Getting a URL hint for the event using Router.get().Event(event).getUrl()
2. Creating an empty tags array
3. Adding a tag for the event's author (using tagPubkey) if it's not the current user
4. Adding a 'k' tag with the event's kind
5. Adding an 'e' tag with the event's ID and hint URL
6. If the event is replaceable (checked with isReplaceable), adding an 'a' tag with the event's address and hint URL
7. Returning the completed tags array

import/access examples:
import { tagEventForReaction } from '@welshman/app';
import { tagEventForReaction } from '@welshman/app/tags';


=========================
workspace: packages/app
file: packages/app/src/thunk.ts
lines: 33:33
id: 69b28b8421d108bd5878f06f27770bf51ed1a97853e4dcc8afb195650631dcf3
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/thunk.ts#L33

declaration:
export type ThunkEvent = EventTemplate | StampedEvent | OwnedEvent | TrustedEvent

summary:
A type alias representing different stages of an event in the thunking system. It can be one of: EventTemplate, StampedEvent, OwnedEvent, or TrustedEvent. This type is used to define the input event format for the thunking system, allowing events at various stages of preparation to be processed.

details:
This type alias serves as a union type that represents the possible states of an event as it moves through the event preparation pipeline. The progression typically follows:
1. EventTemplate - A basic event template
2. StampedEvent - An event that has been timestamped
3. OwnedEvent - An event that has been assigned ownership
4. TrustedEvent - A fully prepared event

The `prepEvent` function in the same file handles the transformation between these states, ensuring an event is properly prepared before publishing.

import/access examples:
import type { ThunkEvent } from '@welshman/app';
import type { ThunkEvent } from '@welshman/app/thunk';


=========================
workspace: packages/app
file: packages/app/src/thunk.ts
lines: 35:49
id: ebc6329095ca54ace63a7d71c5c4ab0e8171ce702afc9b46ca4cafd538f41e81
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/thunk.ts#L35

declaration:
prepEvent = (event: ThunkEvent) => {
  if (!isStampedEvent(event as StampedEvent)) {
    event = stamp(event)
  }

  if (!isOwnedEvent(event as OwnedEvent)) {
    event = own(event as StampedEvent, get(pubkey)!)
  }

  if (!isHashedEvent(event as HashedEvent)) {
    event = hash(event as OwnedEvent)
  }

  return event as TrustedEvent
}

summary:
Prepares an event by ensuring it has the necessary properties to be considered a trusted event. It takes a ThunkEvent (which can be an EventTemplate, StampedEvent, OwnedEvent, or TrustedEvent) and returns a TrustedEvent. The function applies stamping, ownership, and hashing operations if they haven't been applied already.

details:
The implementation follows a sequential transformation process:

1. First checks if the event is already stamped (has timestamp and other metadata). If not, it applies the stamp function.
2. Then checks if the event is owned (has a pubkey). If not, it applies the own function using the current user's public key.
3. Finally checks if the event is hashed (has an ID). If not, it applies the hash function.
4. Returns the fully processed event as a TrustedEvent.

The function uses type assertions to handle the progressive transformation of the event through different states, ensuring type safety at each step.

related: ThunkEvent

import/access examples:
import { prepEvent } from '@welshman/app';
import { prepEvent } from '@welshman/app/thunk';


=========================
workspace: packages/app
file: packages/app/src/thunk.ts
lines: 51:54
id: d3530faea2391891eae3a754861b0a0c9ec7c33c2f70fe0311a5b3d179914100
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/thunk.ts#L51

declaration:
export type ThunkOptions = Omit<PublishOptions, "event"> & {
  event: ThunkEvent
  delay?: number
}

summary:
ThunkOptions is a type that defines the configuration options for creating a thunk. It extends PublishOptions (omitting the 'event' property) and adds specific properties for thunk creation. It includes: event (ThunkEvent) - the event to be published, and an optional delay (number) - time in milliseconds to wait before publishing.

details:
This type alias combines publishing configuration with thunk-specific options. It uses TypeScript's Omit utility type to exclude the 'event' property from PublishOptions, then redefines it with the ThunkEvent type instead of whatever type PublishOptions originally used. This allows the thunk system to work with various event formats (EventTemplate, StampedEvent, OwnedEvent, or TrustedEvent) while maintaining compatibility with the publishing system.

related: ThunkEvent

import/access examples:
import type { ThunkOptions } from '@welshman/app';
import type { ThunkOptions } from '@welshman/app/thunk';


=========================
workspace: packages/app
file: packages/app/src/thunk.ts
lines: 56:203
id: 8dcf02baa81152fb4f45193b8e79ae234c4927183a8e19b1a5cbd3ff941de623
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/thunk.ts#L56

declaration:
export class Thunk{
  _subs: Subscriber<Thunk>[];
  event: TrustedEvent;
  result: Deferred<PublishStatusByRelay, PublishStatusByRelay>;
  status: PublishStatusByRelay;
  details: Record<string, string>;
  controller: AbortController;
  constructor(readonly options: ThunkOptions);
  _notify();
  _fail(message: string);
  _setPending(relay: string);
  _setTimeout(relay: string);
  _setAborted(relay: string);
  async publish();
  subscribe(subscriber: Subscriber<Thunk>);
}

summary:
The `Thunk` class represents a task for publishing an event to one or more relays. It handles event preparation, signing, publishing, and tracking the publish status for each relay. It provides a reactive interface through the `subscribe` method, notifying subscribers of status changes. The class manages the entire lifecycle of an event publication, including handling success, failure, timeout, and abort scenarios.

details:
Implementation details:
1. The class maintains internal state including the event to publish, publish status per relay, and details/error messages.
2. It uses an AbortController to allow cancellation of the publish operation.
3. The constructor takes ThunkOptions, prepares the event using prepEvent(), and initializes status tracking for each relay.
4. The publish() method:
   - Handles early abort checking
   - Ensures the event is properly signed (using a signer if needed)
   - Applies any configured delay
   - Calls the publish() function from @welshman/net with appropriate callbacks
   - Updates status and notifies subscribers on state changes
5. The class implements a Svelte-compatible subscribe pattern with _notify() to update subscribers when status changes.
6. Various helper methods (_setPending, _setTimeout, _setAborted, _fail) handle different status transitions.
7. The class integrates with the repository and tracker systems to persist events and track their distribution.

related: ThunkOptions

code:
export class Thunk {
  _subs: Subscriber<Thunk>[] = []

  event: TrustedEvent
  result = defer<PublishStatusByRelay>()
  status: PublishStatusByRelay = {}
  details: Record<string, string> = {}
  controller = new AbortController()

  constructor(readonly options: ThunkOptions) {
    this.event = prepEvent(options.event)

    for (const relay of options.relays) {
      this.status[relay] = PublishStatus.Sending
    }

    this.controller.signal.addEventListener("abort", () => {
      for (const relay of options.relays) {
        this._setAborted(relay)
      }
    })
  }

  _notify() {
    for (const subscriber of this._subs) {
      subscriber(this)
    }
  }

  _fail(message: string) {
    for (const relay of this.options.relays) {
      this.status[relay] = PublishStatus.Failure
      this.details[relay] = message
    }

    this._notify()
  }

  _setPending(relay: string) {
    this.options.onPending?.(relay)
    this.status[relay] = PublishStatus.Pending
    this._notify()
  }

  _setTimeout(relay: string) {
    this.options.onTimeout?.(relay)
    this.status[relay] = PublishStatus.Timeout
    this.details[relay] = "Publish timed out"
    this._notify()
  }

  _setAborted(relay: string) {
    this.options.onAborted?.(relay)
    this.status[relay] = PublishStatus.Aborted
    this.details[relay] = "Publish was aborted"
    this._notify()
  }

  async publish() {
    let event = this.event

    // Handle abort immediately if possible
    if (this.controller.signal.aborted) return

    // If we were given a wrapped event, make sure to publish the wrapper, not the rumor
    if (isUnwrappedEvent(event)) {
      event = event.wrap
    }

    // If the event was already signed, leave it alone. Otherwise, sign it now. This is to
    // decrease apparent latency in the UI that results from waiting for remote signers
    if (!isSignedEvent(event)) {
      const signer = getSigner(getSession(event.pubkey))

      if (!signer) {
        return this._fail(`No signer found for ${event.pubkey}`)
      }

      try {
        event = await signer.sign(event)
      } catch (e: any) {
        return this._fail(`Failed to sign event: ${String(e.error || e)}`)
      }
    }

    // We're guaranteed to have a signed event at this point
    const signedEvent = event as SignedEvent

    // Copy the signature over since we had deferred signing
    ifLet(repository.getEvent(signedEvent.id), savedEvent => {
      savedEvent.sig = signedEvent.sig
    })

    // Wait if the thunk is to be delayed
    if (this.options.delay) {
      await sleep(this.options.delay)
    }

    // Skip publishing if aborted
    if (this.controller.signal.aborted) {
      return
    }

    // Send it off
    this.result.resolve(
      await publish({
        ...this.options,
        event: signedEvent,
        onSuccess: (message: string, relay: string) => {
          tracker.track(signedEvent.id, relay)
          this.options.onSuccess?.(message, relay)
          this.status[relay] = PublishStatus.Success
          this.details[relay] = message
          this._notify()
        },
        onFailure: (message: string, relay: string) => {
          this.options.onFailure?.(message, relay)
          this.status[relay] = PublishStatus.Failure
          this.details[relay] = message
          this._notify()
        },
        onPending: (relay: string) => {
          this._setPending(relay)
        },
        onTimeout: (relay: string) => {
          this._setTimeout(relay)
        },
        onAborted: (relay: string) => {
          this._setAborted(relay)
        },
        onComplete: () => {
          this.options.onComplete?.()
          this._subs = []
        },
      }),
    )
  }

  subscribe(subscriber: Subscriber<Thunk>) {
    this._subs.push(subscriber)

    subscriber(this)

    return () => {
      this._subs = remove(subscriber, this._subs)
    }
  }
}

import/access examples:
import { Thunk } from '@welshman/app';
import { Thunk } from '@welshman/app/thunk';


=========================
workspace: packages/app
file: packages/app/src/thunk.ts
lines: 205:255
id: 79dececac9c28329f51a9d3a34d8437daa1f751adba704d59e5d036e61063c89
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/thunk.ts#L205

declaration:
export class MergedThunk{
  _subs: Subscriber<MergedThunk>[];
  status: PublishStatusByRelay;
  details: Record<string, string>;
  constructor(readonly thunks: Thunk[]);
  _notify();
  subscribe(subscriber: Subscriber<MergedThunk>);
}

summary:
The `MergedThunk` class represents a collection of individual `Thunk` instances, combining their statuses and details into a unified view. It allows tracking multiple publishing operations as a single entity, providing aggregated status information across all relays used by the contained thunks. The class implements the Svelte store contract with its `subscribe` method, allowing reactive updates when any of the contained thunks change state.

details:
Implementation details:
1. Maintains internal arrays of subscribers (`_subs`) and the thunks it's tracking.
2. Aggregates status and details from child thunks into its own `status` and `details` properties.
3. Sets up subscriptions to all contained thunks in the constructor, updating its aggregated state whenever any child thunk changes.
4. Uses a priority system for status aggregation - if multiple thunks have different statuses for the same relay, it prioritizes statuses in this order: Aborted, Failure, Timeout, Pending, Sending, Success.
5. Automatically cleans up subscriptions when all thunks are complete.
6. Implements the Svelte store contract with a `subscribe` method that returns an unsubscribe function.
7. Notifies all subscribers when the aggregated state changes.

related: Thunk

code:
export class MergedThunk {
  _subs: Subscriber<MergedThunk>[] = []

  status: PublishStatusByRelay = {}
  details: Record<string, string> = {}

  constructor(readonly thunks: Thunk[]) {
    const {Aborted, Failure, Timeout, Pending, Sending, Success} = PublishStatus
    const relays = new Set(thunks.flatMap(thunk => thunk.options.relays))

    for (const thunk of thunks) {
      thunk.subscribe($thunk => {
        this.status = {}
        this.details = {}

        for (const relay of relays) {
          for (const status of [Aborted, Failure, Timeout, Pending, Sending, Success]) {
            const thunk = thunks.find(t => t.status[relay] === status)

            if (thunk) {
              this.status[relay] = thunk.status[relay]!
              this.details[relay] = thunk.details[relay]!
            }
          }
        }

        this._notify()

        if (thunks.every(thunkIsComplete)) {
          this._subs = []
        }
      })
    }
  }

  _notify() {
    for (const subscriber of this._subs) {
      subscriber(this)
    }
  }

  subscribe(subscriber: Subscriber<MergedThunk>) {
    this._subs.push(subscriber)

    subscriber(this)

    return () => {
      this._subs = remove(subscriber, this._subs)
    }
  }
}

import/access examples:
import { MergedThunk } from '@welshman/app';
import { MergedThunk } from '@welshman/app/thunk';


=========================
workspace: packages/app
file: packages/app/src/thunk.ts
lines: 257:257
id: 62a88c74253e6573c40309b0ad6bb6e528843b29edc9779b6deb64389b90e3c2
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/thunk.ts#L257

declaration:
export type AbstractThunk = Thunk | MergedThunk

summary:
A type alias that represents either a `Thunk` or a `MergedThunk` instance. This type is used throughout the application to handle both individual event publishing operations and grouped operations uniformly.

details:
This type alias serves as a union type between the two main thunk classes in the system:
1. `Thunk` - Represents a single event publishing operation
2. `MergedThunk` - Represents multiple thunks grouped together

The `AbstractThunk` type enables polymorphic handling of both individual and grouped publishing operations, allowing functions like `getThunkUrlsWithStatus`, `thunkIsComplete`, and other utility functions to work with either type transparently.

related: Thunk,MergedThunk

import/access examples:
import type { AbstractThunk } from '@welshman/app';
import type { AbstractThunk } from '@welshman/app/thunk';


=========================
workspace: packages/app
file: packages/app/src/thunk.ts
lines: 259:259
id: 033ab7194760570bcb96850e38ae21d56b2cba5b99d6823db93d7248fadfdc44
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/thunk.ts#L259

declaration:
isThunk = (thunk: AbstractThunk): thunk is Thunk => thunk instanceof Thunk

summary:
A type guard function that checks if a given AbstractThunk is specifically a Thunk instance. Returns true if the provided thunk is an instance of the Thunk class, false otherwise. This function helps with type narrowing in TypeScript, allowing safe access to Thunk-specific properties and methods.

details:
The implementation is straightforward - it uses the JavaScript instanceof operator to check if the provided thunk parameter is an instance of the Thunk class. This is a common pattern for type guards in TypeScript that check for class instances.

related: Thunk,AbstractThunk

import/access examples:
import { isThunk } from '@welshman/app';
import { isThunk } from '@welshman/app/thunk';


=========================
workspace: packages/app
file: packages/app/src/thunk.ts
lines: 261:262
id: 8d622f2cad9f8afa490140a50b4dae105bfb552fa339644ee1cf720246cfd98a
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/thunk.ts#L261

declaration:
isMergedThunk = (thunk: AbstractThunk): thunk is MergedThunk =>
  thunk instanceof MergedThunk

summary:
A type guard function that checks if a given AbstractThunk is specifically a MergedThunk instance. Returns true if the thunk is a MergedThunk, false otherwise. This function is useful for safely narrowing the type of a thunk in TypeScript.

details:
The implementation is straightforward - it uses the JavaScript instanceof operator to check if the provided thunk parameter is an instance of the MergedThunk class. This is a common pattern for implementing type guards in TypeScript, allowing the compiler to narrow the type within conditional blocks where this function returns true.

related: MergedThunk,AbstractThunk

import/access examples:
import { isMergedThunk } from '@welshman/app';
import { isMergedThunk } from '@welshman/app/thunk';


=========================
workspace: packages/app
file: packages/app/src/thunk.ts
lines: 266:275
id: 951be2046d392842df65e2a5346a999ad7fd9b391fab255adfd7d2ac08a8b24a
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/thunk.ts#L266

declaration:
getThunkUrlsWithStatus = (
  statuses: PublishStatus | PublishStatus[],
  thunk: AbstractThunk,
) => {
  statuses = ensurePlural(statuses)

  return Object.entries(thunk.status)
    .filter(([_, status]) => statuses.includes(status))
    .map(nth(0))
}

summary:
The `getThunkUrlsWithStatus` function retrieves relay URLs from a thunk that have specific publish statuses. It accepts two parameters: `statuses` (a single PublishStatus or an array of them) and `thunk` (an AbstractThunk instance). It returns an array of relay URLs that match any of the specified statuses.

details:
The implementation works by:
1. Converting the `statuses` parameter to an array using the `ensurePlural` utility function
2. Getting all entries (key-value pairs) from the thunk's status object using `Object.entries(thunk.status)`
3. Filtering these entries to only include those where the status value is included in the provided statuses array
4. Mapping the filtered entries to extract just the relay URLs (the first element of each entry) using the `nth(0)` utility function

This function is part of a larger thunk management system for handling event publishing to relays.

related: AbstractThunk

import/access examples:
import { getThunkUrlsWithStatus } from '@welshman/app';
import { getThunkUrlsWithStatus } from '@welshman/app/thunk';


=========================
workspace: packages/app
file: packages/app/src/thunk.ts
lines: 277:281
id: 1d186fa1c1a98f6f20a34a5461d67bc53f5d08c58238fcc789181107dc64295d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/thunk.ts#L277

declaration:
getCompleteThunkUrls = (thunk: AbstractThunk) =>
  getThunkUrlsWithStatus(
    without([PublishStatus.Sending, PublishStatus.Pending], Object.values(PublishStatus)),
    thunk,
  )

summary:
A function that returns a list of relay URLs from a thunk where the publish status is considered 'complete'. Complete statuses are all possible statuses except 'Sending' and 'Pending'. This helps identify which relays have finished processing the event, regardless of success or failure.

details:
The implementation uses the `getThunkUrlsWithStatus` helper function to filter relay URLs based on their status. It creates a list of all possible publish statuses using `Object.values(PublishStatus)`, then removes 'Sending' and 'Pending' statuses using the `without` utility function. This effectively returns URLs for relays with statuses like Success, Failure, Timeout, or Aborted.

related: __function,getThunkUrlsWithStatus,AbstractThunk

import/access examples:
import { getCompleteThunkUrls } from '@welshman/app';
import { getCompleteThunkUrls } from '@welshman/app/thunk';


=========================
workspace: packages/app
file: packages/app/src/thunk.ts
lines: 283:284
id: 3e0282f0c7fc3d3c516f8fbf962bfbf6d7808c2385b3c8d2d0da7934cf7a9d6e
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/thunk.ts#L283

declaration:
getIncompleteThunkUrls = (thunk: AbstractThunk) =>
  getThunkUrlsWithStatus([PublishStatus.Sending, PublishStatus.Pending], thunk)

summary:
The `getIncompleteThunkUrls` function retrieves URLs from a thunk that are still in progress (either sending or pending). It takes an AbstractThunk (either a Thunk or MergedThunk) as input and returns an array of relay URLs that have not yet completed processing.

details:
This function is a simple utility that delegates to the `getThunkUrlsWithStatus` helper function, passing it an array of specific PublishStatus values ([PublishStatus.Sending, PublishStatus.Pending]) and the thunk object. It's used to identify which relays are still processing the event, which can be useful for UI feedback or determining if a thunk operation is still in progress.

related: __function,getThunkUrlsWithStatus,AbstractThunk

import/access examples:
import { getIncompleteThunkUrls } from '@welshman/app';
import { getIncompleteThunkUrls } from '@welshman/app/thunk';


=========================
workspace: packages/app
file: packages/app/src/thunk.ts
lines: 286:287
id: 5308847629fe2fe90bf252d02a82e98f5e29dee242e3745fcf49402fe9bf11c9
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/thunk.ts#L286

declaration:
getFailedThunkUrls = (thunk: AbstractThunk) =>
  getThunkUrlsWithStatus([PublishStatus.Failure, PublishStatus.Timeout], thunk)

summary:
A function that retrieves URLs of relays where a thunk has failed or timed out. It takes an AbstractThunk (either a Thunk or MergedThunk) as input and returns an array of relay URLs that have either Failure or Timeout status.

details:
The implementation delegates to the `getThunkUrlsWithStatus` helper function, passing an array containing two specific PublishStatus values: Failure and Timeout. This function is part of a group of utility functions that help inspect the status of thunks across different relays.

related: __function,getThunkUrlsWithStatus,AbstractThunk

import/access examples:
import { getFailedThunkUrls } from '@welshman/app';
import { getFailedThunkUrls } from '@welshman/app/thunk';


=========================
workspace: packages/app
file: packages/app/src/thunk.ts
lines: 291:292
id: 47f34117b1fba384d642c034ab6551f4412e6babe7fe8cf1ea355661097a843d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/thunk.ts#L291

declaration:
thunkHasStatus = (statuses: PublishStatus | PublishStatus[], thunk: AbstractThunk) =>
  getThunkUrlsWithStatus(statuses, thunk).length > 0

summary:
Checks if a thunk has any of the specified publish statuses. Takes a single status or an array of statuses to check against, and returns true if any relay in the thunk has any of those statuses.

details:
The implementation is straightforward - it delegates to the `getThunkUrlsWithStatus` function to get all relay URLs that have any of the specified statuses, then checks if the resulting array has any elements by comparing its length to 0.

related: __function,getThunkUrlsWithStatus,AbstractThunk

import/access examples:
import { thunkHasStatus } from '@welshman/app';
import { thunkHasStatus } from '@welshman/app/thunk';


=========================
workspace: packages/app
file: packages/app/src/thunk.ts
lines: 294:295
id: 7d89b63f34026eded76a89de3c73f13e1f94a8c4e4ee4c9610a5cb783584de33
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/thunk.ts#L294

declaration:
thunkIsComplete = (thunk: AbstractThunk) =>
  !thunkHasStatus([PublishStatus.Sending, PublishStatus.Pending], thunk)

summary:
The `thunkIsComplete` function checks if a thunk (either a Thunk or MergedThunk instance) has completed its publishing process. It returns a boolean value indicating whether the thunk has no pending or sending statuses across all relays.

details:
This function works by negating the result of `thunkHasStatus` function, checking specifically that the thunk doesn't have any relays with either `PublishStatus.Sending` or `PublishStatus.Pending` status. If none of the relays have these statuses, it means all publishing operations have reached a terminal state (success, failure, timeout, or aborted), and the thunk is considered complete.

related: __function,thunkHasStatus,AbstractThunk

import/access examples:
import { thunkIsComplete } from '@welshman/app';
import { thunkIsComplete } from '@welshman/app/thunk';


=========================
workspace: packages/app
file: packages/app/src/thunk.ts
lines: 299:309
id: 2184f6f76e68524cd0b2025eead4b42fc738e37c8742a6fba00eac170b576d90
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/thunk.ts#L299

declaration:
getThunkError = (thunk: Thunk) => {
  for (const [relay, status] of Object.entries(thunk.status)) {
    if (status === PublishStatus.Failure) {
      return thunk.details[relay]
    }
  }

  if (thunkIsComplete(thunk)) {
    return ""
  }
}

summary:
The `getThunkError` function retrieves the error message for a failed Thunk. It takes a Thunk object as a parameter and returns the first error message found in the Thunk's details for any relay with a Failure status. If the Thunk is complete but has no failures, it returns an empty string. If the Thunk is still in progress, it returns undefined.

details:
The implementation iterates through all entries in the Thunk's status object, checking each relay for a PublishStatus.Failure status. When it finds the first failure, it immediately returns the corresponding error message from the Thunk's details object for that relay.

If no failures are found but the Thunk is complete (determined by calling thunkIsComplete), it returns an empty string to indicate no errors occurred.

If the Thunk is still in progress and has no failures yet, the function implicitly returns undefined by not having a return statement for this case.

related: Thunk

import/access examples:
import { getThunkError } from '@welshman/app';
import { getThunkError } from '@welshman/app/thunk';


=========================
workspace: packages/app
file: packages/app/src/thunk.ts
lines: 313:322
id: 75e036134c61e5f7fe619fe5a36f68f767a2fe99516c3de9b41ec9a7c6c26cd8
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/thunk.ts#L313

declaration:
waitForThunkError = (thunk: Thunk) =>
  new Promise<string>(resolve => {
    thunk.subscribe($thunk => {
      const error = getThunkError($thunk)

      if (error !== undefined) {
        resolve(error)
      }
    })
  })

summary:
A function that returns a Promise which resolves with the first error message encountered by a Thunk. The function takes a Thunk instance as its parameter and returns a Promise<string> that resolves when an error is detected in the Thunk's status.

details:
The implementation subscribes to the provided Thunk's updates and checks for errors on each update by calling the getThunkError helper function. When an error is found (not undefined), it resolves the Promise with that error message. The subscription remains active until an error is found, at which point the Promise resolves.

This function is useful for error handling in asynchronous workflows where you need to wait for and respond to potential errors in Thunk publishing operations.

related: Thunk

import/access examples:
import { waitForThunkError } from '@welshman/app';
import { waitForThunkError } from '@welshman/app/thunk';


=========================
workspace: packages/app
file: packages/app/src/thunk.ts
lines: 324:331
id: dfc91d40443f18f54b58d0f1df63943055d845f826606b08467844989cdbb257
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/thunk.ts#L324

declaration:
waitForThunkCompletion = (thunk: Thunk) =>
  new Promise<void>(resolve => {
    thunk.subscribe($thunk => {
      if (thunkIsComplete($thunk)) {
        resolve()
      }
    })
  })

summary:
A function that returns a Promise which resolves when a Thunk has completed its publishing process. It takes a Thunk instance as its only parameter and resolves with void when the thunk's status is no longer in a pending or sending state.

details:
The implementation creates a new Promise and subscribes to the provided thunk's state changes. Inside the subscription callback, it checks if the thunk is complete by calling the thunkIsComplete helper function. When the thunk reaches a completed state (not sending or pending), the Promise is resolved. The subscription remains active until the thunk completes, at which point the Promise resolves.

This is a utility function that allows for awaiting the completion of a thunk's publishing process in async code, rather than using callbacks.

related: Thunk

import/access examples:
import { waitForThunkCompletion } from '@welshman/app';
import { waitForThunkCompletion } from '@welshman/app/thunk';


=========================
workspace: packages/app
file: packages/app/src/thunk.ts
lines: 335:335
id: 7cdd30fc30a3d8c4af4153019b2a643d8812ef67fa7857b821896ebac29aca8f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/thunk.ts#L335

declaration:
thunks = writable<Record<string, AbstractThunk>>({})

summary:
A writable Svelte store that maintains a record of active thunks (operations for publishing events to relays) indexed by their event IDs. The store holds a mapping from event IDs to either individual `Thunk` instances or merged thunks (`MergedThunk`), allowing the application to track and manage ongoing publish operations.

details:
This is a simple writable Svelte store initialized with an empty object. It serves as the central registry for all active thunks in the application. The store is updated when new thunks are published (via `publishThunk`) and when thunks are aborted (via `abortThunk`). The store allows components to subscribe to changes in the thunk collection, enabling reactive UI updates based on publish operation statuses.

related: writable

import/access examples:
import { thunks } from '@welshman/app';
import { thunks } from '@welshman/app/thunk';


=========================
workspace: packages/app
file: packages/app/src/thunk.ts
lines: 337:342
id: ba5dcc2057c8d310778bbe55570f3b92a515f06d7a63028c7062a12e9f4c015a
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/thunk.ts#L337

declaration:
thunkQueue = new TaskQueue<Thunk>({
  batchSize: 50,
  processItem: (thunk: Thunk) => {
    thunk.publish()
  },
})

summary:
A TaskQueue instance that manages the processing of Thunk objects for event publishing. It processes Thunks in batches of 50, calling the publish method on each Thunk when processed. This queue helps control the flow of event publishing operations to avoid overwhelming the system.

details:
The thunkQueue is configured with:
1. A batch size of 50, meaning it will process up to 50 Thunk objects at a time
2. A processItem function that simply calls the publish() method on each Thunk

This queue is used by the publishThunk function (line 359) which creates a new Thunk and then pushes it to this queue for processing. The queue implementation comes from the @welshman/lib library's TaskQueue class, which likely handles the batching logic and execution timing.

related: TaskQueue

import/access examples:
import { thunkQueue } from '@welshman/app';
import { thunkQueue } from '@welshman/app/thunk';


=========================
workspace: packages/app
file: packages/app/src/thunk.ts
lines: 346:347
id: 5843a1b62745d4699c054b9c83f267e87d809608ba8bd912c9335fd47543e235
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/thunk.ts#L346

declaration:
mergeThunks = (thunks: AbstractThunk[]) =>
  new MergedThunk(Array.from(flattenThunks(thunks)))

summary:
The `mergeThunks` function combines multiple `AbstractThunk` instances (which can be either `Thunk` or `MergedThunk` objects) into a single `MergedThunk` instance. This allows for tracking and managing the publish status of multiple thunks as a unified entity.

details:
The implementation is straightforward:
1. It takes an array of `AbstractThunk` objects as input
2. It uses the `flattenThunks` generator function to extract all individual `Thunk` instances from the input (recursively handling any nested `MergedThunk` objects)
3. It converts the iterable result from `flattenThunks` into an array using `Array.from()`
4. It creates and returns a new `MergedThunk` instance with the flattened array of thunks

related: __constructor,MergedThunk,AbstractThunk

import/access examples:
import { mergeThunks } from '@welshman/app';
import { mergeThunks } from '@welshman/app/thunk';


=========================
workspace: packages/app
file: packages/app/src/thunk.ts
lines: 349:357
id: b48174543396073fda8d6821d063326cebfee23a94dcb3070aa4dafb56e0ad0a
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/thunk.ts#L349

declaration:
export function* flattenThunks(thunks: AbstractThunk[]): Iterable<Thunk>

summary:
A generator function that flattens a nested structure of AbstractThunk objects (which can be either Thunk or MergedThunk instances) into a flat iterable of Thunk objects. It takes an array of AbstractThunk objects and yields individual Thunk instances, recursively processing any MergedThunk objects it encounters.

details:
The implementation uses a generator function with a yield* expression to recursively flatten the thunk structure:

1. It iterates through each thunk in the input array
2. For each thunk, it checks if it's a MergedThunk using the isMergedThunk type guard
3. If it is a MergedThunk, it recursively calls itself with the thunk.thunks array and yields all results using yield*
4. If it's a regular Thunk, it simply yields that thunk directly

This recursive approach ensures that all nested MergedThunk instances are properly flattened, resulting in a flat sequence of only Thunk objects.

related: AbstractThunk,Thunk

code:
export function* flattenThunks(thunks: AbstractThunk[]): Iterable<Thunk> {
  for (const thunk of thunks) {
    if (isMergedThunk(thunk)) {
      yield* flattenThunks(thunk.thunks)
    } else {
      yield thunk
    }
  }
}

import/access examples:
import { flattenThunks } from '@welshman/app';
import { flattenThunks } from '@welshman/app/thunk';


=========================
workspace: packages/app
file: packages/app/src/thunk.ts
lines: 359:369
id: 42ba117bd6c0930cea28452a8755ce3974d516bdd0f7369e4ac0bb9e37e59047
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/thunk.ts#L359

declaration:
publishThunk = (options: ThunkOptions) => {
  const thunk = new Thunk(options)

  thunkQueue.push(thunk)

  repository.publish(thunk.event)

  thunks.update(assoc(thunk.event.id, thunk))

  return thunk
}

summary:
Creates and publishes a new Thunk with the given options. This function handles the entire process of creating a Thunk instance, adding it to the queue for processing, publishing the event to the repository, and updating the global thunks store. Returns the created Thunk instance.

details:
The implementation follows these steps:
1. Creates a new Thunk instance with the provided options
2. Adds the thunk to the thunkQueue for processing (which will eventually call thunk.publish())
3. Publishes the thunk's event to the repository
4. Updates the global thunks store by adding the new thunk, indexed by the event ID
5. Returns the created thunk instance

This function serves as the main entry point for creating and publishing events through the thunk system, abstracting away the details of queue management and state updates.

related: ThunkOptions,Thunk

import/access examples:
import { publishThunk } from '@welshman/app';
import { publishThunk } from '@welshman/app/thunk';


=========================
workspace: packages/app
file: packages/app/src/thunk.ts
lines: 371:377
id: 9a220d949b9b59a7fc3e8bd140b186b79cc54b2179872202f2989b05b822689d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/thunk.ts#L371

declaration:
abortThunk = (thunk: AbstractThunk) => {
  for (const child of flattenThunks([thunk])) {
    child.controller.abort()
    thunks.update(dissoc(child.event.id))
    repository.removeEvent(child.event.id)
  }
}

summary:
Aborts a thunk or merged thunk, canceling any pending publish operations. Takes an AbstractThunk (either Thunk or MergedThunk) as input and aborts all contained thunks, removing them from the thunk registry and event repository.

details:
The implementation:
1. Takes an AbstractThunk parameter and iterates through all contained thunks using flattenThunks (which handles both single Thunk instances and MergedThunk collections)
2. For each child thunk:
   - Calls abort() on the thunk's AbortController to cancel any in-progress operations
   - Updates the global thunks store by removing the thunk using its event ID
   - Removes the associated event from the repository

The function effectively cleans up all resources associated with the thunk(s) and ensures any pending operations are canceled.

related: AbstractThunk

import/access examples:
import { abortThunk } from '@welshman/app';
import { abortThunk } from '@welshman/app/thunk';


=========================
workspace: packages/app
file: packages/app/src/thunk.ts
lines: 379:382
id: fe1c06e68c3d2e0054e5810b8314a13e55b6a5e8b02f6f087992625cd7a6a80d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/thunk.ts#L379

declaration:
retryThunk = (thunk: AbstractThunk) =>
  isMergedThunk(thunk)
    ? mergeThunks(thunk.thunks.map(t => publishThunk(t.options)))
    : publishThunk(thunk.options)

summary:
The `retryThunk` function allows retrying a failed or aborted publication attempt. It takes an `AbstractThunk` (either a `Thunk` or `MergedThunk`) and creates a new publication attempt with the same options. For a `MergedThunk`, it retries each individual thunk and merges the results. For a regular `Thunk`, it simply creates a new publication with the same options.

details:
The implementation is a simple arrow function that:
1. Checks if the input is a `MergedThunk` using the `isMergedThunk` type guard
2. If it is a merged thunk, it maps over each child thunk, creates a new publication for each using `publishThunk` with the original options, and then merges these new thunks with `mergeThunks`
3. If it's a regular `Thunk`, it simply calls `publishThunk` with the original options

This function effectively creates fresh publication attempts while preserving the original configuration, allowing users to retry failed publications without having to recreate the publication parameters.

related: __function,mergeThunks,__function,publishThunk,AbstractThunk,Thunk,MergedThunk

import/access examples:
import { retryThunk } from '@welshman/app';
import { retryThunk } from '@welshman/app/thunk';


=========================
workspace: packages/app
file: packages/app/__tests__/thunk.test.ts
lines: 18:18
id: 1c671d9bfce47c671c15593baea9d4c684f06eac2cd73f572cc2cbac3b4e0e1c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/__tests__/thunk.test.ts#L18

declaration:
secret = makeSecret()

summary:
A variable that holds a cryptographic secret key generated using the makeSecret function from the @welshman/signer module. This secret is used for testing purposes in the thunk module tests.

details:
This variable is initialized at the top level of the test file and serves as a fixture for the test suite. It's used to create a session for testing thunk functionality and is passed to makeNip01Session in the beforeEach setup. The secret is used indirectly to sign events that are published through thunks in the tests.

related: makeSecret

=========================
workspace: packages/app
file: packages/app/__tests__/thunk.test.ts
lines: 20:20
id: 343dfba4ffe37b319eb2bd9218230ec99cda1bc52e889b919f819852b95db483
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/__tests__/thunk.test.ts#L20

declaration:
pubkey = getPubkey(secret)

summary:
A variable that stores the public key derived from the secret key using the getPubkey function. It represents the user's public key in the Nostr protocol context.

details:
This variable is initialized by calling the getPubkey function with the previously defined secret variable. It's used throughout the test file to identify the user in test scenarios, particularly when creating mock events and sessions. The pubkey is also used when dropping sessions in the afterEach cleanup function.

related: getPubkey

=========================
workspace: packages/app
file: packages/app/__tests__/thunk.test.ts
lines: 22:25
id: 62679cb729dc7e190aa32c536fe1bf482a7909245f944c9470e346e20e33781f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/__tests__/thunk.test.ts#L22

declaration:
mockRequest = {
  event: prepEvent({...makeEvent(NOTE), pubkey}),
  relays: [LOCAL_RELAY_URL],
}

summary:
A constant object that represents a mock request for testing purposes. It contains an event prepared with `prepEvent` function and a list of relay URLs. The event is created using `makeEvent(NOTE)` with the test pubkey.

details:
This constant is used throughout the test suite as a standard mock request object for testing thunk-related functionality. It contains:
1. An event field created by preparing a NOTE type event with the test pubkey
2. A relays array containing only the LOCAL_RELAY_URL

The mockRequest is used to instantiate Thunk objects in various test cases to verify their behavior without making actual network requests.

=========================
workspace: packages/app
file: packages/app/src/blossom.ts
lines: 7:11
id: 9fe92e6a4ac1b9069a1f3aadfce6a57a2f0400b8f33a94130728d2e2ff0abf2d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/blossom.ts#L7

declaration:
blossomServers = deriveEventsMapped<PublishedList>(repository, {
  filters: [{kinds: [BLOSSOM_SERVERS]}],
  itemToEvent: item => item.event,
  eventToItem: (event: TrustedEvent) => readList(asDecryptedEvent(event)),
})

summary:
A derived store that maps Nostr events of kind BLOSSOM_SERVERS from the repository into PublishedList objects. It filters events by the BLOSSOM_SERVERS kind, extracts the event from each item, and converts trusted events into PublishedList objects by decrypting and reading them as lists.

details:
This variable uses the deriveEventsMapped function from @welshman/store to create a derived store that:
1. Observes the main repository for events
2. Filters for only events with kind BLOSSOM_SERVERS
3. Provides mapping functions to convert between the store's internal representation and the PublishedList type
4. Uses asDecryptedEvent to handle encrypted content and readList to parse the event data into a structured list format

The implementation leverages the repository as the source of truth and transforms the raw events into a more usable data structure for the application.

related: deriveEventsMapped

import/access examples:
import { blossomServers } from '@welshman/app';
import { blossomServers } from '@welshman/app/blossom';


=========================
workspace: packages/app
file: packages/app/src/blossom.ts
lines: 13:22
id: c9801ac7ad3cc447262641b2087a7eca268888e1ba2c31740bba302f636ae413
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/blossom.ts#L13

declaration:
{
  indexStore: blossomServersByPubkey,
  deriveItem: deriveBlossomServers,
  loadItem: loadBlossomServers,
} = collection({
  name: "blossomServers",
  store: blossomServers,
  getKey: blossomServers => blossomServers.event.pubkey,
  load: makeOutboxLoader(BLOSSOM_SERVERS),
})

summary:
An object destructuring assignment that exports three utilities for working with blossom servers: `blossomServersByPubkey` (an index store), `deriveBlossomServers` (a function to derive blossom server data), and `loadBlossomServers` (a function to load blossom server data). These utilities are created using the `collection` function with configuration for blossom servers.

details:
This code creates a collection of utilities for managing blossom servers by calling the `collection` function with specific configuration:
1. It names the collection "blossomServers"
2. It uses the `blossomServers` store (defined earlier in the file) as the data source
3. It defines a key extraction function that gets the pubkey from a blossom server event
4. It configures loading using `makeOutboxLoader` with the `BLOSSOM_SERVERS` constant

The resulting destructured object provides three main utilities:
- An index store for looking up blossom servers by pubkey
- A derive function to access blossom server data
- A load function to fetch blossom server data

import/access examples:
import { blossomServersByPubkey } from '@welshman/app';
import { blossomServersByPubkey } from '@welshman/app/blossom';


=========================
workspace: packages/app
file: packages/app/src/blossom.ts
lines: 13:22
id: c9801ac7ad3cc447262641b2087a7eca268888e1ba2c31740bba302f636ae413
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/blossom.ts#L13

declaration:
{
  indexStore: blossomServersByPubkey,
  deriveItem: deriveBlossomServers,
  loadItem: loadBlossomServers,
} = collection({
  name: "blossomServers",
  store: blossomServers,
  getKey: blossomServers => blossomServers.event.pubkey,
  load: makeOutboxLoader(BLOSSOM_SERVERS),
})

summary:
An object destructuring assignment that exports three utilities for working with blossom servers: `blossomServersByPubkey` (an index store), `deriveBlossomServers` (a function to derive blossom server data), and `loadBlossomServers` (a function to load blossom server data). These utilities are created using the `collection` function with configuration for blossom servers.

details:
This code creates a collection of utilities for managing blossom servers by calling the `collection` function with specific configuration:
1. It names the collection "blossomServers"
2. It uses the `blossomServers` store (defined earlier in the file) as the data source
3. It defines a key extraction function that gets the pubkey from a blossom server event
4. It configures loading using `makeOutboxLoader` with the `BLOSSOM_SERVERS` constant

The resulting destructured object provides three main utilities:
- An index store for looking up blossom servers by pubkey
- A derive function to access blossom server data
- A load function to fetch blossom server data

import/access examples:
import { blossomServersByPubkey } from '@welshman/app';
import { blossomServersByPubkey } from '@welshman/app/blossom';


=========================
workspace: packages/app
file: packages/app/src/blossom.ts
lines: 13:22
id: c9801ac7ad3cc447262641b2087a7eca268888e1ba2c31740bba302f636ae413
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/blossom.ts#L13

declaration:
{
  indexStore: blossomServersByPubkey,
  deriveItem: deriveBlossomServers,
  loadItem: loadBlossomServers,
} = collection({
  name: "blossomServers",
  store: blossomServers,
  getKey: blossomServers => blossomServers.event.pubkey,
  load: makeOutboxLoader(BLOSSOM_SERVERS),
})

summary:
An object destructuring assignment that exports three utilities for working with blossom servers: `blossomServersByPubkey` (an index store), `deriveBlossomServers` (a function to derive blossom server data), and `loadBlossomServers` (a function to load blossom server data). These utilities are created using the `collection` function with configuration for blossom servers.

details:
This code creates a collection of utilities for managing blossom servers by calling the `collection` function with specific configuration:
1. It names the collection "blossomServers"
2. It uses the `blossomServers` store (defined earlier in the file) as the data source
3. It defines a key extraction function that gets the pubkey from a blossom server event
4. It configures loading using `makeOutboxLoader` with the `BLOSSOM_SERVERS` constant

The resulting destructured object provides three main utilities:
- An index store for looking up blossom servers by pubkey
- A derive function to access blossom server data
- A load function to fetch blossom server data

import/access examples:
import { blossomServersByPubkey } from '@welshman/app';
import { blossomServersByPubkey } from '@welshman/app/blossom';


=========================
workspace: packages/app
file: packages/app/src/follows.ts
lines: 7:11
id: d7aee7dbc818c5cfb1dd7519701b2e6c5377464f7962858cc9f9f634cb7acf96
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/follows.ts#L7

declaration:
follows = deriveEventsMapped<PublishedList>(repository, {
  filters: [{kinds: [FOLLOWS]}],
  itemToEvent: item => item.event,
  eventToItem: (event: TrustedEvent) => readList(asDecryptedEvent(event)),
})

summary:
A derived store that processes and manages follow events from a repository. It filters events of kind FOLLOWS, converts them to PublishedList objects, and provides access to the decrypted content of these events.

details:
This variable is created using the deriveEventsMapped function, which creates a derived store from the repository. It:
1. Filters events to only include those with kind FOLLOWS
2. Defines transformation functions:
   - itemToEvent: Extracts the event from an item
   - eventToItem: Converts a TrustedEvent to a PublishedList by reading the list from the decrypted event

The implementation leverages utility functions from @welshman/util (asDecryptedEvent, readList) to handle the decryption and parsing of the event data.

related: deriveEventsMapped

import/access examples:
import { follows } from '@welshman/app';
import { follows } from '@welshman/app/follows';


=========================
workspace: packages/app
file: packages/app/src/follows.ts
lines: 13:22
id: ace91ac01d7e14b9f230c958042f59e60ca9572cd3c8a3c5a651e19048440260
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/follows.ts#L13

declaration:
{
  indexStore: followsByPubkey,
  deriveItem: deriveFollows,
  loadItem: loadFollows,
} = collection({
  name: "follows",
  store: follows,
  getKey: follows => follows.event.pubkey,
  load: makeOutboxLoader(FOLLOWS),
})

summary:
An object destructuring assignment that extracts three components from a collection configuration: `followsByPubkey` (an index store for follows data), `deriveFollows` (a function to derive follows for a specific pubkey), and `loadFollows` (a function to load follows data). These components are created by calling the `collection` function with configuration for managing follows data.

details:
This code creates a collection of follow relationships indexed by public keys. The implementation:

1. Uses the `collection` function to create a structured access pattern for the follows data
2. Configures the collection with:
   - A name "follows" for identification
   - The `follows` store (defined earlier) as the data source
   - A key extraction function that uses the event's pubkey as the index key
   - A load function created by `makeOutboxLoader` specifically for FOLLOWS kind events

The destructured components provide different ways to access the follows data:
- `followsByPubkey`: A store that indexes follows by public key
- `deriveFollows`: A function to derive follows for a specific pubkey
- `loadFollows`: A function to load follows data from relays

import/access examples:
import { followsByPubkey } from '@welshman/app';
import { followsByPubkey } from '@welshman/app/follows';


=========================
workspace: packages/app
file: packages/app/src/follows.ts
lines: 13:22
id: ace91ac01d7e14b9f230c958042f59e60ca9572cd3c8a3c5a651e19048440260
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/follows.ts#L13

declaration:
{
  indexStore: followsByPubkey,
  deriveItem: deriveFollows,
  loadItem: loadFollows,
} = collection({
  name: "follows",
  store: follows,
  getKey: follows => follows.event.pubkey,
  load: makeOutboxLoader(FOLLOWS),
})

summary:
An object destructuring assignment that extracts three components from a collection configuration: `followsByPubkey` (an index store for follows data), `deriveFollows` (a function to derive follows for a specific pubkey), and `loadFollows` (a function to load follows data). These components are created by calling the `collection` function with configuration for managing follows data.

details:
This code creates a collection of follow relationships indexed by public keys. The implementation:

1. Uses the `collection` function to create a structured access pattern for the follows data
2. Configures the collection with:
   - A name "follows" for identification
   - The `follows` store (defined earlier) as the data source
   - A key extraction function that uses the event's pubkey as the index key
   - A load function created by `makeOutboxLoader` specifically for FOLLOWS kind events

The destructured components provide different ways to access the follows data:
- `followsByPubkey`: A store that indexes follows by public key
- `deriveFollows`: A function to derive follows for a specific pubkey
- `loadFollows`: A function to load follows data from relays

import/access examples:
import { followsByPubkey } from '@welshman/app';
import { followsByPubkey } from '@welshman/app/follows';


=========================
workspace: packages/app
file: packages/app/src/follows.ts
lines: 13:22
id: ace91ac01d7e14b9f230c958042f59e60ca9572cd3c8a3c5a651e19048440260
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/follows.ts#L13

declaration:
{
  indexStore: followsByPubkey,
  deriveItem: deriveFollows,
  loadItem: loadFollows,
} = collection({
  name: "follows",
  store: follows,
  getKey: follows => follows.event.pubkey,
  load: makeOutboxLoader(FOLLOWS),
})

summary:
An object destructuring assignment that extracts three components from a collection configuration: `followsByPubkey` (an index store for follows data), `deriveFollows` (a function to derive follows for a specific pubkey), and `loadFollows` (a function to load follows data). These components are created by calling the `collection` function with configuration for managing follows data.

details:
This code creates a collection of follow relationships indexed by public keys. The implementation:

1. Uses the `collection` function to create a structured access pattern for the follows data
2. Configures the collection with:
   - A name "follows" for identification
   - The `follows` store (defined earlier) as the data source
   - A key extraction function that uses the event's pubkey as the index key
   - A load function created by `makeOutboxLoader` specifically for FOLLOWS kind events

The destructured components provide different ways to access the follows data:
- `followsByPubkey`: A store that indexes follows by public key
- `deriveFollows`: A function to derive follows for a specific pubkey
- `loadFollows`: A function to load follows data from relays

import/access examples:
import { followsByPubkey } from '@welshman/app';
import { followsByPubkey } from '@welshman/app/follows';


=========================
workspace: packages/app
file: packages/app/src/pins.ts
lines: 7:11
id: 7ac318b850c16bfa2cfb4af54c5645d1cfc398f2672ea1772413efe169bedc36
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/pins.ts#L7

declaration:
pins = deriveEventsMapped<PublishedList>(repository, {
  filters: [{kinds: [PINS]}],
  itemToEvent: item => item.event,
  eventToItem: (event: TrustedEvent) => readList(asDecryptedEvent(event)),
})

summary:
A derived store that manages pin events from the repository. It filters events of kind PINS and transforms them into PublishedList objects. This store allows tracking and accessing pinned content across the application.

details:
This variable is created using the deriveEventsMapped function, which creates a derived store from the repository. It:
1. Filters for events with kind PINS only
2. Transforms between event and item representations:
   - itemToEvent extracts the event property from items
   - eventToItem converts TrustedEvents to PublishedList objects by first decrypting the event (asDecryptedEvent) and then parsing it as a list (readList)

This provides a specialized store focused only on pin events with appropriate transformations for working with them as structured data.

related: deriveEventsMapped

import/access examples:
import { pins } from '@welshman/app';
import { pins } from '@welshman/app/pins';


=========================
workspace: packages/app
file: packages/app/src/pins.ts
lines: 13:22
id: b0cfc511a1b0a8bd1133b4c68f3822471e149a5bdf516235eee9688ad24dc1f4
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/pins.ts#L13

declaration:
{
  indexStore: pinsByPubkey,
  deriveItem: derivePins,
  loadItem: loadPins,
} = collection({
  name: "pins",
  store: pins,
  getKey: pins => pins.event.pubkey,
  load: makeOutboxLoader(PINS),
})

summary:
An object destructuring assignment that exports three utilities for working with pin collections: `pinsByPubkey` (an index store), `derivePins` (a function to derive pins for a specific pubkey), and `loadPins` (a function to load pins for a specific pubkey). These utilities are created by calling the `collection` function with configuration for pin management.

details:
This code creates a collection of pin-related utilities by calling the `collection` function with the following configuration:
1. `name`: "pins" - identifies this collection
2. `store`: pins - uses the pins store defined earlier in the file
3. `getKey`: A function that extracts the pubkey from a pin event
4. `load`: Uses the `makeOutboxLoader` function with the PINS constant to create a loader function

The returned object is destructured to expose three main utilities:
- `pinsByPubkey`: An index store that organizes pins by public key
- `derivePins`: A function to derive pins for a specific pubkey
- `loadPins`: A function to load pins for a specific pubkey

This implementation leverages the collection pattern to provide a consistent interface for working with pin data.

import/access examples:
import { pinsByPubkey } from '@welshman/app';
import { pinsByPubkey } from '@welshman/app/pins';


=========================
workspace: packages/app
file: packages/app/src/pins.ts
lines: 13:22
id: b0cfc511a1b0a8bd1133b4c68f3822471e149a5bdf516235eee9688ad24dc1f4
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/pins.ts#L13

declaration:
{
  indexStore: pinsByPubkey,
  deriveItem: derivePins,
  loadItem: loadPins,
} = collection({
  name: "pins",
  store: pins,
  getKey: pins => pins.event.pubkey,
  load: makeOutboxLoader(PINS),
})

summary:
An object destructuring assignment that exports three utilities for working with pin collections: `pinsByPubkey` (an index store), `derivePins` (a function to derive pins for a specific pubkey), and `loadPins` (a function to load pins for a specific pubkey). These utilities are created by calling the `collection` function with configuration for pin management.

details:
This code creates a collection of pin-related utilities by calling the `collection` function with the following configuration:
1. `name`: "pins" - identifies this collection
2. `store`: pins - uses the pins store defined earlier in the file
3. `getKey`: A function that extracts the pubkey from a pin event
4. `load`: Uses the `makeOutboxLoader` function with the PINS constant to create a loader function

The returned object is destructured to expose three main utilities:
- `pinsByPubkey`: An index store that organizes pins by public key
- `derivePins`: A function to derive pins for a specific pubkey
- `loadPins`: A function to load pins for a specific pubkey

This implementation leverages the collection pattern to provide a consistent interface for working with pin data.

import/access examples:
import { pinsByPubkey } from '@welshman/app';
import { pinsByPubkey } from '@welshman/app/pins';


=========================
workspace: packages/app
file: packages/app/src/pins.ts
lines: 13:22
id: b0cfc511a1b0a8bd1133b4c68f3822471e149a5bdf516235eee9688ad24dc1f4
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/pins.ts#L13

declaration:
{
  indexStore: pinsByPubkey,
  deriveItem: derivePins,
  loadItem: loadPins,
} = collection({
  name: "pins",
  store: pins,
  getKey: pins => pins.event.pubkey,
  load: makeOutboxLoader(PINS),
})

summary:
An object destructuring assignment that exports three utilities for working with pin collections: `pinsByPubkey` (an index store), `derivePins` (a function to derive pins for a specific pubkey), and `loadPins` (a function to load pins for a specific pubkey). These utilities are created by calling the `collection` function with configuration for pin management.

details:
This code creates a collection of pin-related utilities by calling the `collection` function with the following configuration:
1. `name`: "pins" - identifies this collection
2. `store`: pins - uses the pins store defined earlier in the file
3. `getKey`: A function that extracts the pubkey from a pin event
4. `load`: Uses the `makeOutboxLoader` function with the PINS constant to create a loader function

The returned object is destructured to expose three main utilities:
- `pinsByPubkey`: An index store that organizes pins by public key
- `derivePins`: A function to derive pins for a specific pubkey
- `loadPins`: A function to load pins for a specific pubkey

This implementation leverages the collection pattern to provide a consistent interface for working with pin data.

import/access examples:
import { pinsByPubkey } from '@welshman/app';
import { pinsByPubkey } from '@welshman/app/pins';


=========================
workspace: packages/app
file: packages/app/src/plaintext.ts
lines: 8:8
id: 027412e342e671e97429f53c49dc9f3dfd50c786d48374691c29501bcf728a39
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/plaintext.ts#L8

declaration:
plaintext = withGetter(writable<Record<string, string>>({}))

summary:
A Svelte store that holds plaintext content for trusted events, indexed by event ID. It's enhanced with a getter method using `withGetter` to allow direct access to the store's value without subscribing.

details:
This variable is implemented as a Svelte writable store that's enhanced with the `withGetter` utility from `@welshman/store`. The store contains a record mapping event IDs to their corresponding plaintext content. The store is initialized as an empty object and will be populated with decrypted content as events are processed through the `ensurePlaintext` function.

related: withGetter

import/access examples:
import { plaintext } from '@welshman/app';
import { plaintext } from '@welshman/app/plaintext';


=========================
workspace: packages/app
file: packages/app/src/plaintext.ts
lines: 10:10
id: 3d169881dc53357915cf6ab1f25c3ea156d91a6d495500ef0b0eff63f9632fa6
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/plaintext.ts#L10

declaration:
getPlaintext = (e: TrustedEvent) => plaintext.get()[e.id]

summary:
A function that retrieves the plaintext content for a given trusted event. It takes a TrustedEvent object as input and returns the plaintext string associated with the event's ID from the plaintext store.

details:
This function is a simple accessor that:
1. Takes a TrustedEvent parameter 'e'
2. Accesses the plaintext store using the get() method
3. Returns the value associated with the event's ID (e.id) from the store

The function relies on the plaintext store which is defined elsewhere in the file as a writable Svelte store enhanced with a getter method.

related: plaintext

import/access examples:
import { getPlaintext } from '@welshman/app';
import { getPlaintext } from '@welshman/app/plaintext';


=========================
workspace: packages/app
file: packages/app/src/plaintext.ts
lines: 12:13
id: 1e02273c1a1d1398000540e519ee8782c68bce4e2492d75cc2e1a09e9f69ab29
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/plaintext.ts#L12

declaration:
setPlaintext = (e: TrustedEvent, content: string) =>
  plaintext.update(assoc(e.id, content))

summary:
Updates the plaintext content for a given trusted event. Takes a TrustedEvent object and a string content as parameters, and associates the event's ID with the provided content in the plaintext store.

details:
This function updates the plaintext store by using the store's update method combined with the 'assoc' utility function. It creates an association between the event's ID (e.id) and the provided content string in the plaintext store. The implementation is a simple arrow function that leverages the Svelte store update pattern.

related: plaintext

import/access examples:
import { setPlaintext } from '@welshman/app';
import { setPlaintext } from '@welshman/app/plaintext';


=========================
workspace: packages/app
file: packages/app/src/plaintext.ts
lines: 15:41
id: 239233f0fa3f353bce0f7328f73f537d965cc07a206bb25f02e1ab159af74db4
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/plaintext.ts#L15

declaration:
ensurePlaintext = async (e: TrustedEvent) => {
  if (e.content && !getPlaintext(e)) {
    const $session = getSession(e.pubkey)

    if (!$session) return

    const $signer = getSigner($session)

    if (!$signer) return

    let result

    try {
      result = await decrypt($signer, e.pubkey, e.content)
    } catch (e: any) {
      if (!String(e).match(/invalid base64/)) {
        throw e
      }
    }

    if (result) {
      setPlaintext(e, result)
    }
  }

  return getPlaintext(e)
}

summary:
Asynchronously ensures that plaintext content is available for a given trusted event. If the plaintext is not already available and the event has encrypted content, it attempts to decrypt the content using the appropriate session and signer. Returns the plaintext content if available, otherwise undefined.

details:
The function works as follows:
1. Checks if the event has content and if plaintext is not already available for this event
2. If decryption is needed, retrieves the session associated with the event's public key
3. Exits early if no session is found
4. Gets the signer from the session
5. Exits early if no signer is found
6. Attempts to decrypt the content using the signer, the event's public key, and the encrypted content
7. Handles decryption errors, specifically ignoring 'invalid base64' errors but re-throwing other errors
8. If decryption is successful, stores the plaintext using setPlaintext
9. Finally returns the plaintext for the event (which may be undefined if decryption failed or wasn't needed)

import/access examples:
import { ensurePlaintext } from '@welshman/app';
import { ensurePlaintext } from '@welshman/app/plaintext';


=========================
workspace: packages/app
file: packages/app/src/mutes.ts
lines: 8:17
id: 71f1f154b0b1821f5b3f052a66989e92a512c9b68a28d6c6509a30b8cb5c0275
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/mutes.ts#L8

declaration:
mutes = deriveEventsMapped<PublishedList>(repository, {
  filters: [{kinds: [MUTES]}],
  itemToEvent: item => item.event,
  eventToItem: async (event: TrustedEvent) =>
    readList(
      asDecryptedEvent(event, {
        content: await ensurePlaintext(event),
      }),
    ),
})

summary:
A derived store that processes mute list events from the repository. It filters for events of kind MUTES, transforms them into PublishedList objects by decrypting their content and parsing them as lists.

details:
This variable uses deriveEventsMapped to create a derived store that:
1. Filters repository events for those with kind MUTES
2. Transforms events by:
   - Using ensurePlaintext to get or decrypt the event content
   - Using asDecryptedEvent to create a decrypted event object
   - Using readList to parse the decrypted content into a PublishedList

The implementation handles the transformation between raw events and structured mute lists, ensuring proper decryption of content when needed.

related: deriveEventsMapped

import/access examples:
import { mutes } from '@welshman/app';
import { mutes } from '@welshman/app/mutes';


=========================
workspace: packages/app
file: packages/app/src/mutes.ts
lines: 19:28
id: e46563ace662fd2434fcd55741bd223d0377170694f102061de482ee17fc3cbc
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/mutes.ts#L19

declaration:
{
  indexStore: mutesByPubkey,
  deriveItem: deriveMutes,
  loadItem: loadMutes,
} = collection({
  name: "mutes",
  store: mutes,
  getKey: mute => mute.event.pubkey,
  load: makeOutboxLoader(MUTES),
})

summary:
An object destructuring assignment that extracts and exports three components from a collection of mutes: `mutesByPubkey` (an index store), `deriveMutes` (a function to derive mute items), and `loadMutes` (a function to load mute items). The collection is configured with a name, store, key extraction function, and a load function specific to mute events.

details:
This code creates a collection of mute events with the following implementation details:
1. It uses the `collection` function from '@welshman/store' to create an organized collection of mute data
2. The collection is configured with:
   - name: "mutes" for identification
   - store: uses the `mutes` store defined earlier in the file
   - getKey: extracts the pubkey from a mute event to use as the collection key
   - load: uses a specialized outbox loader created with `makeOutboxLoader(MUTES)` to fetch mute events
3. The destructured exports provide different ways to interact with the mute collection:
   - mutesByPubkey: an indexed store of mutes organized by public key
   - deriveMutes: function to derive mute items from the store
   - loadMutes: function to load mute items from external sources

import/access examples:
import { mutesByPubkey } from '@welshman/app';
import { mutesByPubkey } from '@welshman/app/mutes';


=========================
workspace: packages/app
file: packages/app/src/mutes.ts
lines: 19:28
id: e46563ace662fd2434fcd55741bd223d0377170694f102061de482ee17fc3cbc
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/mutes.ts#L19

declaration:
{
  indexStore: mutesByPubkey,
  deriveItem: deriveMutes,
  loadItem: loadMutes,
} = collection({
  name: "mutes",
  store: mutes,
  getKey: mute => mute.event.pubkey,
  load: makeOutboxLoader(MUTES),
})

summary:
An object destructuring assignment that extracts and exports three components from a collection of mutes: `mutesByPubkey` (an index store), `deriveMutes` (a function to derive mute items), and `loadMutes` (a function to load mute items). The collection is configured with a name, store, key extraction function, and a load function specific to mute events.

details:
This code creates a collection of mute events with the following implementation details:
1. It uses the `collection` function from '@welshman/store' to create an organized collection of mute data
2. The collection is configured with:
   - name: "mutes" for identification
   - store: uses the `mutes` store defined earlier in the file
   - getKey: extracts the pubkey from a mute event to use as the collection key
   - load: uses a specialized outbox loader created with `makeOutboxLoader(MUTES)` to fetch mute events
3. The destructured exports provide different ways to interact with the mute collection:
   - mutesByPubkey: an indexed store of mutes organized by public key
   - deriveMutes: function to derive mute items from the store
   - loadMutes: function to load mute items from external sources

import/access examples:
import { mutesByPubkey } from '@welshman/app';
import { mutesByPubkey } from '@welshman/app/mutes';


=========================
workspace: packages/app
file: packages/app/src/mutes.ts
lines: 19:28
id: e46563ace662fd2434fcd55741bd223d0377170694f102061de482ee17fc3cbc
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/mutes.ts#L19

declaration:
{
  indexStore: mutesByPubkey,
  deriveItem: deriveMutes,
  loadItem: loadMutes,
} = collection({
  name: "mutes",
  store: mutes,
  getKey: mute => mute.event.pubkey,
  load: makeOutboxLoader(MUTES),
})

summary:
An object destructuring assignment that extracts and exports three components from a collection of mutes: `mutesByPubkey` (an index store), `deriveMutes` (a function to derive mute items), and `loadMutes` (a function to load mute items). The collection is configured with a name, store, key extraction function, and a load function specific to mute events.

details:
This code creates a collection of mute events with the following implementation details:
1. It uses the `collection` function from '@welshman/store' to create an organized collection of mute data
2. The collection is configured with:
   - name: "mutes" for identification
   - store: uses the `mutes` store defined earlier in the file
   - getKey: extracts the pubkey from a mute event to use as the collection key
   - load: uses a specialized outbox loader created with `makeOutboxLoader(MUTES)` to fetch mute events
3. The destructured exports provide different ways to interact with the mute collection:
   - mutesByPubkey: an indexed store of mutes organized by public key
   - deriveMutes: function to derive mute items from the store
   - loadMutes: function to load mute items from external sources

import/access examples:
import { mutesByPubkey } from '@welshman/app';
import { mutesByPubkey } from '@welshman/app/mutes';


=========================
workspace: packages/app
file: packages/app/src/inboxRelaySelections.ts
lines: 7:11
id: 0cd366a2bc46ad74d203b14658b0fb855bcf69ab57b8f8d58317409424e8ef02
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/inboxRelaySelections.ts#L7

declaration:
inboxRelaySelections = deriveEventsMapped<PublishedList>(repository, {
  filters: [{kinds: [INBOX_RELAYS]}],
  itemToEvent: item => item.event,
  eventToItem: (event: TrustedEvent) => readList(asDecryptedEvent(event)),
})

summary:
A derived store that maps events from the repository to PublishedList objects. It specifically filters for events with kind INBOX_RELAYS, transforming trusted events into decrypted lists. This store tracks inbox relay selections for users in the Nostr network.

details:
This variable is created using the deriveEventsMapped function from @welshman/store, which creates a derived store that transforms repository events into a specific format. The implementation:
1. Filters repository events to only include those with kind INBOX_RELAYS
2. Provides mapping functions to convert between store items and events:
   - itemToEvent extracts the event property from items
   - eventToItem transforms TrustedEvents by first decrypting them with asDecryptedEvent and then parsing them as lists with readList

This creates a reactive store that automatically updates when new inbox relay selection events are added to the repository.

related: deriveEventsMapped

import/access examples:
import { inboxRelaySelections } from '@welshman/app';
import { inboxRelaySelections } from '@welshman/app/inboxRelaySelections';


=========================
workspace: packages/app
file: packages/app/src/inboxRelaySelections.ts
lines: 13:22
id: 6c18bb4b389c1cdbaa8bfe5c8d5c37ab36ae836094a7cc93d5e0442f3a2ec4c8
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/inboxRelaySelections.ts#L13

declaration:
{
  indexStore: inboxRelaySelectionsByPubkey,
  deriveItem: deriveInboxRelaySelections,
  loadItem: loadInboxRelaySelections,
} = collection({
  name: "inboxRelaySelections",
  store: inboxRelaySelections,
  getKey: inboxRelaySelections => inboxRelaySelections.event.pubkey,
  load: makeOutboxLoader(INBOX_RELAYS),
})

summary:
An object destructuring assignment that creates utilities for managing inbox relay selections. It provides three main components: `inboxRelaySelectionsByPubkey` (an index store), `deriveInboxRelaySelections` (a function to derive selections for a specific pubkey), and `loadInboxRelaySelections` (a function to load selections for a pubkey).

details:
This code creates a collection of utilities for working with inbox relay selections by calling the `collection()` function with configuration parameters:

1. It names the collection "inboxRelaySelections"
2. It uses the `inboxRelaySelections` store (defined earlier in the file) as its data source
3. It defines a key extraction function that gets the pubkey from an inbox relay selection event
4. It configures loading behavior using `makeOutboxLoader(INBOX_RELAYS)` to handle fetching inbox relay selections

The resulting destructured object provides indexed access to relay selections by pubkey and functions to derive or load selections for specific pubkeys.

import/access examples:
import { inboxRelaySelectionsByPubkey } from '@welshman/app';
import { inboxRelaySelectionsByPubkey } from '@welshman/app/inboxRelaySelections';


=========================
workspace: packages/app
file: packages/app/src/inboxRelaySelections.ts
lines: 13:22
id: 6c18bb4b389c1cdbaa8bfe5c8d5c37ab36ae836094a7cc93d5e0442f3a2ec4c8
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/inboxRelaySelections.ts#L13

declaration:
{
  indexStore: inboxRelaySelectionsByPubkey,
  deriveItem: deriveInboxRelaySelections,
  loadItem: loadInboxRelaySelections,
} = collection({
  name: "inboxRelaySelections",
  store: inboxRelaySelections,
  getKey: inboxRelaySelections => inboxRelaySelections.event.pubkey,
  load: makeOutboxLoader(INBOX_RELAYS),
})

summary:
An object destructuring assignment that creates utilities for managing inbox relay selections. It provides three main components: `inboxRelaySelectionsByPubkey` (an index store), `deriveInboxRelaySelections` (a function to derive selections for a specific pubkey), and `loadInboxRelaySelections` (a function to load selections for a pubkey).

details:
This code creates a collection of utilities for working with inbox relay selections by calling the `collection()` function with configuration parameters:

1. It names the collection "inboxRelaySelections"
2. It uses the `inboxRelaySelections` store (defined earlier in the file) as its data source
3. It defines a key extraction function that gets the pubkey from an inbox relay selection event
4. It configures loading behavior using `makeOutboxLoader(INBOX_RELAYS)` to handle fetching inbox relay selections

The resulting destructured object provides indexed access to relay selections by pubkey and functions to derive or load selections for specific pubkeys.

import/access examples:
import { inboxRelaySelectionsByPubkey } from '@welshman/app';
import { inboxRelaySelectionsByPubkey } from '@welshman/app/inboxRelaySelections';


=========================
workspace: packages/app
file: packages/app/src/inboxRelaySelections.ts
lines: 13:22
id: 6c18bb4b389c1cdbaa8bfe5c8d5c37ab36ae836094a7cc93d5e0442f3a2ec4c8
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/inboxRelaySelections.ts#L13

declaration:
{
  indexStore: inboxRelaySelectionsByPubkey,
  deriveItem: deriveInboxRelaySelections,
  loadItem: loadInboxRelaySelections,
} = collection({
  name: "inboxRelaySelections",
  store: inboxRelaySelections,
  getKey: inboxRelaySelections => inboxRelaySelections.event.pubkey,
  load: makeOutboxLoader(INBOX_RELAYS),
})

summary:
An object destructuring assignment that creates utilities for managing inbox relay selections. It provides three main components: `inboxRelaySelectionsByPubkey` (an index store), `deriveInboxRelaySelections` (a function to derive selections for a specific pubkey), and `loadInboxRelaySelections` (a function to load selections for a pubkey).

details:
This code creates a collection of utilities for working with inbox relay selections by calling the `collection()` function with configuration parameters:

1. It names the collection "inboxRelaySelections"
2. It uses the `inboxRelaySelections` store (defined earlier in the file) as its data source
3. It defines a key extraction function that gets the pubkey from an inbox relay selection event
4. It configures loading behavior using `makeOutboxLoader(INBOX_RELAYS)` to handle fetching inbox relay selections

The resulting destructured object provides indexed access to relay selections by pubkey and functions to derive or load selections for specific pubkeys.

import/access examples:
import { inboxRelaySelectionsByPubkey } from '@welshman/app';
import { inboxRelaySelectionsByPubkey } from '@welshman/app/inboxRelaySelections';


=========================
workspace: packages/app
file: packages/app/src/wot.ts
lines: 9:10
id: 57abd1ab0aa403d62ae9b5c822f2ea1a50781c9b24c9e4c0c22b8b1030ab6298
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/wot.ts#L9

declaration:
getFollows = (pubkey: string) =>
  getPubkeyTagValues(getListTags(followsByPubkey.get().get(pubkey)))

summary:
A function that retrieves a list of pubkeys that a given user follows. It takes a pubkey string as input and returns an array of pubkey strings representing the accounts followed by the specified user.

details:
The implementation retrieves follow data by:
1. Using followsByPubkey.get() to access the map of follow relationships
2. Getting the specific follow list for the provided pubkey
3. Extracting list tags from that data using getListTags
4. Finally extracting the pubkey values from those tags using getPubkeyTagValues

This function essentially provides a convenient way to access the network graph data by retrieving a user's outgoing follow connections.

related: getPubkeyTagValues

import/access examples:
import { getFollows } from '@welshman/app';
import { getFollows } from '@welshman/app/wot';


=========================
workspace: packages/app
file: packages/app/src/wot.ts
lines: 12:13
id: fcc2a0ed3f146f35cd62bfde2e6aef2c132aec773e98b24f72dd369189f00d0c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/wot.ts#L12

declaration:
getMutes = (pubkey: string) =>
  getPubkeyTagValues(getListTags(mutesByPubkey.get().get(pubkey)))

summary:
A function that retrieves a list of pubkeys that are muted by a given user. It takes a pubkey string as input and returns an array of pubkey strings representing the users that the specified pubkey has muted.

details:
This function works by:
1. Taking a pubkey string parameter
2. Accessing the mutesByPubkey store to get mute list data for the specified pubkey
3. Using getListTags to extract tags from the mute list
4. Using getPubkeyTagValues to filter and extract just the pubkey values from those tags

It's a simple accessor function that provides a convenient way to access mute relationships in the application's social graph.

related: getPubkeyTagValues

import/access examples:
import { getMutes } from '@welshman/app';
import { getMutes } from '@welshman/app/wot';


=========================
workspace: packages/app
file: packages/app/src/wot.ts
lines: 15:28
id: 05c8a1336307f298efb922556d866fce690388c2e4a0dd283ba70ad7626ef788
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/wot.ts#L15

declaration:
getNetwork = (pubkey: string) => {
  const pubkeys = new Set(getFollows(pubkey))
  const network = new Set<string>()

  for (const follow of pubkeys) {
    for (const tpk of getFollows(follow)) {
      if (!pubkeys.has(tpk)) {
        network.add(tpk)
      }
    }
  }

  return Array.from(network)
}

summary:
The `getNetwork` function retrieves the second-degree network connections for a given pubkey. It returns an array of pubkeys that are followed by the user's follows but not directly followed by the user themselves. This represents the extended network or 'friends of friends' of the specified user.

details:
The implementation works in three steps:
1. It first gets all direct follows of the provided pubkey and stores them in a Set for efficient lookups
2. It then iterates through each of these follows and gets their follows (second-degree connections)
3. For each second-degree connection, it checks if it's not already in the user's direct follows
4. If not already directly followed, it adds the pubkey to the network Set
5. Finally, it converts the Set to an Array before returning

This effectively creates a list of pubkeys that are one connection away from the user's direct network but not already part of it.

import/access examples:
import { getNetwork } from '@welshman/app';
import { getNetwork } from '@welshman/app/wot';


=========================
workspace: packages/app
file: packages/app/src/wot.ts
lines: 30:42
id: 5d71cd4367a1c2500622fb0039a92af285a1382b73cda1580f859d729dcbcf6f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/wot.ts#L30

declaration:
followersByPubkey = withGetter(
  derived(throttled(1000, follows), lists => {
    const $followersByPubkey = new Map<string, Set<string>>()

    for (const list of lists) {
      for (const pubkey of getPubkeyTagValues(getListTags(list))) {
        addToMapKey($followersByPubkey, pubkey, list.event.pubkey)
      }
    }

    return $followersByPubkey
  }),
)

summary:
A derived store that maps pubkeys to sets of pubkeys that follow them. It provides a way to look up all followers for a given pubkey. The store includes a getter method for easy access to the current value.

details:
This variable creates a derived Svelte store that:

1. Takes the 'follows' store as input, throttled to update at most once per second
2. Processes the follows data to create a reverse mapping - instead of mapping users to who they follow, it maps users to who follows them
3. For each list in the follows data:
   - Extracts pubkey tag values from the list tags
   - For each pubkey found, adds the list creator's pubkey to that pubkey's set of followers
4. Returns a Map where keys are pubkeys and values are Sets of pubkeys that follow them
5. Uses withGetter to add a .get() method for easy access to the current store value without subscribing

related: withGetter

import/access examples:
import { followersByPubkey } from '@welshman/app';
import { followersByPubkey } from '@welshman/app/wot';


=========================
workspace: packages/app
file: packages/app/src/wot.ts
lines: 44:56
id: 68704fafa9998d655387067af129a847b810fe5eef5dcea522e154e9f45eb46e
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/wot.ts#L44

declaration:
mutersByPubkey = withGetter(
  derived(throttled(1000, mutes), lists => {
    const $mutersByPubkey = new Map<string, Set<string>>()

    for (const list of lists) {
      for (const pubkey of getPubkeyTagValues(getListTags(list))) {
        addToMapKey($mutersByPubkey, pubkey, list.event.pubkey)
      }
    }

    return $mutersByPubkey
  }),
)

summary:
A derived store that maps pubkeys to sets of pubkeys that mute them. It provides a way to look up who mutes a specific pubkey. The store is wrapped with a getter for easier access to its current value.

details:
This variable creates a derived store that processes mute lists to build a reverse index of muters. It:

1. Uses throttled(1000, mutes) to limit updates to once per second for performance
2. Processes each mute list by extracting pubkeys from its tags
3. For each pubkey found in a mute list, adds the muter's pubkey to that pubkey's entry in the map
4. Returns a Map where keys are pubkeys and values are Sets containing pubkeys of users who mute them
5. Wraps the store with withGetter() to provide a .get() method for direct value access without subscription

The implementation efficiently handles potentially large numbers of mute lists by throttling updates and using Map/Set data structures for lookups.

related: withGetter

import/access examples:
import { mutersByPubkey } from '@welshman/app';
import { mutersByPubkey } from '@welshman/app/wot';


=========================
workspace: packages/app
file: packages/app/src/wot.ts
lines: 58:59
id: 7a2189c65466a9c033c6cf5ab8096619b98afefac8bb26ef5116aaf5a23cbf27
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/wot.ts#L58

declaration:
getFollowers = (pubkey: string) =>
  Array.from(followersByPubkey.get().get(pubkey) || [])

summary:
A function that retrieves an array of followers for a given pubkey. It takes a pubkey string as input and returns an array of strings representing the pubkeys of users who follow the specified pubkey.

details:
This function retrieves followers for a given pubkey by:
1. Accessing the followersByPubkey store using its get() method
2. Retrieving the Set of followers for the specified pubkey
3. Converting the Set to an Array using Array.from()
4. Handling the case where no followers exist by providing an empty array as fallback with the || [] pattern

The function relies on the followersByPubkey derived store which maintains a mapping of pubkeys to their followers.

import/access examples:
import { getFollowers } from '@welshman/app';
import { getFollowers } from '@welshman/app/wot';


=========================
workspace: packages/app
file: packages/app/src/wot.ts
lines: 61:61
id: e813e661c9fdd9a03b8ea71372ad4c7901acd7aa5ed7a29e5721f16abc30b11e
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/wot.ts#L61

declaration:
getMuters = (pubkey: string) => Array.from(mutersByPubkey.get().get(pubkey) || [])

summary:
A function that retrieves an array of pubkeys that mute a specified pubkey. It takes a pubkey string as input and returns an array of pubkeys that have muted the given pubkey.

details:
This function retrieves muters for a given pubkey by:
1. Accessing the mutersByPubkey store using get()
2. Retrieving the set of muters for the specified pubkey
3. Converting the set to an array using Array.from()
4. Handling the case where no muters exist by providing an empty array fallback with the || [] pattern

The implementation is a simple one-liner that leverages the mutersByPubkey derived store which maintains a mapping of pubkeys to the sets of pubkeys that mute them.

import/access examples:
import { getMuters } from '@welshman/app';
import { getMuters } from '@welshman/app/wot';


=========================
workspace: packages/app
file: packages/app/src/wot.ts
lines: 63:64
id: c57a3e634af05d2552f5b974cd7508809ebf3744422a29d9624b7192e08ec18c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/wot.ts#L63

declaration:
getFollowsWhoFollow = (pubkey: string, target: string) =>
  getFollows(pubkey).filter(other => getFollows(other).includes(target))

summary:
The `getFollowsWhoFollow` function identifies which accounts followed by a given pubkey also follow a target pubkey. It takes two parameters: `pubkey` (the source account) and `target` (the account to check for followers), both as strings. It returns an array of pubkeys representing the intersection of accounts that the source follows and accounts that follow the target.

details:
The implementation filters the list of accounts followed by the source pubkey to only include those that also follow the target pubkey. It does this by:
1. Getting all accounts followed by the source pubkey using `getFollows(pubkey)`
2. Filtering this list to only include accounts that follow the target
3. For each account in the source's follow list, it checks if the target is included in that account's follow list using `getFollows(other).includes(target)`

related: __function,getFollows

import/access examples:
import { getFollowsWhoFollow } from '@welshman/app';
import { getFollowsWhoFollow } from '@welshman/app/wot';


=========================
workspace: packages/app
file: packages/app/src/wot.ts
lines: 66:67
id: d70b5d6ad0626be735ecb457b19621056680a532ef4ccdd82c1766dcc824f68a
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/wot.ts#L66

declaration:
getFollowsWhoMute = (pubkey: string, target: string) =>
  getFollows(pubkey).filter(other => getMutes(other).includes(target))

summary:
The `getFollowsWhoMute` function identifies which accounts followed by a given user have muted a specific target account. It takes two parameters: `pubkey` (the user's public key) and `target` (the public key of the account to check against). Returns an array of public keys representing the subset of followed accounts that have muted the target.

details:
This function implements a simple filtering operation that:
1. Gets all accounts followed by the specified user using `getFollows(pubkey)`
2. Filters this list to only include accounts that have muted the target account
3. The filtering is done by checking if the target public key is included in each followed account's mute list via `getMutes(other).includes(target)`

The implementation is concise and leverages other utility functions from the web of trust (WoT) system to perform the actual data retrieval.

related: __function,getFollows

import/access examples:
import { getFollowsWhoMute } from '@welshman/app';
import { getFollowsWhoMute } from '@welshman/app/wot';


=========================
workspace: packages/app
file: packages/app/src/wot.ts
lines: 69:69
id: 992090a8f6a0c8a5d23963c353040e5aadc2ca2b41cf87b3b850d6b4a1d23318
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/wot.ts#L69

declaration:
wotGraph = withGetter(writable(new Map<string, number>()))

summary:
A Svelte store that represents a Web of Trust (WoT) graph, mapping public keys to numerical scores. The store is enhanced with a getter method via `withGetter` and initialized with an empty Map where keys are strings (pubkeys) and values are numbers (trust scores).

details:
This variable creates a writable Svelte store that maintains a Web of Trust graph as a Map where:
1. Keys are public keys (strings)
2. Values are numerical scores representing trust levels

The implementation uses:
- `writable` from Svelte's store to create the reactive data store
- `withGetter` utility to enhance the store with a synchronous getter method
- The store is initialized with an empty Map

The store is populated by the `buildGraph` function (defined later in the file) which calculates trust scores based on follows and mutes relationships. The graph is used to represent the social trust network in what appears to be a Nostr-related application.

related: withGetter

import/access examples:
import { wotGraph } from '@welshman/app';
import { wotGraph } from '@welshman/app/wot';


=========================
workspace: packages/app
file: packages/app/src/wot.ts
lines: 71:71
id: ff519ab81d78c11cc31a5c9bc6b3cb2dc591fd38cf5f4ced102b072a66bec4cf
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/wot.ts#L71

declaration:
maxWot = withGetter(derived(wotGraph, $g => max(Array.from($g.values()))))

summary:
A derived store that returns the maximum value from the wotGraph. It uses the withGetter utility to provide a synchronous getter method for the store value. The maxWot store updates whenever the wotGraph changes, calculating the maximum score in the web of trust graph.

details:
This variable is implemented as a derived Svelte store that depends on the wotGraph store. It processes the wotGraph data by:
1. Converting the Map values to an array using Array.from($g.values())
2. Finding the maximum value in that array using the max utility function
3. Wrapping the derived store with withGetter to provide synchronous access to the store value

The implementation is straightforward - it simply extracts the maximum trust score from all entries in the web of trust graph, which can be useful for normalization or visualization purposes.

related: withGetter

import/access examples:
import { maxWot } from '@welshman/app';
import { maxWot } from '@welshman/app/wot';


=========================
workspace: packages/app
file: packages/app/src/wot.ts
lines: 73:89
id: 674af35d86c4dadf4a0c79ff9670ff82599864ccc14d2efa8e6fec8ca61ba6ef
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/wot.ts#L73

declaration:
buildGraph = throttle(1000, () => {
  const $pubkey = pubkey.get()
  const $graph = new Map<string, number>()
  const $follows = $pubkey ? getFollows($pubkey) : followsByPubkey.get().keys()

  for (const follow of $follows) {
    for (const pubkey of getFollows(follow)) {
      $graph.set(pubkey, inc($graph.get(pubkey)))
    }

    for (const pubkey of getMutes(follow)) {
      $graph.set(pubkey, dec($graph.get(pubkey)))
    }
  }

  wotGraph.set($graph)
})

summary:
A throttled function that builds a graph of web of trust scores for users in a network. It runs at most once every 1000ms and updates the wotGraph store with a map of pubkeys to their calculated scores. The scores are incremented when a user is followed and decremented when a user is muted by someone in the network.

details:
The implementation works by:
1. Getting the current user's pubkey
2. Creating a new Map to store the graph data
3. Determining which users to analyze (either follows of current user or all users in followsByPubkey)
4. For each follow in the network:
   - Incrementing scores for users they follow
   - Decrementing scores for users they mute
5. Finally updating the wotGraph store with the new graph

The function is throttled to prevent excessive recalculations when multiple related stores change in quick succession. It's subscribed to the pubkey, follows, and mutes stores to rebuild the graph whenever any of these change.

related: throttle

=========================
workspace: packages/app
file: packages/app/src/wot.ts
lines: 95:100
id: 14b5c93d62d2b6d03c45f5d19da30c966bc8693583163cc3f4d77acabfb17488
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/wot.ts#L95

declaration:
getWotScore = (pubkey: string, target: string) => {
  const follows = pubkey ? getFollowsWhoFollow(pubkey, target) : getFollowers(target)
  const mutes = pubkey ? getFollowsWhoMute(pubkey, target) : getMuters(target)

  return follows.length - mutes.length
}

summary:
The `getWotScore` function calculates a 'web of trust' score between a user and a target. It takes two parameters: `pubkey` (the user's public key) and `target` (the target's public key). The function returns an integer score representing the difference between the number of the user's follows who follow the target and the number who mute the target. If no pubkey is provided, it falls back to counting all followers and muters of the target.

details:
The implementation works by:
1. Determining the relevant follows and mutes based on whether a pubkey is provided:
   - If pubkey exists: Gets follows who follow the target and follows who mute the target
   - If no pubkey: Gets all followers and muters of the target
2. Calculating the score as the difference between the number of follows and the number of mutes

This function is part of a larger web-of-trust system that tracks relationships between users in a social network, likely in a Nostr-based application.

import/access examples:
import { getWotScore } from '@welshman/app';
import { getWotScore } from '@welshman/app/wot';


=========================
workspace: packages/app
file: packages/app/src/user.ts
lines: 13:13
id: 5b93514d4771f37a1a33bdfc4ada83b9501970ae059c4708bf010af2f16c9b67
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/user.ts#L13

declaration:
export type UserDataLoader = (pubkey: string, relays?: string[], force?: boolean) => unknown

summary:
A type alias representing a function that loads user data. It takes a public key as a required parameter, with optional relay URLs and a force flag, and returns an unknown type.

details:
This type alias defines the signature for functions that load various types of user data throughout the application. It's used as a common interface for different data loading functions, allowing for consistent handling of user data retrieval operations across the codebase.

import/access examples:
import type { UserDataLoader } from '@welshman/app';
import type { UserDataLoader } from '@welshman/app/user';


=========================
workspace: packages/app
file: packages/app/src/user.ts
lines: 15:18
id: e68994a336bcc7570399717b96d355b6215899930fcc8e01f2a4dc7cd75b0633
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/user.ts#L15

declaration:
export type MakeUserDataOptions<T> = {
  mapStore: Readable<Map<string, T>>
  loadItem: UserDataLoader
}

summary:
A generic type definition that specifies the options required to create user data stores. It takes a type parameter `T` which represents the type of data being stored for a user. The type contains two properties: `mapStore` which is a Svelte readable store containing a Map of user public keys to their data, and `loadItem` which is a function to load user data.

details:
This type is used as the parameter type for the `makeUserData` function, providing a consistent interface for creating various user-related data stores in the application. It's designed to work with Svelte's reactive store system, allowing components to subscribe to changes in user data. The generic parameter `T` makes this type flexible enough to handle different kinds of user data structures throughout the application.

related: UserDataLoader

import/access examples:
import type { MakeUserDataOptions } from '@welshman/app';
import type { MakeUserDataOptions } from '@welshman/app/user';


=========================
workspace: packages/app
file: packages/app/src/user.ts
lines: 20:29
id: ee77e7be9bc451a42366dda752344814c712cc76d05dee8a707c67cfc51fee99
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/user.ts#L20

declaration:
makeUserData = <T>({mapStore, loadItem}: MakeUserDataOptions<T>) =>
  withGetter(
    derived([mapStore, pubkey], ([$mapStore, $pubkey]) => {
      if (!$pubkey) return undefined

      loadItem($pubkey)

      return $mapStore.get($pubkey)
    }),
  )

summary:
A generic function that creates a derived store for user data. It takes an object with a map store and a load function, and returns a store that automatically loads and retrieves user data for the current pubkey. The returned store is enhanced with a getter method via withGetter.

details:
This function implements a pattern for accessing user-specific data by:
1. Creating a derived store that depends on both the provided map store and the current user's pubkey
2. When the derived store is accessed and a pubkey exists, it triggers the loadItem function to ensure data is loaded
3. Returns the specific user data from the map using the current pubkey as the key
4. The withGetter wrapper enhances the store with a getter method for easier access

The implementation leverages Svelte's reactive store system to ensure data is loaded when needed and the UI is updated when data changes.

related: withGetter,MakeUserDataOptions

=========================
workspace: packages/app
file: packages/app/src/user.ts
lines: 31:39
id: 291a50a57740d9e8a2ef1cd29bf0dc8bf47f4c214aca95fa6b8d7fa0717d92d6
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/user.ts#L31

declaration:
makeUserLoader =
  (loadItem: UserDataLoader) =>
  async (relays: string[] = [], force = false) => {
    const $pubkey = pubkey.get()

    if ($pubkey) {
      await loadItem($pubkey, relays, force)
    }
  }

summary:
A function that creates a user data loader function. It takes a UserDataLoader function as input and returns an async function that loads user data. The returned function accepts optional relay URLs and a force flag, retrieves the current user's public key, and calls the provided loader function with these parameters.

details:
This function implements a factory pattern to create user data loader functions. It:
1. Takes a UserDataLoader function as its parameter
2. Returns an async function that:
   - Accepts optional parameters: relays (default empty array) and force (default false)
   - Gets the current user's public key using pubkey.get()
   - If a public key exists, calls the provided loadItem function with the public key, relays, and force flag
   - Returns implicitly (undefined)

The function is used internally to create various user data loaders like loadUserProfile, loadUserFollows, etc.

related: UserDataLoader

=========================
workspace: packages/app
file: packages/app/src/user.ts
lines: 41:44
id: 7ccf7f482935ccc862308654282e3106ed794dba25b1b482d58dcca860342aa4
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/user.ts#L41

declaration:
userProfile = makeUserData({
  mapStore: profilesByPubkey,
  loadItem: loadProfile,
})

summary:
A derived store that provides access to the current user's profile data. It automatically loads the profile when the user's public key changes. The store returns undefined if no user is logged in, or the user's profile data if available.

details:
This variable is created using the `makeUserData` helper function, which creates a derived store that:
1. Watches for changes in the user's public key and the profiles map
2. Automatically triggers loading of the user's profile data when the public key changes
3. Returns the profile data from the profiles map for the current user
4. Uses the `withGetter` utility to allow accessing the store value directly via a getter method

The implementation connects the global user state (pubkey) with the profile data system, providing reactive access to the current user's profile.

related: __function,makeUserData

import/access examples:
import { userProfile } from '@welshman/app';
import { userProfile } from '@welshman/app/user';


=========================
workspace: packages/app
file: packages/app/src/user.ts
lines: 46:46
id: 93a25571fed722606ac4ca8c34070d482c2207093e00feb89ff2ee74c425dead
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/user.ts#L46

declaration:
loadUserProfile = makeUserLoader(loadProfile)

summary:
A function that loads the profile data for the current user. It takes optional parameters for relay URLs and a force flag to refresh data. Returns a Promise that resolves when the profile loading is complete.

details:
This function is created using the `makeUserLoader` factory function with `loadProfile` as the data loader. It retrieves the current user's public key from the `pubkey` store, and if a public key exists, it calls the `loadProfile` function with the public key and any provided relay URLs and force flag. The implementation follows a pattern used throughout the application for loading different types of user data.

related: __function,makeUserLoader

import/access examples:
import { loadUserProfile } from '@welshman/app';
import { loadUserProfile } from '@welshman/app/user';


=========================
workspace: packages/app
file: packages/app/src/user.ts
lines: 48:51
id: e64c2bd077ed74066db91149525b704f3c37796bea9acca61d209db646578b29
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/user.ts#L48

declaration:
userFollows = makeUserData({
  mapStore: followsByPubkey,
  loadItem: loadFollows,
})

summary:
userFollows is an exported readable store (augmented with a .get() getter) that holds the follow list for the currently logged‑in user. It automatically triggers loading of the user's follows via loadFollows when the user's public key becomes available and updates whenever the underlying followsByPubkey map changes.

details:
userFollows is created by the generic helper makeUserData. The helper builds a Svelte derived store that depends on two sources: the global pubkey store and the followsByPubkey map store. Inside the derived callback it:
1. Returns undefined if no pubkey is set.
2. Calls loadFollows(pubkey) to ensure the follow data is fetched (side‑effect).
3. Retrieves the follows for that pubkey from followsByPubkey via .get(pubkey).
The derived store is then wrapped with withGetter, which adds a synchronous .get() method so callers can read the current value without subscribing. The implementation therefore ties the user‑specific follows data to the global user identity and lazily loads it on demand.

related: __function,makeUserData

import/access examples:
import { userFollows } from '@welshman/app';
import { userFollows } from '@welshman/app/user';


=========================
workspace: packages/app
file: packages/app/src/user.ts
lines: 53:53
id: 790729536b5631b8edb8e1ee64b3788b2d1d29457fcb5fbf3aa85ef2fb4d6377
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/user.ts#L53

declaration:
loadUserFollows = makeUserLoader(loadFollows)

summary:
A function that loads the follows data for the current user. It takes optional parameters for specifying relays and forcing a refresh. This function is used to fetch and update the user's follow list from the network.

details:
This function is created using the `makeUserLoader` factory function with `loadFollows` as the data loader. When called, it:
1. Gets the current user's public key from the `pubkey` store
2. If a public key exists, it calls the `loadFollows` function with the user's public key and any provided relay list and force parameters
3. Returns a Promise that resolves when the loading operation completes

The implementation leverages the generic user data loading pattern established in this module.

related: __function,makeUserLoader

import/access examples:
import { loadUserFollows } from '@welshman/app';
import { loadUserFollows } from '@welshman/app/user';


=========================
workspace: packages/app
file: packages/app/src/user.ts
lines: 55:58
id: b50a10ee0f1ef84abeb1900a45a5a6e51db41659fae1a3f0c029c627ed363996
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/user.ts#L55

declaration:
userMutes = makeUserData({
  mapStore: mutesByPubkey,
  loadItem: loadMutes,
})

summary:
A derived store that provides access to the current user's mute list. It automatically loads the mute data for the current user when accessed. The store value will be undefined if no user is logged in, or the user's mute data if available.

details:
This variable is created using the `makeUserData` helper function, which creates a derived store that:
1. Watches for changes to both the mutes data store (`mutesByPubkey`) and the current user's public key (`pubkey`)
2. Automatically triggers loading of mute data when accessed
3. Returns the mute data for the current user from the mutes map
4. Uses `withGetter` to make the store value accessible via a getter method

The implementation relies on the Svelte store system for reactivity.

related: __function,makeUserData

import/access examples:
import { userMutes } from '@welshman/app';
import { userMutes } from '@welshman/app/user';


=========================
workspace: packages/app
file: packages/app/src/user.ts
lines: 60:60
id: de24d9f5df9233253fbbfacfdd243fcf13f89883b03b52cae9b03f519ec41f5f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/user.ts#L60

declaration:
loadUserMutes = makeUserLoader(loadMutes)

summary:
A function that loads mute data for the current user. It retrieves the user's public key and calls the loadMutes function with optional relay URLs and a force reload flag. Returns a Promise that resolves when the mute data has been loaded.

details:
This function is created using the makeUserLoader factory function, which generates a user data loading function that:
1. Gets the current user's public key from the pubkey store
2. If a public key exists, calls the provided loadMutes function with the public key and optional parameters
3. Returns a Promise that completes when the loading operation finishes

The loadUserMutes function is part of a pattern used throughout this module for loading different types of user data (profiles, follows, mutes, pins, etc.) in a consistent way.

related: __function,makeUserLoader

import/access examples:
import { loadUserMutes } from '@welshman/app';
import { loadUserMutes } from '@welshman/app/user';


=========================
workspace: packages/app
file: packages/app/src/user.ts
lines: 62:65
id: 2df3d1a852838aee7d9ed18d6071a4ffb614c49268a3b3896cc3f3c8cfc17e04
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/user.ts#L62

declaration:
userPins = makeUserData({
  mapStore: pinsByPubkey,
  loadItem: loadPins,
})

summary:
A derived Svelte store that provides access to the current user's pins. It automatically loads the pins data for the current user when accessed. The store value will be undefined if no user is logged in, or the user's pins data if available.

details:
This variable is created using the `makeUserData` helper function, which creates a derived store that:
1. Watches both the pins map store and the current user's pubkey
2. Automatically triggers loading of pins data when accessed
3. Returns the pins data for the current user from the map

The implementation uses the `withGetter` utility to add a getter method to the store, allowing both reactive and direct access to the store's value.

related: __function,makeUserData

import/access examples:
import { userPins } from '@welshman/app';
import { userPins } from '@welshman/app/user';


=========================
workspace: packages/app
file: packages/app/src/user.ts
lines: 67:67
id: 7a310d456b652e9a28446cda53fd58d2171ca2a62fbc707f828eeeccb8978976
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/user.ts#L67

declaration:
loadUserPins = makeUserLoader(loadPins)

summary:
A function that loads pin data for the current user. It takes optional parameters for specifying relays and forcing a refresh. This function is used to fetch and update the user's pinned items from the network.

details:
This function is created using the `makeUserLoader` factory function, which wraps the `loadPins` data loader. When called, it:
1. Retrieves the current user's public key from the `pubkey` store
2. If a public key exists, it calls the `loadPins` function with the user's public key and any provided relay URLs and force refresh flag
3. Returns a Promise that resolves when the loading operation completes

The implementation follows the pattern used for all user data loaders in this module.

related: __function,makeUserLoader

import/access examples:
import { loadUserPins } from '@welshman/app';
import { loadUserPins } from '@welshman/app/user';


=========================
workspace: packages/app
file: packages/app/src/user.ts
lines: 69:72
id: 4f7fd1309afd21509c41823a90e48d5e50a1b9ee659e112b172a2912668d9d3a
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/user.ts#L69

declaration:
userRelaySelections = makeUserData({
  mapStore: relaySelectionsByPubkey,
  loadItem: loadRelaySelections,
})

summary:
A derived store that provides access to the current user's relay selections. It automatically loads the relay selections for the authenticated user when accessed. The store value will be undefined if no user is authenticated, or the user's relay selections data if available.

details:
This variable is created using the `makeUserData` helper function, which creates a derived store with a getter. It combines two data sources:
1. The `relaySelectionsByPubkey` map store that contains relay selections indexed by public keys
2. The current user's public key from the `pubkey` store

When accessed, it automatically triggers the `loadRelaySelections` function to fetch the data for the current user if needed. The implementation leverages Svelte's reactive store system to maintain and update the user's relay selections data when the underlying stores change.

related: __function,makeUserData

import/access examples:
import { userRelaySelections } from '@welshman/app';
import { userRelaySelections } from '@welshman/app/user';


=========================
workspace: packages/app
file: packages/app/src/user.ts
lines: 74:74
id: 39b5e48be5cfb0b7811097f9ffc9fdd0b2562e6836f5b3851de051d281d50a6c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/user.ts#L74

declaration:
loadUserRelaySelections = makeUserLoader(loadRelaySelections)

summary:
A function that loads relay selections for the current user. It takes optional parameters for specifying relays and forcing a reload. This function is used to fetch and update the user's relay selection data from the network.

details:
This function is created using the `makeUserLoader` factory function, which wraps the `loadRelaySelections` function. When called, it:
1. Gets the current user's public key from the `pubkey` store
2. If a public key exists, it calls the `loadRelaySelections` function with the user's public key and any provided parameters
3. Returns a Promise that resolves when the loading operation completes

The implementation leverages the application's data loading pattern for user-specific data.

related: __function,makeUserLoader

import/access examples:
import { loadUserRelaySelections } from '@welshman/app';
import { loadUserRelaySelections } from '@welshman/app/user';


=========================
workspace: packages/app
file: packages/app/src/user.ts
lines: 76:79
id: aa359bcab2aa035a5deafbf10af0b57f8ba6c59d3420b1d17afc5801980b85ff
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/user.ts#L76

declaration:
userInboxRelaySelections = makeUserData({
  mapStore: inboxRelaySelectionsByPubkey,
  loadItem: loadInboxRelaySelections,
})

summary:
A derived Svelte store that provides access to the current user's inbox relay selections. It automatically loads the inbox relay selections for the current user when accessed. The store returns undefined if no user is logged in, or the user's inbox relay selections if available.

details:
This variable is created using the `makeUserData` helper function, which creates a derived store with a getter. The store is derived from two sources:
1. `inboxRelaySelectionsByPubkey` - a map store containing inbox relay selections indexed by pubkey
2. `pubkey` - the current user's public key

When accessed, it triggers loading of the user's inbox relay selections via the `loadInboxRelaySelections` function if a user is logged in. The store value is retrieved from the map using the current user's pubkey.

related: __function,makeUserData

import/access examples:
import { userInboxRelaySelections } from '@welshman/app';
import { userInboxRelaySelections } from '@welshman/app/user';


=========================
workspace: packages/app
file: packages/app/src/user.ts
lines: 81:81
id: 20a3a5a76efc3126f2de60a5e5d1a5e6e7a1eead97a7ddbaeb4c7a6ecff82afb
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/user.ts#L81

declaration:
loadUserInboxRelaySelections = makeUserLoader(loadInboxRelaySelections)

summary:
A function that loads inbox relay selections for the current user. It takes optional parameters for specifying relays and forcing a reload. This function provides a convenient way to load inbox relay selection data for the currently authenticated user.

details:
This function is created using the `makeUserLoader` factory function, which generates a loader function for user-specific data. When called, it:
1. Retrieves the current user's public key from the `pubkey` store
2. If a public key exists, it calls the `loadInboxRelaySelections` function with the user's public key and any provided relay list and force parameters
3. Returns a Promise that resolves when the loading operation completes

The implementation leverages the application's data loading pattern for user-specific data, ensuring inbox relay selections are loaded for the current user context.

related: __function,makeUserLoader

import/access examples:
import { loadUserInboxRelaySelections } from '@welshman/app';
import { loadUserInboxRelaySelections } from '@welshman/app/user';


=========================
workspace: packages/app
file: packages/app/src/user.ts
lines: 83:86
id: 86b5a8cc0a898d909c2f5ec0f1661398ffa4d8b76c3fd364d04f65c4004662dd
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/user.ts#L83

declaration:
userBlossomServers = makeUserData({
  mapStore: blossomServersByPubkey,
  loadItem: loadBlossomServers,
})

summary:
A derived store that provides access to the current user's Blossom servers data. It automatically loads the data when the user's public key changes. The store value is undefined if no user is logged in, otherwise it contains the Blossom servers data associated with the current user's public key.

details:
This variable is created using the `makeUserData` helper function, which creates a derived store with a getter. The store derives its value from two sources:
1. The `blossomServersByPubkey` map store that contains Blossom servers data indexed by public keys
2. The current user's public key from the `pubkey` store

When the user's public key changes, it automatically triggers loading of the Blossom servers data for that user via the `loadBlossomServers` function. The store's value is the Blossom servers data for the current user retrieved from the map, or undefined if no user is logged in.

related: __function,makeUserData

import/access examples:
import { userBlossomServers } from '@welshman/app';
import { userBlossomServers } from '@welshman/app/user';


=========================
workspace: packages/app
file: packages/app/src/user.ts
lines: 88:88
id: 00134466b22272838b9151ad4dac27d6308db0c36a5b22ae27f5791d28c02604
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/user.ts#L88

declaration:
loadUserBlossomServers = makeUserLoader(loadBlossomServers)

summary:
A function that loads blossom server data for the current user. It accepts optional parameters for relay URLs and a force flag to refresh data. Returns a Promise that resolves when the loading operation completes.

details:
This function is created using the `makeUserLoader` factory function, which wraps the `loadBlossomServers` function. When called, it:
1. Gets the current user's public key from the `pubkey` store
2. If a public key exists, it calls the `loadBlossomServers` function with the user's public key and the provided relay URLs and force parameters
3. The implementation leverages the user data loading pattern established in this module for consistent data fetching behavior

related: __function,makeUserLoader

import/access examples:
import { loadUserBlossomServers } from '@welshman/app';
import { loadUserBlossomServers } from '@welshman/app/user';


=========================
workspace: packages/app
file: packages/app/src/user.ts
lines: 90:90
id: cadafb01c2d6888322a8e6024db4d7d0e06955a7102d6d38a7cb485904e41d08
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/user.ts#L90

declaration:
getUserWotScore = (tpk: string) => wotGraph.get().get(tpk) || 0

summary:
A function that retrieves the Web of Trust (WoT) score for a given public key. It takes a target public key (tpk) as a string parameter and returns a numeric score representing the trust level in the WoT graph. If no score is found, it returns 0.

details:
The implementation is straightforward - it accesses the current value of the wotGraph store using the get() method, then attempts to retrieve the score for the specified target public key from this graph. The || 0 operator provides a default value of 0 if the target public key isn't found in the graph.

related: wotGraph

import/access examples:
import { getUserWotScore } from '@welshman/app';
import { getUserWotScore } from '@welshman/app/user';


=========================
workspace: packages/app
file: packages/app/src/user.ts
lines: 92:92
id: f963ea3f3d90b747d4118ebad45ee0188895b04c29775c2a16a19fdcd4804b00
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/user.ts#L92

declaration:
deriveUserWotScore = (tpk: string) => derived(wotGraph, $g => $g.get(tpk) || 0)

summary:
A function that creates a derived Svelte store which tracks the Web of Trust (WoT) score for a specified public key. It takes a target public key (tpk) as input and returns a readable store that updates whenever the WoT graph changes, providing the current score for that public key or 0 if no score exists.

details:
This function implements a reactive way to observe WoT scores by:
1. Taking a target public key (tpk) as a string parameter
2. Using Svelte's 'derived' store to create a subscription to the wotGraph store
3. Transforming the graph data by extracting the specific score for the provided public key
4. Providing a fallback value of 0 if no score exists for the key

The implementation is simple but effective, allowing components to reactively update when WoT scores change without having to manually poll or check for updates.

related: derived

import/access examples:
import { deriveUserWotScore } from '@welshman/app';
import { deriveUserWotScore } from '@welshman/app/user';


=========================
workspace: packages/app
file: packages/app/src/commands.ts
lines: 50:70
id: 82084a3d4e4270f361b585c2ee45d4c9f71e74840eb2102a4550a62977674609
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/commands.ts#L50

declaration:
removeRelay = async (url: string, mode: RelayMode) => {
  await loadUserRelaySelections([], true)

  const list = get(userRelaySelections) || makeList({kind: RELAYS})
  const dup = getRelayTags(getListTags(list)).find(nthEq(1, url))
  const alt = mode === RelayMode.Read ? RelayMode.Write : RelayMode.Read
  const tags = list.publicTags.filter(nthNe(1, url))

  // If we had a duplicate that was used as the alt mode, keep the alt
  if (dup && (!dup[2] || dup[2] === alt)) {
    tags.push(["r", url, alt])
  }

  const event = {kind: list.kind, content: list.event?.content || "", tags}
  const relays = Router.get().FromUser().policy(addMaximalFallbacks).getUrls()

  // Make sure to notify the old relay too
  relays.push(url)

  return publishThunk({event, relays})
}

summary:
Removes a relay from the user's relay list with the specified mode (Read or Write). Takes a relay URL and a RelayMode as parameters and returns a thunk that publishes the updated relay list. If the relay was previously used in the alternate mode, it will be kept with that mode.

details:
Implementation details:
1. Loads the user's relay selections with `loadUserRelaySelections`
2. Gets the current relay list or creates a new one if none exists
3. Checks if the relay exists in the list with the specified mode
4. Determines the alternate mode (Read if Write was specified, Write if Read was specified)
5. Filters out the relay from the tags list
6. If the relay was previously used with the alternate mode, it keeps that entry
7. Creates a new event with the updated tags
8. Gets the user's relay URLs with fallback policy
9. Adds the removed relay URL to the relay list to ensure it gets the update
10. Returns a publishThunk with the event and relays

related: Thunk

import/access examples:
import { removeRelay } from '@welshman/app';
import { removeRelay } from '@welshman/app/commands';


=========================
workspace: packages/app
file: packages/app/src/commands.ts
lines: 72:83
id: b68356cd321683a4c420437a83b2805c896cd41d2363d1924fe24ac2caefc74a
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/commands.ts#L72

declaration:
addRelay = async (url: string, mode: RelayMode) => {
  await loadUserRelaySelections([], true)

  const list = get(userRelaySelections) || makeList({kind: RELAYS})
  const dup = getRelayTags(getListTags(list)).find(nthEq(1, url))
  const tag = removeNil(["r", url, dup && dup[2] !== mode ? undefined : mode])
  const tags = [...list.publicTags.filter(nthNe(1, url)), tag]
  const event = {kind: list.kind, content: list.event?.content || "", tags}
  const relays = Router.get().FromUser().policy(addMaximalFallbacks).getUrls()

  return publishThunk({event, relays})
}

summary:
Adds a relay URL with a specified mode (read or write) to the user's relay selections. This function updates the user's NIP-65 relay list and publishes the updated list to the network. It takes a URL string and a RelayMode enum value as parameters and returns a thunk that can be executed to publish the event.

details:
Implementation details:
1. Loads the user's current relay selections with `loadUserRelaySelections`
2. Gets the current relay list or creates a new one if none exists
3. Checks if the relay URL already exists in the list to handle duplicates
4. Creates a new relay tag with the format ["r", url, mode], removing nil values
5. Builds a new tags array by filtering out any existing entries with the same URL and adding the new tag
6. Constructs a new event with the updated tags
7. Determines appropriate relays to publish to using the Router with maximal fallbacks policy
8. Returns a publishThunk with the event and relays for execution

related: Thunk

import/access examples:
import { addRelay } from '@welshman/app';
import { addRelay } from '@welshman/app/commands';


=========================
workspace: packages/app
file: packages/app/src/commands.ts
lines: 87:95
id: dbae1f6f6f94cabdac69516809938101e7b1f2718bc9c0d5f93ed52bca519798
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/commands.ts#L87

declaration:
removeInboxRelay = async (url: string) => {
  await loadUserInboxRelaySelections([], true)

  const list = get(userInboxRelaySelections) || makeList({kind: INBOX_RELAYS})
  const event = await removeFromList(list, url).reconcile(nip44EncryptToSelf)
  const relays = Router.get().FromUser().policy(addMaximalFallbacks).getUrls()

  return publishThunk({event, relays})
}

summary:
Removes a relay from the user's inbox relay selections. This function takes a URL string as input and returns a thunk that, when executed, will publish an event to remove the specified relay from the user's inbox relay list (NIP-17).

details:
Implementation details:
1. First loads the user's current inbox relay selections with `loadUserInboxRelaySelections`
2. Gets the current inbox relay list from the store or creates a new one if none exists
3. Uses `removeFromList` to create an event that removes the specified URL from the list
4. Encrypts the content to self using NIP-44 encryption via the `reconcile` method
5. Determines appropriate relays to publish to using the Router's FromUser policy with maximal fallbacks
6. Returns a publishThunk with the created event and relay list for actual publishing

related: Thunk

import/access examples:
import { removeInboxRelay } from '@welshman/app';
import { removeInboxRelay } from '@welshman/app/commands';


=========================
workspace: packages/app
file: packages/app/src/commands.ts
lines: 97:105
id: 45a7e49acf7a89eeaac932837050ac9c911a3e20c918a51cf730c9b8d13f443f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/commands.ts#L97

declaration:
addInboxRelay = async (url: string) => {
  await loadUserInboxRelaySelections([], true)

  const list = get(userInboxRelaySelections) || makeList({kind: INBOX_RELAYS})
  const event = await addToListPublicly(list, ["relay", url]).reconcile(nip44EncryptToSelf)
  const relays = Router.get().FromUser().policy(addMaximalFallbacks).getUrls()

  return publishThunk({event, relays})
}

summary:
Adds a relay URL to the user's inbox relay selections list (NIP-17). This function takes a relay URL as input and publishes an event that adds the relay to the user's inbox relay list. The event is published to relays determined by the user's relay policy.

details:
Implementation details:
1. Loads the user's current inbox relay selections with `loadUserInboxRelaySelections`
2. Gets the current inbox relay list from the store or creates a new one if none exists
3. Adds the relay URL to the list publicly using `addToListPublicly` with a tag format of ["relay", url]
4. Encrypts the content to self using NIP-44 encryption via the `reconcile` method
5. Determines which relays to publish to using the Router's FromUser policy with maximal fallbacks
6. Returns a thunk that will publish the event when executed

related: Thunk

import/access examples:
import { addInboxRelay } from '@welshman/app';
import { addInboxRelay } from '@welshman/app/commands';


=========================
workspace: packages/app
file: packages/app/src/commands.ts
lines: 109:115
id: c035d210c10325340d08e4debfc45a9d54289d7fc8fde18e4bac45ce0cb6dd26
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/commands.ts#L109

declaration:
setProfile = (profile: Profile) => {
  const router = Router.get()
  const relays = router.merge([router.Index(), router.FromUser()]).getUrls()
  const event = isPublishedProfile(profile) ? editProfile(profile) : createProfile(profile)

  return publishThunk({event, relays})
}

summary:
A function that updates or creates a user's profile on the Nostr network. It takes a Profile object as input and publishes it to both index relays and the user's own relays. The function automatically determines whether to create a new profile or edit an existing one based on the provided profile data.

details:
Implementation details:
1. Gets the router instance using Router.get()
2. Merges index relays and user relays to determine where to publish the profile
3. Checks if the profile already exists using isPublishedProfile()
4. Based on the check, either calls editProfile() or createProfile() to prepare the event
5. Uses publishThunk() to handle the actual publishing of the event to the network

This function is part of the NIP-01 implementation for basic profile management.

related: Thunk

import/access examples:
import { setProfile } from '@welshman/app';
import { setProfile } from '@welshman/app/commands';


=========================
workspace: packages/app
file: packages/app/src/commands.ts
lines: 119:127
id: 9f547318861bc381abac570b6feca73d6a74fa9b40b5c478cb53be05c881aee6
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/commands.ts#L119

declaration:
unfollow = async (value: string) => {
  await loadUserFollows([], true)

  const list = get(userFollows) || makeList({kind: FOLLOWS})
  const event = await removeFromList(list, value).reconcile(nip44EncryptToSelf)
  const relays = Router.get().FromUser().policy(addMaximalFallbacks).getUrls()

  return publishThunk({event, relays})
}

summary:
Asynchronous function that allows a user to unfollow another user by removing them from their follows list. It takes a string value (typically a pubkey) to unfollow and returns a thunk that will publish the updated follows list to the user's relays.

details:
Implementation details:
1. First loads the user's current follows list with `loadUserFollows([], true)` to ensure fresh data
2. Gets the current follows list from the store or creates a new one if none exists
3. Removes the specified value from the list using `removeFromList()` and reconciles the changes with self-encryption
4. Determines appropriate relays to publish to using the Router's FromUser policy with maximal fallbacks
5. Returns a publishThunk with the updated event and relay list for actual publishing

This function implements NIP-02 (Contact List and Petnames) functionality for the unfollow action.

related: Thunk

import/access examples:
import { unfollow } from '@welshman/app';
import { unfollow } from '@welshman/app/commands';


=========================
workspace: packages/app
file: packages/app/src/commands.ts
lines: 129:137
id: d597b00cab150c0a67324b17371a19ddb10fe85d550753a24ab528c7572e042f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/commands.ts#L129

declaration:
follow = async (tag: string[]) => {
  await loadUserFollows([], true)

  const list = get(userFollows) || makeList({kind: FOLLOWS})
  const event = await addToListPublicly(list, tag).reconcile(nip44EncryptToSelf)
  const relays = Router.get().FromUser().policy(addMaximalFallbacks).getUrls()

  return publishThunk({event, relays})
}

summary:
Follows a user or entity by adding a tag to the user's follow list. This function implements NIP-02 (Contact List and Petnames) functionality.

Parameters:
- tag: string[] - The tag array to add to the follow list, typically in the format ['p', 'pubkey', 'petname?']

Returns:
- A thunk that when executed will publish the updated follow list to the user's relays.

details:
Implementation details:
1. Loads the user's current follows list with loadUserFollows(), ensuring fresh data
2. Gets the current follows list from the store or creates a new one if none exists
3. Adds the provided tag publicly to the list using addToListPublicly()
4. Encrypts sensitive parts to self using nip44EncryptToSelf during reconciliation
5. Determines appropriate relays to publish to using the Router with FromUser policy and maximal fallbacks
6. Returns a publishThunk that will handle the actual publishing of the event when executed

related: Thunk

import/access examples:
import { follow } from '@welshman/app';
import { follow } from '@welshman/app/commands';


=========================
workspace: packages/app
file: packages/app/src/commands.ts
lines: 139:147
id: 1ed4a5cee391817f4f8424e538151777f5d82aa47dc15235fdb9119351b7ed7a
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/commands.ts#L139

declaration:
unmute = async (value: string) => {
  await loadUserMutes([], true)

  const list = get(userMutes) || makeList({kind: MUTES})
  const event = await removeFromList(list, value).reconcile(nip44EncryptToSelf)
  const relays = Router.get().FromUser().policy(addMaximalFallbacks).getUrls()

  return publishThunk({event, relays})
}

summary:
Asynchronous function that removes a specified value from the user's mute list. It takes a string parameter 'value' representing the identifier to unmute and returns a thunk that, when executed, will publish the unmute event to the user's relays.

details:
Implementation details:
1. First loads the user's mutes list with `loadUserMutes([], true)` to ensure fresh data
2. Gets the current mute list from the store or creates a new one if none exists
3. Removes the specified value from the list using `removeFromList`
4. Encrypts the updated list to self using NIP-44 encryption via the `reconcile` method
5. Determines appropriate relays using the router's FromUser policy with maximal fallbacks
6. Returns a publishable thunk containing the event and target relays

This function is part of the NIP-02 implementation for contact list management, specifically handling the removal of entries from a user's mute list.

related: Thunk

import/access examples:
import { unmute } from '@welshman/app';
import { unmute } from '@welshman/app/commands';


=========================
workspace: packages/app
file: packages/app/src/commands.ts
lines: 149:157
id: 2dfa6cbdf8986cb4c11dd7388da38397d971728da9d286dcbd07b6b074633c6c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/commands.ts#L149

declaration:
mutePublicly = async (tag: string[]) => {
  await loadUserMutes([], true)

  const list = get(userMutes) || makeList({kind: MUTES})
  const event = await addToListPublicly(list, tag).reconcile(nip44EncryptToSelf)
  const relays = Router.get().FromUser().policy(addMaximalFallbacks).getUrls()

  return publishThunk({event, relays})
}

summary:
Asynchronous function that publicly mutes a user or content identified by the provided tag. It adds the tag to the user's mute list and publishes this update to the user's relays. The function returns a thunk that can be used to track the publishing process.

details:
Implementation details:
1. First loads the user's current mutes list with `loadUserMutes([], true)` to ensure fresh data
2. Gets the current mutes list from the store or creates a new one if none exists
3. Adds the provided tag to the mute list publicly using `addToListPublicly`
4. Encrypts sensitive parts of the list to self using `reconcile(nip44EncryptToSelf)`
5. Determines appropriate relays to publish to using the Router's FromUser policy with maximal fallbacks
6. Returns a publishThunk with the created event and relay list for actual publishing

related: Thunk

import/access examples:
import { mutePublicly } from '@welshman/app';
import { mutePublicly } from '@welshman/app/commands';


=========================
workspace: packages/app
file: packages/app/src/commands.ts
lines: 159:167
id: dce8b24541e5ab6e7f46fa4152a4369c081406fdf0ae0d289f97c91d1a4c232e
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/commands.ts#L159

declaration:
mutePrivately = async (tag: string[]) => {
  await loadUserMutes([], true)

  const list = get(userMutes) || makeList({kind: MUTES})
  const event = await addToListPrivately(list, tag).reconcile(nip44EncryptToSelf)
  const relays = Router.get().FromUser().policy(addMaximalFallbacks).getUrls()

  return publishThunk({event, relays})
}

summary:
Asynchronous function that privately adds a tag to the user's mute list. It takes a string array parameter 'tag' representing the entity to be muted, and returns a thunk that when executed will publish the updated mute list to the user's relays.

details:
Implementation details:
1. First loads the user's current mutes with `loadUserMutes([], true)` to ensure fresh data
2. Gets the current mute list from the store or creates a new one if none exists
3. Uses `addToListPrivately` to add the tag to the private section of the list
4. Encrypts the list to self using NIP-44 encryption via the `reconcile` method
5. Determines appropriate relays using the Router's FromUser policy with maximal fallbacks
6. Returns a publishThunk that will handle the actual publishing of the event when executed

related: Thunk

import/access examples:
import { mutePrivately } from '@welshman/app';
import { mutePrivately } from '@welshman/app/commands';


=========================
workspace: packages/app
file: packages/app/src/commands.ts
lines: 169:183
id: deb08841e7200c623701270db7e656cf87115744fe19543c007e409aa1d9a3ed
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/commands.ts#L169

declaration:
setMutes = async ({
  publicTags,
  privateTags,
}: {
  publicTags?: string[][]
  privateTags?: string[][]
}) => {
  await loadUserMutes([], true)

  const list = get(userMutes) || makeList({kind: MUTES})
  const event = await updateList(list, {publicTags, privateTags}).reconcile(nip44EncryptToSelf)
  const relays = Router.get().FromUser().policy(addMaximalFallbacks).getUrls()

  return publishThunk({event, relays})
}

summary:
Updates a user's mute list with specified public and private tags. This function allows for batch updating of mute preferences.

Parameters:
- An object containing:
  - publicTags?: string[][] - Optional array of tags to be publicly visible in the mute list
  - privateTags?: string[][] - Optional array of tags to be kept private in the mute list

Returns: A thunk that when executed will publish the updated mute list to appropriate relays.

details:
Implementation details:
1. Loads the current user mutes with `loadUserMutes([], true)` to ensure fresh data
2. Gets the current mute list from the store or creates a new one if none exists
3. Updates the list using the `updateList` utility with the provided public and private tags
4. Encrypts private content using `nip44EncryptToSelf` through the reconcile method
5. Determines appropriate relays using the Router's FromUser policy with maximal fallbacks
6. Returns a publishThunk that will handle the actual publishing of the event when executed

related: Thunk

import/access examples:
import { setMutes } from '@welshman/app';
import { setMutes } from '@welshman/app/commands';


=========================
workspace: packages/app
file: packages/app/src/commands.ts
lines: 185:193
id: c660b9d95e871bd99fb1c873177bb5e7c4eadd426cde231ec5bc2f732e7bb577
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/commands.ts#L185

declaration:
unpin = async (value: string) => {
  await loadUserPins([], true)

  const list = get(userPins) || makeList({kind: PINS})
  const event = await removeFromList(list, value).reconcile(nip44EncryptToSelf)
  const relays = Router.get().FromUser().policy(addMaximalFallbacks).getUrls()

  return publishThunk({event, relays})
}

summary:
Removes a pinned item from the user's pins list. Takes a string value identifying the item to unpin and returns a thunk that, when executed, will publish the updated pins list to the user's relays.

details:
Implementation details:
1. Loads the user's pins list with `loadUserPins([], true)` to ensure fresh data
2. Gets the current pins list from the store or creates a new one if none exists
3. Removes the specified value from the list using `removeFromList`
4. Encrypts the updated list to self using NIP-44 encryption via the `reconcile` method
5. Determines appropriate relays to publish to using the Router's FromUser policy with maximal fallbacks
6. Returns a publishThunk with the updated event and relay list for actual publication

related: Thunk

import/access examples:
import { unpin } from '@welshman/app';
import { unpin } from '@welshman/app/commands';


=========================
workspace: packages/app
file: packages/app/src/commands.ts
lines: 195:203
id: 9bab0c2f4347f35b9c0a0722a8a3c816723b44c2c570e852beaf7b7c3e9c1ea2
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/commands.ts#L195

declaration:
pin = async (tag: string[]) => {
  await loadUserPins([], true)

  const list = get(userPins) || makeList({kind: PINS})
  const event = await addToListPublicly(list, tag).reconcile(nip44EncryptToSelf)
  const relays = Router.get().FromUser().policy(addMaximalFallbacks).getUrls()

  return publishThunk({event, relays})
}

summary:
Pins a tag to the user's pins list. This function adds a specified tag to the user's pins list and publishes the updated list to the user's relays. It takes a string array representing the tag to be pinned and returns a thunk that, when executed, will publish the pin event to the network.

details:
Implementation details:
1. Loads the user's pins list with `loadUserPins([], true)` to ensure fresh data
2. Gets the current pins list from the store or creates a new one if none exists
3. Adds the provided tag publicly to the list using `addToListPublicly`
4. Encrypts sensitive data to self using `reconcile(nip44EncryptToSelf)`
5. Determines appropriate relays using the router with fallback policy
6. Returns a publishThunk with the event and relays for actual publishing

The function is part of the user's content management system, specifically handling pin operations according to Nostr protocol standards.

related: Thunk

import/access examples:
import { pin } from '@welshman/app';
import { pin } from '@welshman/app/commands';


=========================
workspace: packages/app
file: packages/app/src/commands.ts
lines: 207:210
id: 60749a3f612bf203541d7161316135c811a9d279bdfff0d69551780e71dd6b7e
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/commands.ts#L207

declaration:
export type SendWrappedOptions = Omit<ThunkOptions, "event" | "relays"> & {
  template: EventTemplate
  pubkeys: string[]
}

summary:
A TypeScript type alias that defines the options for sending wrapped events according to NIP-59 protocol. It extends ThunkOptions by omitting 'event' and 'relays' properties while adding 'template' (an EventTemplate) and 'pubkeys' (an array of strings representing public keys of recipients).

details:
This type alias is used to define the parameter structure for the `sendWrapped` function that implements NIP-59 functionality. It combines:

1. All properties from ThunkOptions except 'event' and 'relays' (which will be determined by the function)
2. A required 'template' property of type EventTemplate that defines the event to be wrapped
3. A required 'pubkeys' property that contains an array of recipient public keys

The type is designed to provide a clean interface for the sendWrapped function which handles the encryption and distribution of wrapped events to multiple recipients.

related: ThunkOptions

import/access examples:
import type { SendWrappedOptions } from '@welshman/app';
import type { SendWrappedOptions } from '@welshman/app/commands';


=========================
workspace: packages/app
file: packages/app/src/commands.ts
lines: 212:226
id: cde18b34f9f0f95cc0018a810b25071519511b5efe714837797771ddc339e42e
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/commands.ts#L212

declaration:
sendWrapped = async ({template, pubkeys, ...options}: SendWrappedOptions) => {
  const nip59 = Nip59.fromSigner(signer.get()!)

  return new MergedThunk(
    await Promise.all(
      uniq(pubkeys).map(async recipient =>
        publishThunk({
          event: await nip59.wrap(recipient, stamp(template)),
          relays: Router.get().PubkeyInbox(recipient).getUrls(),
          ...options,
        }),
      ),
    ),
  )
}

summary:
Sends a wrapped event to multiple recipients using NIP-59 encryption. This function takes an event template, an array of public keys (recipients), and additional options. It creates a separate wrapped event for each recipient and publishes them to the appropriate inbox relays for each recipient.

details:
Implementation details:
1. Creates a NIP-59 instance from the current user's signer
2. Uses Promise.all to process all recipients in parallel
3. For each recipient:
   - Applies uniq() to ensure no duplicate recipients
   - Wraps the event using NIP-59 encryption (nip59.wrap)
   - Stamps the template with metadata before wrapping
   - Determines appropriate relays using Router.PubkeyInbox
   - Publishes the wrapped event using publishThunk
4. Returns a MergedThunk that combines all the individual publishing operations

related: SendWrappedOptions,MergedThunk

import/access examples:
import { sendWrapped } from '@welshman/app';
import { sendWrapped } from '@welshman/app/commands';


=========================
workspace: packages/app
file: packages/app/src/commands.ts
lines: 230:237
id: 0b0588f6aa3d5bd15eb60966953ae26b51d68742fdd234b934f1692da9963754
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/commands.ts#L230

declaration:
manageRelay = async (url: string, request: ManagementRequest) => {
  url = url.replace(/^ws/, "http")

  const authTemplate = await makeHttpAuth(url, "POST", JSON.stringify(request))
  const authEvent = await signer.get()!.sign(authTemplate)

  return sendManagementRequest(url, request, authEvent)
}

summary:
Asynchronous function that manages a relay by sending a management request to the specified URL. It takes a URL string and a ManagementRequest object as parameters, and returns the result of sending the management request with proper authentication.

details:
Implementation details:
1. Converts WebSocket URLs to HTTP URLs by replacing 'ws' with 'http' at the beginning of the URL
2. Creates an HTTP authentication template using makeHttpAuth with the URL, POST method, and stringified request
3. Signs the authentication template using the current signer
4. Sends the management request to the URL with the original request and signed authentication event

This function implements NIP-86 (HTTP Auth) to authenticate relay management operations.

import/access examples:
import { manageRelay } from '@welshman/app';
import { manageRelay } from '@welshman/app/commands';


=========================
workspace: packages/app
file: packages/app/src/commands.ts
lines: 241:242
id: cccd42633c3ea0aa378c3c3645ac111be46bf1b5fa0be2a5397bb8f7d68ded14
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/commands.ts#L241

declaration:
createRoom = (url: string, room: RoomMeta) =>
  publishThunk({event: makeRoomCreateEvent(room), relays: [url]})

summary:
Creates a new room on a specified relay according to NIP-29 protocol. Takes a relay URL and room metadata as parameters and returns a thunk that, when executed, will publish the room creation event to the specified relay.

details:
This function is a simple wrapper around the publishThunk function. It:
1. Takes a relay URL and room metadata as input
2. Creates a room creation event using makeRoomCreateEvent with the provided room metadata
3. Returns a thunk that will publish this event to the specified relay when executed

The implementation is straightforward with no complex logic - it's essentially a one-liner that composes other functions.

related: __function,publishThunk,Thunk

import/access examples:
import { createRoom } from '@welshman/app';
import { createRoom } from '@welshman/app/commands';


=========================
workspace: packages/app
file: packages/app/src/commands.ts
lines: 244:245
id: 490742e6f4ebf059e101a0ef9586e78fb77384cf5c41ebaf2bc364d4b7779156
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/commands.ts#L244

declaration:
deleteRoom = (url: string, room: RoomMeta) =>
  publishThunk({event: makeRoomDeleteEvent(room), relays: [url]})

summary:
Deletes a NIP‑29 chat room. Takes the relay URL (`url`) and a `RoomMeta` object describing the room to delete. It creates a room‑delete event via `makeRoomDeleteEvent` and publishes it to the specified relay using `publishThunk`. Returns the thunk (or promise) produced by `publishThunk` which resolves when the delete event has been sent.

details:
The function is a thin wrapper: it calls `makeRoomDeleteEvent(room)` to build the appropriate delete event, then invokes `publishThunk({event, relays: [url]})` with the event and a single‑element relay list. No additional logic or side‑effects are performed beyond delegating to these utilities.

related: __function,publishThunk,Thunk

import/access examples:
import { deleteRoom } from '@welshman/app';
import { deleteRoom } from '@welshman/app/commands';


=========================
workspace: packages/app
file: packages/app/src/commands.ts
lines: 247:248
id: f29bedeac2ec23284357252e3bba6955660750dc980298583afaa45f1b4115e5
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/commands.ts#L247

declaration:
editRoom = (url: string, room: RoomMeta) =>
  publishThunk({event: makeRoomEditEvent(room), relays: [url]})

summary:
A function that publishes an event to edit a room's metadata on a specific relay. It takes a relay URL and room metadata as parameters and returns a thunk that, when executed, will publish the room edit event to the specified relay.

details:
This function creates a thunk for publishing a room edit event (NIP-29) to a single relay. It works by:
1. Taking the relay URL and room metadata as inputs
2. Using the makeRoomEditEvent utility to create the appropriate event object from the room metadata
3. Configuring the thunk to publish only to the specified relay URL
4. Returning the thunk which will handle the actual publishing when executed

related: __function,publishThunk,Thunk

import/access examples:
import { editRoom } from '@welshman/app';
import { editRoom } from '@welshman/app/commands';


=========================
workspace: packages/app
file: packages/app/src/commands.ts
lines: 250:251
id: 219b4ee60cd824b79174b22d2bfb943b470fbb10cbed2ce27d58720325ffd8f8
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/commands.ts#L250

declaration:
joinRoom = (url: string, room: RoomMeta) =>
  publishThunk({event: makeRoomJoinEvent(room), relays: [url]})

summary:
A function that creates and publishes a room join event to a specified relay. It takes a relay URL and room metadata as parameters and returns a thunk that will publish the join event to the relay.

details:
This function implements the NIP-29 protocol for joining a chat room. It works by:
1. Taking the relay URL and room metadata as inputs
2. Creating a room join event using the `makeRoomJoinEvent` utility function
3. Publishing this event specifically to the relay URL provided
4. Returning a thunk (delayed execution object) via `publishThunk` that handles the actual publishing process

related: __function,publishThunk,Thunk

import/access examples:
import { joinRoom } from '@welshman/app';
import { joinRoom } from '@welshman/app/commands';


=========================
workspace: packages/app
file: packages/app/src/commands.ts
lines: 253:254
id: f467f03aafa3a7e38e01175e5a84fb32782f9e477c2f4a6d2afe42e5bcbff799
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/commands.ts#L253

declaration:
leaveRoom = (url: string, room: RoomMeta) =>
  publishThunk({event: makeRoomLeaveEvent(room), relays: [url]})

summary:
A function that creates and publishes a room leave event to a specified relay. It takes a relay URL and room metadata as parameters and returns a thunk that will publish the leave event when executed.

details:
This function is part of the NIP-29 (Relay-specific Chat Rooms) implementation. It works by:
1. Taking the relay URL and room metadata as inputs
2. Creating a room leave event using the makeRoomLeaveEvent utility function
3. Returning a publishThunk with the created event and targeting only the specified relay

The implementation is straightforward - it's a one-liner arrow function that wraps the event creation and publishing process.

related: __function,publishThunk,Thunk

import/access examples:
import { leaveRoom } from '@welshman/app';
import { leaveRoom } from '@welshman/app/commands';


=========================
workspace: packages/app
file: packages/app/src/context.ts
lines: 1:3
id: 6fb12f12841d2a0f53206aa188202d860181aa5e10d807572bc0a2d087a6f753
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/context.ts#L1

declaration:
export type AppContext = {
  dufflepudUrl?: string
}

summary:
A type definition for the application context. It defines an object structure with an optional `dufflepudUrl` string property that can be used to configure the URL for the Dufflepud service.

details:
This is a simple TypeScript type alias that defines the shape of the application context. It contains only one optional property: `dufflepudUrl` which is a string. The implementation is straightforward with no complex logic.

import/access examples:
import type { AppContext } from '@welshman/app';
import type { AppContext } from '@welshman/app/context';


=========================
workspace: packages/app
file: packages/app/src/context.ts
lines: 5:5
id: 0f839556c31b56ecb51c053aed3da691c9afe4bded72c9b51377c99e263abea7
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/context.ts#L5

declaration:
appContext: AppContext = {}

summary:
A global variable of type AppContext that stores application-wide configuration. It's initialized as an empty object and can potentially hold a dufflepudUrl property.

details:
The implementation is straightforward - it's a simple constant declaration that initializes an empty object literal as the application context. The object is exported, allowing it to be imported and modified by other modules in the application.

related: AppContext

import/access examples:
import { appContext } from '@welshman/app';
import { appContext } from '@welshman/app/context';


=========================
workspace: packages/app
file: packages/app/src/feeds.ts
lines: 5:24
id: 9534b294aa192676e0a2daa423294ea6316f3da5664d674278e48e9db6f7e97f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/feeds.ts#L5

declaration:
getPubkeysForScope = (scope: string) => {
  const $pubkey = pubkey.get()

  if (!$pubkey) {
    return []
  }

  switch (scope) {
    case Scope.Self:
      return [$pubkey]
    case Scope.Follows:
      return getFollows($pubkey)
    case Scope.Network:
      return getNetwork($pubkey)
    case Scope.Followers:
      return getFollowers($pubkey)
    default:
      return []
  }
}

summary:
A function that returns an array of public keys based on the provided scope. It takes a string parameter 'scope' which should match one of the predefined Scope values (Self, Follows, Network, Followers). Returns an empty array if no user public key is available or if the scope is not recognized.

details:
The implementation:
1. Retrieves the current user's public key using pubkey.get()
2. Returns an empty array if no public key is available
3. Uses a switch statement to handle different scope values:
   - For Scope.Self: Returns an array containing only the user's public key
   - For Scope.Follows: Calls getFollows() to get public keys of accounts the user follows
   - For Scope.Network: Calls getNetwork() to get public keys in the user's network
   - For Scope.Followers: Calls getFollowers() to get public keys of accounts following the user
   - Default case: Returns an empty array for unrecognized scopes

import/access examples:
import { getPubkeysForScope } from '@welshman/app';
import { getPubkeysForScope } from '@welshman/app/feeds';


=========================
workspace: packages/app
file: packages/app/src/feeds.ts
lines: 26:38
id: 5e3a9043ec236b5c6a9e63745a7e0d41b14d8a89a31b243e4d9bb88eca16a91f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/feeds.ts#L26

declaration:
getPubkeysForWOTRange = (min: number, max: number) => {
  const pubkeys = []
  const thresholdMin = maxWot.get() * min
  const thresholdMax = maxWot.get() * max

  for (const [tpk, score] of wotGraph.get().entries()) {
    if (score >= thresholdMin && score <= thresholdMax) {
      pubkeys.push(tpk)
    }
  }

  return pubkeys
}

summary:
A function that retrieves public keys based on a specified range within the Web of Trust (WOT) score. It accepts minimum and maximum values (as decimals between 0 and 1) and returns an array of public keys whose WOT scores fall within the calculated threshold range.

details:
The implementation:
1. Creates an empty array to store matching public keys
2. Calculates threshold values by multiplying the input min/max values by the maximum WOT score
3. Iterates through the WOT graph entries (which contain public keys and their scores)
4. For each entry, checks if the score is within the calculated threshold range
5. If a public key's score is within range, adds it to the result array
6. Returns the collected public keys

The function relies on external state through `maxWot.get()` and `wotGraph.get()` to access the current maximum WOT score and the graph of WOT relationships.

import/access examples:
import { getPubkeysForWOTRange } from '@welshman/app';
import { getPubkeysForWOTRange } from '@welshman/app/feeds';


=========================
workspace: packages/app
file: packages/app/src/feeds.ts
lines: 40:40
id: 997ec6fe7beefb3d46cb7318f6d4a2d3c378b0bd16e5ad2685df45ba4b219654
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/feeds.ts#L40

declaration:
type MakeFeedControllerOptions = Partial<Omit<FeedControllerOptions, "feed">> & {feed: Feed}

summary:
A type alias that defines the options for creating a feed controller. It extends the `FeedControllerOptions` type from the `@welshman/feeds` package, making all properties optional except for `feed`, which remains required.

details:
This type uses TypeScript's utility types to create a modified version of `FeedControllerOptions`. It uses `Partial<Omit<FeedControllerOptions, "feed">>` to make all properties of `FeedControllerOptions` optional except for `feed`, which is explicitly excluded with `Omit`. Then it intersects this with `{feed: Feed}` to ensure that `feed` is still required in the resulting type.

=========================
workspace: packages/app
file: packages/app/src/feeds.ts
lines: 42:43
id: 43fa1182ad323547c2c5388a3fa46642d1e3b899f8e01ce046d31a580304532f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/feeds.ts#L42

declaration:
makeFeedController = (options: MakeFeedControllerOptions) =>
  new FeedController({getPubkeysForScope, getPubkeysForWOTRange, signer: signer.get(), ...options})

summary:
Creates and returns a new FeedController instance with the provided options. This function simplifies the creation of feed controllers by automatically injecting utility functions for scope resolution and WOT (Web of Trust) range calculations, along with the current signer.

details:
The implementation is straightforward:
1. Takes a MakeFeedControllerOptions object that must include a 'feed' property while other FeedControllerOptions properties are optional
2. Creates a new FeedController with:
   - The getPubkeysForScope function from the same module
   - The getPubkeysForWOTRange function from the same module
   - The current signer obtained from signer.get()
   - All properties from the passed options object
3. Returns the instantiated FeedController

related: FeedController,MakeFeedControllerOptions

import/access examples:
import { makeFeedController } from '@welshman/app';
import { makeFeedController } from '@welshman/app/feeds';


=========================
workspace: packages/app
file: packages/app/src/handles.ts
lines: 7:12
id: 5b7f94f979c6de1bef4df340de07c3d5a1f3ddb3b0e8df3e5490e479bb57577e
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/handles.ts#L7

declaration:
export type Handle = {
  nip05: string
  pubkey?: string
  nip46?: string[]
  relays?: string[]
}

summary:
The `Handle` type represents a Nostr identifier with NIP-05 verification. It contains a required NIP-05 string (user@domain format) and optional fields for the public key, NIP-46 bunker URLs, and relay URLs associated with the identity.

details:
This type definition is a core data structure for managing Nostr identities in the application. It contains:
1. `nip05`: A required string in the format 'username@domain' that serves as the primary identifier
2. `pubkey`: An optional hexadecimal string representing the user's Nostr public key
3. `nip46`: An optional array of strings containing NIP-46 bunker URLs
4. `relays`: An optional array of strings containing relay URLs

This structure is used throughout the application to represent verified Nostr identities and their associated connection information.

import/access examples:
import type { Handle } from '@welshman/app';
import type { Handle } from '@welshman/app/handles';


=========================
workspace: packages/app
file: packages/app/src/handles.ts
lines: 14:14
id: 7151da3d93e1a2f3aedeeb96c76ced7daa3fdcd8f7d7361b7e488ae6bb5d9aa4
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/handles.ts#L14

declaration:
NIP05_REGEX = /^(?:([\w.+-]+)@)?([\w_-]+(\.[\w_-]+)+)$/

summary:
A regular expression constant used to validate and parse NIP-05 identifiers. NIP-05 identifiers are formatted as 'name@domain.tld' or just 'domain.tld' (which implies '_@domain.tld'). The regex captures the name part (optional) and the domain part separately.

details:
This regex pattern breaks down as follows:
1. `^` - Start of string
2. `(?:([\w.+-]+)@)?` - Optional group capturing the username part before the '@' symbol, which can contain alphanumeric characters, dots, plus signs, and hyphens
3. `([\w_-]+(\.[\w_-]+)+)` - Captures the domain part, which must have at least one dot separator and consist of alphanumeric characters, underscores, and hyphens
4. `$` - End of string

The regex is used in functions like `queryProfile` to validate and extract components from NIP-05 identifiers.

import/access examples:
import { NIP05_REGEX } from '@welshman/app';
import { NIP05_REGEX } from '@welshman/app/handles';


=========================
workspace: packages/app
file: packages/app/src/handles.ts
lines: 16:45
id: a43bea50a084c3393eb418eae55065efeb757a12c0b6d7a82434bae5846cd9db
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/handles.ts#L16

declaration:
export async function queryProfile(nip05: string)

summary:
Asynchronously queries a Nostr profile using a NIP-05 identifier (similar to an email address). It takes a NIP-05 string (e.g., 'name@domain.com') and returns a Handle object containing the pubkey, NIP-46 bunker URLs, and relays associated with that identifier. Returns undefined if the NIP-05 is invalid or if the query fails.

details:
The function works by:
1. Validating the NIP-05 string against a regex pattern
2. Extracting the name (defaulting to '_' if not provided) and domain parts
3. Fetching the .well-known/nostr.json file from the domain
4. Extracting the pubkey, relays, and NIP-46 information from the response
5. Constructing and returning a Handle object with the gathered information

The function handles errors gracefully, returning undefined if any part of the process fails (invalid format, network error, missing pubkey, etc.).

code:
export async function queryProfile(nip05: string) {
  const match = nip05.match(NIP05_REGEX)

  if (!match) return undefined

  const [_, name = "_", domain] = match

  try {
    const {
      names,
      relays = {},
      nip46 = {},
    } = await fetchJson(`https://${domain}/.well-known/nostr.json?name=${name}`)

    const pubkey = names[name]

    if (!pubkey) {
      return undefined
    }

    return {
      nip05,
      pubkey,
      nip46: nip46[pubkey],
      relays: relays[pubkey],
    }
  } catch (_e) {
    return undefined
  }
}

import/access examples:
import { queryProfile } from '@welshman/app';
import { queryProfile } from '@welshman/app/handles';


=========================
workspace: packages/app
file: packages/app/src/handles.ts
lines: 47:47
id: 8dccabf9dcc6c9237daaa549140140c38c789a2ebc5501dd6d716fad49c9e967
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/handles.ts#L47

declaration:
handles = writable<Handle[]>([])

summary:
A writable Svelte store that holds an array of Handle objects. Each Handle represents a Nostr user with NIP-05 identifier and optional pubkey, NIP-46 endpoints, and relays. This store is exported and can be subscribed to for reactive updates to the handles collection.

details:
This variable initializes a writable Svelte store with an empty array as its initial value. The store is typed to contain Handle objects, which are defined earlier in the file. This store serves as the central data structure for the handles collection system and is used by the collection utility to create derived stores and helper functions (as seen later in the file with handlesByNip05, deriveHandle, etc.). The store's contents can be updated through various functions in this module, particularly through the loadHandle function that ultimately calls the fetchHandles function to retrieve handle information.

related: writable

import/access examples:
import { handles } from '@welshman/app';
import { handles } from '@welshman/app/handles';


=========================
workspace: packages/app
file: packages/app/src/handles.ts
lines: 49:80
id: 448e2da889c82fa00d0fdcf4bc31f317dfd2601d794fdeee45164ff5e694b0d2
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/handles.ts#L49

declaration:
fetchHandles = async (nip05s: string[]) => {
  const base = appContext.dufflepudUrl!
  const handlesByNip05 = new Map<string, Handle>()

  // Use dufflepud if we it's set up to protect user privacy, otherwise fetch directly
  if (base) {
    const res: any = await tryCatch(
      async () => await postJson(`${base}/handle/info`, {handles: nip05s}),
    )

    for (const {handle: nip05, info} of res?.data || []) {
      if (info) {
        handlesByNip05.set(nip05, info)
      }
    }
  } else {
    const results = await Promise.all(
      nip05s.map(async nip05 => ({
        nip05,
        info: await tryCatch(async () => await queryProfile(nip05)),
      })),
    )

    for (const {nip05, info} of results) {
      if (info) {
        handlesByNip05.set(nip05, info)
      }
    }
  }

  return handlesByNip05
}

summary:
Asynchronously fetches handle information for a list of NIP-05 identifiers. It attempts to retrieve pubkey, NIP-46, and relay information for each handle. The function prioritizes using a privacy-preserving 'dufflepud' service if available, otherwise falls back to direct queries. Returns a Map with NIP-05 identifiers as keys and Handle objects as values.

details:
The implementation works in two possible ways depending on configuration:

1. If dufflepudUrl is configured in appContext:
   - Makes a batch POST request to the dufflepud service with all handles
   - Processes the response and extracts handle information
   - This approach protects user privacy by proxying requests

2. If dufflepudUrl is not available:
   - Falls back to direct queries using Promise.all with the queryProfile function
   - Makes parallel requests for each NIP-05 identifier

In both cases, the function:
- Uses tryCatch for error handling
- Collects successful responses in a Map
- Only includes handles that returned valid information
- Returns the final Map of NIP-05 identifiers to Handle objects

related: Handle

import/access examples:
import { fetchHandles } from '@welshman/app';
import { fetchHandles } from '@welshman/app/handles';


=========================
workspace: packages/app
file: packages/app/src/handles.ts
lines: 82:107
id: b6bf3bd5179b05c01e4af692882b83952e0fa1bb4378328af44f2eaac947e0e9
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/handles.ts#L82

declaration:
{
  indexStore: handlesByNip05,
  deriveItem: deriveHandle,
  loadItem: loadHandle,
  onItem: onHandle,
} = collection({
  name: "handles",
  store: handles,
  getKey: (handle: Handle) => handle.nip05,
  load: batcher(800, async (nip05s: string[]) => {
    const fresh = await fetchHandles(uniq(nip05s))
    const stale = handlesByNip05.get()

    for (const nip05 of nip05s) {
      const newHandle = fresh.get(nip05)

      if (newHandle) {
        stale.set(nip05, {...newHandle, nip05})
      }
    }

    handles.set(Array.from(stale.values()))

    return nip05s
  }),
})

summary:
A collection of utilities for managing Nostr handles (NIP-05 identifiers). It provides functions to store, retrieve, and derive handle information. The collection exports several key components: `handlesByNip05` (an index store for handles), `deriveHandle` (to derive a handle from the store), `loadHandle` (to load handle data), and `onHandle` (for handle-related events).

details:
This implementation uses the `collection` utility from `@welshman/store` to create a managed collection of Handle objects. The collection is configured with:

1. A name ('handles')
2. A Svelte writable store
3. A key extractor function that uses the handle's nip05 property as the key
4. A load function that:
   - Uses a batcher with an 800ms window to group requests
   - Calls fetchHandles with unique NIP-05 identifiers
   - Merges fresh data with existing stale data
   - Updates the handles store with the combined results

The implementation efficiently manages handle data by batching requests and maintaining both fresh and stale data states to ensure the UI has the most up-to-date information while minimizing network requests.

import/access examples:
import { handlesByNip05 } from '@welshman/app';
import { handlesByNip05 } from '@welshman/app/handles';


=========================
workspace: packages/app
file: packages/app/src/handles.ts
lines: 82:107
id: b6bf3bd5179b05c01e4af692882b83952e0fa1bb4378328af44f2eaac947e0e9
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/handles.ts#L82

declaration:
{
  indexStore: handlesByNip05,
  deriveItem: deriveHandle,
  loadItem: loadHandle,
  onItem: onHandle,
} = collection({
  name: "handles",
  store: handles,
  getKey: (handle: Handle) => handle.nip05,
  load: batcher(800, async (nip05s: string[]) => {
    const fresh = await fetchHandles(uniq(nip05s))
    const stale = handlesByNip05.get()

    for (const nip05 of nip05s) {
      const newHandle = fresh.get(nip05)

      if (newHandle) {
        stale.set(nip05, {...newHandle, nip05})
      }
    }

    handles.set(Array.from(stale.values()))

    return nip05s
  }),
})

summary:
A collection of utilities for managing Nostr handles (NIP-05 identifiers). It provides functions to store, retrieve, and derive handle information. The collection exports several key components: `handlesByNip05` (an index store for handles), `deriveHandle` (to derive a handle from the store), `loadHandle` (to load handle data), and `onHandle` (for handle-related events).

details:
This implementation uses the `collection` utility from `@welshman/store` to create a managed collection of Handle objects. The collection is configured with:

1. A name ('handles')
2. A Svelte writable store
3. A key extractor function that uses the handle's nip05 property as the key
4. A load function that:
   - Uses a batcher with an 800ms window to group requests
   - Calls fetchHandles with unique NIP-05 identifiers
   - Merges fresh data with existing stale data
   - Updates the handles store with the combined results

The implementation efficiently manages handle data by batching requests and maintaining both fresh and stale data states to ensure the UI has the most up-to-date information while minimizing network requests.

import/access examples:
import { handlesByNip05 } from '@welshman/app';
import { handlesByNip05 } from '@welshman/app/handles';


=========================
workspace: packages/app
file: packages/app/src/handles.ts
lines: 82:107
id: b6bf3bd5179b05c01e4af692882b83952e0fa1bb4378328af44f2eaac947e0e9
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/handles.ts#L82

declaration:
{
  indexStore: handlesByNip05,
  deriveItem: deriveHandle,
  loadItem: loadHandle,
  onItem: onHandle,
} = collection({
  name: "handles",
  store: handles,
  getKey: (handle: Handle) => handle.nip05,
  load: batcher(800, async (nip05s: string[]) => {
    const fresh = await fetchHandles(uniq(nip05s))
    const stale = handlesByNip05.get()

    for (const nip05 of nip05s) {
      const newHandle = fresh.get(nip05)

      if (newHandle) {
        stale.set(nip05, {...newHandle, nip05})
      }
    }

    handles.set(Array.from(stale.values()))

    return nip05s
  }),
})

summary:
A collection of utilities for managing Nostr handles (NIP-05 identifiers). It provides functions to store, retrieve, and derive handle information. The collection exports several key components: `handlesByNip05` (an index store for handles), `deriveHandle` (to derive a handle from the store), `loadHandle` (to load handle data), and `onHandle` (for handle-related events).

details:
This implementation uses the `collection` utility from `@welshman/store` to create a managed collection of Handle objects. The collection is configured with:

1. A name ('handles')
2. A Svelte writable store
3. A key extractor function that uses the handle's nip05 property as the key
4. A load function that:
   - Uses a batcher with an 800ms window to group requests
   - Calls fetchHandles with unique NIP-05 identifiers
   - Merges fresh data with existing stale data
   - Updates the handles store with the combined results

The implementation efficiently manages handle data by batching requests and maintaining both fresh and stale data states to ensure the UI has the most up-to-date information while minimizing network requests.

import/access examples:
import { handlesByNip05 } from '@welshman/app';
import { handlesByNip05 } from '@welshman/app/handles';


=========================
workspace: packages/app
file: packages/app/src/handles.ts
lines: 82:107
id: b6bf3bd5179b05c01e4af692882b83952e0fa1bb4378328af44f2eaac947e0e9
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/handles.ts#L82

declaration:
{
  indexStore: handlesByNip05,
  deriveItem: deriveHandle,
  loadItem: loadHandle,
  onItem: onHandle,
} = collection({
  name: "handles",
  store: handles,
  getKey: (handle: Handle) => handle.nip05,
  load: batcher(800, async (nip05s: string[]) => {
    const fresh = await fetchHandles(uniq(nip05s))
    const stale = handlesByNip05.get()

    for (const nip05 of nip05s) {
      const newHandle = fresh.get(nip05)

      if (newHandle) {
        stale.set(nip05, {...newHandle, nip05})
      }
    }

    handles.set(Array.from(stale.values()))

    return nip05s
  }),
})

summary:
A collection of utilities for managing Nostr handles (NIP-05 identifiers). It provides functions to store, retrieve, and derive handle information. The collection exports several key components: `handlesByNip05` (an index store for handles), `deriveHandle` (to derive a handle from the store), `loadHandle` (to load handle data), and `onHandle` (for handle-related events).

details:
This implementation uses the `collection` utility from `@welshman/store` to create a managed collection of Handle objects. The collection is configured with:

1. A name ('handles')
2. A Svelte writable store
3. A key extractor function that uses the handle's nip05 property as the key
4. A load function that:
   - Uses a batcher with an 800ms window to group requests
   - Calls fetchHandles with unique NIP-05 identifiers
   - Merges fresh data with existing stale data
   - Updates the handles store with the combined results

The implementation efficiently manages handle data by batching requests and maintaining both fresh and stale data states to ensure the UI has the most up-to-date information while minimizing network requests.

import/access examples:
import { handlesByNip05 } from '@welshman/app';
import { handlesByNip05 } from '@welshman/app/handles';


=========================
workspace: packages/app
file: packages/app/src/handles.ts
lines: 109:122
id: 7d2f193fa7d307176d1379a0eea1c36aa64d8c9a5aa8f055f73d171ca14ebfea
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/handles.ts#L109

declaration:
deriveHandleForPubkey = (pubkey: string, relays: string[] = []) =>
  derived([handlesByNip05, deriveProfile(pubkey, relays)], ([$handlesByNip05, $profile]) => {
    if (!$profile?.nip05) {
      return undefined
    }

    loadHandle($profile.nip05)

    const handle = $handlesByNip05.get($profile.nip05)

    if (handle?.pubkey === pubkey) {
      return handle
    }
  })

summary:
A function that creates a derived store to fetch and return a Handle object for a given public key. It takes a public key string and an optional array of relays, and returns a Svelte derived store that resolves to a Handle object if the profile associated with the pubkey has a valid NIP-05 identifier that matches the pubkey.

details:
The implementation:
1. Creates a derived store that depends on two sources: the handlesByNip05 store and the profile derived from the given pubkey
2. When the derived values change, it checks if the profile has a nip05 identifier
3. If a nip05 exists, it triggers loading of the handle data via loadHandle()
4. It then attempts to retrieve the handle from the handlesByNip05 store
5. Returns the handle only if its pubkey matches the requested pubkey (verifying the NIP-05 identifier belongs to this pubkey)
6. Returns undefined if no matching handle is found or if the profile doesn't have a nip05 identifier

related: derived

import/access examples:
import { deriveHandleForPubkey } from '@welshman/app';
import { deriveHandleForPubkey } from '@welshman/app/handles';


=========================
workspace: packages/app
file: packages/app/src/handles.ts
lines: 124:125
id: 3e0e7d9fd6bed60c5d1cf724c98a0043f7660aaa2d3e6949bc531a0665b9d8b5
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/handles.ts#L124

declaration:
displayNip05 = (nip05: string) =>
  nip05?.startsWith("_@") ? last(nip05.split("@")) : nip05

summary:
A utility function that formats a NIP-05 identifier for display purposes. If the NIP-05 starts with '_@', it returns only the domain part (everything after '@'). Otherwise, it returns the original NIP-05 string unchanged.

details:
The implementation is a simple arrow function that takes a NIP-05 string and performs a conditional check:
1. It first checks if the input string starts with '_@' using the startsWith() method
2. If true, it splits the string by '@' and returns the last part (the domain) using the imported 'last' utility function
3. If false, it returns the original NIP-05 string unchanged

This is used to provide a cleaner display format for NIP-05 identifiers where the username part is the default '_' character.

related: last

import/access examples:
import { displayNip05 } from '@welshman/app';
import { displayNip05 } from '@welshman/app/handles';


=========================
workspace: packages/app
file: packages/app/src/handles.ts
lines: 127:127
id: fe7f9ab99549391454b6fb5347f8fbb9f9cb456ac02f6ac2494773fab09f3603
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/handles.ts#L127

declaration:
displayHandle = (handle: Handle) => displayNip05(handle.nip05)

summary:
A function that formats a Handle object's NIP-05 identifier for display purposes. It takes a Handle object as input and returns a string representation of the handle's NIP-05 identifier in a user-friendly format.

details:
This is a simple arrow function that takes a Handle object and passes its nip05 property to the displayNip05 function. The implementation delegates the actual formatting logic to the displayNip05 function, which appears to remove the '_@' prefix from NIP-05 identifiers when present, showing only the domain part in those cases.

related: __function,displayNip05,Handle

import/access examples:
import { displayHandle } from '@welshman/app';
import { displayHandle } from '@welshman/app/handles';


=========================
workspace: packages/app
file: packages/app/src/relays.ts
lines: 30:49
id: b865bc32ea514ecba1b48504bb543bd524e359d6ad2319e4c0286400e9cd65da
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/relays.ts#L30

declaration:
export type RelayStats = {
  first_seen: number
  recent_errors: number[]
  open_count: number
  close_count: number
  publish_count: number
  request_count: number
  event_count: number
  last_open: number
  last_close: number
  last_error: number
  last_publish: number
  last_request: number
  last_event: number
  last_auth: number
  publish_success_count: number
  publish_failure_count: number
  eose_count: number
  notice_count: number
}

summary:
A TypeScript type alias that defines the structure for tracking statistics about a relay connection. It includes counters for various events (opens, closes, publishes, requests, etc.), timestamps for the most recent occurrences of these events, and arrays for tracking errors.

details:
The `RelayStats` type is a comprehensive data structure used to monitor the health and activity of relay connections in a Nostr client. It tracks:

1. Timestamps for first connection and most recent events (open, close, error, publish, request, event, auth)
2. Counters for various operations (open_count, close_count, publish_count, etc.)
3. Success/failure metrics for publishing
4. An array of recent errors for reliability assessment

This type appears to be part of a larger relay management system, where these statistics are likely used to make decisions about relay quality, connection management, and debugging connection issues.

import/access examples:
import type { RelayStats } from '@welshman/app';
import type { RelayStats } from '@welshman/app/relays';


=========================
workspace: packages/app
file: packages/app/src/relays.ts
lines: 51:70
id: 8ba93a0acf326942ffea76a276da35b5e09883d3bf51cb43decbcc83c469394d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/relays.ts#L51

declaration:
makeRelayStats = (): RelayStats => ({
  first_seen: now(),
  recent_errors: [],
  open_count: 0,
  close_count: 0,
  publish_count: 0,
  request_count: 0,
  event_count: 0,
  last_open: 0,
  last_close: 0,
  last_error: 0,
  last_publish: 0,
  last_request: 0,
  last_event: 0,
  last_auth: 0,
  publish_success_count: 0,
  publish_failure_count: 0,
  eose_count: 0,
  notice_count: 0,
})

summary:
Creates and returns a new RelayStats object with default values. This function initializes statistics for tracking relay connection and communication metrics, including counters for various operations (open, close, publish, request, event) and timestamps for the most recent occurrences of these operations.

details:
The implementation is straightforward - it returns a new object literal with the RelayStats shape, setting:
1. first_seen to the current timestamp (via now() function)
2. recent_errors as an empty array to track error history
3. All count fields (open_count, close_count, etc.) initialized to 0
4. All timestamp fields (last_open, last_close, etc.) initialized to 0

This function provides a consistent way to initialize relay statistics tracking with default values.

related: RelayStats

import/access examples:
import { makeRelayStats } from '@welshman/app';
import { makeRelayStats } from '@welshman/app/relays';


=========================
workspace: packages/app
file: packages/app/src/relays.ts
lines: 72:76
id: 100bb4d9af10b5f12ffac6d15e3f08e0cf08a428e950694599fc13fa69c2849d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/relays.ts#L72

declaration:
export type Relay = {
  url: string
  stats?: RelayStats
  profile?: RelayProfile
}

summary:
A type definition representing a relay in a Nostr network. It contains the relay's URL, optional statistics tracking connection and message activity, and an optional profile with metadata about the relay.

details:
The `Relay` type is a fundamental data structure in this application that represents a Nostr relay. It consists of three properties:
1. `url`: A string representing the relay's URL/address
2. `stats`: An optional `RelayStats` object that tracks various metrics about the relay's performance and usage
3. `profile`: An optional `RelayProfile` object that contains metadata about the relay

This type is used throughout the application to manage relay connections, track relay performance, and display relay information to users. It's part of a larger system that includes functions for fetching relay profiles, tracking relay statistics, and evaluating relay quality.

related: RelayStats

import/access examples:
import type { Relay } from '@welshman/app';
import type { Relay } from '@welshman/app/relays';


=========================
workspace: packages/app
file: packages/app/src/relays.ts
lines: 78:78
id: 58cb8eb07771667b4a705612a349229ee2ecdb1b89934a2908eed17703032819
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/relays.ts#L78

declaration:
relays = withGetter(writable<Relay[]>([]))

summary:
A Svelte writable store enhanced with a getter function that holds an array of Relay objects. Each Relay object contains a URL, optional stats, and an optional profile. This store serves as the central repository for relay information in the application.

details:
This variable is created using the `withGetter` utility from `@welshman/store` wrapped around a Svelte `writable` store. The store is initialized with an empty array of `Relay` objects. The `withGetter` enhancement likely adds a method to retrieve the current value of the store without subscribing to it, making it more convenient to access the relay data synchronously when needed. This store is used throughout the module as the source of truth for relay information and is manipulated by various functions that update relay stats and profiles.

related: withGetter

import/access examples:
import { relays } from '@welshman/app';
import { relays } from '@welshman/app/relays';


=========================
workspace: packages/app
file: packages/app/src/relays.ts
lines: 80:85
id: 560d523668a3d63f25a570930dfc0f0daef5b31b78e8f1229fc5fe7415f93d51
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/relays.ts#L80

declaration:
relaysByPubkey = derived(relays, $relays =>
  groupBy(
    $relay => $relay.profile?.pubkey,
    $relays.filter($relay => $relay.profile?.pubkey),
  ),
)

summary:
A derived Svelte store that groups relays by their pubkey. It takes the main `relays` store and transforms it into a map where keys are relay pubkeys and values are arrays of relays with that pubkey. Only relays that have a profile with a pubkey are included in the grouping.

details:
This variable uses Svelte's `derived` store to create a reactive transformation of the `relays` store. The implementation:

1. Takes the current value of the `relays` store
2. Filters out any relays that don't have a profile with a pubkey
3. Uses the `groupBy` utility function to create a map where:
   - Keys are the pubkeys from relay profiles
   - Values are arrays of relay objects that share the same pubkey

This allows for efficiently looking up all relays associated with a particular pubkey.

related: derived

import/access examples:
import { relaysByPubkey } from '@welshman/app';
import { relaysByPubkey } from '@welshman/app/relays';


=========================
workspace: packages/app
file: packages/app/src/relays.ts
lines: 87:102
id: 8225612a972eb2d4aa65006b4538d5f4d31ddaebf41ddb40a63bac6be29b8dd4
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/relays.ts#L87

declaration:
fetchRelayProfiles = async (urls: string[]) => {
  const base = appContext.dufflepudUrl

  if (!base) {
    throw new Error("ctx.app.dufflepudUrl is required to fetch relay metadata")
  }

  const res: any = await postJson(`${base}/relay/info`, {urls})
  const profilesByUrl = new Map<string, RelayProfile>()

  for (const {url, info} of res?.data || []) {
    profilesByUrl.set(url, info)
  }

  return profilesByUrl
}

summary:
Asynchronously fetches relay profiles for a list of relay URLs. Takes an array of relay URLs as input and returns a Map where keys are relay URLs and values are their corresponding RelayProfile objects. Requires a valid dufflepudUrl in the application context.

details:
Implementation details:
1. Retrieves the dufflepudUrl from the application context
2. Validates that the URL exists, throwing an error if not
3. Makes a POST request to the `/relay/info` endpoint of the dufflepud service with the provided URLs
4. Processes the response by creating a Map of URL to RelayProfile
5. Iterates through the response data, extracting URL and info pairs
6. Returns the completed Map of profiles indexed by URL

import/access examples:
import { fetchRelayProfiles } from '@welshman/app';
import { fetchRelayProfiles } from '@welshman/app/relays';


=========================
workspace: packages/app
file: packages/app/src/relays.ts
lines: 104:136
id: 85f2ae00783cc1b0cdf8b5c46a798ac8bdc4ba087091a22966341c8a7b6f5014
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/relays.ts#L104

declaration:
{
  indexStore: relaysByUrl,
  deriveItem: deriveRelay,
  loadItem: loadRelay,
  onItem: onRelay,
} = collection({
  name: "relays",
  store: relays,
  getKey: (relay: Relay) => relay.url,
  load: batcher(800, async (rawUrls: string[]) => {
    const urls = rawUrls.map(normalizeRelayUrl)
    const fresh = await fetchRelayProfiles(uniq(urls))
    const stale = relaysByUrl.get()

    for (const url of urls) {
      const relay = stale.get(url)
      const profile = fresh.get(url)

      if (!url || !isRelayUrl(url)) {
        console.warn(`Attempted to load invalid relay url: ${url}`)
        continue
      }

      if (profile) {
        stale.set(url, {...relay, profile, url})
      }
    }

    relays.set(Array.from(stale.values()))

    return urls
  }),
})

summary:
A collection of utility functions and stores for managing relay data. It provides `relaysByUrl` (an index store for relays), `deriveRelay` (to derive a specific relay by URL), `loadRelay` (to load relay data), and `onRelay` (to subscribe to relay changes). These functions help manage and access relay information throughout the application.

details:
This is a destructured object returned from the `collection` function, which creates a set of utilities for working with the relays store. The implementation:

1. Creates a named collection "relays" based on the main relays store
2. Uses relay URLs as unique keys
3. Implements a load function that:
   - Batches requests with an 800ms delay using batcher
   - Normalizes relay URLs
   - Fetches relay profiles from a remote service
   - Updates the store with new profile information
   - Handles invalid relay URLs by logging warnings
   - Preserves existing relay data while updating with new profiles
   - Updates the main relays store with the combined data

The implementation carefully manages state between the index store and the main store, ensuring data consistency while providing efficient access patterns.

import/access examples:
import { relaysByUrl } from '@welshman/app';
import { relaysByUrl } from '@welshman/app/relays';


=========================
workspace: packages/app
file: packages/app/src/relays.ts
lines: 104:136
id: 85f2ae00783cc1b0cdf8b5c46a798ac8bdc4ba087091a22966341c8a7b6f5014
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/relays.ts#L104

declaration:
{
  indexStore: relaysByUrl,
  deriveItem: deriveRelay,
  loadItem: loadRelay,
  onItem: onRelay,
} = collection({
  name: "relays",
  store: relays,
  getKey: (relay: Relay) => relay.url,
  load: batcher(800, async (rawUrls: string[]) => {
    const urls = rawUrls.map(normalizeRelayUrl)
    const fresh = await fetchRelayProfiles(uniq(urls))
    const stale = relaysByUrl.get()

    for (const url of urls) {
      const relay = stale.get(url)
      const profile = fresh.get(url)

      if (!url || !isRelayUrl(url)) {
        console.warn(`Attempted to load invalid relay url: ${url}`)
        continue
      }

      if (profile) {
        stale.set(url, {...relay, profile, url})
      }
    }

    relays.set(Array.from(stale.values()))

    return urls
  }),
})

summary:
A collection of utility functions and stores for managing relay data. It provides `relaysByUrl` (an index store for relays), `deriveRelay` (to derive a specific relay by URL), `loadRelay` (to load relay data), and `onRelay` (to subscribe to relay changes). These functions help manage and access relay information throughout the application.

details:
This is a destructured object returned from the `collection` function, which creates a set of utilities for working with the relays store. The implementation:

1. Creates a named collection "relays" based on the main relays store
2. Uses relay URLs as unique keys
3. Implements a load function that:
   - Batches requests with an 800ms delay using batcher
   - Normalizes relay URLs
   - Fetches relay profiles from a remote service
   - Updates the store with new profile information
   - Handles invalid relay URLs by logging warnings
   - Preserves existing relay data while updating with new profiles
   - Updates the main relays store with the combined data

The implementation carefully manages state between the index store and the main store, ensuring data consistency while providing efficient access patterns.

import/access examples:
import { relaysByUrl } from '@welshman/app';
import { relaysByUrl } from '@welshman/app/relays';


=========================
workspace: packages/app
file: packages/app/src/relays.ts
lines: 104:136
id: 85f2ae00783cc1b0cdf8b5c46a798ac8bdc4ba087091a22966341c8a7b6f5014
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/relays.ts#L104

declaration:
{
  indexStore: relaysByUrl,
  deriveItem: deriveRelay,
  loadItem: loadRelay,
  onItem: onRelay,
} = collection({
  name: "relays",
  store: relays,
  getKey: (relay: Relay) => relay.url,
  load: batcher(800, async (rawUrls: string[]) => {
    const urls = rawUrls.map(normalizeRelayUrl)
    const fresh = await fetchRelayProfiles(uniq(urls))
    const stale = relaysByUrl.get()

    for (const url of urls) {
      const relay = stale.get(url)
      const profile = fresh.get(url)

      if (!url || !isRelayUrl(url)) {
        console.warn(`Attempted to load invalid relay url: ${url}`)
        continue
      }

      if (profile) {
        stale.set(url, {...relay, profile, url})
      }
    }

    relays.set(Array.from(stale.values()))

    return urls
  }),
})

summary:
A collection of utility functions and stores for managing relay data. It provides `relaysByUrl` (an index store for relays), `deriveRelay` (to derive a specific relay by URL), `loadRelay` (to load relay data), and `onRelay` (to subscribe to relay changes). These functions help manage and access relay information throughout the application.

details:
This is a destructured object returned from the `collection` function, which creates a set of utilities for working with the relays store. The implementation:

1. Creates a named collection "relays" based on the main relays store
2. Uses relay URLs as unique keys
3. Implements a load function that:
   - Batches requests with an 800ms delay using batcher
   - Normalizes relay URLs
   - Fetches relay profiles from a remote service
   - Updates the store with new profile information
   - Handles invalid relay URLs by logging warnings
   - Preserves existing relay data while updating with new profiles
   - Updates the main relays store with the combined data

The implementation carefully manages state between the index store and the main store, ensuring data consistency while providing efficient access patterns.

import/access examples:
import { relaysByUrl } from '@welshman/app';
import { relaysByUrl } from '@welshman/app/relays';


=========================
workspace: packages/app
file: packages/app/src/relays.ts
lines: 104:136
id: 85f2ae00783cc1b0cdf8b5c46a798ac8bdc4ba087091a22966341c8a7b6f5014
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/relays.ts#L104

declaration:
{
  indexStore: relaysByUrl,
  deriveItem: deriveRelay,
  loadItem: loadRelay,
  onItem: onRelay,
} = collection({
  name: "relays",
  store: relays,
  getKey: (relay: Relay) => relay.url,
  load: batcher(800, async (rawUrls: string[]) => {
    const urls = rawUrls.map(normalizeRelayUrl)
    const fresh = await fetchRelayProfiles(uniq(urls))
    const stale = relaysByUrl.get()

    for (const url of urls) {
      const relay = stale.get(url)
      const profile = fresh.get(url)

      if (!url || !isRelayUrl(url)) {
        console.warn(`Attempted to load invalid relay url: ${url}`)
        continue
      }

      if (profile) {
        stale.set(url, {...relay, profile, url})
      }
    }

    relays.set(Array.from(stale.values()))

    return urls
  }),
})

summary:
A collection of utility functions and stores for managing relay data. It provides `relaysByUrl` (an index store for relays), `deriveRelay` (to derive a specific relay by URL), `loadRelay` (to load relay data), and `onRelay` (to subscribe to relay changes). These functions help manage and access relay information throughout the application.

details:
This is a destructured object returned from the `collection` function, which creates a set of utilities for working with the relays store. The implementation:

1. Creates a named collection "relays" based on the main relays store
2. Uses relay URLs as unique keys
3. Implements a load function that:
   - Batches requests with an 800ms delay using batcher
   - Normalizes relay URLs
   - Fetches relay profiles from a remote service
   - Updates the store with new profile information
   - Handles invalid relay URLs by logging warnings
   - Preserves existing relay data while updating with new profiles
   - Updates the main relays store with the combined data

The implementation carefully manages state between the index store and the main store, ensuring data consistency while providing efficient access patterns.

import/access examples:
import { relaysByUrl } from '@welshman/app';
import { relaysByUrl } from '@welshman/app/relays';


=========================
workspace: packages/app
file: packages/app/src/relays.ts
lines: 138:139
id: 5623f01c776d25fe9d6b7c5d8af1c7623c52351a19c7f8882719f0f83ebb774a
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/relays.ts#L138

declaration:
displayRelayByPubkey = (url: string) =>
  displayRelayProfile(relaysByUrl.get().get(url)?.profile, displayRelayUrl(url))

summary:
A function that takes a relay URL as input and returns a display-friendly representation of the relay. It combines the relay's profile information (if available) with a formatted version of the URL.

details:
This function works by:
1. Taking a relay URL as input
2. Retrieving the relay's profile from the relaysByUrl store using the URL
3. Passing both the profile (which might be undefined) and a formatted version of the URL to the displayRelayProfile utility function
4. The displayRelayProfile function likely returns a human-readable string representation of the relay

related: displayRelayProfile

import/access examples:
import { displayRelayByPubkey } from '@welshman/app';
import { displayRelayByPubkey } from '@welshman/app/relays';


=========================
workspace: packages/app
file: packages/app/src/relays.ts
lines: 141:142
id: dfab9467b45a14283ea8b596da3b903379cb2180eca5abce76c2249982cb19a4
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/relays.ts#L141

declaration:
deriveRelayDisplay = (url: string) =>
  derived(deriveRelay(url), $relay => displayRelayProfile($relay?.profile, displayRelayUrl(url)))

summary:
A function that creates a derived Svelte store for displaying relay information. It takes a relay URL as input and returns a derived store that formats the relay's profile information for display. The derived store updates whenever the underlying relay data changes.

details:
This function combines several utilities to create a reactive display of relay information:

1. It uses `deriveRelay(url)` to get a store containing the relay data for the given URL
2. It then creates a derived store that transforms this data using:
   - `displayRelayProfile()` to format the relay's profile information
   - `displayRelayUrl(url)` to format the relay's URL

The resulting store will automatically update whenever the underlying relay data changes, providing a formatted display string for the relay.

related: derived

import/access examples:
import { deriveRelayDisplay } from '@welshman/app';
import { deriveRelayDisplay } from '@welshman/app/relays';


=========================
workspace: packages/app
file: packages/app/src/relays.ts
lines: 144:170
id: d02718fff14b02d15b3340640d4849d10ce138324b25bc89cb5ddda23d3e005b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/relays.ts#L144

declaration:
getRelayQuality = (url: string) => {
  const relay = relaysByUrl.get().get(url)

  // Skip non-relays entirely
  if (!isRelayUrl(url)) return 0

  // If we have recent errors, skip it
  if (relay?.stats) {
    if (relay.stats.recent_errors.filter(n => n > ago(MINUTE)).length > 0) return 0
    if (relay.stats.recent_errors.filter(n => n > ago(HOUR)).length > 3) return 0
    if (relay.stats.recent_errors.filter(n => n > ago(DAY)).length > 10) return 0
  }

  // Prefer stuff we're connected to
  if (Pool.get().has(url)) return 1

  // Prefer stuff we've connected to in the past
  if (relay?.stats) return 0.9

  // If it's not weird url give it an ok score
  if (!isIPAddress(url) && !isLocalUrl(url) && !isOnionUrl(url) && !url.startsWith("ws://")) {
    return 0.8
  }

  // Default to a "meh" score
  return 0.7
}

summary:
A function that evaluates the quality of a relay based on its URL and connection statistics. It returns a numeric score between 0 and 1, where 0 indicates a relay that should be skipped and 1 indicates a preferred relay. The function takes a relay URL as a string parameter and returns a number representing the relay's quality score.

details:
The implementation uses a series of heuristics to determine relay quality:

1. First checks if the URL is a valid relay URL, returning 0 if not
2. Examines recent errors in the relay stats:
   - Returns 0 if any errors occurred in the last minute
   - Returns 0 if more than 3 errors occurred in the last hour
   - Returns 0 if more than 10 errors occurred in the last day
3. Returns 1 (highest quality) if the relay is currently connected in the Pool
4. Returns 0.9 if we have stats for the relay (meaning we've connected before)
5. Returns 0.8 if the URL appears safe (not an IP address, local URL, onion URL, or insecure ws:// protocol)
6. Returns 0.7 as the default "meh" score for all other cases

The function uses utility functions like isRelayUrl, isIPAddress, isLocalUrl, and isOnionUrl to evaluate the URL characteristics.

import/access examples:
import { getRelayQuality } from '@welshman/app';
import { getRelayQuality } from '@welshman/app/relays';


=========================
workspace: packages/app
file: packages/app/src/relays.ts
lines: 174:174
id: feb0e9a48cd48a82951475fdf82a7aeb616e57633c962b245360873a5caf069a
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/relays.ts#L174

declaration:
type RelayStatsUpdate = [string, (stats: RelayStats) => void]

summary:
A type alias representing a tuple used for updating relay statistics. It consists of a string (relay URL) and a function that takes a RelayStats object and modifies it.

details:
This type is used internally in the relay statistics tracking system. It's specifically designed for the batch processing of relay stat updates in the `updateRelayStats` function. The first element of the tuple is the relay URL, and the second element is a callback function that receives the current stats object and applies modifications to it. This pattern allows for collecting multiple stat updates and processing them in batches for better performance.

related: RelayStats

=========================
workspace: packages/app
file: packages/app/src/relays.ts
lines: 176:206
id: 84f3e524b83f95e7d477476aab21d3a786c6ff2e174c491917948b74f5dad083
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/relays.ts#L176

declaration:
updateRelayStats = batch(500, (updates: RelayStatsUpdate[]) => {
  relays.update($relays => {
    const $relaysByUrl = indexBy(r => r.url, $relays)
    const $itemsByUrl = groupBy(([url]) => url, updates)

    for (const [url, items] of $itemsByUrl.entries()) {
      const $relay: Relay = $relaysByUrl.get(url) || {url}

      if (!url || !isRelayUrl(url)) {
        console.warn(`Attempted to update stats for an invalid relay url: ${url}`)
        continue
      }

      if (!$relay.stats) {
        $relay.stats = makeRelayStats()
      } else if ($relay.stats.notice_count === undefined) {
        // Migrate from old stats
        $relay.stats = {...makeRelayStats(), ...$relay.stats}
      }

      for (const [_, update] of items) {
        update($relay.stats)
      }

      // Copy so the database gets updated, since we're mutating in updates
      $relaysByUrl.set(url, {...$relay})
    }

    return Array.from($relaysByUrl.values())
  })
})

summary:
A batched function that updates relay statistics in the relays store. It takes an array of tuples containing a relay URL and an update function, batches these updates over 500ms, and applies them to the corresponding relay objects in the store.

details:
The implementation:
1. Uses the `batch` utility to collect updates over a 500ms window before processing them together
2. Updates the relays store by:
   - Creating indexes of relays by URL and grouping updates by URL
   - For each URL with updates:
     - Gets or creates a relay object
     - Validates the URL is a proper relay URL
     - Initializes stats if needed or migrates from old stats format
     - Applies all update functions to the relay's stats
     - Creates a new relay object to ensure database updates
   - Returns a new array of relays with updated stats
3. The function is used internally to track various relay metrics like connection status, message counts, and errors

related: batch

=========================
workspace: packages/app
file: packages/app/src/relays.ts
lines: 208:226
id: 3c0a6d7a7fea474e659f7213bc859f083086814dd68192e5810c4a7d0f0d2a0f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/relays.ts#L208

declaration:
onSocketSend = ([verb]: ClientMessage, url: string) => {
  if (verb === "REQ") {
    updateRelayStats([
      url,
      stats => {
        stats.request_count++
        stats.last_request = now()
      },
    ])
  } else if (verb === "EVENT") {
    updateRelayStats([
      url,
      stats => {
        stats.publish_count++
        stats.last_publish = now()
      },
    ])
  }
}

summary:
A function that handles socket send events for relay statistics tracking. It takes a ClientMessage array (destructured to get the verb) and a relay URL, updating relay statistics based on the message type. For 'REQ' messages, it increments request count and updates last request timestamp. For 'EVENT' messages, it increments publish count and updates last publish timestamp.

details:
This function is part of the relay statistics tracking system. It works by:

1. Accepting a ClientMessage (destructured to extract the verb) and the relay URL
2. Checking the message verb type:
   - For 'REQ' (subscription request) messages: calls updateRelayStats with the URL and a callback that increments request_count and updates last_request timestamp
   - For 'EVENT' (event publish) messages: calls updateRelayStats with the URL and a callback that increments publish_count and updates last_publish timestamp

The updateRelayStats function is a batched operation (defined earlier in the file) that collects multiple stat updates and processes them efficiently in batches.

=========================
workspace: packages/app
file: packages/app/src/relays.ts
lines: 228:272
id: 643b55aed7f5c286f7492b85ce7cb8feee2d10ec51ad4221b9f7a9e1bb26636b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/relays.ts#L228

declaration:
onSocketReceive = ([verb, ...extra]: RelayMessage, url: string) => {
  if (verb === "OK") {
    const [_, ok] = extra

    updateRelayStats([
      url,
      stats => {
        if (ok) {
          stats.publish_success_count++
        } else {
          stats.publish_failure_count++
        }
      },
    ])
  } else if (verb === "AUTH") {
    updateRelayStats([
      url,
      stats => {
        stats.last_auth = now()
      },
    ])
  } else if (verb === "EVENT") {
    updateRelayStats([
      url,
      stats => {
        stats.event_count++
        stats.last_event = now()
      },
    ])
  } else if (verb === "EOSE") {
    updateRelayStats([
      url,
      stats => {
        stats.eose_count++
      },
    ])
  } else if (verb === "NOTICE") {
    updateRelayStats([
      url,
      stats => {
        stats.notice_count++
      },
    ])
  }
}

summary:
A function that handles relay socket message reception events. It processes different types of relay messages ('OK', 'AUTH', 'EVENT', 'EOSE', 'NOTICE') and updates the corresponding relay statistics accordingly. Takes a RelayMessage array (destructured to get the verb and extra parameters) and the relay URL as parameters.

details:
This function is part of the relay statistics tracking system. It:

1. Processes different message types from relays by checking the first element (verb) of the RelayMessage array
2. For each message type, it calls updateRelayStats with the relay URL and a callback function
3. The callback updates specific statistics based on the message type:
   - 'OK': Increments publish_success_count or publish_failure_count based on success status
   - 'AUTH': Updates last_auth timestamp
   - 'EVENT': Increments event_count and updates last_event timestamp
   - 'EOSE': Increments eose_count (End Of Stored Events)
   - 'NOTICE': Increments notice_count

The function works with the batch-based updateRelayStats system to efficiently update relay statistics in the store.

=========================
workspace: packages/app
file: packages/app/src/relays.ts
lines: 274:304
id: cafe1164db65b526405c738c0c866075aa09c7b4ff182f3e6562948a484d0967
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/relays.ts#L274

declaration:
onSocketStatus = (status: string, url: string) => {
  if (status === SocketStatus.Open) {
    updateRelayStats([
      url,
      stats => {
        stats.last_open = now()
        stats.open_count++
      },
    ])
  }

  if (status === SocketStatus.Closed) {
    updateRelayStats([
      url,
      stats => {
        stats.last_close = now()
        stats.close_count++
      },
    ])
  }

  if (status === SocketStatus.Error) {
    updateRelayStats([
      url,
      stats => {
        stats.last_error = now()
        stats.recent_errors = uniq(stats.recent_errors.concat(now())).slice(-10)
      },
    ])
  }
}

summary:
A function that handles socket status changes for relay connections. It takes a status string and a relay URL, updating the relay's statistics based on the status type (Open, Closed, or Error).

details:
This function is part of the relay statistics tracking system. It processes three types of socket status changes:

1. When a socket opens (SocketStatus.Open), it updates the relay stats to record the current timestamp as last_open and increments the open_count.

2. When a socket closes (SocketStatus.Closed), it updates the relay stats to record the current timestamp as last_close and increments the close_count.

3. When a socket error occurs (SocketStatus.Error), it updates the relay stats to record the current timestamp as last_error and adds the current timestamp to the recent_errors array (keeping only the 10 most recent errors).

The function uses the updateRelayStats utility which batches updates to relay statistics for efficiency.

=========================
workspace: packages/app
file: packages/app/src/relays.ts
lines: 306:316
id: 7bc691d952947196bf9bddf5cfa88d0cf0d91d6bc82c2ca927e077a2b55f2875
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/relays.ts#L306

declaration:
trackRelayStats = (socket: Socket) => {
  socket.on(SocketEvent.Send, onSocketSend)
  socket.on(SocketEvent.Receive, onSocketReceive)
  socket.on(SocketEvent.Status, onSocketStatus)

  return () => {
    socket.off(SocketEvent.Send, onSocketSend)
    socket.off(SocketEvent.Receive, onSocketReceive)
    socket.off(SocketEvent.Status, onSocketStatus)
  }
}

summary:
A function that sets up event listeners on a Socket to track relay statistics. It takes a Socket instance as a parameter and attaches listeners for Send, Receive, and Status events. Returns a cleanup function that removes these event listeners when called.

details:
The implementation works by:
1. Registering three event handlers on the provided socket:
   - onSocketSend: Tracks REQ and EVENT messages sent to relays
   - onSocketReceive: Tracks various incoming messages (OK, AUTH, EVENT, EOSE, NOTICE)
   - onSocketStatus: Tracks connection status changes (Open, Closed, Error)

2. Each handler updates relay statistics through the updateRelayStats function, which batches updates to the relay store

3. Returns a cleanup function that removes all the registered event listeners, preventing memory leaks when the socket is no longer needed

The function is part of a larger relay tracking system that maintains statistics about relay connections, message exchanges, and errors.

import/access examples:
import { trackRelayStats } from '@welshman/app';
import { trackRelayStats } from '@welshman/app/relays';


=========================
workspace: packages/app
file: packages/app/src/topics.ts
lines: 5:8
id: bd08c19afbddf1e8008a0c6421de5676ffce1038d69dc6e628fda84a9106392c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/topics.ts#L5

declaration:
export type Topic = {
  name: string
  count: number
}

summary:
A type definition representing a topic with a name and count. The `Topic` type is exported and used to represent categorized data with a string name and a numeric count.

import/access examples:
import type { Topic } from '@welshman/app';
import type { Topic } from '@welshman/app/topics';


=========================
workspace: packages/app
file: packages/app/src/topics.ts
lines: 10:31
id: e9be2758405ac052c2d7d2410cdb502ad5c4f8d13c9179f2da4659b0bffc09cb
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/topics.ts#L10

declaration:
topics = custom<Topic[]>(setter => {
  const getTopics = () => {
    const topics = new Map<string, number>()
    for (const tagString of repository.eventsByTag.keys()) {
      if (tagString.startsWith("t:")) {
        const topic = tagString.slice(2).toLowerCase()

        topics.set(topic, inc(topics.get(topic)))
      }
    }

    return Array.from(topics.entries()).map(([name, count]) => ({name, count}))
  }

  setter(getTopics())

  const onUpdate = throttle(3000, () => setter(getTopics()))

  repository.on("update", onUpdate)

  return () => repository.off("update", onUpdate)
})

summary:
A custom store that maintains a list of topics extracted from repository event tags. Each topic is represented as an object with a name and count. The store automatically updates when the repository changes.

details:
Implementation details:
1. Uses the `custom` store creator from '@welshman/store'
2. Initializes by extracting topics from repository event tags that start with 't:'
3. Creates a Map to count occurrences of each topic
4. Processes repository tags by:
   - Filtering for tags that start with 't:'
   - Removing the 't:' prefix and converting to lowercase
   - Incrementing the count for each topic using the 'inc' utility
5. Transforms the Map into an array of Topic objects
6. Sets up a throttled update function (3000ms) that recalculates topics when repository changes
7. Subscribes to repository 'update' events
8. Returns a cleanup function that unsubscribes from repository events when the store is destroyed

related: custom

import/access examples:
import { topics } from '@welshman/app';
import { topics } from '@welshman/app/topics';


=========================
workspace: packages/app
file: packages/app/src/search.ts
lines: 15:20
id: 0a2582afc49cea044d601f32c1bb1b39e370f27b6053aa35a52c2e34e5def1a3
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/search.ts#L15

declaration:
export type SearchOptions<V, T> = {
  getValue: (item: T) => V
  fuseOptions?: IFuseOptions<T>
  onSearch?: (term: string) => void
  sortFn?: (items: FuseResult<T>) => any
}

summary:
SearchOptions is a generic type that defines configuration options for creating a search functionality. It takes two type parameters: V (value type) and T (item type). The type includes properties for value extraction, Fuse.js configuration options, an optional search callback, and an optional sorting function for search results.

details:
The SearchOptions type contains four properties:
1. `getValue`: A required function that extracts a value of type V from an item of type T. This is used for mapping and retrieving items.
2. `fuseOptions`: An optional configuration object for Fuse.js, which is the underlying fuzzy search library.
3. `onSearch`: An optional callback function that gets triggered when a search is performed.
4. `sortFn`: An optional function to customize the sorting of search results returned by Fuse.js.

import/access examples:
import type { SearchOptions } from '@welshman/app';
import type { SearchOptions } from '@welshman/app/search';


=========================
workspace: packages/app
file: packages/app/src/search.ts
lines: 22:28
id: 3a052ac14cf213fdf4ea38767222c410ee40e6c134fe848f7acedb0c973ab172
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/search.ts#L22

declaration:
export type Search<V, T> = {
  options: T[]
  getValue: (item: T) => V
  getOption: (value: V) => T | undefined
  searchOptions: (term: string) => T[]
  searchValues: (term: string) => V[]
}

summary:
The `Search<V, T>` type alias defines a generic search interface that manages a collection of items of type `T` with associated values of type `V`. It provides methods to retrieve items by their values, search through options based on a search term, and convert search results to either option objects or their values.

details:
This type alias defines a structure with five properties:
1. `options`: An array of items of type `T` that can be searched through
2. `getValue`: A function that extracts a value of type `V` from an item of type `T`
3. `getOption`: A function that retrieves an item of type `T` based on its value of type `V`
4. `searchOptions`: A function that searches through options based on a string term and returns matching items
5. `searchValues`: A function that searches through options and returns the values of matching items

This type is used in conjunction with the `createSearch` function to implement search functionality across different data types in the application.

import/access examples:
import type { Search } from '@welshman/app';
import type { Search } from '@welshman/app/search';


=========================
workspace: packages/app
file: packages/app/src/search.ts
lines: 30:53
id: 3997ce0500e218a1480017c95f4849fcd98b8929e3e5484f60f64b4c7917fa8d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/search.ts#L30

declaration:
createSearch = <V, T>(options: T[], opts: SearchOptions<V, T>): Search<V, T> => {
  const fuse = new Fuse(options, {...opts.fuseOptions, includeScore: true})
  const map = new Map<V, T>(options.map(item => [opts.getValue(item), item]))

  const search = (term: string) => {
    opts.onSearch?.(term)

    let results = term ? fuse.search(term) : options.map(item => ({item}) as FuseResult<T>)

    if (opts.sortFn) {
      results = sortBy(opts.sortFn, results)
    }

    return results.map(result => result.item)
  }

  return {
    options,
    getValue: opts.getValue,
    getOption: (value: V) => map.get(value),
    searchOptions: (term: string) => search(term),
    searchValues: (term: string) => search(term).map(opts.getValue),
  }
}

summary:
Creates a search utility for a collection of items. The function takes an array of options and configuration settings to create a search interface that can find and filter items based on search terms. It returns an object with methods to search options, get values from options, and retrieve options by value. The search functionality is powered by Fuse.js for fuzzy searching.

details:
Implementation details:
1. Uses Fuse.js library to create a fuzzy search instance with the provided options and configuration
2. Creates a Map for quick lookup of items by their value (determined by the getValue function)
3. Defines an internal search function that:
   - Calls the optional onSearch callback if provided
   - Uses Fuse.search for non-empty search terms or returns all options for empty terms
   - Applies optional custom sorting via the sortFn if provided
   - Returns the matched items
4. Returns an object with the following capabilities:
   - The original options array
   - The getValue function from options
   - getOption method to look up an item by its value using the Map
   - searchOptions method that returns matching items for a search term
   - searchValues method that returns the values of matching items for a search term

related: SearchOptions,Search

import/access examples:
import { createSearch } from '@welshman/app';
import { createSearch } from '@welshman/app/search';


=========================
workspace: packages/app
file: packages/app/src/search.ts
lines: 55:62
id: 83ad2e1ffd14babf06519244d5bd73606bb61ac8cba686fca792d715e6850057
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/search.ts#L55

declaration:
searchProfiles = debounce(500, (search: string) => {
  if (search.length > 2) {
    load({
      filters: [{kinds: [PROFILE], search}],
      relays: Router.get().Search().getUrls(),
    })
  }
})

summary:
A debounced function that triggers a search for profiles when given a search string. It only performs the search if the search string is longer than 2 characters. The function has a 500ms debounce delay to prevent excessive API calls during rapid typing.

details:
This function implements a debounced profile search mechanism that:

1. Waits 500ms after the last call before executing (via the debounce wrapper)
2. Checks if the search string is at least 3 characters long
3. If the condition is met, it calls the 'load' function with:
   - A filter specifying PROFILE kinds and the search term
   - Relay URLs obtained from the Router's Search configuration

The implementation uses the debounce utility from throttle-debounce to optimize performance by preventing multiple rapid searches when a user is typing.

related: debounce

import/access examples:
import { searchProfiles } from '@welshman/app';
import { searchProfiles } from '@welshman/app/search';


=========================
workspace: packages/app
file: packages/app/src/search.ts
lines: 64:94
id: a504f06ea1686be288b73916902e2e3d5a55603d760c7c75244d843ef9833eff
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/search.ts#L64

declaration:
profileSearch = derived(
  [throttled(800, profiles), throttled(800, handlesByNip05)],
  ([$profiles, $handlesByNip05]) => {
    // Remove invalid nip05's from profiles
    const options = $profiles.map(p => {
      const isNip05Valid = !p.nip05 || $handlesByNip05.get(p.nip05)?.pubkey === p.event.pubkey

      return isNip05Valid ? p : {...p, nip05: ""}
    })

    return createSearch(options, {
      onSearch: searchProfiles,
      getValue: (profile: PublishedProfile) => profile.event.pubkey,
      sortFn: ({score = 1, item}) => {
        const wotScore = wotGraph.get().get(item.event.pubkey) || 0

        return dec(score) * inc(wotScore / maxWot.get())
      },
      fuseOptions: {
        keys: [
          "nip05",
          {name: "name", weight: 0.8},
          {name: "display_name", weight: 0.5},
          {name: "about", weight: 0.3},
        ],
        threshold: 0.3,
        shouldSort: false,
      },
    })
  },
)

summary:
A derived store that provides search functionality for user profiles. It creates a search interface that allows filtering and sorting profiles based on various criteria like name, display name, about, and NIP-05 identifier. The search results are sorted by a combination of text match score and web of trust (WoT) score.

details:
The implementation creates a derived store that depends on throttled versions of the profiles and handlesByNip05 stores. When these stores update:

1. It first sanitizes the profiles by removing invalid NIP-05 identifiers (where the NIP-05 doesn't match the profile's pubkey)
2. It then creates a search interface using createSearch with:
   - A custom search handler that triggers profile loading from relays
   - A getValue function that extracts the pubkey from profiles
   - A custom sorting function that combines the Fuse.js match score with the profile's WoT score
   - Fuse.js configuration that prioritizes searching by NIP-05, name, display_name, and about fields with different weights

The search results are influenced by both text relevance and the user's position in the web of trust graph, giving preference to profiles that are more trusted in the network.

related: derived

import/access examples:
import { profileSearch } from '@welshman/app';
import { profileSearch } from '@welshman/app/search';


=========================
workspace: packages/app
file: packages/app/src/search.ts
lines: 96:101
id: 914a1521e7718c1b1e3467d30509711d765a8d6d1ac901a99124979839093057
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/search.ts#L96

declaration:
topicSearch = derived(topics, $topics =>
  createSearch($topics, {
    getValue: (topic: Topic) => topic.name,
    fuseOptions: {keys: ["name"]},
  }),
)

summary:
A derived store that creates a search functionality for topics. It takes the topics store and returns a Search object that allows searching through topics by their name. The search is powered by Fuse.js for fuzzy searching capabilities.

details:
This variable is implemented as a Svelte derived store that depends on the 'topics' store. When the topics store updates, it creates a new search instance using the 'createSearch' function with the following configuration:
1. It uses the current value of topics as the options to search through
2. It configures the search to use the topic name as the value identifier
3. It sets up Fuse.js to search only through the 'name' property of topics

The implementation is fairly straightforward, leveraging the createSearch utility to handle the fuzzy search functionality.

related: derived

import/access examples:
import { topicSearch } from '@welshman/app';
import { topicSearch } from '@welshman/app/search';


=========================
workspace: packages/app
file: packages/app/src/search.ts
lines: 103:110
id: 3da4c8b73472be587d0ec055bdcbbb768384d45936b9f8d7ce2a323df18356cc
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/search.ts#L103

declaration:
relaySearch = derived(relays, $relays =>
  createSearch($relays, {
    getValue: (relay: Relay) => relay.url,
    fuseOptions: {
      keys: ["url", "name", {name: "description", weight: 0.3}],
    },
  }),
)

summary:
A derived store that provides search functionality for relays. It creates a search interface for relay objects, allowing users to search relays by their URL, name, and description (with lower weight). The search returns relay objects or their URL values based on the search term.

details:
This variable is implemented as a Svelte derived store that depends on the 'relays' store. When the relays store updates, it creates a new search interface using the createSearch function with the following configuration:
1. It uses relay.url as the value getter for each relay object
2. It configures fuse.js to search across three fields:
   - "url" (full weight)
   - "name" (full weight)
   - "description" (reduced weight of 0.3)

The implementation leverages the createSearch utility function which internally uses Fuse.js for fuzzy searching capabilities.

related: derived

import/access examples:
import { relaySearch } from '@welshman/app';
import { relaySearch } from '@welshman/app/search';


=========================
workspace: packages/app
file: packages/app/src/storage.ts
lines: 8:11
id: 8319b5db2f55c275823ffe9352d8089c8aada9cc0100d2700dd6dcfcba9b549b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/storage.ts#L8

declaration:
export type StorageAdapterOptions = {
  throttle?: number
  migrate?: (items: any[]) => any[]
}

summary:
A type definition for options that can be passed to a storage adapter. It includes optional properties: `throttle` for controlling the frequency of operations, and `migrate` for transforming items during data migration.

details:
This type alias defines configuration options for storage adapters in an IndexedDB-based storage system. The options include:
1. `throttle?: number` - An optional numeric value that likely controls the rate at which storage operations are performed, helping to prevent performance issues from too many rapid operations.
2. `migrate?: (items: any[]) => any[]` - An optional function that takes an array of items and returns a transformed array, useful for data migration scenarios when the structure of stored data needs to change.

import/access examples:
import type { StorageAdapterOptions } from '@welshman/app';
import type { StorageAdapterOptions } from '@welshman/app/storage';


=========================
workspace: packages/app
file: packages/app/src/storage.ts
lines: 13:17
id: 942523e52e2ca6224ab34641cd54d52ac8015e50eda28b67d97b785b5f8ffadb
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/storage.ts#L13

declaration:
export type StorageAdapter = {
  keyPath: string
  init: () => Promise<void>
  sync: () => Unsubscriber
}

summary:
A TypeScript type definition that represents an adapter for storage operations. It defines the interface for interacting with a storage mechanism, containing three properties: `keyPath` (a string that identifies the primary key in the storage), `init` (an asynchronous function to initialize the adapter), and `sync` (a function that returns an Unsubscriber to synchronize data).

details:
This type is part of a storage system that appears to be built on top of IndexedDB (based on the imports and other functions in the file). The `StorageAdapter` interface is designed to abstract the storage operations for different types of data stores. It requires implementers to provide:

1. A `keyPath` string that defines the primary key for the object store
2. An `init` method that performs any necessary initialization
3. A `sync` method that sets up data synchronization and returns an unsubscriber function

The adapter pattern used here allows for different storage implementations while maintaining a consistent interface for the rest of the application to interact with.

import/access examples:
import type { StorageAdapter } from '@welshman/app';
import type { StorageAdapter } from '@welshman/app/storage';


=========================
workspace: packages/app
file: packages/app/src/storage.ts
lines: 19:19
id: c931a213938b930077aaac331c125503332de042e357755fae70d3d60a3ebbbf
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/storage.ts#L19

declaration:
db: IDBPDatabase | undefined

summary:
A variable that holds the reference to the IndexedDB database instance. It's exported and can be undefined if the database hasn't been initialized yet. This variable is used throughout the storage module to interact with the database.

details:
This variable serves as the central reference point to the active IndexedDB database connection in the application. It's initialized during the `initStorage` function call and cleared during `clearStorage`. The database instance is used by various functions like `getAll`, `bulkPut`, and `bulkDelete` to perform database operations. The variable is marked as potentially undefined to handle cases where the database hasn't been initialized yet or has been closed.

import/access examples:
import { db } from '@welshman/app';
import { db } from '@welshman/app/storage';


=========================
workspace: packages/app
file: packages/app/src/storage.ts
lines: 21:21
id: 6637f6064110f78aa138d743b46fcd094b805eac87083692499b82de13903578
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/storage.ts#L21

declaration:
ready = defer<void>()

summary:
A deferred Promise that resolves when the IndexedDB storage is ready for use. This exported variable allows consumers to await storage initialization before performing operations.

details:
The `ready` variable is created using the `defer<void>()` function imported from `@welshman/lib`. A deferred Promise is a Promise that can be resolved or rejected from outside its executor function, which gives control over when the Promise resolves. In this implementation, the Promise is resolved in the `initStorage` function (line 101) after the database has been successfully opened and configured.

related: defer

import/access examples:
import { ready } from '@welshman/app';
import { ready } from '@welshman/app/storage';


=========================
workspace: packages/app
file: packages/app/src/storage.ts
lines: 23:23
id: 9f27fde022c9b26f4a09c884278454a01db52b5b99af6642bb61739d611d45af
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/storage.ts#L23

declaration:
dead = withGetter(writable(false))

summary:
A Svelte store that tracks whether the storage system is in a 'dead' state (i.e., closed or unusable). It's created using `withGetter` and initialized with a value of `false`. This store can be subscribed to for reactive updates when the storage state changes.

details:
This variable is implemented using a combination of Svelte's `writable` store and a custom `withGetter` utility. The `withGetter` function likely enhances the standard Svelte store with a getter method for easier value access without subscription. The store is initialized with `false`, indicating that the storage system starts in a 'live' (not dead) state. It's later set to `true` in the `closeStorage` function when the database connection is being terminated.

related: withGetter

import/access examples:
import { dead } from '@welshman/app';
import { dead } from '@welshman/app/storage';


=========================
workspace: packages/app
file: packages/app/src/storage.ts
lines: 25:25
id: 5ebbec956335379daaae501c9db420608702c4acda05d9345c129ba71a953e32
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/storage.ts#L25

declaration:
unsubscribers: Unsubscriber[] = []

summary:
An exported array that stores Svelte store unsubscriber functions. These functions are collected during storage initialization and are called when the storage is closed to clean up subscriptions.

details:
This variable is initialized as an empty array and serves as a registry for all the unsubscriber functions returned by the `sync` method of storage adapters. When `initStorage` is called, it collects unsubscriber functions from each adapter and pushes them into this array (line 107). Later, when `closeStorage` is called, all these functions are executed using the `call` utility function (line 114) to properly clean up all active subscriptions and prevent memory leaks.

import/access examples:
import { unsubscribers } from '@welshman/app';
import { unsubscribers } from '@welshman/app/storage';


=========================
workspace: packages/app
file: packages/app/src/storage.ts
lines: 27:37
id: b0a6ce2fe0dc956829ee3ff06aea8e03d90bbb51886e938f37776aaf9f6fbda1
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/storage.ts#L27

declaration:
getAll = async (name: string) => {
  await ready

  const tx = db!.transaction(name, "readwrite")
  const store = tx.objectStore(name)
  const result = await store.getAll()

  await tx.done

  return result
}

summary:
Asynchronous function that retrieves all records from a specified IndexedDB object store. It takes a store name as a parameter and returns a Promise that resolves to an array of all records in that store.

details:
The implementation:
1. Waits for the database to be ready using the 'ready' promise
2. Creates a readwrite transaction on the specified store
3. Gets a reference to the object store
4. Calls the native IndexedDB getAll() method to retrieve all records
5. Waits for the transaction to complete with 'await tx.done'
6. Returns the retrieved records

The function assumes the database has been properly initialized and the specified store exists.

import/access examples:
import { getAll } from '@welshman/app';
import { getAll } from '@welshman/app/storage';


=========================
workspace: packages/app
file: packages/app/src/storage.ts
lines: 39:56
id: a742912e95ba1a3e1e638be99ff28f7116bf1e7fa53db1e583c3e2c18383f531
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/storage.ts#L39

declaration:
bulkPut = async (name: string, data: any[]) => {
  await ready

  const tx = db!.transaction(name, "readwrite")
  const store = tx.objectStore(name)

  await Promise.all(
    data.map(item => {
      try {
        store.put(item)
      } catch (e) {
        console.error(e, item)
      }
    }),
  )

  await tx.done
}

summary:
Asynchronously stores multiple items in an IndexedDB object store. Takes a store name and an array of data items to be stored. This function waits for the database to be ready, creates a readwrite transaction, and attempts to put each item into the store, logging errors for any failed operations without stopping the process.

details:
Implementation details:
1. Waits for the database to be ready using the 'ready' promise
2. Creates a readwrite transaction on the specified store
3. Gets a reference to the object store
4. Uses Promise.all with Array.map to process all items in parallel
5. For each item, attempts to call store.put() inside a try/catch block to handle errors gracefully
6. Logs any errors to console but continues processing other items
7. Waits for the transaction to complete with tx.done before returning
8. Does not return any value (void Promise)

import/access examples:
import { bulkPut } from '@welshman/app';
import { bulkPut } from '@welshman/app/storage';


=========================
workspace: packages/app
file: packages/app/src/storage.ts
lines: 58:66
id: 1400c20461be9a0c20ccd40993c50f033ce9723e45ef4613656ec64c7cb466e0
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/storage.ts#L58

declaration:
bulkDelete = async (name: string, ids: string[]) => {
  await ready

  const tx = db!.transaction(name, "readwrite")
  const store = tx.objectStore(name)

  await Promise.all(ids.map(id => store.delete(id)))
  await tx.done
}

summary:
Asynchronously deletes multiple items from an IndexedDB object store by their IDs. The function takes a store name and an array of IDs to delete, waits for the database to be ready, and performs the deletion operations in parallel.

details:
Implementation details:
1. Waits for the database to be ready using the 'ready' promise
2. Creates a readwrite transaction on the specified object store
3. Gets a reference to the object store
4. Uses Promise.all to concurrently delete all items by mapping over the IDs array and calling store.delete for each ID
5. Waits for the transaction to complete with tx.done before returning
6. No error handling is implemented for individual deletion operations

import/access examples:
import { bulkDelete } from '@welshman/app';
import { bulkDelete } from '@welshman/app/storage';


=========================
workspace: packages/app
file: packages/app/src/storage.ts
lines: 68:110
id: a5e55cba31c9fd1803a16e4641a3958ca04da27523ff9cf484776b7bc6ba1022
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/storage.ts#L68

declaration:
initStorage = async (
  name: string,
  version: number,
  adapters: Record<string, StorageAdapter>,
) => {
  if (!window.indexedDB) return

  window.addEventListener("beforeunload", () => closeStorage())

  if (db) {
    throw new Error("Db initialized multiple times")
  }

  db = await openDB(name, version, {
    upgrade(db: IDBPDatabase) {
      const names = Object.keys(adapters)

      for (const name of db.objectStoreNames) {
        if (!names.includes(name)) {
          db.deleteObjectStore(name)
        }
      }

      for (const [name, {keyPath}] of Object.entries(adapters)) {
        try {
          db.createObjectStore(name, {keyPath})
        } catch (e) {
          console.warn(e)
        }
      }
    },
  })

  ready.resolve()

  await Promise.all(
    Object.values(adapters).map(async adapter => {
      await adapter.init()

      unsubscribers.push(adapter.sync())
    }),
  )
}

summary:
Initializes IndexedDB storage with the specified name, version, and adapters. Takes a database name, version number, and a record of storage adapters that define the object stores. Returns a Promise that resolves when initialization is complete. If IndexedDB is not available, the function returns immediately without initializing storage.

details:
The implementation:
1. Checks if IndexedDB is available in the browser, returning early if not
2. Sets up a beforeunload event listener to close the database when the page unloads
3. Throws an error if the database is already initialized to prevent multiple initializations
4. Opens the IndexedDB database with the provided name and version
5. Implements an upgrade handler that:
   - Removes any object stores that aren't in the provided adapters
   - Creates object stores for each adapter with the specified keyPath
6. Resolves the 'ready' deferred promise to signal database availability
7. Initializes each adapter by:
   - Calling its init() method
   - Setting up synchronization by calling sync() and storing the unsubscriber

The function uses the idb library for IndexedDB operations and manages global state including the db reference and unsubscribers array.

related: StorageAdapter

import/access examples:
import { initStorage } from '@welshman/app';
import { initStorage } from '@welshman/app/storage';


=========================
workspace: packages/app
file: packages/app/src/storage.ts
lines: 112:116
id: a55adf602acd7fe81298a59dcd0431faaa7b04d8a651c0fedb1d04b9adc9560d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/storage.ts#L112

declaration:
closeStorage = async () => {
  dead.set(true)
  unsubscribers.forEach(call)
  await db?.close()
}

summary:
Asynchronous function that closes the IndexedDB storage connection, marks the storage as dead, and cleans up any subscriptions. This function is exported and can be used to properly shut down the storage system.

details:
The implementation:
1. Sets the 'dead' store value to true, which likely signals to other parts of the application that the storage is no longer available
2. Calls all unsubscriber functions stored in the 'unsubscribers' array using the 'call' utility function, which cleans up any active subscriptions
3. Waits for the database connection to close if it exists (using optional chaining with '?.')

This function is automatically called during the 'beforeunload' event as set up in the 'initStorage' function to ensure proper cleanup when the page is closed.

import/access examples:
import { closeStorage } from '@welshman/app';
import { closeStorage } from '@welshman/app/storage';


=========================
workspace: packages/app
file: packages/app/src/storage.ts
lines: 118:124
id: f3e650c6347725b058255321ec9ce197275998a8823df419ad6469b3c773d87a
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/storage.ts#L118

declaration:
clearStorage = async () => {
  if (db) {
    await closeStorage()
    await deleteDB(db.name)
    db = undefined // force initStorage to run again in tests
  }
}

summary:
Asynchronous function that clears the IndexedDB storage by closing the current database connection and deleting the database. It sets the database reference to undefined to allow re-initialization.

details:
Implementation details:
1. Checks if the database (`db`) is currently initialized
2. If database exists:
   - Calls `closeStorage()` to properly close connections and clean up resources
   - Uses the imported `deleteDB` function from the 'idb' library to delete the database using its name
   - Sets the `db` variable to undefined, which allows `initStorage` to be called again (particularly useful in testing scenarios as noted in the comment)

import/access examples:
import { clearStorage } from '@welshman/app';
import { clearStorage } from '@welshman/app/storage';


=========================
workspace: packages/app
file: packages/app/src/zappers.ts
lines: 17:17
id: ca7af303572ef39265e48f28cdde045fd17c6f9d1bb96cf31fa93270fbd9eba9
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/zappers.ts#L17

declaration:
zappers = writable<Zapper[]>([])

summary:
A writable Svelte store that holds an array of Zapper objects. This store serves as the central repository for zapper information in the application, allowing components to subscribe to changes in the collection of zappers.

details:
This is a simple writable Svelte store initialized with an empty array of Zapper objects. It's used as the underlying storage mechanism for the zappers collection defined later in the file. The store is exported so it can be directly subscribed to or updated from other modules if needed, though most interactions with zappers should happen through the collection API (zappersByLnurl, deriveZapper, loadZapper, etc.).

related: writable

import/access examples:
import { zappers } from '@welshman/app';
import { zappers } from '@welshman/app/zappers';


=========================
workspace: packages/app
file: packages/app/src/zappers.ts
lines: 19:54
id: 443ca7f5da87aa4778edc6d02cd04b5eb5aec18aacdc97b6849fa69d2fa8e561
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/zappers.ts#L19

declaration:
fetchZappers = async (lnurls: string[]) => {
  const base = appContext.dufflepudUrl
  const zappersByLnurl = new Map<string, Zapper>()

  // Use dufflepud if we it's set up to protect user privacy, otherwise fetch directly
  if (base) {
    const hexUrls = removeNil(lnurls.map(lnurl => tryCatch(() => bech32ToHex(lnurl))))

    if (hexUrls.length > 0) {
      const res: any = await tryCatch(
        async () => await postJson(`${base}/zapper/info`, {lnurls: hexUrls}),
      )

      for (const {lnurl, info} of res?.data || []) {
        tryCatch(() => zappersByLnurl.set(hexToBech32("lnurl", lnurl), info))
      }
    }
  } else {
    const results = await Promise.all(
      lnurls.map(async lnurl => {
        const hexUrl = tryCatch(() => bech32ToHex(lnurl))
        const info = hexUrl ? await tryCatch(async () => await fetchJson(hexUrl)) : undefined

        return {lnurl, hexUrl, info}
      }),
    )

    for (const {lnurl, info} of results) {
      if (info) {
        zappersByLnurl.set(lnurl, info)
      }
    }
  }

  return zappersByLnurl
}

summary:
Fetches information about Lightning Network zappers from their LNURLs. Takes an array of LNURL strings and returns a Map where keys are LNURLs and values are Zapper information objects. The function prioritizes user privacy by using a dufflepud proxy server when available, otherwise fetching directly from the LNURLs.

details:
The implementation works in two different ways depending on whether a dufflepud URL is available in the app context:

1. With dufflepud proxy (privacy-preserving):
   - Converts LNURLs from bech32 to hex format
   - Sends a batch request to the dufflepud server with all hex LNURLs
   - Processes the response by converting hex back to bech32 format and storing zapper info

2. Direct fetching (when no dufflepud available):
   - Makes parallel requests to each LNURL directly
   - Converts each LNURL to hex for fetching
   - Stores successful responses in the result map

The function uses error handling via tryCatch throughout to ensure robustness when dealing with potentially invalid LNURLs or network failures.

import/access examples:
import { fetchZappers } from '@welshman/app';
import { fetchZappers } from '@welshman/app/zappers';


=========================
workspace: packages/app
file: packages/app/src/zappers.ts
lines: 56:81
id: 652b20d484adc33e0e78a4a4586a9586521a3f7f010f7daeded0f5f86657b423
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/zappers.ts#L56

declaration:
{
  indexStore: zappersByLnurl,
  deriveItem: deriveZapper,
  loadItem: loadZapper,
  onItem: onZapper,
} = collection({
  name: "zappers",
  store: zappers,
  getKey: (zapper: Zapper) => zapper.lnurl,
  load: batcher(800, async (lnurls: string[]) => {
    const fresh = await fetchZappers(uniq(lnurls))
    const stale = zappersByLnurl.get()

    for (const lnurl of lnurls) {
      const newZapper = fresh.get(lnurl)

      if (newZapper) {
        stale.set(lnurl, {...newZapper, lnurl})
      }
    }

    zappers.set(Array.from(stale.values()))

    return lnurls
  }),
})

summary:
A collection of utility functions and stores for managing zapper data. It exports several functions and stores: `zappersByLnurl` (an index store for zappers by their LNURL), `deriveZapper` (to derive a zapper from the store), `loadZapper` (to load a zapper by LNURL), and `onZapper` (to subscribe to zapper changes). These are created using the `collection` utility with configuration for zapper management.

details:
This is an object destructuring assignment from the result of calling the `collection` function. The implementation:

1. Creates a collection named "zappers" that uses the `zappers` store
2. Defines how to get a key from a zapper object (using its `lnurl` property)
3. Implements a batched loading mechanism that:
   - Waits 800ms to batch multiple requests together
   - Calls `fetchZappers` with unique LNURLs
   - Updates the existing zappers map with fresh data
   - Updates the main zappers store with all values
   - Returns the requested LNURLs

The collection pattern provides a consistent way to access, derive, load and subscribe to zapper data throughout the application.

import/access examples:
import { zappersByLnurl } from '@welshman/app';
import { zappersByLnurl } from '@welshman/app/zappers';


=========================
workspace: packages/app
file: packages/app/src/zappers.ts
lines: 56:81
id: 652b20d484adc33e0e78a4a4586a9586521a3f7f010f7daeded0f5f86657b423
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/zappers.ts#L56

declaration:
{
  indexStore: zappersByLnurl,
  deriveItem: deriveZapper,
  loadItem: loadZapper,
  onItem: onZapper,
} = collection({
  name: "zappers",
  store: zappers,
  getKey: (zapper: Zapper) => zapper.lnurl,
  load: batcher(800, async (lnurls: string[]) => {
    const fresh = await fetchZappers(uniq(lnurls))
    const stale = zappersByLnurl.get()

    for (const lnurl of lnurls) {
      const newZapper = fresh.get(lnurl)

      if (newZapper) {
        stale.set(lnurl, {...newZapper, lnurl})
      }
    }

    zappers.set(Array.from(stale.values()))

    return lnurls
  }),
})

summary:
A collection of utility functions and stores for managing zapper data. It exports several functions and stores: `zappersByLnurl` (an index store for zappers by their LNURL), `deriveZapper` (to derive a zapper from the store), `loadZapper` (to load a zapper by LNURL), and `onZapper` (to subscribe to zapper changes). These are created using the `collection` utility with configuration for zapper management.

details:
This is an object destructuring assignment from the result of calling the `collection` function. The implementation:

1. Creates a collection named "zappers" that uses the `zappers` store
2. Defines how to get a key from a zapper object (using its `lnurl` property)
3. Implements a batched loading mechanism that:
   - Waits 800ms to batch multiple requests together
   - Calls `fetchZappers` with unique LNURLs
   - Updates the existing zappers map with fresh data
   - Updates the main zappers store with all values
   - Returns the requested LNURLs

The collection pattern provides a consistent way to access, derive, load and subscribe to zapper data throughout the application.

import/access examples:
import { zappersByLnurl } from '@welshman/app';
import { zappersByLnurl } from '@welshman/app/zappers';


=========================
workspace: packages/app
file: packages/app/src/zappers.ts
lines: 56:81
id: 652b20d484adc33e0e78a4a4586a9586521a3f7f010f7daeded0f5f86657b423
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/zappers.ts#L56

declaration:
{
  indexStore: zappersByLnurl,
  deriveItem: deriveZapper,
  loadItem: loadZapper,
  onItem: onZapper,
} = collection({
  name: "zappers",
  store: zappers,
  getKey: (zapper: Zapper) => zapper.lnurl,
  load: batcher(800, async (lnurls: string[]) => {
    const fresh = await fetchZappers(uniq(lnurls))
    const stale = zappersByLnurl.get()

    for (const lnurl of lnurls) {
      const newZapper = fresh.get(lnurl)

      if (newZapper) {
        stale.set(lnurl, {...newZapper, lnurl})
      }
    }

    zappers.set(Array.from(stale.values()))

    return lnurls
  }),
})

summary:
A collection of utility functions and stores for managing zapper data. It exports several functions and stores: `zappersByLnurl` (an index store for zappers by their LNURL), `deriveZapper` (to derive a zapper from the store), `loadZapper` (to load a zapper by LNURL), and `onZapper` (to subscribe to zapper changes). These are created using the `collection` utility with configuration for zapper management.

details:
This is an object destructuring assignment from the result of calling the `collection` function. The implementation:

1. Creates a collection named "zappers" that uses the `zappers` store
2. Defines how to get a key from a zapper object (using its `lnurl` property)
3. Implements a batched loading mechanism that:
   - Waits 800ms to batch multiple requests together
   - Calls `fetchZappers` with unique LNURLs
   - Updates the existing zappers map with fresh data
   - Updates the main zappers store with all values
   - Returns the requested LNURLs

The collection pattern provides a consistent way to access, derive, load and subscribe to zapper data throughout the application.

import/access examples:
import { zappersByLnurl } from '@welshman/app';
import { zappersByLnurl } from '@welshman/app/zappers';


=========================
workspace: packages/app
file: packages/app/src/zappers.ts
lines: 56:81
id: 652b20d484adc33e0e78a4a4586a9586521a3f7f010f7daeded0f5f86657b423
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/zappers.ts#L56

declaration:
{
  indexStore: zappersByLnurl,
  deriveItem: deriveZapper,
  loadItem: loadZapper,
  onItem: onZapper,
} = collection({
  name: "zappers",
  store: zappers,
  getKey: (zapper: Zapper) => zapper.lnurl,
  load: batcher(800, async (lnurls: string[]) => {
    const fresh = await fetchZappers(uniq(lnurls))
    const stale = zappersByLnurl.get()

    for (const lnurl of lnurls) {
      const newZapper = fresh.get(lnurl)

      if (newZapper) {
        stale.set(lnurl, {...newZapper, lnurl})
      }
    }

    zappers.set(Array.from(stale.values()))

    return lnurls
  }),
})

summary:
A collection of utility functions and stores for managing zapper data. It exports several functions and stores: `zappersByLnurl` (an index store for zappers by their LNURL), `deriveZapper` (to derive a zapper from the store), `loadZapper` (to load a zapper by LNURL), and `onZapper` (to subscribe to zapper changes). These are created using the `collection` utility with configuration for zapper management.

details:
This is an object destructuring assignment from the result of calling the `collection` function. The implementation:

1. Creates a collection named "zappers" that uses the `zappers` store
2. Defines how to get a key from a zapper object (using its `lnurl` property)
3. Implements a batched loading mechanism that:
   - Waits 800ms to batch multiple requests together
   - Calls `fetchZappers` with unique LNURLs
   - Updates the existing zappers map with fresh data
   - Updates the main zappers store with all values
   - Returns the requested LNURLs

The collection pattern provides a consistent way to access, derive, load and subscribe to zapper data throughout the application.

import/access examples:
import { zappersByLnurl } from '@welshman/app';
import { zappersByLnurl } from '@welshman/app/zappers';


=========================
workspace: packages/app
file: packages/app/src/zappers.ts
lines: 83:91
id: b0a4ade40b473f239389d969ea3cb219222312220fb63e01665d365b34ebd63b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/zappers.ts#L83

declaration:
loadZapperForPubkey = async (pubkey: string, relays: string[] = []) => {
  const $profile = await loadProfile(pubkey, relays)

  if (!$profile?.lnurl) {
    return undefined
  }

  return loadZapper($profile.lnurl)
}

summary:
Asynchronously loads a zapper (Lightning Network payment information) for a given public key. Takes a public key string and an optional array of relays as parameters. Returns the zapper information if the associated profile has an LNURL, otherwise returns undefined.

details:
The function works by:
1. First loading the user profile associated with the provided public key using the loadProfile function
2. Checking if the loaded profile contains an LNURL property
3. If no LNURL exists in the profile, it returns undefined
4. If an LNURL exists, it calls loadZapper with that LNURL to fetch and return the zapper information

This function essentially bridges profile data with zapper functionality, allowing Lightning Network payment information to be retrieved based on a user's public key.

import/access examples:
import { loadZapperForPubkey } from '@welshman/app';
import { loadZapperForPubkey } from '@welshman/app/zappers';


=========================
workspace: packages/app
file: packages/app/src/zappers.ts
lines: 93:102
id: f07027fd7622cd181aa97fd03010ef695db8edc008d8e85192f8616d05a57545
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/zappers.ts#L93

declaration:
deriveZapperForPubkey = (pubkey: string, relays: string[] = []) =>
  derived([zappersByLnurl, deriveProfile(pubkey, relays)], ([$zappersByLnurl, $profile]) => {
    if (!$profile?.lnurl) {
      return undefined
    }

    loadZapper($profile.lnurl)

    return $zappersByLnurl.get($profile.lnurl)
  })

summary:
A function that creates a derived store for a zapper associated with a given pubkey. It takes a pubkey string and an optional array of relays, and returns a Svelte derived store that will contain the zapper information when available. The store will update whenever the underlying zapper or profile data changes.

details:
This function works by:
1. Creating a derived store that depends on two sources: the zappersByLnurl store and the profile derived from the pubkey
2. When either source changes, the callback function checks if the profile has an lnurl
3. If no lnurl exists in the profile, it returns undefined
4. Otherwise, it triggers loading of the zapper data for that lnurl (side effect)
5. Returns the current zapper from the zappersByLnurl store for the profile's lnurl

The function uses the Svelte derived store pattern to reactively compute the zapper based on changes to the underlying stores.

related: derived

import/access examples:
import { deriveZapperForPubkey } from '@welshman/app';
import { deriveZapperForPubkey } from '@welshman/app/zappers';


=========================
workspace: packages/app
file: packages/app/src/zappers.ts
lines: 104:114
id: c01c677de981a397de51d7e5b32875a8f4ec1ed17f1389c33addae69142ac97b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/zappers.ts#L104

declaration:
getLnUrlsForEvent = async (event: TrustedEvent) => {
  const lnurls = removeNil(getTagValues("zap", event.tags).map(getLnUrl))

  if (lnurls.length > 0) {
    return lnurls
  }

  const profile = await loadProfile(event.pubkey)

  return removeNil([profile?.lnurl])
}

summary:
Asynchronously extracts Lightning Network URLs (LNURLs) from a Nostr event. First attempts to find LNURLs in the event's 'zap' tags. If none are found, falls back to retrieving the LNURL from the event author's profile.

details:
Implementation details:
1. First extracts values from 'zap' tags in the event using getTagValues(), then maps them through getLnUrl() to get LNURLs
2. Filters out any nil values using removeNil()
3. If LNURLs are found in the tags, returns them immediately
4. Otherwise, loads the profile of the event's author using loadProfile() with the event's pubkey
5. Returns an array containing the profile's LNURL (if it exists), filtered to remove nil values

import/access examples:
import { getLnUrlsForEvent } from '@welshman/app';
import { getLnUrlsForEvent } from '@welshman/app/zappers';


=========================
workspace: packages/app
file: packages/app/src/zappers.ts
lines: 116:120
id: a83f4f6356aeb66baefb6dddd8684f9552f0da9b24153fa16f78a4068fe2456b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/zappers.ts#L116

declaration:
getZapperForZap = async (zap: TrustedEvent, parent: TrustedEvent) => {
  const lnurls = await getLnUrlsForEvent(parent)

  return lnurls.length > 0 ? loadZapper(lnurls[0]) : undefined
}

summary:
Asynchronously retrieves a Zapper (Lightning Network service provider) associated with a zap event. It takes two parameters: the zap event and its parent event. The function returns the Zapper object if found, or undefined if no valid Lightning URL is available.

details:
The implementation works by:
1. Calling `getLnUrlsForEvent()` on the parent event to extract Lightning URLs
2. If at least one Lightning URL is found, it loads the Zapper information for the first URL using `loadZapper()`
3. Returns the loaded Zapper or undefined if no Lightning URLs were found

This function serves as a helper to validate zap events by connecting them to their associated payment service provider.

import/access examples:
import { getZapperForZap } from '@welshman/app';
import { getZapperForZap } from '@welshman/app/zappers';


=========================
workspace: packages/app
file: packages/app/src/zappers.ts
lines: 122:126
id: f68c7295ff0bf727ad8fe3ab740d235e3332bd6244f948f6601350b3703a5144
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/zappers.ts#L122

declaration:
getValidZap = async (zap: TrustedEvent, parent: TrustedEvent) => {
  const zapper = await getZapperForZap(zap, parent)

  return zapper ? zapFromEvent(zap, zapper) : undefined
}

summary:
Asynchronous function that validates a zap event against its parent event. It takes two parameters: `zap` (the zap event to validate) and `parent` (the event being zapped). Returns a validated Zap object if the zap is valid, or undefined if validation fails.

details:
The implementation works by:
1. First retrieving the appropriate zapper for the zap/parent combination using `getZapperForZap`
2. If a zapper is found, it uses the `zapFromEvent` utility function to validate and convert the raw zap event into a proper Zap object
3. If no zapper is found, it returns undefined, indicating the zap couldn't be validated

This function serves as a bridge between raw nostr events and validated zap objects that can be safely used in the application.

import/access examples:
import { getValidZap } from '@welshman/app';
import { getValidZap } from '@welshman/app/zappers';


=========================
workspace: packages/app
file: packages/app/src/zappers.ts
lines: 128:129
id: 76e99d45404348b7014d42088b2161eb93ae55c347d01c023f6c0c8696245e6c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/zappers.ts#L128

declaration:
getValidZaps = async (zaps: TrustedEvent[], parent: TrustedEvent) =>
  removeNil(await Promise.all(zaps.map(zap => getValidZap(zap, parent))))

summary:
Asynchronously filters and validates a list of zap events against a parent event. It takes an array of TrustedEvent objects representing zaps and a parent TrustedEvent, then returns a Promise that resolves to an array of valid Zap objects. Invalid zaps are removed from the result.

details:
This function works by:
1. Taking an array of zap events and a parent event as parameters
2. Using Promise.all to concurrently process each zap event through getValidZap
3. The getValidZap function checks if the zap is valid against the parent event by:
   - Finding the appropriate zapper for the parent event
   - Validating the zap against that zapper
4. Finally, removeNil is used to filter out any null/undefined results from invalid zaps

The implementation is a simple one-liner that combines Promise.all with array mapping and null removal.

related: removeNil

import/access examples:
import { getValidZaps } from '@welshman/app';
import { getValidZaps } from '@welshman/app/zappers';


=========================
workspace: packages/app
file: packages/app/src/zappers.ts
lines: 131:139
id: ed90560dedeb76b998afe14b412dffc6b5cf7a868272cf7f8851cc7de6671110
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/zappers.ts#L131

declaration:
deriveValidZaps = (zaps: TrustedEvent[], parent: TrustedEvent) => {
  const store = writable<Zap[]>([])

  getValidZaps(zaps, parent).then(validZaps => {
    store.set(validZaps)
  })

  return store
}

summary:
Creates a Svelte store that asynchronously validates and filters zap events. Takes an array of TrustedEvent objects representing zaps and a parent TrustedEvent that the zaps are associated with. Returns a writable Svelte store that will be populated with valid Zap objects once the validation process completes.

details:
The implementation:
1. Creates an empty writable Svelte store initialized with an empty array of Zap objects
2. Calls the getValidZaps function asynchronously, passing the provided zaps and parent event
3. When the promise resolves with validated zaps, updates the store with these valid zaps
4. Returns the store immediately, which will initially be empty but later populated when validation completes

This function provides a reactive way to work with zap validation in a Svelte application, allowing components to subscribe to the store and react when valid zaps are available.

import/access examples:
import { deriveValidZaps } from '@welshman/app';
import { deriveValidZaps } from '@welshman/app/zappers';


=========================
workspace: packages/app
file: packages/app/src/storageAdapters.ts
lines: 26:28
id: 0cba5f8df21a87c13dbb9778c850c655907a575dc6136997675251aa99416927
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/storageAdapters.ts#L26

declaration:
export type RelaysStorageAdapterOptions = {
  name: string
}

summary:
A type definition that specifies the configuration options for the RelaysStorageAdapter class. It contains a single required property 'name' which is a string that identifies the storage location for relay data.

import/access examples:
import type { RelaysStorageAdapterOptions } from '@welshman/app';
import type { RelaysStorageAdapterOptions } from '@welshman/app/storageAdapters';


=========================
workspace: packages/app
file: packages/app/src/storageAdapters.ts
lines: 30:42
id: 1a08eeef67ca6b090ed3192d329404e365789c5033309b26765fba1a3d45cbdc
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/storageAdapters.ts#L30

declaration:
export class RelaysStorageAdapter{
  keyPath: string;
  constructor(readonly options: RelaysStorageAdapterOptions);
  async init();
  sync();
}

summary:
RelaysStorageAdapter is a class that manages the persistence of relay information between application sessions. It provides methods to initialize relay data from storage and synchronize changes back to storage. The adapter requires a name option to identify the storage location.

details:
The implementation works by:
1. Storing a keyPath property ('url') that identifies the primary key for relay objects
2. In the init() method, it loads relay data from storage using getAll() and updates the relays store
3. The sync() method sets up a subscription to the relays store with throttling (3000ms) to prevent excessive writes
4. When the relays store changes, it persists the updated data using bulkPut
5. The throttling mechanism helps optimize storage operations by batching changes together

related: RelaysStorageAdapterOptions

code:
export class RelaysStorageAdapter {
  keyPath = "url"

  constructor(readonly options: RelaysStorageAdapterOptions) {}

  async init() {
    relays.set(await getAll(this.options.name))
  }

  sync() {
    return throttled(3000, relays).subscribe($relays => bulkPut(this.options.name, $relays))
  }
}

import/access examples:
import { RelaysStorageAdapter } from '@welshman/app';
import { RelaysStorageAdapter } from '@welshman/app/storageAdapters';


=========================
workspace: packages/app
file: packages/app/src/storageAdapters.ts
lines: 44:46
id: 3676e4b30b8c71b65455f996dc1adc89d3d3b0ae9df9d8392428036d5aadf914
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/storageAdapters.ts#L44

declaration:
export type HandlesStorageAdapterOptions = {
  name: string
}

summary:
A TypeScript type definition that specifies the configuration options for the HandlesStorageAdapter class. It contains a single property 'name' which is a string that identifies the storage location for handles data.

details:
This type is a simple configuration interface with just one required property:
1. `name`: A string that specifies the name of the storage collection/table where handle data will be stored and retrieved from.

The type is used as a parameter for the HandlesStorageAdapter constructor, which manages the persistence of handle data (likely NIP-05 identifiers based on the keyPath property in the related class).

import/access examples:
import type { HandlesStorageAdapterOptions } from '@welshman/app';
import type { HandlesStorageAdapterOptions } from '@welshman/app/storageAdapters';


=========================
workspace: packages/app
file: packages/app/src/storageAdapters.ts
lines: 48:60
id: 729223bb8caf3d04ae9f96879d6602c970fb8da53546168790ee60a97d6182bb
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/storageAdapters.ts#L48

declaration:
export class HandlesStorageAdapter{
  keyPath: string;
  constructor(readonly options: HandlesStorageAdapterOptions);
  async init();
  sync();
}

summary:
A storage adapter class for managing handles (NIP-05 identifiers) persistence. It provides methods to initialize handles from storage and synchronize changes back to storage. The class requires a name option to identify the storage location.

details:
The `HandlesStorageAdapter` implements a simple storage adapter pattern with:

1. A `keyPath` property set to "nip05" which serves as the primary key for handle records
2. An `init()` method that loads handles from storage using the `getAll()` function and sets them to the global `handles` store
3. A `sync()` method that subscribes to handle changes via `onHandle()` and batches updates every 300ms before persisting them to storage using `bulkPut()`

The implementation leverages the batch utility to optimize storage operations by grouping multiple handle updates together rather than persisting each change individually.

related: HandlesStorageAdapterOptions

code:
export class HandlesStorageAdapter {
  keyPath = "nip05"

  constructor(readonly options: HandlesStorageAdapterOptions) {}

  async init() {
    handles.set(await getAll(this.options.name))
  }

  sync() {
    return onHandle(batch(300, $handles => bulkPut(this.options.name, $handles)))
  }
}

import/access examples:
import { HandlesStorageAdapter } from '@welshman/app';
import { HandlesStorageAdapter } from '@welshman/app/storageAdapters';


=========================
workspace: packages/app
file: packages/app/src/storageAdapters.ts
lines: 62:64
id: ba9bf7b341ba75daa1a011c0aa33de35d7c2dd5928d68b70271db52fc370f6dc
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/storageAdapters.ts#L62

declaration:
export type ZappersStorageAdapterOptions = {
  name: string
}

summary:
A TypeScript type definition that specifies the configuration options for the ZappersStorageAdapter class. It contains a single property 'name' which is a string that identifies the storage location for zapper data.

details:
This type alias is part of a storage adapter system in the application. It defines the configuration interface for the ZappersStorageAdapter class which is responsible for persisting zapper data (likely Lightning Network URL handlers for payments). The 'name' property is used as the identifier for the storage collection when interacting with the underlying storage system.

import/access examples:
import type { ZappersStorageAdapterOptions } from '@welshman/app';
import type { ZappersStorageAdapterOptions } from '@welshman/app/storageAdapters';


=========================
workspace: packages/app
file: packages/app/src/storageAdapters.ts
lines: 66:78
id: 2a0ecab5f97c729c688a517fc3d5bd5df6f071672df1b630001ff375f0013c38
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/storageAdapters.ts#L66

declaration:
export class ZappersStorageAdapter{
  keyPath: string;
  constructor(readonly options: ZappersStorageAdapterOptions);
  async init();
  sync();
}

summary:
ZappersStorageAdapter is a class responsible for persisting and synchronizing zapper data between memory and storage. It provides methods to initialize the data from storage and set up synchronization to persist changes back to storage. The class requires a storage name to be provided in its constructor options.

details:
The implementation details of ZappersStorageAdapter include:
1. It defines a keyPath property set to "lnurl" which is used as the primary key for zapper records
2. The init() method loads zapper data from storage using getAll() and updates the zappers store
3. The sync() method sets up a subscription to zapper changes using onZapper, batching updates every 300ms before persisting them to storage with bulkPut
4. It works with the zappers store which is imported from "./zappers.js"
5. The storage operations are performed using the bulkPut function imported from "./storage.js"

related: ZappersStorageAdapterOptions

code:
export class ZappersStorageAdapter {
  keyPath = "lnurl"

  constructor(readonly options: ZappersStorageAdapterOptions) {}

  async init() {
    zappers.set(await getAll(this.options.name))
  }

  sync() {
    return onZapper(batch(300, $zappers => bulkPut(this.options.name, $zappers)))
  }
}

import/access examples:
import { ZappersStorageAdapter } from '@welshman/app';
import { ZappersStorageAdapter } from '@welshman/app/storageAdapters';


=========================
workspace: packages/app
file: packages/app/src/storageAdapters.ts
lines: 80:82
id: 7bdfcf1dfc0ae9251c85a8a3a9ecda76d1c55afaf0d407d0170fd2d46312539c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/storageAdapters.ts#L80

declaration:
export type FreshnessStorageAdapterOptions = {
  name: string
}

summary:
A type definition for the options required to initialize a FreshnessStorageAdapter. It contains a single property 'name' which specifies the storage location name for freshness data.

details:
This type alias defines the configuration interface for the FreshnessStorageAdapter class. The 'name' property is used as the identifier for the storage location where freshness data will be persisted. The FreshnessStorageAdapter uses this name when interacting with the storage system through functions like getAll and bulkPut.

import/access examples:
import type { FreshnessStorageAdapterOptions } from '@welshman/app';
import type { FreshnessStorageAdapterOptions } from '@welshman/app/storageAdapters';


=========================
workspace: packages/app
file: packages/app/src/storageAdapters.ts
lines: 84:105
id: 69ebd24d51b5ad97c4cf688fc566f4a452b7f1c3a80345950af92c4bccc4c5c4
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/storageAdapters.ts#L84

declaration:
export class FreshnessStorageAdapter{
  keyPath: string;
  constructor(readonly options: FreshnessStorageAdapterOptions);
  async init();
  sync();
}

summary:
A storage adapter class for managing freshness data persistence. It provides methods to initialize data from storage and synchronize changes back to storage. The class requires a name option to identify the storage location. It uses a key-value structure where 'key' is the primary identifier for each record.

details:
The implementation works as follows:

1. The class maintains a keyPath property set to "key" for identifying records.

2. The `init()` method:
   - Retrieves all items from the specified storage location
   - Transforms the data from array format to an object map using `fromPairs`
   - Sets this data to the global `freshness` store

3. The `sync()` method:
   - Sets up a 10-second interval that periodically saves data
   - On each interval, it:
     - Gets the current state from the freshness store
     - Transforms the object map back to an array of {key, value} objects
     - Performs a bulk update to storage
   - Returns a cleanup function that clears the interval when called

The class integrates with a global `freshness` store and uses `getAll` and `bulkPut` functions from the storage module to handle persistence.

related: FreshnessStorageAdapterOptions

code:
export class FreshnessStorageAdapter {
  keyPath = "key"

  constructor(readonly options: FreshnessStorageAdapterOptions) {}

  async init() {
    const items = await getAll(this.options.name)

    freshness.set(fromPairs(items.map(item => [item.key, item.value])))
  }

  sync() {
    const interval = setInterval(() => {
      bulkPut(
        this.options.name,
        Object.entries(freshness.get()).map(([key, value]) => ({key, value})),
      )
    }, 10_000)

    return () => clearInterval(interval)
  }
}

import/access examples:
import { FreshnessStorageAdapter } from '@welshman/app';
import { FreshnessStorageAdapter } from '@welshman/app/storageAdapters';


=========================
workspace: packages/app
file: packages/app/src/storageAdapters.ts
lines: 107:109
id: e8a9b0a56deb62480f0554275c946e027a60fd8ff1f7d6773215eb1f3229081c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/storageAdapters.ts#L107

declaration:
export type PlaintextStorageAdapterOptions = {
  name: string
}

summary:
PlaintextStorageAdapterOptions is a type definition that specifies the configuration options for the PlaintextStorageAdapter class. It contains a single property 'name' which is used to identify the storage location for plaintext data.

details:
This type is a simple configuration interface used by the PlaintextStorageAdapter class to specify which storage container to use when persisting plaintext key-value pairs. The 'name' property is passed to storage operations like getAll() and bulkPut() to target the correct storage collection.

import/access examples:
import type { PlaintextStorageAdapterOptions } from '@welshman/app';
import type { PlaintextStorageAdapterOptions } from '@welshman/app/storageAdapters';


=========================
workspace: packages/app
file: packages/app/src/storageAdapters.ts
lines: 111:132
id: cac3445b7cd10a7b7fadecbe7543ac2a521cc05b93dc837b997f225995a10a15
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/storageAdapters.ts#L111

declaration:
export class PlaintextStorageAdapter{
  keyPath: string;
  constructor(readonly options: PlaintextStorageAdapterOptions);
  async init();
  sync();
}

summary:
PlaintextStorageAdapter is a class that manages the persistence of plaintext key-value pairs between memory and storage. It provides methods to initialize data from storage and synchronize changes back to storage. The adapter uses a 'key' property as the unique identifier for each entry.

details:
The implementation:
1. Defines a keyPath property set to 'key' which serves as the unique identifier for stored items
2. Takes a 'name' option in the constructor to identify the storage collection
3. In the init() method:
   - Retrieves all items from storage using getAll()
   - Transforms the array of {key, value} objects into a key-value map using fromPairs()
   - Updates the plaintext store with this data
4. In the sync() method:
   - Sets up an interval that runs every 10 seconds
   - On each interval, it takes the current plaintext store data
   - Transforms the object back into an array of {key, value} objects
   - Persists this data using bulkPut()
   - Returns a cleanup function that clears the interval when called

related: PlaintextStorageAdapterOptions

code:
export class PlaintextStorageAdapter {
  keyPath = "key"

  constructor(readonly options: PlaintextStorageAdapterOptions) {}

  async init() {
    const items = await getAll(this.options.name)

    plaintext.set(fromPairs(items.map(item => [item.key, item.value])))
  }

  sync() {
    const interval = setInterval(() => {
      bulkPut(
        this.options.name,
        Object.entries(plaintext.get()).map(([key, value]) => ({key, value})),
      )
    }, 10_000)

    return () => clearInterval(interval)
  }
}

import/access examples:
import { PlaintextStorageAdapter } from '@welshman/app';
import { PlaintextStorageAdapter } from '@welshman/app/storageAdapters';


=========================
workspace: packages/app
file: packages/app/src/storageAdapters.ts
lines: 134:137
id: 8db380d51911fc75400feaa212559dbca79bbc0d6e363591e259deade44226b8
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/storageAdapters.ts#L134

declaration:
export type TrackerStorageAdapterOptions = {
  name: string
  tracker: Tracker
}

summary:
A type definition that specifies the configuration options for the TrackerStorageAdapter class. It contains two properties: 'name' which is a string identifier for storage, and 'tracker' which is an instance of the Tracker class from the @welshman/net package.

details:
This type alias defines the structure of the options object that must be passed to the TrackerStorageAdapter constructor. The 'name' property is used to identify the storage location where tracker data will be persisted, while the 'tracker' property provides the actual Tracker instance that will be synchronized with the storage.

import/access examples:
import type { TrackerStorageAdapterOptions } from '@welshman/app';
import type { TrackerStorageAdapterOptions } from '@welshman/app/storageAdapters';


=========================
workspace: packages/app
file: packages/app/src/storageAdapters.ts
lines: 139:179
id: aa25823aa9139c5bc960d6cd5a64ee5ac71b2f4d43854def72beab96bc17fcaa
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/storageAdapters.ts#L139

declaration:
export class TrackerStorageAdapter{
  keyPath: string;
  constructor(readonly options: TrackerStorageAdapterOptions);
  async init();
  sync();
}

summary:
The `TrackerStorageAdapter` class provides persistent storage functionality for a Tracker instance. It manages the storage and retrieval of tracking information, where each tracked item has an ID and a set of associated relays. The class implements initialization from storage and synchronization back to storage when the tracker state changes.

details:
Implementation details:
1. The class maintains a `keyPath` property set to "id" for database indexing.
2. During initialization (`init` method), it:
   - Loads tracking data from storage using `getAll`
   - Converts the data into a Map of Sets (id -> Set of relay URLs)
   - Loads this data into the provided tracker instance
3. The `sync` method sets up event listeners on the tracker to persist changes:
   - Defines `updateOne` function to update a single tracked item when relays are added/removed
   - Defines `updateAll` function to update all tracked items when bulk operations occur
   - Attaches these functions to the tracker's "add", "remove", "load", and "clear" events
   - Returns a cleanup function that removes all event listeners
4. The storage format uses an array of objects with `id` and `relays` properties, where `relays` is converted between Set and Array as needed.

related: TrackerStorageAdapterOptions

code:
export class TrackerStorageAdapter {
  keyPath = "id"

  constructor(readonly options: TrackerStorageAdapterOptions) {}

  async init() {
    const relaysById = new Map<string, Set<string>>()

    for (const {id, relays} of await getAll(this.options.name)) {
      relaysById.set(id, new Set(relays))
    }

    this.options.tracker.load(relaysById)
  }

  sync() {
    const updateOne = (id: string, relay: string) =>
      bulkPut(this.options.name, [{id, relays: Array.from(this.options.tracker.getRelays(id))}])

    const updateAll = () =>
      bulkPut(
        this.options.name,
        Array.from(this.options.tracker.relaysById.entries()).map(([id, relays]) => ({
          id,
          relays: Array.from(relays),
        })),
      )

    this.options.tracker.on("add", updateOne)
    this.options.tracker.on("remove", updateOne)
    this.options.tracker.on("load", updateAll)
    this.options.tracker.on("clear", updateAll)

    return () => {
      this.options.tracker.off("add", updateOne)
      this.options.tracker.off("remove", updateOne)
      this.options.tracker.off("load", updateAll)
      this.options.tracker.off("clear", updateAll)
    }
  }
}

import/access examples:
import { TrackerStorageAdapter } from '@welshman/app';
import { TrackerStorageAdapter } from '@welshman/app/storageAdapters';


=========================
workspace: packages/app
file: packages/app/src/storageAdapters.ts
lines: 181:186
id: 3d5a2687c224ecc5e025bec41fe66b0df855a2eb0d862b7e16a9fe7dde1c63d7
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/storageAdapters.ts#L181

declaration:
export type EventsStorageAdapterOptions = {
  name: string
  limit: number
  repository: Repository
  rankEvent: (event: TrustedEvent) => number
}

summary:
A TypeScript type definition that specifies the configuration options for the EventsStorageAdapter class. It includes the following properties:
- `name`: A string identifier for the storage.
- `limit`: A number representing the maximum number of events to store.
- `repository`: An instance of the Repository class from '@welshman/relay'.
- `rankEvent`: A function that takes a TrustedEvent and returns a number representing its importance/priority.

details:
This type alias defines the configuration interface for the EventsStorageAdapter, which appears to be part of a storage system for Nostr events. The options control:

1. The storage name used for persistence
2. A limit on how many events to retain
3. A repository object that likely manages the events in memory
4. A ranking function that determines which events are worth keeping

The ranking function is particularly important as it's used in the adapter's sync method to determine which events should be persisted and which can be discarded when storage limits are reached.

import/access examples:
import type { EventsStorageAdapterOptions } from '@welshman/app';
import type { EventsStorageAdapterOptions } from '@welshman/app/storageAdapters';


=========================
workspace: packages/app
file: packages/app/src/storageAdapters.ts
lines: 188:235
id: 7d6dcf65fb6cfcc8d3919b542f23df1415320e534f29a3ab5d64ebc5022b4838
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/storageAdapters.ts#L188

declaration:
export class EventsStorageAdapter{
  keyPath: string;
  eventCount: number;
  constructor(readonly options: EventsStorageAdapterOptions);
  async init();
  sync();
}

summary:
EventsStorageAdapter is a class that manages the storage and persistence of events in a repository. It handles initialization from storage, synchronization between memory and persistent storage, and implements event retention policies based on ranking and limits. The adapter maintains a keyPath of 'id' for indexing events and tracks the total event count.

details:
The implementation works as follows:

1. The class requires options including a storage name, event limit, repository instance, and a ranking function for events.

2. During initialization (`init()`), it:
   - Loads events from storage using `getAll()`
   - Tracks the event count
   - Loads the events into the provided repository

3. The `sync()` method sets up event handling for repository updates by:
   - Filtering added events based on the ranking function (only keeping events with rank > 0)
   - Persisting new events to storage with `bulkPut()`
   - Implementing a cleanup strategy when the event count exceeds 1.5x the limit
   - Removing events from storage using `bulkDelete()`
   - Tracking the approximate event count
   - Setting up event listeners on the repository's 'update' event
   - Returning a cleanup function that removes the event listeners

The class balances memory usage by periodically pruning the lowest-ranked events when the total count exceeds the specified limit by a significant margin.

related: EventsStorageAdapterOptions

code:
export class EventsStorageAdapter {
  keyPath = "id"
  eventCount = 0

  constructor(readonly options: EventsStorageAdapterOptions) {}

  async init() {
    const events = await getAll(this.options.name)

    this.eventCount = events.length

    this.options.repository.load(events)
  }

  sync() {
    const {name, limit, rankEvent} = this.options

    const onUpdate = async ({added, removed}: RepositoryUpdate) => {
      // Only add events we want to keep
      const keep = added.filter(e => rankEvent(e) > 0)

      // Add new events
      if (keep.length > 0) {
        await bulkPut(name, keep)
      }

      // If we're well above our retention limit, drop lowest-ranked events
      if (this.eventCount > limit * 1.5) {
        removed = new Set(removed)

        for (const event of sortBy(e => -rankEvent(e), await getAll(name)).slice(limit)) {
          removed.add(event.id)
        }
      }

      if (removed.size > 0) {
        await bulkDelete(name, Array.from(removed))
      }

      // Keep track of our total number of events. This isn't strictly accurate, but it's close enough
      this.eventCount = this.eventCount + keep.length - removed.size
    }

    this.options.repository.on("update", onUpdate)

    return () => this.options.repository.off("update", onUpdate)
  }
}

import/access examples:
import { EventsStorageAdapter } from '@welshman/app';
import { EventsStorageAdapter } from '@welshman/app/storageAdapters';


=========================
workspace: packages/app
file: packages/app/src/storageAdapters.ts
lines: 237:266
id: 068bf5b06aaae3e3cdb9a0f60b58c565bae1b63ed202596b45114dd099599021
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/storageAdapters.ts#L237

declaration:
defaultStorageAdapters = {
  relays: new RelaysStorageAdapter({name: "relays"}),
  handles: new HandlesStorageAdapter({name: "handles"}),
  zappers: new ZappersStorageAdapter({name: "zappers"}),
  freshness: new FreshnessStorageAdapter({name: "freshness"}),
  plaintext: new PlaintextStorageAdapter({name: "plaintext"}),
  tracker: new TrackerStorageAdapter({name: "tracker", tracker}),
  events: new EventsStorageAdapter(
    call(() => {
      const userFollowPubkeys = withGetter(
        derived(userFollows, l => new Set(getPubkeyTagValues(getListTags(l)))),
      )

      return {
        repository,
        name: "events",
        limit: 10_000,
        rankEvent: (e: TrustedEvent) => {
          const $sessions = sessions.get()
          const metaKinds = [PROFILE, FOLLOWS, MUTES, RELAYS, INBOX_RELAYS]

          if ($sessions[e.pubkey] || e.tags.some(t => $sessions[t[1]])) return 1
          if (metaKinds.includes(e.kind) && userFollowPubkeys.get()?.has(e.pubkey)) return 1

          return 0
        },
      }
    }),
  ),
}

summary:
A constant object that provides default storage adapter instances for various data types in the application. It includes adapters for relays, handles, zappers, freshness data, plaintext data, tracker, and events. Each adapter is pre-configured with appropriate settings for persistent storage and synchronization of its respective data type.

details:
The `defaultStorageAdapters` object instantiates seven different storage adapter classes, each configured for a specific data type:

1. `relays`: Uses RelaysStorageAdapter to store relay URLs
2. `handles`: Uses HandlesStorageAdapter to store NIP-05 handles
3. `zappers`: Uses ZappersStorageAdapter to store Lightning Network URLs
4. `freshness`: Uses FreshnessStorageAdapter to store key-value freshness data
5. `plaintext`: Uses PlaintextStorageAdapter to store generic key-value data
6. `tracker`: Uses TrackerStorageAdapter connected to the global tracker instance
7. `events`: Uses EventsStorageAdapter with a complex configuration that:
   - Limits storage to 10,000 events
   - Uses a ranking function that prioritizes events from active sessions and metadata events from followed users
   - Connects to the global repository instance

The implementation uses a self-executing function (`call()`) for the events adapter to create a derived store that tracks user follows for the ranking function.

import/access examples:
import { defaultStorageAdapters } from '@welshman/app';
import { defaultStorageAdapters } from '@welshman/app/storageAdapters';


=========================
workspace: packages/app
file: packages/app/src/sync.ts
lines: 7:8
id: 18b33af4a6da723bb15f8a0e0331eedbf376d02ef7dd36c5219bd2da2cc63015
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/sync.ts#L7

declaration:
query = (filters: Filter[]) =>
  repository.query(filters, {shouldSort: filters.every(f => f.limit === undefined)})

summary:
A function that queries the repository with the provided filters. It returns results sorted if all filters don't have a limit specified.

details:
This is a helper function that wraps the repository.query method with a specific configuration. It passes the filters directly to the repository query method and sets the shouldSort option based on whether all filters in the array don't have a limit property defined. The function uses the Array.every() method to check if all filter objects lack a limit property.

related: repository

=========================
workspace: packages/app
file: packages/app/src/sync.ts
lines: 10:18
id: 358a12e53ebca37d60b2885d5851a642993f96c8cb86ed65ee4fbcd533c3f4b3
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/sync.ts#L10

declaration:
hasNegentropy = (url: string) => {
  const p = relaysByUrl.get().get(url)?.profile

  if (p?.negentropy) return true
  if (p?.supported_nips?.includes?.(77)) return true
  if (p?.software?.includes?.("strfry") && !p?.version?.match(/^0\./)) return true

  return false
}

summary:
Determines if a relay supports the Negentropy protocol based on its URL. Returns true if the relay explicitly supports Negentropy, includes NIP-77, or runs a compatible version of strfry software.

details:
The function works by checking several properties of a relay's profile:
1. First checks if the relay profile explicitly declares negentropy support
2. Then checks if the relay's supported NIPs include NIP-77 (which is the Negentropy protocol)
3. Finally checks if the relay is running strfry software that's not a 0.x version

The implementation uses optional chaining (?.) throughout to safely navigate potentially undefined properties in the relay profile object.

import/access examples:
import { hasNegentropy } from '@welshman/app';
import { hasNegentropy } from '@welshman/app/sync';


=========================
workspace: packages/app
file: packages/app/src/sync.ts
lines: 20:23
id: b89d469ad529d29bd4803c61a5f4e68f48806b726d84a7b074bf1dfa3f5fe7b8
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/sync.ts#L20

declaration:
export type AppSyncOpts = {
  relays: string[]
  filters: Filter[]
}

summary:
AppSyncOpts is a type definition that specifies the parameters required for synchronization operations in the application. It contains two properties: 'relays', which is an array of relay server URLs, and 'filters', which is an array of Filter objects used to query events.

details:
This type alias is used as the parameter type for both the 'pull' and 'push' functions in the sync module. It provides a consistent interface for specifying which relays to connect to and what filters to apply when synchronizing data between the local repository and remote relays.

import/access examples:
import type { AppSyncOpts } from '@welshman/app';
import type { AppSyncOpts } from '@welshman/app/sync';


=========================
workspace: packages/app
file: packages/app/src/sync.ts
lines: 25:35
id: 46b20d53b666246e9d3786edc37ee514edc0cd0910a549ff8d2acf930f43819c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/sync.ts#L25

declaration:
pull = async ({relays, filters}: AppSyncOpts) => {
  const events = query(filters).filter(isSignedEvent)

  await Promise.all(
    relays.map(async relay => {
      await (hasNegentropy(relay)
        ? basePull({filters, events, relays: [relay]})
        : requestOne({filters, relay, autoClose: true}))
    }),
  )
}

summary:
Asynchronously pulls events from specified relays based on provided filters. It uses either negentropy-based synchronization or standard request methods depending on relay capabilities. The function takes an object with 'relays' (array of relay URLs) and 'filters' (array of Filter objects) as parameters and returns a Promise that resolves when all pull operations are complete.

details:
Implementation details:
1. First queries the local repository for events matching the provided filters and filters them to only include signed events
2. Then for each relay in the provided array:
   - Checks if the relay supports negentropy protocol using the hasNegentropy function
   - If negentropy is supported, uses basePull with the filters, events, and a single relay
   - If negentropy is not supported, falls back to requestOne with autoClose set to true
3. Uses Promise.all to handle all relay operations concurrently

related: AppSyncOpts

import/access examples:
import { pull } from '@welshman/app';
import { pull } from '@welshman/app/sync';


=========================
workspace: packages/app
file: packages/app/src/sync.ts
lines: 37:47
id: 26a826042590f98d52b2c2b898d529668ad9ab7ad6f7103a388cc5afa4545f7a
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/sync.ts#L37

declaration:
push = async ({relays, filters}: AppSyncOpts) => {
  const events = query(filters).filter(isSignedEvent)

  await Promise.all(
    relays.map(async relay => {
      await (hasNegentropy(relay)
        ? basePush({filters, events, relays: [relay]})
        : Promise.all(events.map((event: SignedEvent) => publishOne({event, relay}))))
    }),
  )
}

summary:
Pushes events matching specified filters to a list of relays. It accepts an object with `relays` (array of relay URLs) and `filters` (array of Filter objects) properties. The function queries the local repository for events matching the filters and pushes them to each specified relay, using either negentropy-based sync or traditional publishing based on relay capabilities.

details:
Implementation details:
1. Queries the local repository using the provided filters and filters the results to only include signed events
2. For each relay in the provided list:
   - Checks if the relay supports negentropy protocol using the `hasNegentropy` function
   - If negentropy is supported, uses the base push function with negentropy optimization
   - If not, falls back to publishing each event individually using `publishOne`
3. All relay operations are executed concurrently using Promise.all

related: AppSyncOpts

import/access examples:
import { push } from '@welshman/app';
import { push } from '@welshman/app/sync';


=========================
workspace: packages/app
file: packages/app/src/index.ts
lines: 62:73
id: fc8a3bc0642082140458f2189453863eacd0e86964802a47f03951f5dd54dce0
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/index.ts#L62

declaration:
_relayGetter = (fn?: (relay: Relay) => any) =>
  throttleWithValue(200, () => {
    let _relays = relays.get()

    if (fn) {
      _relays = _relays.filter(fn)
    }

    return sortBy(r => -getRelayQuality(r.url), _relays)
      .slice(0, 5)
      .map(r => r.url)
  })

summary:
A private utility function that creates a throttled function for retrieving a list of relay URLs. It optionally accepts a filter function to further refine the relay selection. The returned function will return up to 5 relay URLs sorted by quality (highest quality first).

details:
The implementation creates a throttled function (200ms) that:
1. Gets the current list of relays using relays.get()
2. Optionally filters the relays using the provided filter function
3. Sorts the relays by negative quality (using getRelayQuality) to get highest quality first
4. Takes the top 5 relays
5. Maps the relay objects to just their URLs

The throttling ensures this potentially expensive operation isn't called too frequently when multiple components need relay information in quick succession.

related: throttleWithValue,Relay

=========================
workspace: packages/app
file: packages/app/src/index.ts
lines: 75:78
id: 63bb517af10850cbb5b98c439436bf7f67797bd03931dd57817f96269b21f356
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/index.ts#L75

declaration:
getPubkeyRelays = (pubkey: string, mode?: RelayMode) =>
  mode === RelayMode.Inbox
    ? getRelaysFromList(inboxRelaySelectionsByPubkey.get().get(pubkey))
    : getRelaysFromList(relaySelectionsByPubkey.get().get(pubkey), mode)

summary:
A function that retrieves relay URLs associated with a specific public key. It accepts a pubkey string and an optional RelayMode parameter to filter the relays. If the mode is set to RelayMode.Inbox, it returns inbox-specific relays for the pubkey; otherwise, it returns standard relays that may be filtered by the provided mode.

details:
The implementation works by:
1. Checking if the mode parameter equals RelayMode.Inbox
2. If true, it retrieves inbox relay selections for the pubkey from the inboxRelaySelectionsByPubkey store
3. If false, it retrieves standard relay selections from relaySelectionsByPubkey store
4. In both cases, it uses the getRelaysFromList utility function to convert the selections into a list of relay URLs
5. For standard relays, it passes the mode parameter to potentially filter the results by read/write capabilities

related: getRelaysFromList

import/access examples:
import { getPubkeyRelays } from '@welshman/app';


=========================
workspace: packages/app
file: packages/app/src/index.ts
lines: 80:83
id: 692f6a6474c2c037ceb46128b8f16de39466c35c84ccfd1a57fa81a846a0d5da
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/index.ts#L80

declaration:
derivePubkeyRelays = (pubkey: string, mode?: RelayMode) =>
  mode === RelayMode.Inbox
    ? derived(inboxRelaySelectionsByPubkey, $m => getRelaysFromList($m.get(pubkey)))
    : derived(relaySelectionsByPubkey, $m => getRelaysFromList($m.get(pubkey), mode))

summary:
A function that creates a derived Svelte store for a user's relay selections. It takes a pubkey and an optional relay mode, and returns a store that updates whenever the user's relay selections change. The function differentiates between inbox relays and regular relays based on the provided mode.

details:
This function implements a reactive way to access a user's relay selections by creating a Svelte derived store. The implementation:

1. Checks if the requested mode is RelayMode.Inbox
2. If it is, creates a derived store from inboxRelaySelectionsByPubkey that extracts the relays for the given pubkey
3. If not, creates a derived store from relaySelectionsByPubkey that extracts the relays for the given pubkey with the specified mode
4. In both cases, it uses getRelaysFromList to transform the raw selections into a usable relay list

The function enables reactive access to relay selections that automatically update when the underlying selections change.

related: derived

import/access examples:
import { derivePubkeyRelays } from '@welshman/app';


=========================
type: dir
workspace: packages/app
path: packages/app/__tests__/
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/__tests__/
summary: The __tests__ directory contains test files for Nostr-related functionality, focusing on event publishing and tag handling. The main test file (thunk.test.ts) verifies the behavior of the Thunk and MergedThunk classes along with utility functions for asynchronous event publishing, including proper event creation, status tracking, and abort handling. This directory appears to be part of a test suite for a Nostr client implementation.

=========================
type: file
workspace: packages/app
path: packages/app/__tests__/thunk.test.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/__tests__/thunk.test.ts
summary: This file contains tests for the thunk module, which appears to handle asynchronous event publishing operations in a Nostr-related application. It tests the Thunk and MergedThunk classes, along with utility functions like flattenThunks, publishThunk, and abortThunk. The tests verify proper event publishing, status tracking, and abort handling functionality.

details: The test suite uses Vitest and mocks several dependencies to test the thunk functionality:

1. It sets up a test environment with fake timers and a test session before each test, and cleans up afterward.
2. Tests for MergedThunk verify that aborting a merged thunk aborts all contained thunks.
3. Tests for flattenThunks confirm it correctly iterates through nested thunk structures.
4. Tests for publishThunk verify it properly creates and publishes events, and handles abort operations.
5. Tests for abortThunk ensure it properly aborts operations and cleans up resources.
6. A final test verifies the publishing process updates status correctly and tracks events through the publishing lifecycle.

The implementation uses spies to verify interactions with the repository and tracker modules, and checks the state of thunks at various points in their lifecycle.

=========================
type: file
workspace: packages/app
path: packages/app/src/blossom.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/blossom.ts
summary: This file exports functionality related to Blossom servers in a Nostr-based application. It provides stores and utilities for managing and accessing lists of Blossom servers, including functions to derive, load, and index server information by public key.

details: The implementation leverages several components:
1. It imports utilities from '@welshman/util' for handling encrypted events and published lists
2. Uses data storage patterns from '@welshman/store' with the 'deriveEventsMapped' and 'collection' functions
3. Creates a derived store 'blossomServers' that filters events by the BLOSSOM_SERVERS kind
4. Transforms events using readList and asDecryptedEvent functions
5. Sets up a collection with indexing by pubkey and provides load/derive functions
6. Uses 'makeOutboxLoader' from relaySelections.js to handle loading functionality

=========================
type: file
workspace: packages/app
path: packages/app/src/commands.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/commands.ts
summary: This file exports a collection of functions for interacting with Nostr protocol features. It includes functions for managing relays (adding, removing), handling user profiles, managing follows/mutes/pins lists, sending encrypted messages (NIP-59), authenticating with relays (NIP-86), and managing chat rooms (NIP-29). These functions serve as command handlers that prepare and publish events to the Nostr network.

details: The implementation is organized around different NIPs (Nostr Implementation Possibilities):

1. For relay management (NIP-65), functions like `addRelay` and `removeRelay` modify relay lists and publish updates.

2. For inbox relays (NIP-17), `addInboxRelay` and `removeInboxRelay` handle specialized relay configurations.

3. Profile management uses `setProfile` to create or edit user profiles.

4. List management functions (NIP-02) include `follow`/`unfollow`, `mutePublicly`/`mutePrivately`/`unmute`, and `pin`/`unpin`.

5. For encrypted messaging (NIP-59), `sendWrapped` handles creating encrypted messages for multiple recipients.

6. Relay authentication (NIP-86) is handled by `manageRelay`.

7. Chat room operations (NIP-29) include functions for creating, editing, deleting, joining, and leaving rooms.

All functions follow a similar pattern: load current state, prepare an event, determine target relays, and publish using `publishThunk`. Many operations use encryption via `nip44EncryptToSelf` for private data.

=========================
type: file
workspace: packages/app
path: packages/app/src/context.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/context.ts
summary: This file exports a TypeScript type `AppContext` which defines a structure with an optional `dufflepudUrl` string property. It also exports a constant `appContext` initialized as an empty object that conforms to the `AppContext` type.

details: The implementation is minimal, consisting only of a type definition and an empty object initialization. The `AppContext` type has a single optional property `dufflepudUrl` of type string, and the exported `appContext` constant is initialized as an empty object, which is valid since all properties in the type are optional.

=========================
type: file
workspace: packages/app
path: packages/app/src/core.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/core.ts
summary: This file exports core components for a data management system: a repository, a local relay, a tracker, and functions to create reactive stores from these components. The `makeRepositoryStore` and `makeTrackerStore` functions convert the repository and tracker objects into reactive stores that update when the underlying data changes.

details: The implementation imports utilities from several modules in the @welshman namespace. It creates singleton instances of Repository, LocalRelay, and Tracker classes.

The two main functions, `makeRepositoryStore` and `makeTrackerStore`, use a custom store creator to wrap the repository and tracker objects in reactive stores. Both functions:
1. Accept an optional throttle parameter (defaulting to 300ms)
2. Create a setter function that updates the store with the current state
3. Apply throttling to the update function if specified
4. Register event listeners on the respective objects
5. Return a cleanup function to remove event listeners
6. Provide an onUpdate handler to synchronize data when the store is updated externally

The repository store listens for 'update' events, while the tracker store listens for 'add', 'remove', 'load', and 'clear' events.

=========================
type: file
workspace: packages/app
path: packages/app/src/feeds.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/feeds.ts
summary: This module provides functions for managing feeds in a social network context. It exports three main functions: `getPubkeysForScope` which retrieves public keys based on a specified scope (Self, Follows, Network, Followers), `getPubkeysForWOTRange` which filters public keys based on a Web of Trust score range, and `makeFeedController` which creates a new FeedController instance with the necessary dependencies.

details: The implementation relies on imported functionality from external modules:
1. It imports types and classes from '@welshman/feeds'
2. It uses session management via 'pubkey' and 'signer' from './session.js'
3. It leverages Web of Trust (WOT) functionality from './wot.js'

The `getPubkeysForScope` function uses a switch statement to return different sets of public keys based on the provided scope. The `getPubkeysForWOTRange` function filters public keys from the WOT graph based on normalized score thresholds. The `makeFeedController` function is a factory that creates a new FeedController with the local functions and session signer.

=========================
type: file
workspace: packages/app
path: packages/app/src/follows.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/follows.ts
summary: This file exports functionality related to managing and accessing user follows in a Nostr-like system. It provides access to follows data through `follows`, `followsByPubkey`, `deriveFollows`, and `loadFollows` exports, allowing retrieval and manipulation of follow lists by public key.

details: The implementation leverages several components:
1. It uses `deriveEventsMapped` from '@welshman/store' to create a derived store of follow events (kind FOLLOWS).
2. Events are processed through `readList` and `asDecryptedEvent` utilities to transform raw events into usable PublishedList objects.
3. The `collection` utility creates an indexed access pattern with:
   - An index store organized by pubkey
   - A derive function to get follows for a specific pubkey
   - A load function that uses `makeOutboxLoader` to fetch follows from relays

=========================
type: file
workspace: packages/app
path: packages/app/src/handles.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/handles.ts
summary: This file provides functionality for handling NIP-05 identifiers in a Nostr context. It exports types, functions, and stores for querying, fetching, and managing NIP-05 handles. Key exports include the `Handle` type, `queryProfile` function for fetching NIP-05 data, various stores like `handles` and `handlesByNip05`, and utility functions for displaying and deriving handles.

details: The implementation revolves around NIP-05 identifiers (user@domain.com format) and their associated data:

1. It uses Svelte stores (writable, derived) for state management.
2. The `queryProfile` function parses a NIP-05 identifier using regex and fetches the associated data from the domain's well-known nostr.json endpoint.
3. `fetchHandles` provides two methods to retrieve handle information:
   - Using a 'dufflepud' service (for privacy protection)
   - Direct fetching via `queryProfile`
4. The file implements a collection pattern with `handlesByNip05` store and associated helper functions.
5. Batching is used to optimize multiple handle requests with an 800ms delay.
6. `deriveHandleForPubkey` creates a derived store that connects pubkeys to their handles.
7. Helper functions like `displayNip05` and `displayHandle` format NIP-05 identifiers for display.

=========================
type: file
workspace: packages/app
path: packages/app/src/inboxRelaySelections.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/inboxRelaySelections.ts
summary: This file exports utilities for managing inbox relay selections in a Nostr-like system. It provides access to inbox relay selections through `inboxRelaySelectionsByPubkey`, `deriveInboxRelaySelections`, and `loadInboxRelaySelections` functions, which help retrieve and manage relay selection data by public key.

details: The implementation uses the repository pattern with derived events mapping. It creates a store for inbox relay selections by:
1. Using `deriveEventsMapped` to transform events of kind INBOX_RELAYS into PublishedList objects
2. Setting up a collection with indexing by pubkey
3. Utilizing `makeOutboxLoader` from relaySelections.js to handle loading functionality

The code leverages utility functions from @welshman/util for event decryption and list reading, and collection management from @welshman/store.

=========================
type: file
workspace: packages/app
path: packages/app/src/index.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/index.ts
summary: This file serves as the main export hub for a Nostr client library, exporting functionality from various modules related to Nostr protocol implementation. It also configures relay connections, event handling, and provides utility functions for working with relays, particularly for retrieving relays associated with specific public keys in different modes (inbox or general).

details: The implementation consists of three main parts:

1. Export declarations (lines 1-25) that re-export functionality from numerous modules that handle different aspects of Nostr functionality.

2. Relay synchronization logic (lines 40-58) that:
   - Loads and tracks relay statistics
   - Sets up event listeners for incoming messages
   - Filters out ephemeral and DVM-kind events
   - Validates events and publishes them to a repository

3. Router configuration and relay utility functions (lines 62-92):
   - A throttled relay getter function that returns high-quality relays
   - Functions to get relays for specific pubkeys in different modes
   - Configuration of router context with relay-related utilities

The code integrates with Svelte's store system (derived) and uses various utility functions from external libraries.

=========================
type: file
workspace: packages/app
path: packages/app/src/mutes.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/mutes.ts
summary: This file exports functionality for handling mute lists in a Nostr-like application. It provides the 'mutes' store for mute list events, and utilities for accessing mutes by pubkey, deriving mute information, and loading mute data. The module leverages the repository pattern and event handling from the @welshman libraries.

details: The implementation consists of two main parts:
1. The 'mutes' store created with deriveEventsMapped to handle PublishedList events of kind MUTES. It transforms events by ensuring their content is in plaintext and reading them as lists.
2. A collection utility that creates indexed access to mutes by pubkey, with functions for deriving and loading mute data. The collection uses makeOutboxLoader to handle loading mute events of the specific MUTES kind.

The file relies on external utilities for event handling, decryption, and repository management from various @welshman packages and local modules.

=========================
type: file
workspace: packages/app
path: packages/app/src/pins.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/pins.ts
summary: This file exports functionality related to user pins in a nostr-like system. It provides access to pin events through the `pins` store, and offers utilities to access pins by pubkey, derive pins for a specific user, and load pins data. The pins are stored as `PublishedList` objects and are identified by the `PINS` kind.

details: The implementation leverages several components:
1. It uses `deriveEventsMapped` from '@welshman/store' to create a reactive store for pin events
2. It transforms raw events into `PublishedList` objects using `readList` and `asDecryptedEvent` utilities
3. It creates a collection interface with `collection()` that provides indexing by pubkey and methods to derive/load pins
4. Pin loading is handled by a relay selection mechanism through `makeOutboxLoader`
5. The implementation connects to the application's main repository defined in core.js

=========================
type: file
workspace: packages/app
path: packages/app/src/plaintext.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/plaintext.ts
summary: This module manages plaintext content for trusted events. It exports a writable store for plaintext data, along with functions to get, set, and ensure plaintext content for events. The `ensurePlaintext` function handles decryption of encrypted event content when needed.

details: The implementation uses Svelte's writable store to maintain a record of plaintext content indexed by event IDs. The module:
1. Creates a plaintext store with a getter using `withGetter`
2. Provides `getPlaintext` to retrieve plaintext for a specific event
3. Provides `setPlaintext` to update the store with new plaintext content
4. Implements `ensurePlaintext` which:
   - Checks if decryption is needed (content exists but plaintext doesn't)
   - Gets the session and signer for the event's public key
   - Attempts to decrypt the content, handling base64 validation errors
   - Updates the plaintext store if decryption succeeds
   - Returns the plaintext content

=========================
type: file
workspace: packages/app
path: packages/app/src/profiles.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/profiles.ts
summary: This file exports functionality for managing and displaying Nostr profiles. It provides a store for profiles, functions to retrieve profiles by pubkey, and utilities to format profile display names. Key exports include 'profiles' store, 'profilesByPubkey' index, 'deriveProfile' and 'loadProfile' functions, and profile display utilities.

details: The implementation uses Svelte stores and custom store utilities from '@welshman/store' to manage profile data. It creates:
1. A main 'profiles' store using 'deriveEventsMapped' to track profile events (kind 0)
2. A collection with an index by pubkey for efficient lookup
3. Helper functions for loading and displaying profiles

The file leverages the repository from core.js and relay selection functionality to load profiles from the Nostr network. Profile display functions handle the formatting of profile information with fallbacks to pubkey display when profile data is unavailable.

=========================
type: file
workspace: packages/app
path: packages/app/src/relaySelections.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/relaySelections.ts
summary: This file provides utilities for loading and managing relay selections in a Nostr-like system. It exports functions for loading data using outbox relays, creating specialized loaders, and managing relay selections. Key exports include `loadUsingOutbox`, `makeOutboxLoader`, `makeOutboxLoaderWithIndexers`, and a collection of utilities for relay selections including `relaySelectionsByPubkey`, `deriveRelaySelections`, and `loadRelaySelections`.

details: The implementation revolves around relay selection and data loading strategies:

1. `loadUsingOutbox` is a batched function that loads data from relays associated with specific pubkeys.
2. `makeOutboxLoader` and `makeOutboxLoaderWithIndexers` are factory functions that create specialized loaders for specific event kinds, with the latter also querying indexer relays.
3. The file sets up a data store for relay selections using `deriveEventsMapped` from the repository.
4. It then creates a collection for relay selections with indexing by pubkey, providing functions to derive and load relay selections.
5. The implementation leverages several external modules including batching utilities, router functionality, and data loading mechanisms.

=========================
type: file
workspace: packages/app
path: packages/app/src/relays.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/relays.ts
summary: This file provides functionality for managing and tracking relay connections in a Nostr-like application. It exports types like `RelayStats` and `Relay`, along with utilities for creating, fetching, and displaying relay information. Key exports include the `relays` store, collection utilities (`relaysByUrl`, `deriveRelay`, etc.), functions for assessing relay quality, and a `trackRelayStats` function that monitors socket connections to update relay statistics.

details: The implementation revolves around Svelte stores to manage relay data:

1. The core data structure is a writable store of `Relay` objects, enhanced with collection utilities for indexing and deriving.

2. Relay statistics tracking is implemented through socket event listeners that monitor:
   - Socket status changes (open, close, error)
   - Message sending (requests, event publications)
   - Message receiving (events, notices, authentication, etc.)

3. The file uses batching for performance optimization in two key areas:
   - When loading relay profiles via API calls
   - When updating relay statistics to reduce store updates

4. Relay quality assessment is implemented in `getRelayQuality()`, which considers factors like:
   - Recent error history
   - Current connection status
   - Connection history
   - URL characteristics (security, locality)

5. The implementation includes data normalization and validation throughout to handle edge cases like invalid relay URLs.

=========================
type: file
workspace: packages/app
path: packages/app/src/search.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/search.ts
summary: This file provides search functionality for the application. It exports a generic `createSearch` function that creates a search interface for any collection of items, along with specialized search implementations for profiles, topics, and relays. The search functionality is built on top of Fuse.js for fuzzy searching, with debouncing and throttling for performance optimization.

details: The implementation consists of:

1. A generic `createSearch` function (lines 30-53) that takes a collection of items and search options, returning a search interface with methods to search and retrieve items.

2. Three derived stores that create specialized search interfaces:
   - `profileSearch` (lines 64-94): Searches user profiles with special handling for NIP-05 verification and web-of-trust scoring
   - `topicSearch` (lines 96-101): Simple search for topics by name
   - `relaySearch` (lines 103-110): Search for relays by URL, name, and description

3. A debounced `searchProfiles` function (lines 55-62) that loads profile data from relays when searching.

The profile search is the most complex, incorporating web-of-trust scores to rank results and validating NIP-05 identifiers. The implementation uses Svelte's derived stores to reactively update search results when the underlying data changes.

=========================
type: file
workspace: packages/app
path: packages/app/src/session.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/session.ts
summary: This file defines a session management system for different Nostr signing methods. It exports enums, types, and functions for creating, managing, and using sessions with various NIP (Nostr Implementation Possibilities) methods like NIP-01, NIP-07, NIP-46, NIP-55, and others. The module provides stores for tracking the current pubkey and sessions, functions for session manipulation, type guards, login utilities, and signer wrapping functionality.

details: The implementation revolves around Svelte stores to manage session state:

1. The file defines several session types (SessionNip01, SessionNip07, etc.) each corresponding to different Nostr authentication methods.

2. Three main stores are created:
   - `pubkey`: Stores the current active public key
   - `sessions`: Stores all available sessions indexed by pubkey
   - `session`: A derived store that returns the current active session

3. Session management functions include:
   - `addSession`, `putSession`, `updateSession` for creating/updating sessions
   - `dropSession`, `clearSessions` for removing sessions
   - Various factory functions like `makeNip01Session` to create specific session types
   - Login utility functions that combine creation and adding sessions

4. The `getSigner` function uses a caching mechanism to create appropriate signer instances based on session type, wrapping them with performance logging functionality.

5. The `wrapSigner` function adds logging capabilities to track signer operations with timing and status information.

6. Special handling exists for NIP-46 sessions, which require cleanup of broker resources when dropped.

=========================
type: file
workspace: packages/app
path: packages/app/src/storage.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/storage.ts
summary: This module provides a storage system using IndexedDB for client-side data persistence. It exports functions for initializing, closing, and clearing storage, as well as utilities for bulk operations (getAll, bulkPut, bulkDelete). The module defines types for storage adapters that can be registered with the system, allowing for flexible data storage configurations with features like throttling and migration.

details: The implementation uses the 'idb' library for IndexedDB operations and Svelte stores for reactivity. Key components include:

1. A deferred promise ('ready') that resolves when the database is initialized
2. A 'dead' store to track when the storage system is being shut down
3. Storage adapter pattern that allows different data stores to be registered with their own initialization and sync logic
4. Transaction-based operations that ensure data consistency
5. Error handling for database operations
6. Cleanup mechanisms for proper resource management (unsubscribers, event listeners)
7. Database versioning support with schema migration capabilities

The module handles browser compatibility checks and provides safeguards against multiple initializations.

=========================
type: file
workspace: packages/app
path: packages/app/src/storageAdapters.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/storageAdapters.ts
summary: This file exports various storage adapter classes for managing different types of data persistence in a Nostr-related application. It includes adapters for relays, handles, zappers, freshness tracking, plaintext storage, event tracking, and repository events. Each adapter implements an init method to load data from storage and a sync method to persist changes. The file also exports a defaultStorageAdapters object with pre-configured instances of these adapters.

details: The implementation consists of several storage adapter classes that follow a similar pattern:

1. Each adapter has a keyPath property defining the primary key for storage operations
2. Each implements init() to load data from storage (using getAll) into memory stores
3. Each implements sync() to persist changes back to storage (using bulkPut/bulkDelete)

Specific implementation details:
- RelaysStorageAdapter uses throttled updates to avoid excessive writes
- HandlesStorageAdapter and ZappersStorageAdapter use batch operations with a 300ms window
- FreshnessStorageAdapter and PlaintextStorageAdapter use interval-based persistence (every 10 seconds)
- TrackerStorageAdapter connects to a Tracker instance and syncs its state by listening to events
- EventsStorageAdapter is the most complex, implementing a ranking and retention system that:
  * Only persists events with positive rank scores
  * Prunes events when they exceed 1.5x the configured limit
  * Tracks event counts to optimize storage operations

The defaultStorageAdapters object provides pre-configured instances with appropriate storage names and dependencies injected.

=========================
type: dir
workspace: packages/app
path: packages/app/src/
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/
summary: This directory contains a comprehensive Nostr client library implementation. It provides a reactive data layer built on Svelte stores for managing Nostr protocol interactions, including event handling, relay management, user profiles, social graphs, and encrypted messaging. The library implements various NIPs (Nostr Implementation Possibilities) and offers high-level abstractions for common operations like following users, publishing content, and managing relay connections. Key components include a repository for event storage, utilities for Web of Trust scoring, authentication methods (NIP-01, NIP-07, NIP-46, NIP-55), and persistent storage via IndexedDB. The architecture emphasizes reactivity, privacy, and efficient data synchronization with relays.

=========================
type: file
workspace: packages/app
path: packages/app/src/sync.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/sync.ts
summary: This module provides synchronization utilities for a Nostr-like application. It exports functions for checking negentropy support (`hasNegentropy`), pulling data from relays (`pull`), and pushing data to relays (`push`). The module also defines an `AppSyncOpts` type that specifies relay URLs and filters for synchronization operations.

details: The implementation leverages both negentropy-based and traditional synchronization methods:

1. `hasNegentropy` determines if a relay supports the negentropy protocol by checking relay profile attributes (explicit negentropy support, NIP-77 support, or strfry software with version > 0).

2. Both `pull` and `push` functions:
   - Query the local repository for events matching the provided filters
   - Filter for signed events only
   - Process each relay in parallel using Promise.all
   - Use optimized negentropy-based methods when supported, falling back to traditional methods otherwise

3. The module imports base synchronization functions from '@welshman/net' and uses repository and relay information from local modules.

=========================
type: file
workspace: packages/app
path: packages/app/src/tags.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/tags.ts
summary: This file exports various functions for creating Nostr event tags. It includes functions for tagging pubkeys, events, zap splits, and creating tags for different types of interactions like quotes, replies, comments, and reactions. Each function generates the appropriate tag structure based on the event type and context.

details: The implementation revolves around creating arrays of tags for different Nostr event scenarios:

1. `tagZapSplit` - Creates a zap tag with split information
2. `tagPubkey` - Creates a pubkey tag with routing information
3. `tagEvent` - Creates event tags (both 'e' and 'a' tags if replaceable)
4. `tagEventPubkeys` - Extracts and tags unique pubkeys from an event
5. `tagEventForQuote` - Creates a quote tag for an event
6. `tagEventForReply` - Implements NIP-10 reply chain logic, handling roots, mentions, and replies
7. `tagEventForComment` - Creates tags for commenting on an event, preserving context
8. `tagEventForReaction` - Creates tags for reactions to events

The implementation uses the Router utility to generate appropriate URLs for navigation, and follows Nostr Improvement Proposals (NIPs) for tag structure and ordering. It handles special cases for replaceable events by including address tags.

=========================
type: file
workspace: packages/app
path: packages/app/src/thunk.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/thunk.ts
summary: This file provides a system for managing and publishing events in a Nostr-like network. It exports the `Thunk` and `MergedThunk` classes which handle event preparation, signing, publishing, and status tracking. The module offers utilities for creating, monitoring, aborting, and retrying event publications across multiple relays. Key exports include `publishThunk`, `abortThunk`, `retryThunk`, and various status checking functions.

details: The implementation revolves around two main classes:

1. `Thunk` - Represents a single event publication:
   - Prepares events using `prepEvent` which ensures events are stamped, owned, and hashed
   - Handles signing via external signers when needed
   - Manages publication status per relay with detailed error tracking
   - Implements Svelte's store subscription pattern for reactivity

2. `MergedThunk` - Combines multiple thunks and aggregates their statuses:
   - Provides a unified view of multiple related publications
   - Uses a priority system for determining the effective status per relay

The file implements a task queue system (`thunkQueue`) to manage concurrent publications with a batch size of 50. It maintains a global store of active thunks and provides helper functions for:

- Status checking and filtering (complete, incomplete, failed)
- Error extraction and monitoring
- Promise-based waiting for completion or errors
- Flattening nested thunk structures

The publication process includes proper handling of event preparation, optional delays, abort signals, and comprehensive status tracking with callbacks for various state changes.

=========================
type: file
workspace: packages/app
path: packages/app/src/topics.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/topics.ts
summary: This file exports a `Topic` type and a `topics` store. The `Topic` type represents a named topic with a count. The `topics` store provides a reactive collection of topics extracted from repository event tags, automatically updating when the repository changes.

details: The implementation uses a custom store from '@welshman/store' that initializes with a function to extract topics from repository event tags. It:
1. Creates a Map to count occurrences of each topic
2. Iterates through repository event tags, identifying topics by the 't:' prefix
3. Increments the count for each topic found
4. Transforms the Map into an array of Topic objects
5. Sets up a throttled update function that runs when repository events change
6. Returns a cleanup function to remove the event listener when the store is destroyed

=========================
type: file
workspace: packages/app
path: packages/app/src/user.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/user.ts
summary: This module provides utilities for accessing and loading user-related data. It exports functions to retrieve and load various user data types including profiles, follows, mutes, pins, relay selections, inbox relay selections, and blossom servers. It also provides utilities for working with Web of Trust (WoT) scores between users.

details: The implementation uses a factory pattern with two main factory functions:

1. `makeUserData` - Creates a derived Svelte store that automatically loads and retrieves user data from a map store based on the current user's public key.

2. `makeUserLoader` - Creates a function that loads user data for the current user, optionally specifying relays and whether to force a reload.

These factories are used to create consistent pairs of data accessors and loaders for different types of user data (profiles, follows, mutes, etc.). Each data type follows the same pattern of having a store for accessing the current data and a loader function for fetching/refreshing it.

The module also includes utilities for working with Web of Trust scores through the `getUserWotScore` and `deriveUserWotScore` functions.

=========================
type: file
workspace: packages/app
path: packages/app/src/wot.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/wot.ts
summary: This module provides utilities for managing and analyzing a Web of Trust (WoT) network. It exports functions to retrieve follows, mutes, followers, and muters for a given pubkey, as well as functions to analyze relationships between users in the network. The module also maintains a WoT graph that scores users based on follow/mute relationships and provides methods to access these scores.

details: The implementation revolves around several key components:

1. Derived stores that transform follow and mute lists into reverse-indexed maps (followersByPubkey and mutersByPubkey).
2. Helper functions to extract network relationships, such as getFollows, getMutes, getFollowers, and getMuters.
3. Network analysis functions like getNetwork (which gets second-degree connections), getFollowsWhoFollow, and getFollowsWhoMute.
4. A WoT scoring system implemented through the wotGraph store, which is built by the buildGraph function that increments scores for followed users and decrements for muted users.
5. The buildGraph function is throttled and triggered whenever the pubkey, follows, or mutes stores change.
6. The getWotScore function calculates a trust score for a target user based on how many of a user's follows also follow or mute the target.

=========================
type: file
workspace: packages/app
path: packages/app/src/zappers.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/src/zappers.ts
summary: This file provides functionality for managing and interacting with Lightning Network zappers in a Nostr application. It exports functions and stores for fetching zapper information, loading zappers by LNURL or pubkey, validating zaps, and deriving zapper data. The module includes privacy-conscious fetching of zapper information through an optional proxy service (dufflepud).

details: The implementation revolves around a few key components:

1. A writable Svelte store (`zappers`) that maintains a list of Zapper objects
2. A collection utility that creates derived stores and helper functions for managing zappers by LNURL
3. The `fetchZappers` function that retrieves zapper information either through a privacy-preserving proxy (dufflepud) or directly
4. Functions for loading and deriving zappers based on pubkeys or events
5. Utilities for validating zaps against their parent events

The code uses batching for efficient loading of multiple zappers at once, and includes privacy protections by optionally routing requests through a proxy service when available. The implementation leverages Svelte's reactive stores extensively to maintain state and provide reactive access to zapper data.

=========================
type: dir
workspace: packages/app
path: packages/app/
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/app/
summary: This directory contains a comprehensive Nostr client library built on Svelte stores, providing a reactive data layer for Nostr protocol interactions. The library implements various NIPs and offers high-level abstractions for common operations like event publishing, relay management, user profiles, follows, mutes, and encrypted messaging. Key components include event storage, Web of Trust scoring, authentication methods (NIP-01, NIP-07, NIP-46, NIP-55), and persistent storage via IndexedDB. The architecture emphasizes reactivity, privacy, and efficient data synchronization with relays, with thorough test coverage for core functionality like event publishing and tag handling.

=========================
type: file
workspace: packages/content
file: packages/content/package.json
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/package.json
include: always
{
  "name": "@welshman/content",
  "version": "0.4.6",
  "author": "hodlbod",
  "license": "MIT",
  "description": "A collection of utilities for parsing nostr note content.",
  "publishConfig": {
    "access": "public"
  },
  "type": "module",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "files": [
    "dist"
  ],
  "scripts": {
    "build": "pnpm run clean && pnpm run compile --force",
    "clean": "rimraf ./dist",
    "compile": "tsc -b tsconfig.build.json",
    "prepublishOnly": "pnpm run build"
  },
  "dependencies": {
    "@braintree/sanitize-url": "^7.0.2",
    "nostr-tools": "^2.14.2"
  },
  "devDependencies": {
    "rimraf": "~6.0.0",
    "typescript": "~5.8.0"
  }
}


=========================
type: file
workspace: packages/content
file: packages/content/tsconfig.json
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/tsconfig.json
include: always
{
  "extends": "../../tsconfig.json"
}


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 3:3
id: 44d542f8ce13c9735da3b3a60d13f0993262a5581ec7d1ff969d4802f7b012bf
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L3

declaration:
last = <T>(xs: T[], ...args: unknown[]) => xs[xs.length - 1]

summary:
A utility function that returns the last element of an array. It takes a generic array `xs` of type `T` and returns the last element of that array.

details:
This is a simple helper function that calculates the last element of an array by accessing the element at index `xs.length - 1`. It accepts a rest parameter `args` of type `unknown[]` which isn't used in the implementation, suggesting it might be there for compatibility with some API or could be removed. The function uses TypeScript generics to preserve the type of array elements.

=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 5:5
id: 3fe4771fcb7626cd3aa9e01077412510047d8e1554b9dea9eaac0fe5be44bad4
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L5

declaration:
fromNostrURI = (s: string) => s.replace(/^nostr:\/?\/?/, "")

summary:
A utility function that removes the 'nostr:' or 'nostr://' or 'nostr:///' prefix from a string. It takes a string parameter and returns the string with the Nostr URI scheme removed.

details:
This function uses a regular expression to match and replace the Nostr URI scheme prefix. The regex `^nostr:\/?\/?\/` matches 'nostr:' followed by zero, one, or two forward slashes at the beginning of the string. The function then replaces this matched pattern with an empty string, effectively stripping the Nostr URI scheme from the input.

=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 7:8
id: 8e35a0de942179102e239043b29174ec2e0c3c74e045f3b806a43ffd70e36985
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L7

declaration:
urlIsMedia = (url: string) =>
  Boolean(url.match(/\.(jpe?g|png|wav|mp3|mp4|mov|avi|webm|webp|gif|bmp|svg)$/))

summary:
The `urlIsMedia` function checks if a given URL string points to a media file. It returns a boolean value indicating whether the URL ends with a common media file extension such as jpg, png, wav, mp3, mp4, mov, avi, webm, webp, gif, bmp, or svg.

details:
This function uses a regular expression to match the end of the URL string against common media file extensions. The implementation is straightforward:
1. Takes a URL string as input
2. Uses a regular expression with the `$` anchor to ensure the match occurs at the end of the string
3. The regex checks for various media extensions with some flexibility (e.g., `jpe?g` matches both jpg and jpeg)
4. Wraps the result in `Boolean()` to ensure a boolean return value

import/access examples:
import { urlIsMedia } from '@welshman/content';
import { urlIsMedia } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 12:17
id: e07f872031cf76a9361ee726cee0aaf711e078686279a12ee201d02f053cef87
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L12

declaration:
export type AddressPointer = {
  identifier: string
  pubkey: string
  kind: number
  relays?: string[]
}

summary:
The `AddressPointer` type represents a reference to a Nostr address. It contains the necessary information to locate a specific Nostr resource, including an identifier, public key, kind number, and optional relay URLs. This type is exported and can be used to reference Nostr addresses in applications.

details:
This type definition appears to be a copy of a type from the nostr-tools library (as noted in the comment on line 10). It's a simple structure that contains:

1. `identifier`: A string that uniquely identifies the resource
2. `pubkey`: The public key associated with the address
3. `kind`: A number representing the kind of Nostr event
4. `relays`: An optional array of relay URLs where the address might be found

The type is used in the parser module for handling Nostr address references in content.

import/access examples:
import type { AddressPointer } from '@welshman/content';
import type { AddressPointer } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 19:24
id: b7f4050984fefe9b12de4467f9e516ee63f005016d030d72a231e1fba363c8e5
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L19

declaration:
export type EventPointer = {
  id: string
  relays?: string[]
  author?: string
  kind?: number
}

summary:
EventPointer is a type that represents a reference to a Nostr event. It contains the event's unique identifier (`id`), optional relay URLs where the event can be found (`relays`), optional author's public key (`author`), and optional event kind (`kind`).

details:
This type is part of a set of pointer types used in the Nostr protocol implementation. It's defined as a copy from nostr-tools since the original types couldn't be imported directly (as noted in the comment on line 10). The EventPointer is used in parsing Nostr event references from text content, particularly in the `parseEvent` function which extracts event references from nostr: URI schemes.

import/access examples:
import type { EventPointer } from '@welshman/content';
import type { EventPointer } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 26:29
id: e3ea532bc54276ccb1ca68435d999faecb52eb339c33c32123dc33a8ff8346d2
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L26

declaration:
export type ProfilePointer = {
  pubkey: string
  relays?: string[]
}

summary:
ProfilePointer is a type that represents a reference to a Nostr profile. It contains a required `pubkey` field which is a string identifier for the profile, and an optional `relays` array of strings that specify relay servers where the profile can be found.

details:
This type is part of a set of pointer types used in the Nostr protocol implementation. It's a simple data structure that mirrors the structure used in the nostr-tools library (as noted in the comment above these type definitions). The type is used throughout the parser to handle references to Nostr profiles, particularly in functions like `parseProfile` which converts Nostr URI strings into structured ProfilePointer objects.

import/access examples:
import type { ProfilePointer } from '@welshman/content';
import type { ProfilePointer } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 33:37
id: 2cacda788187e967a2c5a9eb48cc16a41b50125f50a3d2994e18bbf4d9290e4c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L33

declaration:
export type ParseContext = {
  results: Parsed[]
  content: string
  tags: string[][]
}

summary:
ParseContext is an exported type that represents the mutable state used during parsing. It contains three properties:
- **results**: an array of `Parsed` objects that have been extracted so far.
- **content**: the original text content being parsed.
- **tags**: a two‑dimensional string array representing Nostr tags associated with the content.
Parsers receive a `ParseContext` instance to read the original content, access tags for metadata, and push newly parsed elements into `results`.

details:
ParseContext is defined as a simple TypeScript type alias:
```ts
export type ParseContext = {
  results: Parsed[]
  content: string
  tags: string[][]
}
```
It does not contain any methods or computed properties; it merely groups related data. The type is instantiated in the `parse` function (line 368) where an object with empty `results` and the supplied `content` and `tags` is created. Throughout the parser pipeline, this context object is passed by reference to each parser function, allowing them to read `content`/`tags` and mutate `results` by pushing new `Parsed` entries. No additional runtime logic is associated with the type itself.

related: Parsed

import/access examples:
import type { ParseContext } from '@welshman/content';
import type { ParseContext } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 39:53
id: ba3b06938b78e5375f97b73f0b8bcac6ea04c0158350948757d46add82b43398
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L39

declaration:
export enum ParsedType {
  Address = "address",
  Cashu = "cashu",
  Code = "code",
  Ellipsis = "ellipsis",
  Emoji = "emoji",
  Event = "event",
  Invoice = "invoice",
  Link = "link",
  LinkGrid = "link-grid",
  Newline = "newline",
  Profile = "profile",
  Text = "text",
  Topic = "topic",
}

summary:
The `ParsedType` enum defines the different types of content that can be parsed from a Nostr message. It includes various content types such as addresses, cashu tokens, code blocks, emojis, events, links, profiles, text, and more. This enum serves as a type discriminator for the parsed content objects in the parser system.

details:
This enum is a central part of the parser's type system, working as a discriminant for the union type `Parsed` (defined elsewhere in the file). Each enum value corresponds to a specific content type that the parser can recognize and extract from Nostr messages.

The enum includes the following types:
1. Address - for Nostr address pointers
2. Cashu - for Cashu tokens
3. Code - for code blocks or inline code
4. Ellipsis - for truncated content
5. Emoji - for emoji references
6. Event - for Nostr event references
7. Invoice - for Lightning invoices
8. Link - for URLs
9. LinkGrid - for collections of links
10. Newline - for line breaks
11. Profile - for Nostr profile references
12. Text - for plain text
13. Topic - for hashtags/topics

These types are used throughout the parser to identify and process different content elements.

import/access examples:
import { ParsedType } from '@welshman/content';
import { ParsedType } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 55:57
id: 844cff215fc7ba0423a12bc9f96fc3869ffed347f3167bc241bf7aca408072b1
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L55

declaration:
export type ParsedBase = {
  raw: string
}

summary:
ParsedBase is a type alias that defines the base structure for all parsed content types in the parser system. It contains a single property 'raw', which stores the original unparsed string that was matched by the parser.

details:
This is a foundational type that serves as the base for all the more specific parsed content types (like ParsedLink, ParsedEmoji, etc.) in the type hierarchy. All parsed content types extend this base type to ensure they include the original raw text that was matched. This allows the system to track how much of the original content has been consumed during parsing and helps with reconstructing or referencing the original content when needed.

import/access examples:
import type { ParsedBase } from '@welshman/content';
import type { ParsedBase } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 59:62
id: 2e4d7d247488a6a3d052ddc45fef39a8a967c4c96869bcb0b66a6631cb82aaa2
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L59

declaration:
export type ParsedCashu = ParsedBase & {
  type: ParsedType.Cashu
  value: string
}

summary:
ParsedCashu is a type that represents a parsed Cashu token in the content parsing system. It extends the ParsedBase type and includes a type field set to ParsedType.Cashu and a value field containing the Cashu token string. This type is used to identify and handle Cashu tokens (a form of ecash) within parsed content.

details:
This type is part of a larger content parsing system that identifies different elements in text content. The ParsedCashu type specifically represents Cashu tokens, which are identified by the prefix 'cashu:cashu' followed by a string of characters. The implementation uses the parseCashu function (defined around line 193) to detect and extract these tokens from text content.

related: ParsedBase,Cashu

import/access examples:
import type { ParsedCashu } from '@welshman/content';
import type { ParsedCashu } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 64:67
id: 83ac4707a963c7810f4770503951a23c670c95296e98f7a68375f2f5b7820082
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L64

declaration:
export type ParsedCode = ParsedBase & {
  type: ParsedType.Code
  value: string
}

summary:
ParsedCode is a type alias that represents parsed code blocks or inline code in text content. It extends the ParsedBase interface and includes a type property set to ParsedType.Code and a value property containing the code content as a string.

details:
This type is part of a larger parsing system for structured content. It specifically handles code blocks (```code```) and inline code (`code`). The type consists of:
1. The ParsedBase interface which provides the 'raw' property containing the original unparsed text
2. A 'type' property fixed to ParsedType.Code to identify this as code content
3. A 'value' property containing the extracted code content as a string

The actual parsing of code is implemented in the parseCodeBlock and parseCodeInline functions elsewhere in the file.

related: ParsedBase,Code

import/access examples:
import type { ParsedCode } from '@welshman/content';
import type { ParsedCode } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 69:72
id: 2348633020f76a7f2e6847a306311bc85e62fc71d909ef0ee9276711baad519f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L69

declaration:
export type ParsedEllipsis = ParsedBase & {
  type: ParsedType.Ellipsis
  value: string
}

summary:
ParsedEllipsis is a type that represents an ellipsis in parsed content. It extends the ParsedBase interface and includes a specific type identifier (ParsedType.Ellipsis) and a string value. This type is used to represent truncated content with an ellipsis character.

details:
The ParsedEllipsis type is part of a content parsing system that breaks down text into different semantic components. It's a simple type that consists of:

1. The inherited 'raw' property from ParsedBase which contains the original raw string
2. A fixed type property set to ParsedType.Ellipsis
3. A value property containing the ellipsis string (typically "…")

This type is primarily used in the truncate function (lines 408-456) to indicate that content has been shortened.

related: ParsedBase,Ellipsis

import/access examples:
import type { ParsedEllipsis } from '@welshman/content';
import type { ParsedEllipsis } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 74:77
id: 9357ef93fd1e229c3dc66a629c79c47759dbc3cf76315135554ef7b16afc52e9
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L74

declaration:
export type ParsedEmojiValue = {
  name: string
  url?: string
}

summary:
The `ParsedEmojiValue` type represents the structure of an emoji entity after parsing. It contains two properties: `name` which is a required string representing the emoji's identifier, and an optional `url` property that can point to a custom emoji image.

details:
This type is used as part of the `ParsedEmoji` type in the parser system. When the parser encounters an emoji in the format `:emojiname:`, it creates an object with this structure. The `url` property is populated from the context's tags if there's a matching emoji tag with the same name, allowing for custom emoji implementations.

import/access examples:
import type { ParsedEmojiValue } from '@welshman/content';
import type { ParsedEmojiValue } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 79:82
id: 505b765683b2506389aaabdd26a02b619e2d3cfb82b22474d4501c2f1cb5a9c5
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L79

declaration:
export type ParsedEmoji = ParsedBase & {
  type: ParsedType.Emoji
  value: ParsedEmojiValue
}

summary:
ParsedEmoji is a type that represents an emoji parsed from text content. It extends the ParsedBase type and includes a type identifier and a value object containing the emoji's name and optional URL. This type is used in the parser system to identify and process emoji elements within text content.

details:
ParsedEmoji combines the base parsing information (raw string) with emoji-specific data. It has:
1. The type field set to ParsedType.Emoji to identify it as an emoji entity
2. A value field containing a ParsedEmojiValue object with:
   - name: The identifier of the emoji (without colons)
   - url?: An optional URL to the emoji image, which is typically extracted from the context's tags

This type is used by the parseEmoji function (lines 217-225) which looks for text in the format of :name: and checks if there's a corresponding emoji tag in the context.

related: ParsedBase,Emoji,ParsedEmojiValue

import/access examples:
import type { ParsedEmoji } from '@welshman/content';
import type { ParsedEmoji } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 84:87
id: 50f886c4fc7b9034b3e7e609a18900a35b0cba8645f79b771815935c9e8605d7
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L84

declaration:
export type ParsedInvoice = ParsedBase & {
  type: ParsedType.Invoice
  value: string
}

summary:
ParsedInvoice is a type that represents a parsed Lightning Network invoice in the content parser. It extends the ParsedBase type and includes a specific type identifier (ParsedType.Invoice) and a value string that contains the actual invoice data.

details:
This type is part of a content parsing system that identifies and structures different types of content in text. The ParsedInvoice type specifically handles Lightning Network payment invoices (starting with 'lnbc' or 'lnurl'). It has three properties:
1. The inherited 'raw' property from ParsedBase that contains the original unparsed text
2. A 'type' property fixed to ParsedType.Invoice to identify this as an invoice
3. A 'value' property containing the invoice string

The actual parsing of invoices is handled by the parseInvoice function (lines 242-248), which uses regex to match lightning invoice formats.

related: ParsedBase,Invoice

import/access examples:
import type { ParsedInvoice } from '@welshman/content';
import type { ParsedInvoice } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 89:92
id: 8fa16309d48c02fec62fff3f914326afe65eca383d1d9b209cbaed36fd5e8d9c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L89

declaration:
export type ParsedLinkValue = {
  url: URL
  meta: Record<string, string>
}

summary:
ParsedLinkValue is a type that represents a parsed URL link with associated metadata. It contains two properties: 'url' of type URL which holds the parsed URL object, and 'meta' which is a record of string key-value pairs containing any metadata associated with the link.

details:
This type is used within the parser system to represent links found in content. The 'url' property stores the actual URL object after parsing, while the 'meta' property stores any metadata extracted from the URL hash or from special tags in the content (like 'imeta' tags as seen in the parseLink function around line 274-280). This type is used as a value type for ParsedLink objects and is also used in collections like ParsedLinkGridValue.

import/access examples:
import type { ParsedLinkValue } from '@welshman/content';
import type { ParsedLinkValue } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 94:96
id: 732146abdc8a6a0437606720003886e07c8433f7efef5b03bf57bdd511e00925
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L94

declaration:
export type ParsedLinkGridValue = {
  links: ParsedLinkValue[]
}

summary:
The `ParsedLinkGridValue` type represents a collection of parsed links that are displayed as a grid. It contains a single property `links` which is an array of `ParsedLinkValue` objects. This type is used to structure data for rendering multiple links in a grid layout.

details:
This type is part of a content parsing system that identifies and structures different elements in text content. The `ParsedLinkGridValue` specifically handles collections of links that should be displayed together in a grid format. It's used by the `ParsedLinkGrid` type (line 103) and is populated during the `reduceLinks` function (line 458) which groups consecutive links into grids for better visual presentation.

related: ParsedLinkValue

import/access examples:
import type { ParsedLinkGridValue } from '@welshman/content';
import type { ParsedLinkGridValue } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 98:101
id: 5bc4f4cbe552e01e6877f1031ebf75176959a331c1ea0c32080a6929c24cfcb2
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L98

declaration:
export type ParsedLink = ParsedBase & {
  type: ParsedType.Link
  value: ParsedLinkValue
}

summary:
ParsedLink is a type that represents a parsed link within content. It extends the ParsedBase type and includes a specific type identifier (ParsedType.Link) and a value property containing URL information and associated metadata.

details:
This type is part of a content parsing system that breaks down text into different semantic components. The ParsedLink type specifically handles URL links found in content.

It has the following structure:
1. Extends ParsedBase which provides the 'raw' property (the original unparsed string)
2. Has a fixed 'type' property set to ParsedType.Link for type discrimination
3. Contains a 'value' property of type ParsedLinkValue which includes:
   - url: A URL object representing the parsed link
   - meta: A record of metadata associated with the link

This type is used in conjunction with the parseLink function (lines 250-283) which extracts URLs from text and creates ParsedLink objects. It's also used with type guards like isLink and isImage (lines 165-167) to identify and work with link elements in parsed content.

related: ParsedBase,Link,ParsedLinkValue

import/access examples:
import type { ParsedLink } from '@welshman/content';
import type { ParsedLink } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 103:106
id: 5f23dac54389893c8e7a705bce1c7954df51ce8a89777c30737ce8ff37da5106
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L103

declaration:
export type ParsedLinkGrid = ParsedBase & {
  type: ParsedType.LinkGrid
  value: ParsedLinkGridValue
}

summary:
ParsedLinkGrid is a type that represents a grid of links in parsed content. It extends the ParsedBase type and includes a specific type identifier (ParsedType.LinkGrid) and a value property containing an array of ParsedLinkValue objects. This type is used to represent multiple links that should be displayed together in a grid layout.

details:
This type is part of a content parsing system that breaks down text content into different semantic elements. ParsedLinkGrid specifically handles collections of links that should be displayed together.

The type has three main components:
1. It extends ParsedBase which provides the 'raw' property (original unparsed string)
2. It has a fixed type property set to ParsedType.LinkGrid for type discrimination
3. It contains a value property of type ParsedLinkGridValue which holds an array of ParsedLinkValue objects

This type is used in the reduceLinks function (lines 458-487) which transforms consecutive links into link grids for better visual presentation.

related: ParsedBase,LinkGrid,ParsedLinkGridValue

import/access examples:
import type { ParsedLinkGrid } from '@welshman/content';
import type { ParsedLinkGrid } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 108:111
id: a5e814d23a625b579ec24f041faf58c3758ab3483081c928d6bead7e34afb98f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L108

declaration:
export type ParsedNewline = ParsedBase & {
  type: ParsedType.Newline
  value: string
}

summary:
ParsedNewline is a type that represents a newline character or sequence in parsed content. It extends the ParsedBase interface and includes a type property set to ParsedType.Newline and a value property containing the raw newline string.

details:
This type is part of a content parsing system that breaks down text into different semantic components. The ParsedNewline type specifically handles newline characters (\n) in text content. It's a simple data structure that stores:
1. The raw newline string that was matched
2. The type identifier (ParsedType.Newline)
3. The value, which is the same as the raw newline string

This type is used by the parseNewline function (line 285-291) which identifies newline sequences in text.

related: ParsedBase,Newline

import/access examples:
import type { ParsedNewline } from '@welshman/content';
import type { ParsedNewline } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 113:116
id: 10f6d22a4b5af435c49248b6bf92b7aababaa9c79ca9c412966289a799b8abc8
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L113

declaration:
export type ParsedText = ParsedBase & {
  type: ParsedType.Text
  value: string
}

summary:
ParsedText is a type alias that represents parsed text content in a Nostr message. It extends the ParsedBase interface and includes a specific type identifier (ParsedType.Text) and a string value containing the actual text content. This type is part of a larger parsing system that breaks down Nostr content into different semantic components.

details:
ParsedText is a simple type definition that follows the pattern of other parsed content types in this parser system. It consists of:

1. The ParsedBase properties (which includes the 'raw' string property that contains the original unparsed text)
2. A type field set to ParsedType.Text to identify this as text content
3. A value field containing the actual text string

This type is used in the parse function to represent plain text segments that don't match any of the special formats (links, mentions, etc.) handled by the other parsers.

related: ParsedBase,Text

import/access examples:
import type { ParsedText } from '@welshman/content';
import type { ParsedText } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 118:121
id: c03aba5e1d4b3bd9b0d4e325a6ae909ab5e68963d355786081dd84f210d6ebec
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L118

declaration:
export type ParsedTopic = ParsedBase & {
  type: ParsedType.Topic
  value: string
}

summary:
ParsedTopic is a type that represents a parsed topic (hashtag) in a Nostr message. It extends the ParsedBase type and includes a specific type identifier (ParsedType.Topic) and a value string that contains the topic text without the '#' prefix. This type is used in the parser system to identify and handle topic mentions in Nostr content.

details:
ParsedTopic is part of a type system for parsed content elements in what appears to be a Nostr message parser. It follows the pattern of other parsed types in the system:

1. It extends ParsedBase which provides the 'raw' property that contains the original unparsed text
2. It has a 'type' property set to ParsedType.Topic to identify it as a topic
3. It has a 'value' property that stores the actual topic text (without the '#' prefix)

This type is used by the parseTopic function (lines 309-316) which extracts hashtags from text, and is one of the many content types handled by the parse function.

related: ParsedBase,Topic

import/access examples:
import type { ParsedTopic } from '@welshman/content';
import type { ParsedTopic } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 123:126
id: 6a20f2afbe0e6d85ad10ebd24bcd723c5ebab00f1a44bceac93f0c1fe1d07bac
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L123

declaration:
export type ParsedEvent = ParsedBase & {
  type: ParsedType.Event
  value: EventPointer
}

summary:
ParsedEvent is a type that represents a parsed Nostr event reference in text content. It extends the ParsedBase type and includes a specific type identifier (ParsedType.Event) and a value property containing an EventPointer. The EventPointer contains information about the referenced event such as its ID, optional relays, author, and kind.

details:
This type is part of a larger parsing system for Nostr content. It specifically handles references to Nostr events that might appear in text content, typically in formats like 'nostr:nevent1...' or 'nostr:note1...'. 

The ParsedEvent type is used in conjunction with the parseEvent function (lines 227-240) which extracts event references from text and decodes them using the nostr-tools/nip19 library. The function handles both 'nevent' and 'note' formats, converting them to a standardized EventPointer structure.

This type is one of many parsed content types in the system, all of which extend ParsedBase and are used in the unified Parsed type union (lines 138-151).

related: ParsedBase,Event,EventPointer

import/access examples:
import type { ParsedEvent } from '@welshman/content';
import type { ParsedEvent } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 128:131
id: d9e045ee76dcfb7a328e377f691471b8dc25e09c54de5fd8dee3d1ff574875df
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L128

declaration:
export type ParsedProfile = ParsedBase & {
  type: ParsedType.Profile
  value: ProfilePointer
}

summary:
ParsedProfile is a type alias that represents a parsed Nostr profile pointer in the content parsing system. It extends the ParsedBase interface and includes a type property set to ParsedType.Profile and a value property containing a ProfilePointer object. The ProfilePointer contains a pubkey string and an optional array of relay URLs.

details:
This type is part of a content parsing system for Nostr protocol data. It specifically handles profile references in text content. The ParsedProfile type is used when the parser encounters a Nostr profile identifier (npub1 or nprofile1) in text content. The structure contains:

1. The raw string that was matched
2. A type identifier (ParsedType.Profile)
3. A value object containing:
   - pubkey: The public key of the referenced profile
   - relays: Optional array of relay URLs where the profile might be found

This type works together with the parseProfile function (lines 293-307) which handles the actual parsing logic for profile references in text.

related: ParsedBase,Profile,ProfilePointer

import/access examples:
import type { ParsedProfile } from '@welshman/content';
import type { ParsedProfile } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 133:136
id: d57133c9e221b6e1b6910103dcec2275ec06e3e5b463d025b34b794ac6ec789c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L133

declaration:
export type ParsedAddress = ParsedBase & {
  type: ParsedType.Address
  value: AddressPointer
}

summary:
ParsedAddress is a type alias that represents a parsed Nostr address pointer in content. It extends the ParsedBase interface and includes a type property set to ParsedType.Address and a value property containing an AddressPointer object. This type is used in the parser system to represent Nostr address references found in text content.

details:
This type is part of a larger content parsing system for Nostr content. It specifically handles the representation of parsed Nostr address pointers (naddr1 format). The type consists of:

1. The ParsedBase properties (raw string containing the original text)
2. A type property fixed to ParsedType.Address for type discrimination
3. A value property containing an AddressPointer object with:
   - identifier: string
   - pubkey: string
   - kind: number
   - relays?: string[]

This type works with the parseAddress function (lines 179-191) which extracts naddr1 format addresses from text content.

related: ParsedBase,Address,AddressPointer

import/access examples:
import type { ParsedAddress } from '@welshman/content';
import type { ParsedAddress } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 138:151
id: 020deb64e38c8a19b0be209d2fe5cf3247e1b8bed8bd17ce91df30a204de84e8
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L138

declaration:
export type Parsed =
  | ParsedAddress
  | ParsedCashu
  | ParsedCode
  | ParsedEllipsis
  | ParsedEmoji
  | ParsedEvent
  | ParsedInvoice
  | ParsedLink
  | ParsedLinkGrid
  | ParsedNewline
  | ParsedProfile
  | ParsedText
  | ParsedTopic

summary:
The `Parsed` type is a union type that represents various parsed content elements in a Nostr message. It encompasses different content types such as addresses, cashu tokens, code blocks, emojis, events, invoices, links, newlines, profiles, text, and topics. Each parsed element has a specific structure based on its type, allowing for type-safe handling of different content formats in Nostr messages.

details:
This type serves as the core data structure for the parser system in this module. It's a discriminated union where each variant has:

1. A common `raw` property (from `ParsedBase`) containing the original unparsed string
2. A `type` property that acts as the discriminant (from `ParsedType` enum)
3. A `value` property with type-specific data

The union includes 13 different parsed content types:
- `ParsedAddress`: Nostr address pointers
- `ParsedCashu`: Cashu token strings
- `ParsedCode`: Code blocks or inline code
- `ParsedEllipsis`: Truncation indicators
- `ParsedEmoji`: Custom emoji with optional URL
- `ParsedEvent`: Nostr event pointers
- `ParsedInvoice`: Lightning invoices
- `ParsedLink`: URL links with metadata
- `ParsedLinkGrid`: Collections of links
- `ParsedNewline`: Line breaks
- `ParsedProfile`: Nostr profile pointers
- `ParsedText`: Plain text content
- `ParsedTopic`: Hashtag topics

This type is used throughout the parser system to represent the results of parsing Nostr content.

related: ParsedAddress,ParsedCashu,ParsedCode,ParsedEllipsis,ParsedEmoji,ParsedEvent,ParsedInvoice,ParsedLink,ParsedLinkGrid,ParsedNewline,ParsedProfile,ParsedText,ParsedTopic

import/access examples:
import type { Parsed } from '@welshman/content';
import type { Parsed } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 155:156
id: 8c63b9f2cb3ed9c84d60255f0d044af5f72e3a54af8dcd39228eb69bccac0aeb
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L155

declaration:
isAddress = (parsed: Parsed): parsed is ParsedAddress =>
  parsed.type === ParsedType.Address

summary:
A type guard function that checks if a parsed object is of type ParsedAddress. It returns true if the parsed object's type property equals ParsedType.Address, allowing TypeScript to narrow the type of the object to ParsedAddress in conditional blocks.

details:
This is a simple type predicate function that performs a direct comparison between the parsed object's type property and the ParsedType.Address enum value. It's part of a series of similar type guards in the parser module that help with type narrowing when working with the Parsed union type.

related: type,ParsedType,Address,Parsed

import/access examples:
import { isAddress } from '@welshman/content';
import { isAddress } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 157:157
id: 280feee749ea35fb3806b9b64b07f58cf5d25ea6b9acfb097182287810b8b3d1
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L157

declaration:
isCashu = (parsed: Parsed): parsed is ParsedCashu => parsed.type === ParsedType.Cashu

summary:
A type guard function that checks if a parsed content item is of type 'cashu'. Returns true if the provided parsed item is a ParsedCashu object, false otherwise. This function is useful for safely narrowing down the type of a Parsed union type to the specific ParsedCashu type.

details:
The implementation is a simple type predicate function that checks if the 'type' property of the parsed parameter equals ParsedType.Cashu. This is a straightforward type guard that leverages TypeScript's type narrowing capabilities through the 'parsed is ParsedCashu' return type annotation.

related: type,ParsedType,Cashu,Parsed

import/access examples:
import { isCashu } from '@welshman/content';
import { isCashu } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 158:158
id: 7bd17b002c6746732872b9fc8f35bbbd97a8e5c1a896c8bbfbbe8e5f4bbbebb9
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L158

declaration:
isCode = (parsed: Parsed): parsed is ParsedCode => parsed.type === ParsedType.Code

summary:
A type guard function that checks if a parsed content item is of type 'code'. It takes a Parsed object as input and returns a boolean indicating whether the parsed item is a ParsedCode type. This function enables type narrowing in TypeScript, allowing for safer access to ParsedCode-specific properties.

details:
The implementation is straightforward - it checks if the 'type' property of the parsed object equals ParsedType.Code. This is a standard TypeScript type predicate pattern (using 'parsed is ParsedCode') that helps the TypeScript compiler understand the type narrowing when this function returns true.

related: type,ParsedType,Code,Parsed

import/access examples:
import { isCode } from '@welshman/content';
import { isCode } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 159:160
id: b619f9b32df2d7aeca92e76b6477f4cba79db219c2612a564b62bca434aa21c0
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L159

declaration:
isEllipsis = (parsed: Parsed): parsed is ParsedEllipsis =>
  parsed.type === ParsedType.Ellipsis

summary:
A type guard function that checks if a parsed content item is of type 'ellipsis'. It takes a Parsed object as input and returns a boolean indicating whether the parsed item is a ParsedEllipsis type. This function is useful for safely narrowing down the type of a Parsed object in TypeScript.

details:
The implementation is a simple arrow function that checks if the 'type' property of the passed 'parsed' parameter equals ParsedType.Ellipsis. It uses TypeScript's type predicate syntax ('parsed is ParsedEllipsis') to inform the TypeScript compiler that when this function returns true, the passed object can be safely treated as a ParsedEllipsis type.

related: type,ParsedType,Ellipsis,Parsed

import/access examples:
import { isEllipsis } from '@welshman/content';
import { isEllipsis } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 161:161
id: 38e41e464809ca681d2d46bf3ed18e54905ed24c440f25826f4a3d093b424212
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L161

declaration:
isEmoji = (parsed: Parsed): parsed is ParsedEmoji => parsed.type === ParsedType.Emoji

summary:
A type guard function that checks if a parsed content item is of type emoji. It takes a `Parsed` object and returns a boolean indicating whether the parsed item is a `ParsedEmoji`. The function also serves as a type predicate, narrowing the type to `ParsedEmoji` when it returns true.

details:
The implementation is straightforward - it checks if the `type` property of the passed `parsed` object equals `ParsedType.Emoji` (which is defined in the enum as "emoji"). This is a simple equality check that returns a boolean result. When this function returns true, TypeScript will narrow the type of the `parsed` parameter to `ParsedEmoji` in type-checked code blocks.

related: type,ParsedType,Emoji,Parsed

import/access examples:
import { isEmoji } from '@welshman/content';
import { isEmoji } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 162:162
id: 142d682275873715f74b46c5b0527e7e37de45275a2d406bb809f57fe186f0de
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L162

declaration:
isEvent = (parsed: Parsed): parsed is ParsedEvent => parsed.type === ParsedType.Event

summary:
A type guard function that checks if a parsed object is of type ParsedEvent. It takes a Parsed object as input and returns a boolean indicating whether the object is a ParsedEvent. This function is useful for type narrowing in TypeScript.

details:
The implementation is straightforward - it checks if the 'type' property of the parsed object equals ParsedType.Event. This is a standard TypeScript type predicate function that helps the compiler understand when a variable has been narrowed to a specific type.

related: type,ParsedType,Event,Parsed

import/access examples:
import { isEvent } from '@welshman/content';
import { isEvent } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 163:164
id: f7486821c7310197753cbb8095439065ebf48acfda1db9e22e5b297e3dad82c1
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L163

declaration:
isInvoice = (parsed: Parsed): parsed is ParsedInvoice =>
  parsed.type === ParsedType.Invoice

summary:
A type guard function that checks if a parsed content item is a Lightning Network invoice. It returns true if the parsed item's type is ParsedType.Invoice, allowing TypeScript to narrow the type to ParsedInvoice in conditional blocks.

details:
This is a simple type predicate function that performs a type check against the ParsedType enum. It compares the 'type' property of the passed 'parsed' parameter against the Invoice enum value. The function uses TypeScript's type predicate syntax ('parsed is ParsedInvoice') to provide type narrowing when used in conditional statements.

related: type,ParsedType,Invoice,Parsed

import/access examples:
import { isInvoice } from '@welshman/content';
import { isInvoice } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 165:165
id: 6a1e58eb96c28aed827fecc01715e47aa659d48769e2d70e44f06d0451eaa3eb
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L165

declaration:
isLink = (parsed: Parsed): parsed is ParsedLink => parsed.type === ParsedType.Link

summary:
A type guard function that checks if a parsed content item is of type 'link'. It takes a Parsed object as input and returns a boolean indicating whether the parsed item is a ParsedLink type.

details:
This function is a simple type predicate that checks if the 'type' property of the provided parsed object equals ParsedType.Link. When used in conditional statements, TypeScript will narrow the type of the variable to ParsedLink in the scope where the condition is true, enabling type-safe access to ParsedLink-specific properties.

related: type,ParsedType,Link,Parsed

import/access examples:
import { isLink } from '@welshman/content';
import { isLink } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 166:167
id: c1f181e70f38c232d595c70f48e1183e10ff1431cb1d0bf5f8382f97393b701b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L166

declaration:
isImage = (parsed: Parsed): parsed is ParsedLink =>
  isLink(parsed) && Boolean(parsed.value.url.toString().match(/\.(jpe?g|png|gif|webp)$/))

summary:
A type guard function that checks if a parsed content item is an image link. It returns true if the parsed item is a link and its URL ends with a common image file extension (.jpg, .jpeg, .png, .gif, or .webp).

details:
The implementation uses two checks in combination:
1. First verifies the item is a link using the `isLink` type guard
2. Then checks if the URL string matches a regular expression that looks for common image file extensions at the end of the URL

The function leverages the URL.toString() method to get the string representation of the URL before applying the regex pattern.

related: __function,isLink,Parsed

import/access examples:
import { isImage } from '@welshman/content';
import { isImage } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 168:169
id: 79a012ecb5d475f5a89a6482225d67ab9936228f41483f4e8df1ead250a608bd
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L168

declaration:
isLinkGrid = (parsed: Parsed): parsed is ParsedLinkGrid =>
  parsed.type === ParsedType.LinkGrid

summary:
A type guard function that checks if a parsed content item is of type ParsedLinkGrid. It takes a Parsed object as input and returns a boolean indicating whether the parsed object is a ParsedLinkGrid type. This function is useful for safely accessing ParsedLinkGrid-specific properties after type narrowing.

details:
The implementation is straightforward - it performs a simple type check by comparing the 'type' property of the parsed object against the ParsedType.LinkGrid enum value. This is a standard TypeScript type guard pattern that enables type narrowing in conditional blocks.

related: type,ParsedType,LinkGrid,Parsed

import/access examples:
import { isLinkGrid } from '@welshman/content';
import { isLinkGrid } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 170:171
id: 0a4004456e6b77e4b50f12e1208b2ebee9b87c675f8ad683c57fc38b5992cbf9
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L170

declaration:
isNewline = (parsed: Parsed): parsed is ParsedNewline =>
  parsed.type === ParsedType.Newline

summary:
A type guard function that checks if a parsed content item is of type 'newline'. It takes a `Parsed` object as input and returns a boolean indicating whether the parsed item is a `ParsedNewline` type. The function also acts as a TypeScript type predicate, narrowing the type of the parameter in conditional blocks.

details:
The implementation is straightforward - it checks if the `type` property of the provided `parsed` object equals `ParsedType.Newline` enum value. This is a simple equality comparison that returns a boolean result. The function uses TypeScript's type predicate pattern (`parsed is ParsedNewline`) to provide type narrowing when used in conditional statements.

related: type,ParsedType,Newline,Parsed

import/access examples:
import { isNewline } from '@welshman/content';
import { isNewline } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 172:173
id: 59e7d3da180719ec28bc804442b057e12e698e42bb2c5d16b021d749db8fcc9e
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L172

declaration:
isProfile = (parsed: Parsed): parsed is ParsedProfile =>
  parsed.type === ParsedType.Profile

summary:
A type guard function that checks if a parsed object is of type ParsedProfile. It returns true if the parsed object's type property equals ParsedType.Profile, allowing TypeScript to narrow the type to ParsedProfile in conditional blocks.

details:
This is a simple type predicate function that performs a strict equality check between the parsed object's type property and the ParsedType.Profile enum value. It's part of a collection of similar type guards in the parser module that help with type narrowing when working with the Parsed union type.

related: type,ParsedType,Profile,Parsed

import/access examples:
import { isProfile } from '@welshman/content';
import { isProfile } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 174:174
id: 038f79308a9ff5f322c62be54656d5231badc1c9f062ee22266296f39928edb7
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L174

declaration:
isText = (parsed: Parsed): parsed is ParsedText => parsed.type === ParsedType.Text

summary:
The `isText` function is a type guard that checks if a parsed content item is of type `ParsedText`. It takes a `Parsed` object as input and returns a boolean indicating whether the parsed item is text content. This function is useful for type narrowing in TypeScript, allowing you to safely access `ParsedText`-specific properties after the check.

details:
The implementation is a simple type predicate function that checks if the `type` property of the provided `parsed` parameter equals `ParsedType.Text`. This is part of a collection of type guard functions in the parser module that help identify different types of parsed content (like links, emojis, events, etc.). The function leverages TypeScript's type predicate syntax (`parsed is ParsedText`) to provide type narrowing capabilities to the compiler.

related: type,ParsedType,Text,Parsed

import/access examples:
import { isText } from '@welshman/content';
import { isText } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 175:175
id: 2dafd5eb3c804f00ad8293dd884d77e6e83498c44f3a8db4f88387a8b2aa2d26
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L175

declaration:
isTopic = (parsed: Parsed): parsed is ParsedTopic => parsed.type === ParsedType.Topic

summary:
A type guard function that checks if a parsed content item is of type 'topic'. It takes a `Parsed` object as input and returns a boolean indicating whether the parsed item is a `ParsedTopic`. This function is used for type narrowing in TypeScript, allowing safe access to `ParsedTopic` specific properties.

details:
The implementation is straightforward - it checks if the `type` property of the provided `parsed` parameter equals `ParsedType.Topic` enum value. This is a standard TypeScript type predicate function that uses the `is` keyword to inform TypeScript's type system about the narrowed type when the function returns true.

related: type,ParsedType,Topic,Parsed

import/access examples:
import { isTopic } from '@welshman/content';
import { isTopic } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 179:191
id: 8f4ba117ee117e115a22d9964d1a9962501c22dbf338413494567e5afd5dda34
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L179

declaration:
parseAddress = (text: string, context: ParseContext): ParsedAddress | void => {
  const [naddr] = text.match(/^(web\+)?(nostr:)naddr1[\d\w]+/i) || []

  if (naddr) {
    try {
      const {data} = decode(fromNostrURI(naddr))

      return {type: ParsedType.Address, value: data as AddressPointer, raw: naddr}
    } catch (e) {
      // Pass
    }
  }
}

summary:
The `parseAddress` function attempts to parse a Nostr address (naddr) from a given text string. It takes a text string and a ParseContext object as parameters and returns either a ParsedAddress object or void if no valid address is found. The function recognizes addresses in formats like 'nostr:naddr1...' or 'web+nostr:naddr1...'.

details:
The implementation works by:
1. Using a regular expression to match potential Nostr address patterns at the beginning of the text
2. If a match is found, it attempts to decode the address using the imported `decode` function from nostr-tools/nip19
3. The address is normalized by removing the 'nostr:' prefix using the `fromNostrURI` helper function
4. If decoding is successful, it returns a ParsedAddress object with the appropriate type, value, and raw string
5. If decoding fails (throws an exception), the function silently ignores the error and returns nothing
6. If no match is found initially, the function returns nothing

related: ParseContext,ParsedAddress,ParsedBase

import/access examples:
import { parseAddress } from '@welshman/content';
import { parseAddress } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 193:199
id: 9c8e112f03212a714646e4e11f349df54073f2b39637083674b77e3dd9a57590
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L193

declaration:
parseCashu = (text: string, context: ParseContext): ParsedCashu | void => {
  const [value] = text.match(/^cashu:cashu[-\d\w=]{50,5000}/i) || []

  if (value) {
    return {type: ParsedType.Cashu, value, raw: value}
  }
}

summary:
A function that parses Cashu tokens from text. It takes a string and a parsing context as input and returns either a ParsedCashu object or void. The function looks for strings that match the Cashu token format (starting with 'cashu:cashu' followed by 50-5000 characters that can be digits, letters, hyphens, or equals signs).

details:
The implementation is straightforward:
1. It uses a regular expression to match Cashu token patterns at the beginning of the input text
2. The regex pattern looks for strings starting with 'cashu:cashu' followed by 50-5000 characters that can be digits, letters, hyphens, or equals signs (case insensitive)
3. If a match is found, it extracts the value and returns a ParsedCashu object with the appropriate type and the matched value
4. If no match is found, the function implicitly returns undefined

related: ParseContext,ParsedCashu,ParsedBase

import/access examples:
import { parseCashu } from '@welshman/content';
import { parseCashu } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 201:207
id: 9f64d22b7daf4014b5537d59f5e1941f4ad1bbf0f476f0d39996eee07e333e76
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L201

declaration:
parseCodeBlock = (text: string, context: ParseContext): ParsedCode | void => {
  const [raw, value] = text.match(/^```([^]*?)```/i) || []

  if (raw) {
    return {type: ParsedType.Code, value, raw}
  }
}

summary:
A function that parses code blocks from text. It takes a string and a parsing context as input and returns either a ParsedCode object or void. The function looks for text surrounded by triple backticks (```), which is the standard markdown syntax for code blocks.

details:
The implementation uses a regular expression to match text that starts with triple backticks (```) followed by any content (including newlines) and ends with triple backticks. The regex pattern `/^```([^]*?)```/i` captures the content between the backticks in a capturing group.

If a match is found, the function extracts both the raw matched text and the captured content value, then returns a ParsedCode object with the appropriate type, value, and raw properties. If no match is found, the function implicitly returns undefined (void).

related: ParseContext,ParsedCode,ParsedBase

import/access examples:
import { parseCodeBlock } from '@welshman/content';
import { parseCodeBlock } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 209:215
id: 74ee763bf66b16966dc9d7890f55fb9d785d2b49f9bb57060cb5fcf5e0e9ce8b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L209

declaration:
parseCodeInline = (text: string, context: ParseContext): ParsedCode | void => {
  const [raw, value] = text.match(/^`(.*?)`/i) || []

  if (raw) {
    return {type: ParsedType.Code, value, raw}
  }
}

summary:
A function that parses inline code blocks from text. It takes a string and a parsing context as input and returns either a ParsedCode object or void. The function looks for text surrounded by backticks (`code`) and extracts the content inside.

details:
The implementation uses a regular expression to match text that starts with a backtick, followed by any characters (non-greedy matching with .*?), and ends with another backtick. The 'i' flag makes the match case-insensitive.

If a match is found, it destructures the result into 'raw' (the full matched string including backticks) and 'value' (the content inside the backticks). It then returns a ParsedCode object with the appropriate type, value, and raw content.

If no match is found, the function implicitly returns undefined (void).

related: ParseContext,ParsedCode,ParsedBase

import/access examples:
import { parseCodeInline } from '@welshman/content';
import { parseCodeInline } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 217:225
id: afbb25fb09aab1e532e227178f1e4bac8fcf7340276bc461668d712b235bcf14
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L217

declaration:
parseEmoji = (text: string, context: ParseContext): ParsedEmoji | void => {
  const [raw, name] = text.match(/^:(\w+):/i) || []

  if (raw) {
    const url = context.tags.find(t => t[0] === "emoji" && t[1] === name)?.[2]

    return {type: ParsedType.Emoji, value: {name, url}, raw}
  }
}

summary:
The `parseEmoji` function parses emoji shortcodes from text content. It takes a string of text and a ParseContext object as parameters and returns either a ParsedEmoji object or void if no emoji is found. The function recognizes emoji in the format `:name:` and looks up associated URLs from the context's tags.

details:
The implementation works by:
1. Using a regular expression (`/^:(\w+):/i`) to match text that starts with a colon, followed by one or more word characters, and ends with another colon
2. If a match is found, it extracts the raw matched text and the emoji name
3. It then searches through the context's tags array to find an "emoji" tag where the second element matches the emoji name
4. If found, it extracts the URL from the third element of the matching tag
5. Finally, it returns a ParsedEmoji object containing the type (Emoji), value (with name and optional URL), and the raw matched text

related: ParseContext,ParsedEmoji,ParsedBase

import/access examples:
import { parseEmoji } from '@welshman/content';
import { parseEmoji } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 227:240
id: e3f97e81ae5b2e7d416fd061b72075769bd59ca28618d9832ab20108d8ad170f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L227

declaration:
parseEvent = (text: string, context: ParseContext): ParsedEvent | void => {
  const [entity] = text.match(/^(web\+)?(nostr:)n(event|ote)1[\d\w]+/i) || []

  if (entity) {
    try {
      const {type, data} = decode(fromNostrURI(entity))
      const value = type === "note" ? {id: data as string, relays: []} : (data as EventPointer)

      return {type: ParsedType.Event, value, raw: entity}
    } catch (e) {
      // Pass
    }
  }
}

summary:
The `parseEvent` function parses Nostr event references from text. It takes a string and a parsing context, and returns a ParsedEvent object if the text contains a valid Nostr event reference (starting with 'nostr:nevent1' or 'nostr:note1'), or void if no match is found. The function extracts the event ID and any associated relay information from the encoded reference.

details:
The implementation works as follows:

1. It uses a regular expression to match Nostr event references in the format `nostr:nevent1...` or `nostr:note1...`, optionally prefixed with `web+`
2. If a match is found, it:
   - Uses the `decode` function from nostr-tools/nip19 to decode the entity after removing the `nostr:` prefix
   - Handles two possible formats: 'note' type (simple ID reference) or 'event' type (with additional metadata)
   - For 'note' type, it constructs an EventPointer with just the ID and empty relays array
   - For 'event' type, it uses the decoded data directly as an EventPointer
   - Returns a ParsedEvent object with the appropriate type, value, and raw text
3. If decoding fails or no match is found, it returns nothing (void)

The function silently handles decoding errors by catching exceptions and continuing execution.

related: ParseContext,ParsedEvent,ParsedBase

import/access examples:
import { parseEvent } from '@welshman/content';
import { parseEvent } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 242:248
id: ef1555d4d9ce2147f3348485435f96d7e2887f8234f4a28440e4ac8248298152
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L242

declaration:
parseInvoice = (text: string, context: ParseContext): ParsedInvoice | void => {
  const [raw, _, value] = text.match(/^(lightning:)(ln(bc|url)[0-9a-z]{10,})/i) || []

  if (raw && value) {
    return {type: ParsedType.Invoice, value, raw}
  }
}

summary:
A function that parses a Lightning Network invoice from text. It takes a string and a ParseContext object as parameters and returns either a ParsedInvoice object or void if no invoice is found. The function recognizes Lightning Network invoices that start with 'lightning:' followed by an lnbc or lnurl format string.

details:
The implementation uses a regular expression to match Lightning Network invoice patterns in the input text. It extracts three capture groups from the match:
1. The full raw match (stored in 'raw')
2. The 'lightning:' prefix (ignored with '_')
3. The actual invoice value (stored in 'value')

If both the raw match and the invoice value are found, it returns a ParsedInvoice object with the appropriate type, value, and raw text. Otherwise, it returns undefined (void).

related: ParseContext,ParsedInvoice,ParsedBase

import/access examples:
import { parseInvoice } from '@welshman/content';
import { parseInvoice } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 250:283
id: 768bc6c7c3e5adde4f986fda1eee5bb2855cf4728e7fba922882017c239b9d8e
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L250

declaration:
parseLink = (text: string, context: ParseContext): ParsedLink | void => {
  const prev = last(context.results)
  const link = text.match(
    /^([a-z\+:]{2,30}:\/\/)?[-\.~\w]+\.[\w]{2,6}([^\s]*[^<>"'\.!,:\s\)\(]+)?/gi,
  )?.[0]

  // Skip url if it's just the end of a filepath or an ellipse
  if (!link || (prev?.type === ParsedType.Text && prev.value.endsWith("/")) || link.match(/\.\./)) {
    return
  }

  // Skip it if it looks like an IP address but doesn't have a protocol
  if (link.match(/\d+\.\d+/) && !link.includes("://")) {
    return
  }

  // Parse using URL, make sure there's a protocol
  let url
  try {
    url = new URL(link.match(/^\w+:\/\//) ? link : "https://" + link)
  } catch (e) {
    return
  }

  const meta = Object.fromEntries(new URLSearchParams(url.hash.slice(1)).entries())

  for (const tag of context.tags) {
    if (tag[0] === "imeta" && tag.find(t => t.includes(`url ${link}`))) {
      Object.assign(meta, Object.fromEntries(tag.slice(1).map((m: string) => m.split(" "))))
    }
  }

  return {type: ParsedType.Link, value: {url, meta}, raw: link}
}

summary:
A function that parses a string to identify and extract URL links. It returns a ParsedLink object if a valid link is found, or void if no link is detected. The function handles various URL formats, extracts metadata from URL hashes, and processes 'imeta' tags from the context.

details:
The implementation works through several steps:

1. Gets the previous parsed result from context to check for context-dependent cases
2. Uses a complex regex to match potential URLs with or without protocols
3. Performs several validation checks:
   - Skips if it's likely part of a filepath or ellipsis
   - Skips IP-like addresses without protocols
4. Attempts to create a proper URL object, adding 'https://' protocol if missing
5. Extracts metadata from:
   - URL hash parameters
   - Any 'imeta' tags in the context that reference this URL
6. Returns a structured ParsedLink object with the URL, metadata, and original raw text

The function handles edge cases carefully to avoid false positives while being flexible enough to recognize various URL formats.

related: ParseContext,ParsedLink,ParsedBase

import/access examples:
import { parseLink } from '@welshman/content';
import { parseLink } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 285:291
id: ab4b46218e114e4b88f57c79515efbe6fb1ab9bb46a6cf06541e0619caf6fe02
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L285

declaration:
parseNewline = (text: string, context: ParseContext): ParsedNewline | void => {
  const [value] = text.match(/^\n+/) || []

  if (value) {
    return {type: ParsedType.Newline, value, raw: value}
  }
}

summary:
A function that parses newline characters from the beginning of a text string. It takes a text string and a ParseContext object as parameters and returns either a ParsedNewline object or void if no newlines are found at the beginning of the text.

details:
The implementation is straightforward:
1. It uses a regular expression `/^\n+/` to match one or more newline characters at the beginning of the input text
2. It destructures the first match result (or an empty array if no match) into the `value` variable
3. If a value was found (meaning newlines were detected), it returns a ParsedNewline object with:
   - type set to ParsedType.Newline
   - value set to the matched newlines
   - raw set to the matched newlines
4. If no newlines were found at the beginning of the text, it implicitly returns undefined

related: ParseContext,ParsedNewline,ParsedBase

import/access examples:
import { parseNewline } from '@welshman/content';
import { parseNewline } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 293:307
id: e9ef69a5094316227bd287b36c9dc748c4591af75403b0b3090ab224099716b8
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L293

declaration:
parseProfile = (text: string, context: ParseContext): ParsedProfile | void => {
  const [entity] = text.match(/^@?(web\+)?(nostr:)n(profile|pub)1[\d\w]+/i) || []

  if (entity) {
    try {
      const {type, data} = decode(fromNostrURI(entity.replace("@", "")))
      const value =
        type === "npub" ? {pubkey: data as string, relays: []} : (data as ProfilePointer)

      return {type: ParsedType.Profile, value, raw: entity}
    } catch (e) {
      // Pass
    }
  }
}

summary:
The `parseProfile` function attempts to parse a Nostr profile identifier from a given text string. It takes a text string and a parsing context as parameters and returns either a ParsedProfile object or void if no profile identifier is found. The function recognizes both 'nprofile' and 'npub' formats, with or without 'web+' or 'nostr:' prefixes, and optionally with a leading '@' character.

details:
Implementation details:
1. The function first attempts to match the input text against a regular expression that identifies Nostr profile identifiers (nprofile1 or npub1 format).
2. If a match is found, it:
   - Removes any '@' prefix from the entity
   - Uses the `decode` function from nostr-tools/nip19 to decode the identifier
   - Determines if it's an 'npub' type (just a public key) or 'nprofile' type (which includes relays)
   - For 'npub', creates a ProfilePointer with the pubkey and empty relays array
   - For 'nprofile', uses the decoded data directly as a ProfilePointer
   - Returns a ParsedProfile object with the appropriate type, value, and raw text
3. If decoding fails, it silently catches the error and continues
4. If no match is found, it returns undefined (void)

related: ParseContext,ParsedProfile,ParsedBase

import/access examples:
import { parseProfile } from '@welshman/content';
import { parseProfile } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 309:316
id: 1d210340d37daaaba1606a24af58008c7f4b5e9839cb9866bfb72ced070500ac
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L309

declaration:
parseTopic = (text: string, context: ParseContext): ParsedTopic | void => {
  const [value] = text.match(/^#[^\s!\"#$%&'()*+,-.\/:;<=>?@[\\\]^_`{|}~]+/i) || []

  // Skip numeric topics
  if (value && !value.match(/^#\d+$/)) {
    return {type: ParsedType.Topic, value: value.slice(1), raw: value}
  }
}

summary:
The `parseTopic` function parses hashtag topics from text. It takes a string and a parsing context as input and returns either a ParsedTopic object or void. It identifies text starting with '#' followed by non-whitespace and non-special characters, excluding purely numeric hashtags (like #123).

details:
The implementation:
1. Uses a regular expression to match text starting with '#' followed by any characters except whitespace and special characters
2. If a match is found, it checks that the topic isn't purely numeric (using another regex `/^#\d+$/`)
3. For valid topics, it returns a ParsedTopic object with:
   - type: ParsedType.Topic
   - value: The matched text with the '#' prefix removed
   - raw: The original matched text including the '#'
4. Returns undefined (void) if no valid topic is found

related: ParseContext,ParsedTopic,ParsedBase

import/access examples:
import { parseTopic } from '@welshman/content';
import { parseTopic } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 320:338
id: 728acb2d118a891d7758d75373f15be0dd2442c8c72ad8616637f1364242e40f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L320

declaration:
parseLegacyMention = (
  text: string,
  context: ParseContext,
): ParsedProfile | ParsedEvent | void => {
  const mentionMatch = text.match(/^#\[(\d+)\]/i) || []

  if (mentionMatch) {
    const [tag, value, url] = context.tags[parseInt(mentionMatch[1])] || []
    const relays = url ? [url] : []

    if (tag === "p") {
      return {type: ParsedType.Profile, value: {pubkey: value, relays}, raw: mentionMatch[0]!}
    }

    if (tag === "e") {
      return {type: ParsedType.Event, value: {id: value, relays}, raw: mentionMatch[0]!}
    }
  }
}

summary:
The `parseLegacyMention` function parses legacy Nostr mentions in the format `#[n]` where n is a number. It takes a text string and a ParseContext object, and returns either a ParsedProfile, ParsedEvent, or void. The function identifies mentions that reference tags in the context and converts them to the appropriate parsed type based on the tag type ('p' for profiles, 'e' for events).

details:
The implementation works as follows:

1. It uses a regular expression to match text starting with `#[` followed by digits and ending with `]`
2. If a match is found, it extracts the index number from the match
3. It looks up the corresponding tag in the context.tags array using the extracted index
4. It extracts the tag type, value, and optional URL from the tag
5. If a URL is present, it's added to a relays array
6. Based on the tag type:
   - If 'p' (person/profile), returns a ParsedProfile object with the pubkey and relays
   - If 'e' (event), returns a ParsedEvent object with the event id and relays
7. If no match is found or the tag type isn't recognized, it returns undefined (void)

related: ParseContext,ParsedEvent,ParsedBase,ParsedProfile

import/access examples:
import { parseLegacyMention } from '@welshman/content';
import { parseLegacyMention } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 340:353
id: ef54e25d63b9884ce361fbb59e45d41d394a2a856e4cf312d6d55eaeb7794d7f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L340

declaration:
parsers = [
  parseNewline,
  parseLegacyMention,
  parseTopic,
  parseCodeBlock,
  parseCodeInline,
  parseAddress,
  parseProfile,
  parseEmoji,
  parseEvent,
  parseCashu,
  parseInvoice,
  parseLink,
]

summary:
An array of parser functions used to identify and extract various content types from text. This array includes parsers for newlines, legacy mentions, topics, code blocks, inline code, addresses, profiles, emojis, events, cashu tokens, invoices, and links. These parsers are used in sequence when attempting to parse content in the Nostr protocol.

details:
The `parsers` array contains a specific ordered list of parser functions that are applied sequentially during the content parsing process. The order is important as it determines the precedence of different content types:

1. First checks for newlines (`parseNewline`)
2. Then legacy mentions (`parseLegacyMention`)
3. Followed by topics (`parseTopic`)
4. Code blocks and inline code (`parseCodeBlock`, `parseCodeInline`)
5. Various Nostr-specific entities (`parseAddress`, `parseProfile`, etc.)
6. Finally checks for links (`parseLink`)

This array is used by the `parseNext` function which iterates through these parsers until one successfully matches and returns a parsed result. The ordering ensures that more specific patterns are checked before more general ones to prevent incorrect matches.

related: parseNewline,parseLegacyMention,parseTopic,parseCodeBlock,parseCodeInline,parseAddress,parseProfile,parseEmoji,parseEvent,parseCashu,parseInvoice,parseLink

import/access examples:
import { parsers } from '@welshman/content';
import { parsers } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 355:363
id: c5364d26250fedfc62592d1682a7257695f5023afe4e93293fa1e75d8d9785f4
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L355

declaration:
parseNext = (raw: string, context: ParseContext): Parsed | void => {
  for (const parser of parsers) {
    const result = parser(raw, context)

    if (result) {
      return result
    }
  }
}

summary:
The `parseNext` function attempts to parse a string using a series of parsers to identify specific content types in Nostr messages. It takes a raw string and a parsing context, and returns a parsed result object or void if no parser matches the input. This function is a core part of the content parsing pipeline.

details:
The implementation iterates through an array of parser functions (defined in the `parsers` array) and applies each one to the raw input string. Each parser attempts to match a specific pattern (like links, mentions, emoji, etc.) at the beginning of the string.

The function works by:
1. Looping through each parser in the predefined `parsers` array
2. Calling each parser with the raw string and context
3. If any parser returns a result (successfully matched), immediately returning that result
4. If no parser matches, returning undefined (void)

This is used as part of a larger parsing system where the main `parse` function repeatedly calls `parseNext` to incrementally process content.

related: ParseContext,ParsedAddress,ParsedBase,ParsedCashu,ParsedCode,ParsedEllipsis,ParsedEmoji,ParsedEvent,ParsedInvoice,ParsedLink,ParsedLinkGrid,ParsedNewline,ParsedProfile,ParsedText,ParsedTopic

import/access examples:
import { parseNext } from '@welshman/content';
import { parseNext } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 367:399
id: 7fd8aaf97f2fe3af6ad93c785a84ca9635101ea24d661ae07b0ceabc5dbd8205
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L367

declaration:
parse = ({content = "", tags = []}: {content?: string; tags?: string[][]}) => {
  const context: ParseContext = {content, tags, results: []}

  let buffer = ""
  let remaining = content.trim() || tags.find(t => t[0] === "alt")?.[1] || ""

  while (remaining) {
    const parsed = parseNext(remaining, context)

    if (parsed) {
      if (buffer) {
        context.results.push({type: ParsedType.Text, value: buffer, raw: buffer})
        buffer = ""
      }

      context.results.push(parsed)
      remaining = remaining.slice(parsed.raw.length)
    } else {
      // Instead of going character by character and re-running all the above regular expressions
      // a million times, try to match the next word and add it to the buffer
      const [match] = remaining.match(/^[\w\d]+ ?/i) || remaining[0]

      buffer += match
      remaining = remaining.slice(match.length)
    }
  }

  if (buffer) {
    context.results.push({type: ParsedType.Text, value: buffer, raw: buffer})
  }

  return context.results
}

summary:
The `parse` function processes content and tags from a Nostr event, breaking down the content into structured parsed elements. It accepts an object with optional `content` (string) and `tags` (string[][]) parameters and returns an array of parsed elements. Each element is categorized by type (text, link, emoji, etc.) according to the `ParsedType` enum.

details:
The implementation works by iterating through the content string and identifying special formats using a series of parser functions:

1. It initializes a context object with the content, tags, and an empty results array
2. It processes the content character by character, trying to match patterns using the `parseNext` function
3. When a match is found:
   - Any accumulated text buffer is pushed as a ParsedText element
   - The matched element is added to results
   - The matched portion is removed from the remaining content
4. When no match is found:
   - It adds the next word to a buffer instead of processing character by character (optimization)
5. After processing all content, any remaining buffer is added as text

The function uses the `parseNext` helper which tries each parser in sequence until one returns a result. The parsers detect various formats like links, mentions, hashtags, emoji codes, and Nostr-specific formats.

related: Parsed,ParsedAddress,ParsedBase,ParsedCashu,ParsedCode,ParsedEllipsis,ParsedEmoji,ParsedEvent,ParsedInvoice,ParsedLink,ParsedLinkGrid,ParsedNewline,ParsedProfile,ParsedText,ParsedTopic

import/access examples:
import { parse } from '@welshman/content';
import { parse } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 401:406
id: 99c283ef8a2bfc55a10aa738e673e9f791aec51fb576b10a97cf70119d46b45a
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L401

declaration:
type TruncateOpts = {
  minLength?: number
  maxLength?: number
  mediaLength?: number
  entityLength?: number
}

summary:
TruncateOpts is a type alias that defines the configuration options for the truncate function. It contains optional parameters to control how content is truncated:
- minLength?: number - Minimum length before truncation begins (default: 500)
- maxLength?: number - Maximum length allowed before truncation (default: 700)
- mediaLength?: number - Length value assigned to media elements (default: 200)
- entityLength?: number - Length value assigned to entity elements (default: 30)

details:
This type is used as the parameter type for the truncate function (lines 408-456) which determines how parsed content should be truncated based on these configuration values. The truncate function uses these values to calculate the effective size of different content types and decide where to cut off content when it exceeds the specified limits.

=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 408:456
id: 2dd443101d53a08faf301a083413cedc37f04b1c70e7ceeb0ab7fc904589a274
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L408

declaration:
truncate = (
  content: Parsed[],
  {minLength = 500, maxLength = 700, mediaLength = 200, entityLength = 30}: TruncateOpts = {},
) => {
  // Get a list of content sizes so we know where to truncate
  // Non-plaintext things might take up more or less room if rendered
  const sizes = content.map((parsed: Parsed) => {
    switch (parsed.type) {
      case ParsedType.Link:
      case ParsedType.LinkGrid:
      case ParsedType.Cashu:
      case ParsedType.Invoice:
        return mediaLength
      case ParsedType.Event:
      case ParsedType.Address:
      case ParsedType.Profile:
        return entityLength
      case ParsedType.Emoji:
        return parsed.value.name.length
      default:
        return parsed.value.length
    }
  })

  // If total size fits inside our max, we're done
  if (sizes.reduce((r, x) => r + x, 0) < maxLength) {
    return content
  }

  let currentSize = 0

  // Otherwise, truncate more then necessary so that when the user expands the note
  // they have more than just a tiny bit to look at. Truncating a single word is annoying.
  sizes.every((size, i) => {
    currentSize += size

    if (currentSize > minLength) {
      content = content
        .slice(0, Math.max(1, i + 1))
        .concat({type: ParsedType.Ellipsis, value: "…", raw: ""})

      return false
    }

    return true
  })

  return content
}

summary:
The `truncate` function takes an array of parsed content elements and truncates it to a reasonable length. It accepts a content array of `Parsed` objects and an optional options object with parameters for controlling truncation behavior: `minLength` (default 500), `maxLength` (default 700), `mediaLength` (default 200), and `entityLength` (default 30). The function returns a truncated version of the content array with an ellipsis element appended if truncation was necessary.

details:
The implementation works by:

1. Calculating the display size of each content element based on its type:
   - Media elements (links, link grids, cashu tokens, invoices) use the `mediaLength` value
   - Entity references (events, addresses, profiles) use the `entityLength` value
   - Emojis use their name length
   - Other elements use their value length

2. Checking if the total content size exceeds `maxLength`
   - If not, return the original content unchanged

3. If truncation is needed, it iterates through elements, accumulating size until `minLength` is exceeded
   - At that point, it slices the content array to that position
   - Ensures at least one element is kept with `Math.max(1, i + 1)`
   - Appends an ellipsis element to indicate truncation
   - Returns the truncated content

The function intelligently truncates content to provide a meaningful preview while indicating that more content is available.

related: Parsed,TruncateOpts,ParsedAddress,ParsedBase,ParsedCashu,ParsedCode,ParsedEllipsis,ParsedEmoji,ParsedEvent,ParsedInvoice,ParsedLink,ParsedLinkGrid,ParsedNewline,ParsedProfile,ParsedText,ParsedTopic

import/access examples:
import { truncate } from '@welshman/content';
import { truncate } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/parser.ts
lines: 458:487
id: 7e9725066310a1ed8875aa15c092edfb758fdaed9273ef382cc54af3165a1418
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts#L458

declaration:
reduceLinks = (content: Parsed[]): Parsed[] => {
  const result: Parsed[] = []
  const buffer: ParsedLinkValue[] = []

  for (const parsed of content) {
    const prev = last(result)

    // If we have a link and we're in our own block, start a grid
    if (isLink(parsed) && (!prev || isNewline(prev))) {
      buffer.push(parsed.value)
      continue
    }

    // Ignore newlines and empty space if we're building a grid
    if (isNewline(parsed) && buffer.length > 0) continue
    if (isText(parsed) && !parsed.value.trim() && buffer.length > 0) continue

    if (buffer.length > 0) {
      result.push({type: ParsedType.LinkGrid, value: {links: buffer.splice(0)}, raw: ""})
    }

    result.push(parsed)
  }

  if (buffer.length > 0) {
    result.push({type: ParsedType.LinkGrid, value: {links: buffer.splice(0)}, raw: ""})
  }

  return result
}

summary:
The `reduceLinks` function transforms an array of parsed content elements by grouping consecutive links into link grids. It takes an array of `Parsed` objects as input and returns a new array where sequences of links are consolidated into `ParsedLinkGrid` objects. This function is useful for improving the display of content that contains multiple consecutive links by organizing them into a grid layout.

details:
The implementation works by:

1. Maintaining two arrays: `result` (the final output) and `buffer` (temporary storage for links that might form a grid)
2. Iterating through each parsed element in the input content
3. When a link is encountered at the start of a block (either at the beginning or after a newline), it's added to the buffer instead of directly to the result
4. Newlines and empty text elements are ignored if we're in the process of building a grid (buffer has items)
5. When a non-link element is encountered after collecting links in the buffer, the function:
   - Creates a new LinkGrid element from the buffered links
   - Adds it to the result array
   - Clears the buffer
   - Adds the current non-link element to the result
6. Finally, if there are any remaining links in the buffer after processing all elements, they're converted to a LinkGrid and added to the result

related: Parsed,ParsedAddress,ParsedBase,ParsedCashu,ParsedCode,ParsedEllipsis,ParsedEmoji,ParsedEvent,ParsedInvoice,ParsedLink,ParsedLinkGrid,ParsedNewline,ParsedProfile,ParsedText,ParsedTopic

import/access examples:
import { reduceLinks } from '@welshman/content';
import { reduceLinks } from '@welshman/content/parser';


=========================
workspace: packages/content
file: packages/content/src/render.ts
lines: 20:48
id: bbc1c6df0718495ea70adac02600330ae139c54164e0480faca8f363b8682e79
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/render.ts#L20

declaration:
export class Renderer{
  constructor(readonly options: RenderOptions);
  toString: () => string;
  addText: (value: string) => void;
  addNewlines: (count: number) => void;
  addLink: (href: string, display: string) => void;
  addEntityLink: (entity: string) => void;
}

summary:
The `Renderer` class is responsible for converting parsed content into a formatted string representation. It maintains an internal string value that accumulates rendered content and provides methods to add different types of content (text, newlines, links, entity links). The class requires `RenderOptions` to be passed to its constructor, which defines how various elements should be rendered.

details:
The implementation of the `Renderer` class is straightforward:

1. It maintains a private `value` string that accumulates the rendered content.
2. It exposes several methods for adding different types of content to the rendered output:
   - `toString()`: Returns the current value of the rendered content
   - `addText()`: Adds text by creating a temporary DOM element, setting its innerText (which handles escaping), and then extracting the innerHTML
   - `addNewlines()`: Adds a specified number of newline characters based on the options
   - `addLink()`: Adds a link using the renderLink function from options
   - `addEntityLink()`: Adds a specialized link for entities by combining the entityBase with the entity and using renderEntity for display

The class relies on the provided RenderOptions to determine exactly how each element should be rendered, making it flexible for different output formats.

related: RenderOptions

code:
export class Renderer {
  private value = ""

  constructor(readonly options: RenderOptions) {}

  toString = () => this.value

  addText = (value: string) => {
    const element = this.options.createElement("div")

    element.innerText = value

    this.value += element.innerHTML
  }

  addNewlines = (count: number) => {
    for (let i = 0; i < count; i++) {
      this.value += this.options.newline
    }
  }

  addLink = (href: string, display: string) => {
    this.value += this.options.renderLink(href, display)
  }

  addEntityLink = (entity: string) => {
    this.addLink(this.options.entityBase + entity, this.options.renderEntity(entity))
  }
}

import/access examples:
import { Renderer } from '@welshman/content';
import { Renderer } from '@welshman/content/render';


=========================
workspace: packages/content
file: packages/content/src/render.ts
lines: 50:56
id: ceebd2505e98d2e26fbe494103eccb52ba6c27fb58e6ec01a7cc2b30caf658a1
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/render.ts#L50

declaration:
export type RenderOptions = {
  newline: string
  entityBase: string
  renderLink: (href: string, display: string) => string
  renderEntity: (entity: string) => string
  createElement: (tag: string) => any
}

summary:
RenderOptions is a type definition that specifies the configuration options for rendering parsed content. It includes properties for handling newlines, entity base URLs, and functions for rendering links, entities, and creating DOM elements.

details:
The RenderOptions type defines the interface for configuring how the Renderer class will transform parsed content into text or HTML. It contains five key properties:
1. `newline`: A string that represents how line breaks should be rendered
2. `entityBase`: A base URL string used for entity links
3. `renderLink`: A function that takes a URL and display text and returns a formatted link
4. `renderEntity`: A function that takes an entity string and returns a formatted display version
5. `createElement`: A function that creates DOM elements for rendering text content

This type is used throughout the rendering system to customize output format and behavior, with default implementations provided by textRenderOptions and htmlRenderOptions.

import/access examples:
import type { RenderOptions } from '@welshman/content';
import type { RenderOptions } from '@welshman/content/render';


=========================
workspace: packages/content
file: packages/content/src/render.ts
lines: 58:64
id: 3e35993de6e87946b9b43a1cbddc1b7982cf47b097a1200aff27fcb21acc56fa
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/render.ts#L58

declaration:
textRenderOptions = {
  newline: "\n",
  entityBase: "",
  createElement: (tag: string) => document.createElement(tag) as any,
  renderLink: (href: string, display: string) => href,
  renderEntity: (entity: string) => entity.slice(0, 16) + "…",
}

summary:
A constant object that provides default rendering options for text output. It includes settings for newline characters, entity base URL, a function to create DOM elements, a function to render links, and a function to render entity references. This is used as the base configuration for text rendering in the Renderer class.

details:
The `textRenderOptions` object contains five key properties:
1. `newline`: Set to "\n" for standard line breaks
2. `entityBase`: An empty string, meaning no base URL is prepended to entity references
3. `createElement`: A function that creates DOM elements using document.createElement
4. `renderLink`: A simple function that returns just the href URL (not formatted HTML)
5. `renderEntity`: A function that truncates entity strings to 16 characters followed by an ellipsis

This configuration is designed for plain text rendering without HTML formatting. It's used as the default options in the `makeTextRenderer` factory function.

import/access examples:
import { textRenderOptions } from '@welshman/content';
import { textRenderOptions } from '@welshman/content/render';


=========================
workspace: packages/content
file: packages/content/src/render.ts
lines: 66:80
id: 3bb3937d9860a18a969be138ec378bbc063e30c10a08244b779b85ea4e938e63
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/render.ts#L66

declaration:
htmlRenderOptions = {
  newline: "\n",
  entityBase: "https://njump.me/",
  createElement: (tag: string) => document.createElement(tag) as any,
  renderLink(href: string, display: string) {
    const element = this.createElement("a")

    element.href = sanitizeUrl(href)
    element.target = "_blank"
    element.innerText = display

    return element.outerHTML
  },
  renderEntity: (entity: string) => entity.slice(0, 16) + "…",
}

summary:
A constant object that provides default rendering options for HTML output. It includes settings for newline characters, entity base URL, DOM element creation, link rendering with sanitization and target attributes, and entity display formatting. This is used with the Renderer class to convert parsed content into HTML.

details:
The `htmlRenderOptions` object implements the `RenderOptions` interface with HTML-specific behaviors:

1. Sets newline character to "\n"
2. Uses "https://njump.me/" as the base URL for entity links
3. Provides a createElement function that creates DOM elements
4. Implements a renderLink function that:
   - Creates an anchor element
   - Sanitizes the URL using the @braintree/sanitize-url library
   - Sets target="_blank" for external links
   - Sets the display text
   - Returns the element's outerHTML
5. Formats entity displays by showing the first 16 characters followed by an ellipsis

This object serves as the default configuration for HTML rendering when used with makeHtmlRenderer.

import/access examples:
import { htmlRenderOptions } from '@welshman/content';
import { htmlRenderOptions } from '@welshman/content/render';


=========================
workspace: packages/content
file: packages/content/src/render.ts
lines: 82:83
id: 346f309795aaa92623fc655cb5d07408009eaf7fe172b46e2992c74d5c6a9218
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/render.ts#L82

declaration:
makeTextRenderer = (options: Partial<RenderOptions> = {}) =>
  new Renderer({...textRenderOptions, ...options})

summary:
Creates and returns a new Renderer instance configured for text rendering. The function accepts an optional `options` parameter that allows customizing the default text rendering options. Any provided options will override the default `textRenderOptions`.

details:
This function creates a text renderer by:
1. Taking an optional partial RenderOptions object as input
2. Merging these custom options with the default textRenderOptions using the spread operator
3. Creating a new Renderer instance with the merged options

The default text renderer is configured to use newlines as separators, has no entity base URL, and renders links and entities in a plain text format. This function is useful when you need to render parsed content as plain text rather than HTML.

related: __constructor,Renderer,RenderOptions

import/access examples:
import { makeTextRenderer } from '@welshman/content';
import { makeTextRenderer } from '@welshman/content/render';


=========================
workspace: packages/content
file: packages/content/src/render.ts
lines: 85:86
id: 8eec8a1111ee59a082097a503c2abd6698e4c6a967652380d2bd94d89e3a1083
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/render.ts#L85

declaration:
makeHtmlRenderer = (options: Partial<RenderOptions> = {}) =>
  new Renderer({...htmlRenderOptions, ...options})

summary:
Creates and returns a new Renderer instance configured with HTML rendering options. The function accepts an optional parameter to override default HTML rendering settings. This renderer is designed to convert parsed Nostr content into HTML format.

details:
The implementation creates a new Renderer instance by merging the default HTML rendering options (htmlRenderOptions) with any custom options provided by the caller. The htmlRenderOptions include:
1. Newline character as "\n"
2. Entity base URL set to "https://njump.me/"
3. A document.createElement function for creating DOM elements
4. A renderLink function that creates HTML anchor tags with proper sanitization and target="_blank"
5. A renderEntity function that truncates entity strings to 16 characters followed by an ellipsis

related: __constructor,Renderer,RenderOptions

import/access examples:
import { makeHtmlRenderer } from '@welshman/content';
import { makeHtmlRenderer } from '@welshman/content/render';


=========================
workspace: packages/content
file: packages/content/src/render.ts
lines: 90:90
id: cccaa82367c73ecaa84710e4642424d96c96a2fe23c2a99554e4c060a9a3c036
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/render.ts#L90

declaration:
renderCashu = (p: ParsedCashu, r: Renderer) => r.addText(p.value)

summary:
The `renderCashu` function renders a parsed Cashu token as plain text. It takes a ParsedCashu object and a Renderer instance as parameters, and adds the Cashu token's value as text to the renderer.

details:
This is a simple rendering function that extracts the value from a ParsedCashu object and adds it as text to the provided Renderer instance using the renderer's `addText` method. It doesn't perform any special formatting or transformation on the Cashu token value.

related: __function,addText,ParsedCashu,Renderer

import/access examples:
import { renderCashu } from '@welshman/content';
import { renderCashu } from '@welshman/content/render';


=========================
workspace: packages/content
file: packages/content/src/render.ts
lines: 92:92
id: b437967ca510f02cf73346303d3e092fa67d1956d82f8728318d0cfbebb068c0
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/render.ts#L92

declaration:
renderCode = (p: ParsedCode, r: Renderer) => r.addText(p.value)

summary:
A function that renders a ParsedCode object using a Renderer instance. It takes a ParsedCode object and a Renderer instance as parameters, and adds the code's value as text to the renderer.

details:
This is a simple rendering function that extracts the value from a ParsedCode object and adds it as text to the provided Renderer instance using the renderer's addText method. It doesn't perform any special formatting or syntax highlighting for code - it just renders the raw text content.

related: __function,addText,ParsedCode,Renderer

import/access examples:
import { renderCode } from '@welshman/content';
import { renderCode } from '@welshman/content/render';


=========================
workspace: packages/content
file: packages/content/src/render.ts
lines: 94:94
id: bfc42809b9a26895e9e975d384793b0c3727204207de137b1dbd8e483c29dabf
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/render.ts#L94

declaration:
renderEllipsis = (p: ParsedEllipsis, r: Renderer) => r.addText("…")

summary:
A function that renders an ellipsis character ('…') from a ParsedEllipsis object using the provided Renderer instance. It takes a ParsedEllipsis object and a Renderer instance as parameters and adds the ellipsis character to the renderer's output.

details:
This is a simple rendering function that handles the specific case of rendering an ellipsis. It uses the Renderer's addText method to add the ellipsis character ('…') to the output string being built by the renderer. The implementation is straightforward with no complex logic - it simply delegates to the renderer's text addition functionality.

related: __function,addText,ParsedEllipsis,Renderer

import/access examples:
import { renderEllipsis } from '@welshman/content';
import { renderEllipsis } from '@welshman/content/render';


=========================
workspace: packages/content
file: packages/content/src/render.ts
lines: 96:96
id: 29a5a32771c38384c1611331276a2d3531b99e1d2fa5ff1b46f84dc5ec7ca893
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/render.ts#L96

declaration:
renderEmoji = (p: ParsedEmoji, r: Renderer) => r.addText(p.raw)

summary:
A function that renders an emoji parsed element to text. It takes a ParsedEmoji object and a Renderer instance, and adds the raw emoji text to the renderer's output.

details:
This is a simple rendering function that extracts the raw emoji text from the ParsedEmoji object and adds it to the renderer using the addText method. The implementation is straightforward - it just passes the raw emoji value directly to the renderer without any transformation.

related: __function,addText,ParsedEmoji,Renderer

import/access examples:
import { renderEmoji } from '@welshman/content';
import { renderEmoji } from '@welshman/content/render';


=========================
workspace: packages/content
file: packages/content/src/render.ts
lines: 98:99
id: 9485e2d1cd8538b70842d7f3710869bdc5c15e1709c5de1f8989234c9d734b74
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/render.ts#L98

declaration:
renderInvoice = (p: ParsedInvoice, r: Renderer) =>
  r.addLink("lightning:" + p.value, p.value.slice(0, 16) + "…")

summary:
Renders a parsed Lightning invoice. Takes a `ParsedInvoice` object `p` and a `Renderer` instance `r`, then adds a hyperlink to the renderer using the `lightning:` URI scheme. The link's display text is the first 16 characters of the invoice value followed by an ellipsis.

details:
The function is a thin wrapper around `Renderer.addLink`. It constructs the hyperlink URL by prefixing the invoice string (`p.value`) with `"lightning:"`. For the link text it slices the invoice value to the first 16 characters and appends the Unicode ellipsis character (U+2026). Finally it delegates to `r.addLink(href, display)`. No additional side‑effects or complex logic are performed.

related: __function,addLink,ParsedInvoice,Renderer

import/access examples:
import { renderInvoice } from '@welshman/content';
import { renderInvoice } from '@welshman/content/render';


=========================
workspace: packages/content
file: packages/content/src/render.ts
lines: 101:102
id: 5fbd78865f6601ccfb0fb6ecf250d667a483d6cddadd686784f8fcca94fd0e85
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/render.ts#L101

declaration:
renderLink = (p: ParsedLink, r: Renderer) =>
  r.addLink(p.value.url.toString(), p.value.url.host + p.value.url.pathname.replace(/^\/$/, ""))

summary:
A function that renders a parsed link into a formatted string using a Renderer instance. It takes a ParsedLink object and a Renderer instance as parameters, and adds a link to the renderer with the URL as the href and a display text constructed from the URL's host and pathname.

details:
This function implements the rendering logic for link entities in parsed content. It:
1. Takes the URL from the ParsedLink object and converts it to a string for the href parameter
2. Creates a display text by combining the URL's host with its pathname
3. Uses a regex replacement to remove trailing slashes from the pathname when it's just '/'
4. Calls the renderer's addLink method with these two parameters to generate the appropriate link representation

The function relies on the Renderer's implementation of addLink to handle the actual formatting according to the renderer's options.

related: __function,addLink,ParsedLink,Renderer

import/access examples:
import { renderLink } from '@welshman/content';
import { renderLink } from '@welshman/content/render';


=========================
workspace: packages/content
file: packages/content/src/render.ts
lines: 104:105
id: c9d94e5aabbba3eb18c2930423044e55e3390c5da32bda808b9a9e7fba7da6dc
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/render.ts#L104

declaration:
renderNewline = (p: ParsedNewline, r: Renderer) =>
  r.addNewlines(Array.from(p.value).length)

summary:
A function that renders newline characters from a ParsedNewline object using a Renderer instance. It takes a ParsedNewline object and a Renderer instance as parameters and adds the appropriate number of newlines to the renderer's output.

details:
This function converts a ParsedNewline object into actual newline characters in the rendered output. It works by:
1. Taking the parsed newline value from the input parameter
2. Converting it to an array using Array.from() to properly count the number of newline characters
3. Getting the length of that array to determine how many newlines to add
4. Calling the renderer's addNewlines() method with that count

The implementation handles multiple consecutive newlines by counting them and adding the same number to the rendered output.

related: __function,addNewlines,ParsedNewline,Renderer

import/access examples:
import { renderNewline } from '@welshman/content';
import { renderNewline } from '@welshman/content/render';


=========================
workspace: packages/content
file: packages/content/src/render.ts
lines: 107:107
id: 3031446ac51d4685e30cb54687bac663c3527a777cb07338c78a72aaa6e86364
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/render.ts#L107

declaration:
renderText = (p: ParsedText, r: Renderer) => r.addText(p.value)

summary:
A function that renders a ParsedText object using a Renderer instance. It takes a ParsedText object and a Renderer instance as parameters, and adds the text value from the ParsedText to the Renderer.

details:
This is a simple rendering function that extracts the text value from a ParsedText object and adds it to the renderer using the renderer's addText method. It's part of a collection of specialized rendering functions, each handling a different type of parsed content. This particular function handles plain text content by directly passing the text value to the renderer without any special formatting or processing.

related: __function,addText,ParsedText,Renderer

import/access examples:
import { renderText } from '@welshman/content';
import { renderText } from '@welshman/content/render';


=========================
workspace: packages/content
file: packages/content/src/render.ts
lines: 109:109
id: 218b1b68a6be63d772986e9bf4066a14c653cd7012f4748e8dc455a69d1efff8
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/render.ts#L109

declaration:
renderTopic = (p: ParsedTopic, r: Renderer) => r.addText(p.value)

summary:
A function that renders a parsed topic element using a renderer. It takes a ParsedTopic object and a Renderer instance, and adds the topic's value as text to the renderer.

details:
This is a simple rendering function that takes a ParsedTopic object (which contains a topic value) and a Renderer instance. It calls the renderer's addText method with the topic's value, effectively converting the parsed topic into its text representation in the final output. The implementation is straightforward with no complex logic - it's a one-line function that delegates the actual rendering to the Renderer instance.

related: __function,addText,ParsedTopic,Renderer

import/access examples:
import { renderTopic } from '@welshman/content';
import { renderTopic } from '@welshman/content/render';


=========================
workspace: packages/content
file: packages/content/src/render.ts
lines: 111:111
id: ff6dad08dbeaca80349a3f3dfcc1670bb773410c69d4855e3f9911d14a74c465
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/render.ts#L111

declaration:
renderEvent = (p: ParsedEvent, r: Renderer) => r.addEntityLink(neventEncode(p.value))

summary:
A function that renders a parsed Nostr event by encoding it using neventEncode and adding it as an entity link to the renderer. Takes a ParsedEvent object and a Renderer instance as parameters, and returns nothing.

details:
This function handles the rendering of Nostr event references in text. It works by:
1. Taking the parsed event data from the ParsedEvent object
2. Encoding the event data using the neventEncode function from nostr-tools/nip19
3. Passing the encoded event to the renderer's addEntityLink method, which will create a link to the event with appropriate formatting

The function is part of a larger rendering system for different types of parsed content in Nostr messages.

related: __function,addEntityLink,ParsedEvent,Renderer

import/access examples:
import { renderEvent } from '@welshman/content';
import { renderEvent } from '@welshman/content/render';


=========================
workspace: packages/content
file: packages/content/src/render.ts
lines: 113:114
id: 750b1063fb415598a9999fa21352dbf7d377019c9e9067e1fc92da3082188ec2
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/render.ts#L113

declaration:
renderProfile = (p: ParsedProfile, r: Renderer) =>
  r.addEntityLink(nprofileEncode(p.value))

summary:
The `renderProfile` function renders a parsed profile entity into a link format. It takes a ParsedProfile object and a Renderer instance as parameters, and uses the renderer to add an entity link with the profile data encoded using nprofileEncode.

details:
This function is part of a rendering system for Nostr entities. It specifically handles profile entities by:
1. Taking the parsed profile data from the ParsedProfile object
2. Encoding that data using the nprofileEncode function from nostr-tools/nip19
3. Passing the encoded string to the renderer's addEntityLink method

The addEntityLink method will create a link with the appropriate URL prefix (defined in the renderer options) and format the display text according to the renderer's configuration.

related: __function,addEntityLink,ParsedProfile,Renderer

import/access examples:
import { renderProfile } from '@welshman/content';
import { renderProfile } from '@welshman/content/render';


=========================
workspace: packages/content
file: packages/content/src/render.ts
lines: 116:117
id: 2549b9eae017d386eeb5242b28cbc8bcd2d53bf94d9fdb25a3e3f7c35b2bda64
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/render.ts#L116

declaration:
renderAddress = (p: ParsedAddress, r: Renderer) =>
  r.addEntityLink(naddrEncode(p.value))

summary:
A function that renders a parsed Nostr address into a displayable format. It takes a ParsedAddress object and a Renderer instance, encodes the address value using naddrEncode, and adds it as an entity link to the renderer.

details:
This function is part of the rendering system for Nostr content. It specifically handles address entities by:
1. Taking the parsed address object which contains the address value
2. Encoding that address using the naddrEncode function from nostr-tools/nip19
3. Using the renderer's addEntityLink method to create a link to this encoded address

The function doesn't return anything directly, but modifies the renderer state by adding the encoded address link to the output.

related: __function,addEntityLink,ParsedAddress,Renderer

import/access examples:
import { renderAddress } from '@welshman/content';
import { renderAddress } from '@welshman/content/render';


=========================
workspace: packages/content
file: packages/content/src/render.ts
lines: 119:160
id: ff0eb0f217873c2f3fd679e14aaf82d8232106c5954cdaab29efba9f85a16168
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/render.ts#L119

declaration:
renderOne = (parsed: Parsed, renderer: Renderer) => {
  switch (parsed.type) {
    case ParsedType.Address:
      renderAddress(parsed as ParsedAddress, renderer)
      break
    case ParsedType.Cashu:
      renderCashu(parsed as ParsedCashu, renderer)
      break
    case ParsedType.Code:
      renderCode(parsed as ParsedCode, renderer)
      break
    case ParsedType.Ellipsis:
      renderEllipsis(parsed as ParsedEllipsis, renderer)
      break
    case ParsedType.Emoji:
      renderEmoji(parsed as ParsedEmoji, renderer)
      break
    case ParsedType.Event:
      renderEvent(parsed as ParsedEvent, renderer)
      break
    case ParsedType.Invoice:
      renderInvoice(parsed as ParsedInvoice, renderer)
      break
    case ParsedType.Link:
      renderLink(parsed as ParsedLink, renderer)
      break
    case ParsedType.Newline:
      renderNewline(parsed as ParsedNewline, renderer)
      break
    case ParsedType.Profile:
      renderProfile(parsed as ParsedProfile, renderer)
      break
    case ParsedType.Text:
      renderText(parsed as ParsedText, renderer)
      break
    case ParsedType.Topic:
      renderTopic(parsed as ParsedTopic, renderer)
      break
  }

  return renderer
}

summary:
Renders a single parsed element to a renderer. Takes a parsed object and a renderer instance, determines the type of the parsed object, and calls the appropriate rendering function based on that type. Returns the renderer instance after rendering is complete, allowing for method chaining.

details:
The function implements a switch statement that handles all possible ParsedType values. For each case, it:
1. Casts the generic Parsed object to its specific type (e.g., ParsedAddress, ParsedCashu)
2. Calls the corresponding specialized render function (e.g., renderAddress, renderCashu)
3. Passes both the typed parsed object and the renderer instance to that function

The implementation follows a consistent pattern for all parsed types, making it easy to extend with new types. After rendering the content, it returns the renderer instance to enable method chaining in the calling code.

related: Parsed,Renderer

import/access examples:
import { renderOne } from '@welshman/content';
import { renderOne } from '@welshman/content/render';


=========================
workspace: packages/content
file: packages/content/src/render.ts
lines: 162:168
id: 82627da634da02e4aa222da7f2aee8c2beeaa27d554facca9e2322f241bee18c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/render.ts#L162

declaration:
renderMany = (parsed: Parsed[], renderer: Renderer) => {
  for (const p of parsed) {
    renderOne(p, renderer)
  }

  return renderer
}

summary:
The `renderMany` function processes an array of parsed elements and renders them using the provided renderer. It takes two parameters: `parsed` (an array of `Parsed` objects) and `renderer` (a `Renderer` instance). The function returns the renderer after all elements have been processed, allowing for method chaining.

details:
The implementation is straightforward:
1. It iterates through each parsed element in the input array using a for-of loop
2. For each element, it calls the `renderOne` function, passing the current parsed element and the renderer
3. After processing all elements, it returns the renderer instance

This function serves as a utility to handle batch rendering of multiple parsed elements, delegating the actual rendering of each individual element to the `renderOne` function.

related: Parsed,Renderer

import/access examples:
import { renderMany } from '@welshman/content';
import { renderMany } from '@welshman/content/render';


=========================
workspace: packages/content
file: packages/content/src/render.ts
lines: 170:171
id: b230d6547768d1a6c33abd4f4e189c8d186f25691e148405a15ad45e41c6beeb
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/render.ts#L170

declaration:
render = (parsed: Parsed | Parsed[], renderer: Renderer) =>
  Array.isArray(parsed) ? renderMany(parsed, renderer) : renderOne(parsed, renderer)

summary:
The `render` function processes parsed content and renders it using a provided renderer. It accepts either a single parsed item or an array of parsed items, along with a Renderer instance, and returns the renderer after processing all items. This function serves as the main entry point for rendering parsed content.

details:
The implementation is straightforward:

1. It takes two parameters:
   - `parsed`: Either a single `Parsed` object or an array of `Parsed` objects
   - `renderer`: A `Renderer` instance that will accumulate the rendered output

2. It uses a ternary operator to determine if the input is an array:
   - If `parsed` is an array, it calls `renderMany()` to process each item in the array
   - If `parsed` is a single item, it calls `renderOne()` to process just that item

3. Both code paths return the renderer instance, which allows for method chaining and accessing the final rendered output via the renderer's methods.

related: __function,renderMany,__function,renderOne,Parsed,Renderer

import/access examples:
import { render } from '@welshman/content';
import { render } from '@welshman/content/render';


=========================
workspace: packages/content
file: packages/content/src/render.ts
lines: 173:174
id: b0810557777cb96674806c4168d877c5af247ad754ee156ae4f76f1ba81ab059
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/render.ts#L173

declaration:
renderAsText = (parsed: Parsed | Parsed[], options: Partial<RenderOptions> = {}) =>
  render(parsed, makeTextRenderer(options))

summary:
Renders one or more parsed Nostr elements into plain‑text. Takes a Parsed object or an array of Parsed objects and optional RenderOptions to override defaults. Returns the Renderer that holds the rendered output (its toString() yields the final string). No external side effects; it only builds the Renderer instance.

details:
The function creates a text‑oriented Renderer by calling makeTextRenderer(options), which merges the supplied Partial<RenderOptions> with the built‑in textRenderOptions (newline '\n', empty entityBase, simple link rendering, etc.). It then forwards the parsed data to the generic render function. render decides whether the input is an array (renderMany) or a single item (renderOne) and invokes the appropriate renderX helpers (e.g., renderText, renderLink, renderEmoji) that add content to the Renderer via its addText, addLink, addNewlines, etc. The wrapper itself contains no complex logic; it merely composes these utilities to produce a text representation.

related: __function,render,Parsed,RenderOptions,Renderer

import/access examples:
import { renderAsText } from '@welshman/content';
import { renderAsText } from '@welshman/content/render';


=========================
workspace: packages/content
file: packages/content/src/render.ts
lines: 176:177
id: 6d43efcd2c69c489de054172a0bb5b7bd8c6053e2f7caa137dacd02541a2e7cc
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/render.ts#L176

declaration:
renderAsHtml = (parsed: Parsed | Parsed[], options: Partial<RenderOptions> = {}) =>
  render(parsed, makeHtmlRenderer(options))

summary:
Renders parsed content as HTML. Takes parsed content (either a single Parsed object or an array of Parsed objects) and optional rendering options, and returns a Renderer instance that can be converted to an HTML string. The function uses the HTML rendering options by default, which can be customized through the options parameter.

details:
This function is a convenience wrapper around the core `render` function, specifically configured for HTML output. It:

1. Creates an HTML renderer using `makeHtmlRenderer()` with the provided options (or default HTML options if none are specified)
2. Passes the parsed content and the renderer to the `render` function
3. The renderer transforms the parsed content into HTML markup based on the type of each parsed element
4. The resulting renderer contains the complete HTML representation that can be accessed via its `toString()` method

The HTML renderer by default uses "https://njump.me/" as the entity base URL and creates proper HTML anchor tags with target="_blank" for links.

related: __function,render,Parsed,RenderOptions,Renderer

import/access examples:
import { renderAsHtml } from '@welshman/content';
import { renderAsHtml } from '@welshman/content/render';


=========================
type: file
workspace: packages/content
path: packages/content/src/parser.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/parser.ts
summary: This module provides utilities for parsing and processing Nostr content. It exports functions to parse various types of content (like links, events, profiles, emojis, etc.) from text, as well as type definitions for parsed content. The main exports include `parse` for converting content and tags into structured data, `truncate` for limiting content length, `reduceLinks` for organizing links into grids, and various type guards like `isLink`, `isEvent`, etc. to check the type of parsed content.

details: The implementation consists of several key components:

1. Type definitions: The file defines numerous types for different parsed content (ParsedLink, ParsedEvent, ParsedProfile, etc.) all extending a base ParsedBase type, with an enum ParsedType to categorize them.

2. Parser functions: For each content type, there's a dedicated parser function (parseLink, parseEvent, parseEmoji, etc.) that uses regular expressions to match and extract data from text.

3. Type guards: Functions like isLink, isEvent, etc. that check if a parsed item is of a specific type.

4. Main parsing logic: The `parse` function that iterates through content, applying parsers in sequence and building up a result array.

5. Post-processing utilities:
   - `truncate`: Limits content length based on configurable parameters
   - `reduceLinks`: Organizes consecutive links into grid structures

The implementation uses the nostr-tools library for decoding NIP-19 entities and handles various Nostr-specific formats like naddr, nevent, npub, etc. It also includes special handling for media links, code blocks, emojis, and other rich content types.

=========================
type: file
workspace: packages/content
path: packages/content/src/render.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/render.ts
summary: This file provides a rendering system for parsed content, primarily for Nostr-related data. It exports a `Renderer` class, render options types, pre-configured renderers for text and HTML, and various rendering functions for different parsed content types. The main exports include `renderAsText` and `renderAsHtml` functions that convert parsed content into text or HTML format, along with utility functions to customize rendering behavior.

details: The implementation consists of:

1. A `Renderer` class that accumulates rendered content and provides methods for adding text, links, and newlines.
2. Two sets of render options: `textRenderOptions` and `htmlRenderOptions` with different defaults for plain text vs HTML output.
3. Factory functions `makeTextRenderer` and `makeHtmlRenderer` that create pre-configured renderers.
4. Individual render functions for each parsed content type (e.g., `renderCashu`, `renderLink`, `renderProfile`, etc.).
5. A type-switching function `renderOne` that dispatches to the appropriate render function based on the parsed content type.
6. Helper functions `renderMany` and `render` that handle arrays of parsed content.
7. Top-level convenience functions `renderAsText` and `renderAsHtml` that create the appropriate renderer and process the content.

The implementation uses sanitization for URLs and handles various Nostr-specific encodings (neventEncode, nprofileEncode, naddrEncode) for entity links.

=========================
type: dir
workspace: packages/content
path: packages/content/src/
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/src/
summary: This directory provides a comprehensive toolkit for parsing and rendering Nostr content. It exports functionality to parse text containing various entities (links, events, profiles, emojis, code blocks, payment formats) into structured data, and then render that parsed content as either plain text or HTML. The main exports include the `parse` function for content parsing, type guards like `isLink` and `isEvent`, rendering functions `renderAsText` and `renderAsHtml`, and utilities like `truncate` for content length management. This module serves as a foundation for applications that need to process and display Nostr-related content with rich formatting support.

=========================
type: dir
workspace: packages/content
path: packages/content/
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/content/
summary: This directory contains a Nostr content parsing and rendering toolkit. It provides functionality to parse text with various entities (links, events, profiles, emojis, code blocks, payment formats) and render the parsed content as plain text or HTML. Key exports include the `parse` function, type guards like `isLink` and `isEvent`, rendering functions `renderAsText` and `renderAsHtml`, and utilities like `truncate` for content length management. The package is structured with source code in the src directory and corresponding tests in the __tests__ directory, making it a complete solution for applications needing to process and display Nostr-related content with rich formatting.

=========================
type: file
workspace: packages/editor
file: packages/editor/package.json
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/editor/package.json
include: always
{
  "name": "@welshman/editor",
  "version": "0.4.6",
  "author": "hodlbod",
  "license": "MIT",
  "description": "A batteries-included nostr editor.",
  "publishConfig": {
    "access": "public"
  },
  "type": "module",
  "exports": {
    ".": {
      "import": "./dist/editor/src/index.js",
      "types": "./dist/editor/src/index.d.ts"
    },
    "./index.css": "src/index.css"
  },
  "files": [
    "dist",
    "src/index.css"
  ],
  "scripts": {
    "build": "pnpm run clean && pnpm run compile --force",
    "clean": "rimraf ./dist",
    "compile": "tsc -b tsconfig.build.json",
    "prepublishOnly": "pnpm run build"
  },
  "dependencies": {
    "@tiptap/core": "^2.11.5",
    "@tiptap/extension-code": "^2.11.5",
    "@tiptap/extension-code-block": "^2.11.5",
    "@tiptap/extension-document": "^2.11.5",
    "@tiptap/extension-dropcursor": "^2.11.5",
    "@tiptap/extension-gapcursor": "^2.11.5",
    "@tiptap/extension-hard-break": "^2.11.5",
    "@tiptap/extension-history": "^2.11.5",
    "@tiptap/extension-paragraph": "^2.11.5",
    "@tiptap/extension-placeholder": "^2.11.5",
    "@tiptap/extension-text": "^2.11.5",
    "@tiptap/pm": "^2.11.5",
    "@tiptap/suggestion": "^2.11.5",
    "@welshman/lib": "workspace:*",
    "@welshman/util": "workspace:*",
    "nostr-editor": "^1.0.0",
    "nostr-tools": "^2.14.2",
    "tippy.js": "^6.3.7"
  },
  "devDependencies": {
    "rimraf": "~6.0.0",
    "typescript": "~5.8.0"
  }
}


=========================
type: file
workspace: packages/editor
file: packages/editor/tsconfig.json
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/editor/tsconfig.json
include: always
{
  "extends": "../../tsconfig.json"
}


=========================
workspace: packages/editor
file: packages/editor/src/nodeviews/MentionNodeView.ts
lines: 3:18
id: 6eec0919407e1651460ac323c93d165b9ac698812dfb9c3228a5873e4dda3486
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/editor/src/nodeviews/MentionNodeView.ts#L3

declaration:
MentionNodeView = ({node}: NodeViewProps) => {
  const dom = document.createElement("span")

  dom.classList.add("tiptap-object")
  dom.textContent = `@${node.attrs.bech32.slice(0, 16)}...`

  return {
    dom,
    selectNode() {
      dom.classList.add("tiptap-active")
    },
    deselectNode() {
      dom.classList.remove("tiptap-active")
    },
  }
}

summary:
A function that creates a custom node view for mentions in a Tiptap editor. It takes a NodeViewProps object containing a node and returns a DOM element with selection handlers. The function displays a shortened version of the mention's bech32 address prefixed with '@'.

details:
Implementation details:
1. Creates a span element to represent the mention in the editor
2. Adds the 'tiptap-object' CSS class to style the mention
3. Sets the text content to '@' followed by a truncated version of the node's bech32 attribute (first 16 characters followed by '...')
4. Returns an object with:
   - dom: the created span element
   - selectNode: a method that adds 'tiptap-active' class when the node is selected
   - deselectNode: a method that removes 'tiptap-active' class when the node is deselected

import/access examples:
import { MentionNodeView } from '@welshman/editor';
import { MentionNodeView } from '@welshman/editor/nodeviews';
import { MentionNodeView } from '@welshman/editor/nodeviews/MentionNodeView';


=========================
workspace: packages/editor
file: packages/editor/src/nodeviews/Bolt11NodeView.ts
lines: 3:18
id: 4dc167a1f889fc21d0e2376b0e995d50bd7dc2fd386b9b2f9415e71a7f5ca8f4
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/editor/src/nodeviews/Bolt11NodeView.ts#L3

declaration:
Bolt11NodeView = ({node}: NodeViewProps) => {
  const dom = document.createElement("span")

  dom.classList.add("tiptap-object")
  dom.innerText = `${node.attrs.lnbc.slice(0, 16)}...`

  return {
    dom,
    selectNode() {
      dom.classList.add("tiptap-active")
    },
    deselectNode() {
      dom.classList.remove("tiptap-active")
    },
  }
}

summary:
A node view function for rendering BOLT11 Lightning Network invoice strings in a TipTap editor. It creates a span element displaying a truncated version of the invoice string (first 16 characters followed by '...'). The node view also handles selection states by adding/removing a 'tiptap-active' class when the node is selected or deselected.

details:
Implementation details:
1. Creates a DOM span element to represent the BOLT11 invoice in the editor
2. Adds a 'tiptap-object' CSS class to the span for styling
3. Sets the element's text content to a truncated version of the invoice string from node.attrs.lnbc
4. Returns an object with:
   - dom: the created span element
   - selectNode: function that adds 'tiptap-active' class when node is selected
   - deselectNode: function that removes 'tiptap-active' class when node is deselected

import/access examples:
import { Bolt11NodeView } from '@welshman/editor';
import { Bolt11NodeView } from '@welshman/editor/nodeviews';
import { Bolt11NodeView } from '@welshman/editor/nodeviews/Bolt11NodeView';


=========================
workspace: packages/editor
file: packages/editor/src/nodeviews/EventNodeView.ts
lines: 4:19
id: d911efc952e85d36c9140da1d5218e2f24168dbf8da2166dde6784c4a7e074af
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/editor/src/nodeviews/EventNodeView.ts#L4

declaration:
EventNodeView = ({node}: NodeViewProps) => {
  const dom = document.createElement("span")

  dom.classList.add("tiptap-object")
  dom.innerText = `${fromNostrURI(node.attrs.bech32).slice(0, 16)}...`

  return {
    dom,
    selectNode() {
      dom.classList.add("tiptap-active")
    },
    deselectNode() {
      dom.classList.remove("tiptap-active")
    },
  }
}

summary:
A node view function for rendering Nostr event references in a TipTap editor. It takes a NodeViewProps object containing a node with a bech32 attribute, creates a span element displaying a truncated version of the Nostr URI, and returns an object with the DOM element and methods to handle selection state.

details:
Implementation creates a span element with 'tiptap-object' class and sets its text content to a truncated version of the Nostr URI (first 16 characters followed by '...'). The returned object includes:
1. The DOM element
2. A selectNode method that adds 'tiptap-active' class when the node is selected
3. A deselectNode method that removes 'tiptap-active' class when the node is deselected

The implementation uses fromNostrURI utility from @welshman/util to process the bech32 string from node attributes.

import/access examples:
import { EventNodeView } from '@welshman/editor';
import { EventNodeView } from '@welshman/editor/nodeviews';
import { EventNodeView } from '@welshman/editor/nodeviews/EventNodeView';


=========================
workspace: packages/editor
file: packages/editor/src/nodeviews/MediaNodeView.ts
lines: 3:31
id: e479524eb285b821a10bf9b0bd93bca5ef392053f12864e7ca09c3fe124d0459
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/editor/src/nodeviews/MediaNodeView.ts#L3

declaration:
MediaNodeView = ({node}: NodeViewProps) => {
  const dom = document.createElement("span")

  const syncUploading = (node: NodeViewProps["node"]) => {
    if (node.attrs.uploading) {
      dom.classList.add("tiptap-uploading")
    } else {
      dom.classList.remove("tiptap-uploading")
    }
  }

  dom.classList.add("tiptap-object")
  dom.innerText = node.attrs.file?.name || node.attrs.src

  syncUploading(node)

  return {
    dom,
    update(node: NodeViewProps["node"]) {
      syncUploading(node)
    },
    selectNode() {
      dom.classList.add("tiptap-active")
    },
    deselectNode() {
      dom.classList.remove("tiptap-active")
    },
  }
}

summary:
A function that creates a node view for media elements in a TipTap editor. It takes a NodeViewProps object with a node property and returns a node view object with DOM representation and methods to handle updates and selection states. The node view displays the file name or source URL and visually indicates uploading and selection states through CSS classes.

details:
Implementation creates a span element as the DOM representation with the following features:
1. Adds 'tiptap-object' class to all media elements
2. Sets the inner text to either the file name or source URL from node attributes
3. Defines an internal syncUploading helper function to toggle the 'tiptap-uploading' class based on the node's uploading state
4. Returns an object with:
   - dom: the created span element
   - update(): method to sync the uploading state when node changes
   - selectNode(): adds 'tiptap-active' class when selected
   - deselectNode(): removes 'tiptap-active' class when deselected

import/access examples:
import { MediaNodeView } from '@welshman/editor';
import { MediaNodeView } from '@welshman/editor/nodeviews';
import { MediaNodeView } from '@welshman/editor/nodeviews/MediaNodeView';


=========================
workspace: packages/editor
file: packages/editor/src/extensions/BreakOrSubmit.ts
lines: 3:9
id: 4aacca1aa430b8ccaff16548c89237cca3b7be0c01eb1c85ca83eb24b97e0c52
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/editor/src/extensions/BreakOrSubmit.ts#L3

declaration:
export interface BreakOrSubmitOptions extends HardBreakOptions {
  /** Handler for when enter is pressed. */
  submit: () => void

  /** Whether to call `submit` on unmodified Enter */
  aggressive?: boolean
}

summary:
The `BreakOrSubmitOptions` interface extends `HardBreakOptions` from the TipTap editor's hard-break extension. It defines configuration options for the BreakOrSubmit extension, which handles Enter key behavior. It includes a required `submit` function that will be called when Enter is pressed with modifiers, and an optional `aggressive` boolean flag that determines whether unmodified Enter should trigger submission.

details:
This interface is part of a custom TipTap extension that modifies the behavior of the Enter key. It extends the base HardBreakOptions interface and adds two properties:

1. `submit`: A required callback function that will be executed when the user presses Enter with modifiers or unmodified Enter in aggressive mode
2. `aggressive`: An optional boolean flag that, when true, causes unmodified Enter to trigger the submit function rather than the default editor behavior

import/access examples:
import type { BreakOrSubmitOptions } from '@welshman/editor';
import type { BreakOrSubmitOptions } from '@welshman/editor/extensions';
import type { BreakOrSubmitOptions } from '@welshman/editor/extensions/BreakOrSubmit';


=========================
workspace: packages/editor
file: packages/editor/src/extensions/BreakOrSubmit.ts
lines: 11:31
id: a5d8e0467b0fe21db39e00bcdf6a9d3ffe10409ebae09dceaa4f3e480945fac3
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/editor/src/extensions/BreakOrSubmit.ts#L11

declaration:
BreakOrSubmit = HardBreak.extend<BreakOrSubmitOptions>({
  addKeyboardShortcuts() {
    return {
      "Shift-Enter": () => this.editor.commands.setHardBreak(),
      "Mod-Enter": () => {
        this.options.submit()

        return true
      },
      Enter: () => {
        if (this.options.aggressive) {
          this.options.submit()

          return true
        }

        return false
      },
    }
  },
})

summary:
BreakOrSubmit is a TipTap extension that extends the HardBreak extension to provide additional keyboard shortcuts for handling Enter key presses. It allows for submitting content with Mod+Enter, inserting hard breaks with Shift+Enter, and optionally submitting on unmodified Enter key press when the 'aggressive' option is enabled. The extension requires a 'submit' callback function to be provided in its options.

details:
The implementation extends TipTap's HardBreak extension by overriding the addKeyboardShortcuts method to provide custom behavior for three key combinations:

1. Shift+Enter: Inserts a hard break (line break) using the editor's setHardBreak command
2. Mod+Enter (Ctrl/Cmd+Enter): Calls the user-provided submit function and returns true to indicate the event was handled
3. Enter (unmodified): Conditionally calls the submit function if the aggressive option is true, otherwise returns false to allow default behavior

The extension uses the options.submit callback that must be provided when initializing the extension. The aggressive flag determines whether plain Enter should trigger submission or follow default editor behavior.

related: HardBreak

import/access examples:
import { BreakOrSubmit } from '@welshman/editor';
import { BreakOrSubmit } from '@welshman/editor/extensions';
import { BreakOrSubmit } from '@welshman/editor/extensions/BreakOrSubmit';


=========================
workspace: packages/editor
file: packages/editor/src/extensions/CodeInline.ts
lines: 4:4
id: 139eb8433f9251f2bb290ba4cf1ada5fbb4f85a8b0fbf25c4d630ae2f932e721
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/editor/src/extensions/CodeInline.ts#L4

declaration:
inputRegex = /(^|\s)(`(?!\s+`)((?:[^`]+))`(?!\s+`))$/

summary:
A regular expression pattern that matches inline code syntax in text. It identifies text surrounded by backticks (`) that isn't preceded or followed by spaces and backticks together. The pattern captures the entire match, any leading whitespace, and the content inside the backticks.

details:
This regular expression is designed to match inline code formatting for input rules in a text editor. It has three capturing groups:
1. First group captures either the start of a line or whitespace
2. Second group captures the entire code block including backticks
3. Third group captures just the content inside the backticks

The pattern includes negative lookaheads (`(?!\s+`)`) to ensure proper formatting by preventing matches where backticks are followed by spaces and more backticks. The $ at the end ensures it only matches at the end of the input, making it suitable for use with input rules that trigger as users type.

=========================
workspace: packages/editor
file: packages/editor/src/extensions/CodeInline.ts
lines: 6:6
id: 43b896a8aaff978ee0e8a76f7c88fd37e7bc7e52c4ec3545574f55c63c7906f6
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/editor/src/extensions/CodeInline.ts#L6

declaration:
pasteRegex = /(^|\s)(`(?!\s+`)((?:[^`]+))`(?!\s+`))/g

summary:
A regular expression constant used to match inline code patterns during paste operations. It identifies text surrounded by backticks (`code`) that isn't part of a code block (not preceded or followed by spaces and backticks). The pattern includes capturing groups for the leading whitespace, the entire code segment, and the code content itself. The global flag 'g' ensures all matches in the pasted text are found.

details:
This regular expression is designed to work with the PasteRule in the CodeInline extension. It has several components:
1. `(^|\s)` - Matches either the start of a line or a whitespace character
2. `(`(?!\s+`)((?:[^`]+))`(?!\s+`))` - The main pattern that matches:
   - A backtick that isn't followed by spaces and another backtick
   - Any content that doesn't include backticks
   - A closing backtick that isn't preceded by spaces and a backtick
3. The global flag `/g` ensures all matches are found in the text being processed.

This regex is later used in the addPasteRules method to convert matching text into proper code inline nodes.

=========================
workspace: packages/editor
file: packages/editor/src/extensions/CodeInline.ts
lines: 8:8
id: 5066fd550ea09ad26d6868785d74de2462a6447355bd9522d2d4212d28559121
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/editor/src/extensions/CodeInline.ts#L8

declaration:
export type CodeInlineOptions = object

summary:
A TypeScript type alias that defines the options for the CodeInline extension. It's an empty object type, indicating that the CodeInline extension doesn't accept any custom options beyond what might be inherited from its parent types.

import/access examples:
import type { CodeInlineOptions } from '@welshman/editor';
import type { CodeInlineOptions } from '@welshman/editor/extensions';
import type { CodeInlineOptions } from '@welshman/editor/extensions/CodeInline';


=========================
workspace: packages/editor
file: packages/editor/src/extensions/CodeInline.ts
lines: 10:79
id: 30ad6de4bb0d53f6af53bd8d735e85f087bab0be489205182a103f4efff869c0
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/editor/src/extensions/CodeInline.ts#L10

declaration:
CodeInline = Node.create<CodeOptions>({
  name: "codeInline",
  content: "text*",
  marks: "",
  group: "inline",
  inline: true,
  code: true,
  defining: true,
  addOptions() {
    return {
      HTMLAttributes: {},
    }
  },
  parseHTML() {
    return [{tag: "code"}]
  },
  renderHTML({HTMLAttributes}) {
    return ["code", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]
  },
  addKeyboardShortcuts() {
    return {
      // remove code block when at start of document or code block is empty
      Backspace: () => {
        const {empty, $anchor, $from} = this.editor.state.selection

        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2

        if (!empty || $anchor.parent.type.name !== this.name) {
          return false
        }

        if (isAtEnd) {
          const {tr} = this.editor.state
          tr.delete($from.start(), $from.end() + 1)
          this.editor.view.dispatch(tr)
        }

        return false
      },
    }
  },
  addInputRules() {
    return [
      new InputRule({
        find: inputRegex,
        handler: ({state, range, match}) => {
          const textNode = state.schema.text(match[3])
          const codeNode = this.type.create(null, textNode)
          // Preserve any leading space by adjusting the range start
          const spaceAdjustment = match[1] === " " ? 1 : 0
          state.tr.replaceWith(range.from + spaceAdjustment, range.to, codeNode).insertText(" ")
        },
      }),
    ]
  },
  addPasteRules() {
    return [
      new PasteRule({
        find: pasteRegex,
        handler: ({state, range, match}) => {
          const textNode = state.schema.text(match[3])
          const codeNode = this.type.create(null, textNode)
          // Preserve any leading space by adjusting the range start
          const spaceAdjustment = match[1] === " " ? 1 : 0
          state.tr.replaceWith(range.from + spaceAdjustment, range.to, codeNode).insertText(" ")
        },
      }),
    ]
  },
})

summary:
CodeInline is a Tiptap extension that creates an inline code node for displaying code snippets within text. It renders as an HTML <code> element and supports creation via backtick syntax (`code`). The extension handles keyboard shortcuts for removing code blocks and provides input/paste rules for automatically converting backtick-wrapped text into code nodes.

details:
Implementation details:

1. Extends Tiptap's Node class with CodeOptions configuration.
2. Defines two regex patterns:
   - inputRegex: For detecting backtick-wrapped text during typing
   - pasteRegex: For detecting backtick-wrapped text during pasting

3. Core functionality includes:
   - HTML parsing/rendering for <code> tags
   - Backspace handler to remove code blocks when at the end of the node
   - Input rules that convert text wrapped in backticks to code nodes
   - Paste rules that handle similar conversion for pasted content

4. Both input and paste handlers preserve leading spaces and add a trailing space after insertion for better editing experience.

related: Node

import/access examples:
import { CodeInline } from '@welshman/editor';
import { CodeInline } from '@welshman/editor/extensions';
import { CodeInline } from '@welshman/editor/extensions/CodeInline';


=========================
workspace: packages/editor
file: packages/editor/src/extensions/WordCount.ts
lines: 3:19
id: 72dd667eb8dbd88a49caf10ca617efdafe451d752c418a5064f4a4c7be162c2c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/editor/src/extensions/WordCount.ts#L3

declaration:
WordCount = Extension.create({
  name: "wordCount",

  addStorage() {
    return {
      words: 0,
      chars: 0,
    }
  },

  onUpdate() {
    const text = this.editor.state.doc.textContent

    this.storage.words = text.split(/\s+/).filter(word => word.length > 0).length
    this.storage.chars = text.length
  },
})

summary:
WordCount is a Tiptap extension that tracks the number of words and characters in the editor content. It provides this information through its storage, which can be accessed via the editor instance. The extension automatically updates these counts whenever the editor content changes.

details:
The implementation:
1. Creates a Tiptap extension named "wordCount"
2. Initializes storage with two properties: words and chars, both set to 0
3. Implements an onUpdate hook that runs whenever the editor content changes
4. In the onUpdate hook:
   - Retrieves the text content from the editor's document
   - Counts words by splitting the text on whitespace and filtering out empty strings
   - Counts characters by measuring the text length
   - Stores both counts in the extension's storage for later access

related: Extension

import/access examples:
import { WordCount } from '@welshman/editor';
import { WordCount } from '@welshman/editor/extensions';
import { WordCount } from '@welshman/editor/extensions/WordCount';


=========================
workspace: packages/editor
file: packages/editor/src/extensions/Welshman.ts
lines: 41:46
id: f1bb1585863ebbc26d39e0b3d7c13d0989a3589b083e9b6c8c047ec4beff6a70
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/editor/src/extensions/Welshman.ts#L41

declaration:
export type ChildExtensionOptions<C = any, E = any> =
  | false
  | {
      extend?: Partial<E>
      config?: Partial<C>
    }

summary:
A generic type alias that defines the structure for configuring child extensions in the Welshman editor. It can either be `false` to disable the extension, or an object with optional `extend` and `config` properties to customize the extension's behavior. The type parameters `C` and `E` represent the configuration options and extension type respectively, both defaulting to `any`.

details:
This type alias serves as a flexible configuration pattern for the Welshman editor extensions. It allows:

1. Completely disabling an extension by setting it to `false`
2. Customizing an extension through two mechanisms:
   - `extend`: For modifying the extension's core behavior or overriding methods
   - `config`: For configuring the extension's options

The generic parameters make this type reusable across different extension types:
- `C` represents the configuration options specific to each extension
- `E` represents the extension type itself

This pattern is used throughout the WelshmanExtensionOptions type to provide a consistent configuration interface for all supported extensions.

import/access examples:
import type { ChildExtensionOptions } from '@welshman/editor';
import type { ChildExtensionOptions } from '@welshman/editor/extensions';
import type { ChildExtensionOptions } from '@welshman/editor/extensions/Welshman';


=========================
workspace: packages/editor
file: packages/editor/src/extensions/Welshman.ts
lines: 48:48
id: daea992ba4952d9937d4a9a07ba21bf4df93772f26c2363894f1e1e119816c9e
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/editor/src/extensions/Welshman.ts#L48

declaration:
export type EmptyOptions = object

summary:
EmptyOptions is a type alias that represents an empty object. It's used as a generic placeholder for extension configurations that don't require any specific options.

details:
This is a simple type alias that defines an empty object type. It's used throughout the Welshman extension system as a placeholder for extensions that don't need configuration options but still need to conform to the extension options pattern. The implementation is trivial - it's just defined as `object` which represents any non-null object with no specific properties.

import/access examples:
import type { EmptyOptions } from '@welshman/editor';
import type { EmptyOptions } from '@welshman/editor/extensions';
import type { EmptyOptions } from '@welshman/editor/extensions/Welshman';


=========================
workspace: packages/editor
file: packages/editor/src/extensions/Welshman.ts
lines: 50:75
id: b9584b62b42c0398d93bc96aaf4be5a86883a28f2f05e0f8183ba9bfc1bd175b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/editor/src/extensions/Welshman.ts#L50

declaration:
export type WelshmanExtensionOptions = {
  bolt11?: false
  breakOrSubmit?: ChildExtensionOptions<BreakOrSubmitOptions>
  codeInline?: ChildExtensionOptions<CodeInlineOptions>
  codeBlock?: ChildExtensionOptions<CodeBlockOptions>
  document?: false
  dropcursor?: ChildExtensionOptions<DropcursorOptions>
  fileUpload?: {
    extend?: Partial<any>
    config?: Partial<FileUploadOptions> & Pick<FileUploadOptions, "upload">
  }
  gapcursor?: false
  history?: ChildExtensionOptions<HistoryOptions>
  image?: ChildExtensionOptions<ImageOptions>
  link?: ChildExtensionOptions<LinkOptions>
  naddr?: ChildExtensionOptions<EmptyOptions>
  nevent?: ChildExtensionOptions<EmptyOptions>
  nprofile?: ChildExtensionOptions<EmptyOptions>
  nsecReject?: ChildExtensionOptions<NSecRejectOptions>
  paragraph?: ChildExtensionOptions<ParagraphOptions>
  placeholder?: ChildExtensionOptions<PlaceholderOptions>
  tag?: false
  text?: false
  video?: false
  wordCount?: false
}

summary:
WelshmanExtensionOptions is a TypeScript type that defines configuration options for the Welshman editor extension. It allows customization of various child extensions like code blocks, document handling, cursor behavior, file uploads, and more. Each property can be set to false to disable the extension or configured with extend/config options to customize its behavior.

details:
This type definition serves as a configuration interface for the Welshman editor, which appears to be built on top of TipTap and includes Nostr-specific functionality. The structure follows a pattern where each extension can be:

1. Disabled by setting it to `false`
2. Configured using a `ChildExtensionOptions` object that contains:
   - `extend`: For extending the extension's functionality
   - `config`: For configuring the extension's options

Some extensions have special configuration requirements, like `fileUpload` which requires an `upload` property. The type leverages TypeScript's utility types and generics to ensure type safety when configuring each extension. It's designed to be used with the `WelshmanExtension` class that processes these options to build the final editor configuration.

related: ChildExtensionOptions,BreakOrSubmitOptions,CodeInlineOptions,EmptyOptions

import/access examples:
import type { WelshmanExtensionOptions } from '@welshman/editor';
import type { WelshmanExtensionOptions } from '@welshman/editor/extensions';
import type { WelshmanExtensionOptions } from '@welshman/editor/extensions/Welshman';


=========================
workspace: packages/editor
file: packages/editor/src/extensions/Welshman.ts
lines: 77:80
id: 903d3dbbe217d12ecd30e62527c14385d02ba801e9b153449781a4b62ad5236a
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/editor/src/extensions/Welshman.ts#L77

declaration:
export interface WelshmanOptions extends NostrOptions {
  submit?: () => void
  extensions?: WelshmanExtensionOptions
}

summary:
The `WelshmanOptions` interface extends `NostrOptions` and defines the configuration options for the Welshman editor. It includes two optional properties: `submit`, a callback function that is called when content is submitted, and `extensions`, which allows customization of various editor extensions through the `WelshmanExtensionOptions` type.

details:
This interface is a key part of the Welshman editor configuration system. It extends the base `NostrOptions` from the nostr-editor package, adding Welshman-specific configuration options. The `submit` property is particularly important as it's required by the `WelshmanExtension` (as seen in the implementation where an error is thrown if it's not provided). The `extensions` property allows for granular control over all the editor's extensions, enabling users to customize or disable specific features like code blocks, images, links, and various Nostr-specific extensions. The interface is exported and available through the module's public API.

related: WelshmanExtensionOptions

import/access examples:
import type { WelshmanOptions } from '@welshman/editor';
import type { WelshmanOptions } from '@welshman/editor/extensions';
import type { WelshmanOptions } from '@welshman/editor/extensions/Welshman';


=========================
workspace: packages/editor
file: packages/editor/src/extensions/Welshman.ts
lines: 82:215
id: bed386da0cb60704cc17f93a8383e8e0b161a39795da5ee37b56badc2f16beac
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/editor/src/extensions/Welshman.ts#L82

declaration:
WelshmanExtension = NostrExtension.extend<WelshmanOptions>({
  // Return an empty object or else options can't be passed
  addOptions() {
    return {}
  },

  addExtensions() {
    const {submit} = this.options

    if (!submit) throw new Error("submit is a required argument to WelshmanExtension")

    const extensionOptions = deepMergeLeft(this.options.extensions || {}, {
      codeInline: {
        extend: {
          renderText: (props: any) => "`" + props.node.textContent + "`",
        },
      },
      codeBlock: {
        extend: {
          renderText: (props: any) => "```" + props.node.textContent + "```",
        },
      },
      bolt11: {
        config: {
          inline: true,
          group: "inline",
        },
        extend: {
          addNodeView: () => Bolt11NodeView,
        },
      },
      image: {
        config: {
          inline: true,
          group: "inline",
        },
        extend: {
          addNodeView: () => MediaNodeView,
        },
      },
      video: {
        config: {
          inline: true,
          group: "inline",
        },
        extend: {
          addNodeView: () => MediaNodeView,
        },
      },
      nevent: {
        config: {
          inline: true,
          group: "inline",
        },
        extend: {
          addNodeView: () => EventNodeView,
        },
      },
      naddr: {
        config: {
          inline: true,
          group: "inline",
        },
        extend: {
          addNodeView: () => EventNodeView,
        },
      },
      nprofile: {
        extend: {
          addNodeView: () => MentionNodeView,
        },
      },
      breakOrSubmit: {
        config: {
          submit,
        },
      },
      fileUpload: {
        config: {
          immediateUpload: true,
          allowedMimeTypes: [
            "image/jpeg",
            "image/png",
            "image/gif",
            "image/webp",
            "video/mp4",
            "video/mpeg",
            "video/webm",
          ],
        },
      },
    }) as WelshmanExtensionOptions

    const extensions: Extensions = []

    const addExtension = (extension: AnyExtension, options?: any) => {
      if (options === false) return

      if (options?.extend) {
        extension = extension.extend(options.extend)
      }

      if (options?.config) {
        extension = extension.configure(options.config)
      }

      extensions.push(extension)
    }

    addExtension(Document, extensionOptions.document)
    addExtension(Text, extensionOptions.text)
    addExtension(Paragraph, extensionOptions.paragraph)
    addExtension(History, extensionOptions.history)
    addExtension(CodeBlock, extensionOptions.codeBlock)
    addExtension(CodeInline, extensionOptions.codeInline)
    addExtension(Dropcursor, extensionOptions.dropcursor)
    addExtension(FileUploadExtension, extensionOptions.fileUpload)
    addExtension(Gapcursor, extensionOptions.gapcursor)
    addExtension(BreakOrSubmit, extensionOptions.breakOrSubmit)
    addExtension(ImageExtension, extensionOptions.image)
    addExtension(LinkExtension, extensionOptions.link)
    addExtension(NAddrExtension, extensionOptions.naddr)
    addExtension(NEventExtension, extensionOptions.nevent)
    addExtension(NProfileExtension, extensionOptions.nprofile)
    addExtension(NSecRejectExtension, extensionOptions.nsecReject)
    addExtension(Placeholder, extensionOptions.placeholder)
    addExtension(TagExtension, extensionOptions.tag)
    addExtension(VideoExtension, extensionOptions.video)
    addExtension(Bolt11Extension, extensionOptions.bolt11)
    addExtension(WordCount, extensionOptions.wordCount)

    return extensions
  },
})

summary:
WelshmanExtension is a customized extension for the TipTap editor that extends NostrExtension. It provides a comprehensive set of editor features specifically tailored for Nostr-related content. The extension requires a submit callback function and accepts optional configuration for various child extensions. It combines standard editor functionality (text, paragraphs, code blocks) with Nostr-specific features like handling Bolt11 invoices, NAddr, NEvent, and NProfile references.

details:
The implementation works by:

1. Extending the NostrExtension with WelshmanOptions interface that includes a submit callback and extensions configuration.

2. In addExtensions(), it first validates that the required submit callback is provided.

3. It then merges user-provided extension options with default configurations using deepMergeLeft, setting up defaults for:
   - Code rendering (inline and block)
   - Node views for various content types (Bolt11, media, events, profiles)
   - File upload settings with allowed MIME types
   - Inline configuration for various node types

4. It defines a helper function addExtension() that handles the conditional extension loading based on configuration:
   - Skips extensions marked as false
   - Applies extension modifications via extend() if provided
   - Applies configuration via configure() if provided
   - Adds the resulting extension to the extensions array

5. Finally, it systematically adds all supported extensions (over 20 different extensions) using the helper function, passing the appropriate configuration for each.

The extension serves as a comprehensive bundle of editor functionality with sensible defaults that can be selectively enabled, disabled, or configured.

related: NostrExtension

import/access examples:
import { WelshmanExtension } from '@welshman/editor';
import { WelshmanExtension } from '@welshman/editor/extensions';
import { WelshmanExtension } from '@welshman/editor/extensions/Welshman';


=========================
workspace: packages/editor
file: packages/editor/src/plugins/TippySuggestion.ts
lines: 10:10
id: 9db5b389a3a2f34dca6907b45ed17a01dcfe893b2845bb0aa39d2531c7e1bfb2
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/editor/src/plugins/TippySuggestion.ts#L10

declaration:
export type CreateSuggestion = (item: string) => HTMLElement

summary:
A type definition that represents a function which creates an HTML element from a string item. This type is used for customizing the appearance of suggestion items in dropdown menus, particularly in the TippySuggestion plugin. The function takes a string parameter and returns an HTMLElement that will be displayed in the suggestion UI.

details:
This is a simple type alias that defines a function signature. It doesn't have complex implementation details as it's just a type definition that other components use to create customizable suggestion items. The actual implementation of this function type would be provided by consumers of the API, with `defaultCreateSuggestion` being the default implementation that simply creates a span element with the item text.

import/access examples:
import type { CreateSuggestion } from '@welshman/editor';
import type { CreateSuggestion } from '@welshman/editor/plugins';
import type { CreateSuggestion } from '@welshman/editor/plugins/TippySuggestion';


=========================
workspace: packages/editor
file: packages/editor/src/plugins/TippySuggestion.ts
lines: 12:18
id: 53874e8dcfb4e34803af6f420996702a7abf1f381330d9e0e3765e6c34aaea97
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/editor/src/plugins/TippySuggestion.ts#L12

declaration:
defaultCreateSuggestion = (item: string) => {
  const span = document.createElement("span")

  span.textContent = item

  return span
}

summary:
A default function for creating suggestion elements in a dropdown menu. It takes a string item and returns an HTML span element with the item as its text content. This function is used as the default implementation for rendering suggestions in the TippySuggestion component.

details:
The implementation is straightforward:
1. Creates a new HTML span element using document.createElement("span")
2. Sets the textContent property of the span to the provided item string
3. Returns the span element

This provides a simple text-only representation of suggestions when no custom renderer is provided.

import/access examples:
import { defaultCreateSuggestion } from '@welshman/editor';
import { defaultCreateSuggestion } from '@welshman/editor/plugins';
import { defaultCreateSuggestion } from '@welshman/editor/plugins/TippySuggestion';


=========================
workspace: packages/editor
file: packages/editor/src/plugins/TippySuggestion.ts
lines: 20:26
id: a79556d2c307d3f3c1ed4f6570038195510c1e6465379a6107492619b735da55
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/editor/src/plugins/TippySuggestion.ts#L20

declaration:
export type SuggestionsWrapperProps = {
  term: string
  allowCreate: boolean
  select: (value: string) => void
  search: (term: string) => string[]
  createSuggestion: CreateSuggestion
}

summary:
The `SuggestionsWrapperProps` type defines the properties required for a suggestions wrapper component in a TippySuggestion plugin. It includes properties for the current search term, whether creation of new items is allowed, a selection handler, a search function, and a function to create suggestion elements.

details:
This type alias defines the interface for the props object passed to suggestion wrapper components. It contains five properties:

1. `term`: A string representing the current search term
2. `allowCreate`: A boolean flag indicating whether users can create new items
3. `select`: A callback function that takes a string value and handles selection
4. `search`: A function that takes a search term and returns an array of matching strings
5. `createSuggestion`: A function that takes a string item and returns an HTMLElement to represent it visually

This type is used throughout the TippySuggestion plugin to ensure consistent prop handling between different suggestion wrapper implementations.

related: CreateSuggestion

import/access examples:
import type { SuggestionsWrapperProps } from '@welshman/editor';
import type { SuggestionsWrapperProps } from '@welshman/editor/plugins';
import type { SuggestionsWrapperProps } from '@welshman/editor/plugins/TippySuggestion';


=========================
workspace: packages/editor
file: packages/editor/src/plugins/TippySuggestion.ts
lines: 28:30
id: 123290c2aec7d5d0a97162ff8e88cb8ea2467f501f3a683113a4bcd632a60b6b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/editor/src/plugins/TippySuggestion.ts#L28

declaration:
export interface ISuggestionsWrapperConstructor {
  new (target: HTMLElement, props: SuggestionsWrapperProps): ISuggestionsWrapper
}

summary:
The `ISuggestionsWrapperConstructor` interface defines a constructor type for creating suggestion wrapper components. It specifies that implementing classes must have a constructor that accepts an HTML element target and a props object of type `SuggestionsWrapperProps`, and returns an instance of `ISuggestionsWrapper`. This interface is used for dependency injection in the TippySuggestion plugin, allowing custom suggestion UI implementations.

details:
This interface is part of the suggestion system architecture in the TippySuggestion plugin. It enables a factory pattern where different implementations of suggestion UI components can be provided. The interface is used in the `createSuggestionsWrapper` function (line 38-44) which instantiates suggestion wrapper components. The default implementation is `DefaultSuggestionsWrapper` (line 46), but the architecture allows for custom implementations to be injected through the `suggestionsWrapper` parameter in the `TippySuggestionOptions`.

related: SuggestionsWrapperProps,ISuggestionsWrapper

import/access examples:
import type { ISuggestionsWrapperConstructor } from '@welshman/editor';
import type { ISuggestionsWrapperConstructor } from '@welshman/editor/plugins';
import type { ISuggestionsWrapperConstructor } from '@welshman/editor/plugins/TippySuggestion';


=========================
workspace: packages/editor
file: packages/editor/src/plugins/TippySuggestion.ts
lines: 32:36
id: 95018aed5b1931254fd58102e37ec3bd83fdf04ad7e262b91dcbc2d14ab70cef
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/editor/src/plugins/TippySuggestion.ts#L32

declaration:
export interface ISuggestionsWrapper {
  setProps: (props: SuggestionsWrapperProps) => void
  onKeyDown: (event: Event) => boolean
  destroy: () => void
}

summary:
The `ISuggestionsWrapper` interface defines the contract for components that handle suggestion dropdowns in a text editor. It specifies three essential methods: `setProps` for updating the component's properties, `onKeyDown` for handling keyboard interactions (returning a boolean to indicate if the event was handled), and `destroy` for cleaning up resources when the component is no longer needed.

details:
This interface is part of a suggestion system likely used for mentions or other auto-complete features in a text editor. It works alongside the `TippySuggestion` plugin to create popup suggestion interfaces. The interface is minimal by design, focusing only on the essential methods needed for the suggestion component lifecycle:

1. Updating state via `setProps`
2. Handling keyboard navigation via `onKeyDown`
3. Proper cleanup via `destroy`

Implementations of this interface (like `DefaultSuggestionsWrapper`) would manage the DOM elements, event handling, and selection state for the suggestion dropdown.

related: SuggestionsWrapperProps

import/access examples:
import type { ISuggestionsWrapper } from '@welshman/editor';
import type { ISuggestionsWrapper } from '@welshman/editor/plugins';
import type { ISuggestionsWrapper } from '@welshman/editor/plugins/TippySuggestion';


=========================
workspace: packages/editor
file: packages/editor/src/plugins/TippySuggestion.ts
lines: 38:44
id: 3e2fdf595edaa1c56c387a777e95d42437d04b39393a2cd1426f9d5f5ab4aec6
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/editor/src/plugins/TippySuggestion.ts#L38

declaration:
function createSuggestionsWrapper(
  ctor: ISuggestionsWrapperConstructor,
  target: HTMLElement,
  props: SuggestionsWrapperProps,
): ISuggestionsWrapper

summary:
Creates and returns an instance of a suggestions wrapper component. This function takes a constructor class, a target HTML element, and props to initialize the wrapper. It's used to create UI components that display suggestions in a dropdown, typically for mentions or other interactive elements in a text editor.

details:
This is a simple factory function that instantiates a new suggestions wrapper using the provided constructor. It takes three parameters:
1. `ctor`: The constructor class that implements the ISuggestionsWrapperConstructor interface
2. `target`: The HTML element where the suggestions will be rendered
3. `props`: Configuration properties for the suggestions wrapper

The function simply calls the constructor with the target and props, and returns the resulting instance. This abstraction allows for different implementations of suggestion wrappers to be used interchangeably.

related: ISuggestionsWrapperConstructor,SuggestionsWrapperProps,ISuggestionsWrapper

code:
function createSuggestionsWrapper(
  ctor: ISuggestionsWrapperConstructor,
  target: HTMLElement,
  props: SuggestionsWrapperProps,
): ISuggestionsWrapper {
  return new ctor(target, props)
}

=========================
workspace: packages/editor
file: packages/editor/src/plugins/TippySuggestion.ts
lines: 46:177
id: c87d8275da1b862f7a422bb0b8c3a62fc3dfbd077776cb640c4333266a1d9e1f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/editor/src/plugins/TippySuggestion.ts#L46

declaration:
export class DefaultSuggestionsWrapper implements ISuggestionsWrapper{
  index: number;
  items: string[];
  target: HTMLElement;
  content: HTMLElement;
  props: SuggestionsWrapperProps;
  constructor(target: HTMLElement, props: SuggestionsWrapperProps);
  search: (() => void) | (() => void);
  render();
  setIndex(index: number);
  setProps(props: SuggestionsWrapperProps);
  onKeyDown(event: any);
  destroy();
}

summary:
DefaultSuggestionsWrapper is a class that implements the ISuggestionsWrapper interface, providing a default implementation for rendering and managing suggestion dropdowns in a text editor. It creates a UI component that displays a list of suggestions based on user input, allows navigation through the suggestions using keyboard arrows, and enables selection via mouse clicks or keyboard shortcuts. The class handles rendering, searching, and interaction with suggestion items.

details:
The implementation details include:

1. The class maintains state for the current selected index, available items, and DOM elements.
2. It uses throttling (via the throttle function) to limit how frequently search operations are performed (300ms delay).
3. The render method creates the suggestion UI by:
   - Clearing previous content
   - Optionally adding a "create" button if the term matches an existing item
   - Creating buttons for each suggestion item with appropriate event listeners
4. Keyboard navigation is implemented in onKeyDown to handle:
   - Selection via Enter/Tab/Space
   - Navigation via ArrowUp/ArrowDown
5. The class provides methods for updating the selected index, setting new props, and proper cleanup via destroy().
6. It uses DOM manipulation to create and manage the suggestion UI elements with appropriate CSS classes for styling.

related: ISuggestionsWrapper,SuggestionsWrapperProps

code:
export class DefaultSuggestionsWrapper implements ISuggestionsWrapper {
  index = 0
  items: string[] = []
  target: HTMLElement
  content: HTMLElement
  props: SuggestionsWrapperProps

  constructor(target: HTMLElement, props: SuggestionsWrapperProps) {
    this.target = target
    this.props = props
    this.content = document.createElement("div")
    this.content.classList.add("tiptap-suggestions__content")

    target.appendChild(this.content)
    target.classList.add("tiptap-suggestions")

    this.search()
    this.render()
  }

  search = throttle(300, () => {
    const {term, search} = this.props

    this.items = search(term).slice(0, 5)
    this.render()
  })

  render() {
    const {index} = this
    const {select, term, allowCreate, createSuggestion} = this.props

    this.content.innerHTML = ""

    if (term && allowCreate && this.items.includes(term)) {
      const button = document.createElement("button")

      button.classList.add("tiptap-suggestions__create")

      button.addEventListener("mousedown", (event: Event) => {
        event.preventDefault()
        event.stopPropagation()
      })

      button.addEventListener("click", (event: Event) => {
        event.preventDefault()
        event.stopPropagation()
        select(term)
      })

      this.content.appendChild(button)
    }

    for (const [i, item] of enumerate(this.items)) {
      const button = document.createElement("button")

      button.classList.add("tiptap-suggestions__item")

      if (i === index) {
        button.classList.add("tiptap-suggestions__selected")
      }

      button.addEventListener("mousedown", (event: Event) => {
        event.preventDefault()
        event.stopPropagation()
      })

      button.addEventListener("click", (event: Event) => {
        event.preventDefault()
        event.stopPropagation()
        select(item)
      })

      button.appendChild(createSuggestion(item))

      this.content.appendChild(button)
    }
  }

  setIndex(index: number) {
    this.index = clamp([0, this.items.length - 1], index)
    this.render()
  }

  setProps(props: SuggestionsWrapperProps) {
    this.props = props
    this.search()
    this.render()
  }

  onKeyDown(event: any) {
    const {index, items} = this
    const {term, select, allowCreate} = this.props

    if (["Enter", "Tab"].includes(event.code)) {
      const value = items[index]

      if (value) {
        select(value)

        return true
      } else if (term && allowCreate) {
        select(term)

        return true
      }
    }

    if (event.code === "Space" && term && allowCreate) {
      select(term)

      return true
    }

    if (event.code === "ArrowUp") {
      this.setIndex(index - 1)

      return true
    }

    if (event.code === "ArrowDown") {
      this.setIndex(index + 1)

      return true
    }

    return false
  }

  destroy() {
    this.target.remove()
  }
}

import/access examples:
import { DefaultSuggestionsWrapper } from '@welshman/editor';
import { DefaultSuggestionsWrapper } from '@welshman/editor/plugins';
import { DefaultSuggestionsWrapper } from '@welshman/editor/plugins/TippySuggestion';


=========================
workspace: packages/editor
file: packages/editor/src/plugins/TippySuggestion.ts
lines: 179:188
id: 7199f38b13fb3fff7f90c412a1652736525056abca2143c08b895e491a207676
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/editor/src/plugins/TippySuggestion.ts#L179

declaration:
export type TippySuggestionOptions = {
  char: string
  name: string
  editor: Editor
  search: (term: string) => string[]
  select: (value: string, props: any) => void
  allowCreate?: boolean
  createSuggestion?: CreateSuggestion
  suggestionsWrapper?: ISuggestionsWrapperConstructor
}

summary:
TippySuggestionOptions is a type definition that specifies the configuration options for creating a tippy.js-powered suggestion plugin for a TipTap editor. It includes properties for customizing the trigger character, name of the suggestion, editor instance, search functionality, selection handling, and optional settings for allowing custom entries, customizing suggestion rendering, and providing a custom suggestions wrapper component.

details:
This type defines the configuration interface for the TippySuggestion plugin with the following properties:

1. `char`: The character that triggers the suggestion popup (like '@' for mentions)
2. `name`: Identifier for the suggestion type
3. `editor`: Reference to the TipTap Editor instance
4. `search`: Function that takes a search term and returns matching string results
5. `select`: Callback function executed when a suggestion is selected
6. `allowCreate`: Optional boolean to allow creating custom entries
7. `createSuggestion`: Optional function to customize how suggestions are rendered in the dropdown
8. `suggestionsWrapper`: Optional constructor for a custom suggestions wrapper component

This type is used as the parameter type for the TippySuggestion function that creates a suggestion plugin using tippy.js for the popup interface.

related: CreateSuggestion,ISuggestionsWrapperConstructor

import/access examples:
import type { TippySuggestionOptions } from '@welshman/editor';
import type { TippySuggestionOptions } from '@welshman/editor/plugins';
import type { TippySuggestionOptions } from '@welshman/editor/plugins/TippySuggestion';


=========================
workspace: packages/editor
file: packages/editor/src/plugins/TippySuggestion.ts
lines: 190:292
id: 07994bb85d08eb2749096ab9e9e8d2ee3769a5c9184bee66d509a6ef05dcc2d2
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/editor/src/plugins/TippySuggestion.ts#L190

declaration:
TippySuggestion = ({
  char,
  name,
  editor,
  search,
  select,
  allowCreate = false,
  createSuggestion = defaultCreateSuggestion,
  suggestionsWrapper = DefaultSuggestionsWrapper,
}: TippySuggestionOptions) =>
  Suggestion({
    char,
    editor,
    pluginKey: new PluginKey(`suggest-${name}`),
    command: ({editor, range, props}) => {
      // increase range.to by one when the next node is of type "text"
      // and starts with a space character
      const nodeAfter = editor.view.state.selection.$to.nodeAfter
      const overrideSpace = nodeAfter?.text?.startsWith(" ")

      if (overrideSpace) {
        range.to += 1
      }

      editor
        .chain()
        .focus()
        .insertContentAt(range, [
          {type: name, attrs: props},
          {type: "text", text: " "},
        ])
        .run()

      window.getSelection()?.collapseToEnd()
    },
    allow: ({state, range}) => {
      const $from = state.doc.resolve(range.from)
      const type = state.schema.nodes[name]

      return !!$from.parent.type.contentMatch.matchType(type)
    },
    render: () => {
      let popover: Instance[]
      let wrapper: ISuggestionsWrapper

      const mapProps = (props: any) => ({
        term: props.query,
        search,
        allowCreate,
        createSuggestion,
        select: (value: string) => select(value, props),
      })

      return {
        onStart: props => {
          const target = document.createElement("div")

          // @ts-ignore
          popover = tippy("body", {
            getReferenceClientRect: props.clientRect as any,
            appendTo: document.querySelector("dialog[open]") || document.body,
            content: target,
            showOnCreate: true,
            interactive: true,
            trigger: "manual",
            placement: "bottom-start",
          })

          if (!props.query) popover[0].hide()

          wrapper = createSuggestionsWrapper(suggestionsWrapper, target, mapProps(props))
        },
        onUpdate: props => {
          if (props.query) {
            popover[0].show()
          } else {
            popover[0].hide()
          }

          wrapper.setProps(mapProps(props))

          if (props.clientRect) {
            popover[0].setProps({
              getReferenceClientRect: props.clientRect as any,
            })
          }
        },
        onKeyDown: props => {
          if (props.event.key === "Escape") {
            popover[0].hide()

            return true
          }

          return Boolean(wrapper.onKeyDown(props.event))
        },
        onExit: () => {
          popover[0].destroy()
          wrapper.destroy()
        },
      }
    },
  })

summary:
A function that creates a suggestion plugin for TipTap editor. It displays a popup with suggestions when a specific character is typed. The function accepts configuration options including the trigger character, node name, editor instance, search function, selection handler, and customization options for the suggestion UI. It returns a Suggestion plugin instance configured with the provided options.

details:
The implementation uses the Tippy.js library to create a popup tooltip that displays suggestions. The function works by:

1. Taking configuration options through the TippySuggestionOptions parameter
2. Returning a Suggestion plugin with the following key components:
   - A command handler that inserts content at the current position when a suggestion is selected
   - An allow function that checks if the suggestion is valid in the current context
   - A render function that manages the suggestion UI lifecycle with:
     - onStart: Creates the Tippy popup and suggestion wrapper
     - onUpdate: Shows/hides the popup and updates suggestions based on query
     - onKeyDown: Handles keyboard navigation (Escape key and delegation to wrapper)
     - onExit: Cleans up resources when suggestion UI is closed

The function handles special cases like automatically extending the selection range when a space follows the cursor and ensures proper focus management after insertion.

related: Suggestion,TippySuggestionOptions

import/access examples:
import { TippySuggestion } from '@welshman/editor';
import { TippySuggestion } from '@welshman/editor/plugins';
import { TippySuggestion } from '@welshman/editor/plugins/TippySuggestion';


=========================
workspace: packages/editor
file: packages/editor/src/plugins/TippySuggestion.ts
lines: 294:298
id: 20f5ba518df0a783b439e3309c1ff79515d0b0d7204d18a0599c39187a9a60e7
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/editor/src/plugins/TippySuggestion.ts#L294

declaration:
export type MentionSuggestionOptions = Partial<TippySuggestionOptions> & {
  editor: Editor
  search: (term: string) => string[]
  getRelays: (pubkey: string) => string[]
}

summary:
A TypeScript type alias that defines the configuration options for creating a mention suggestion feature in a text editor. It extends `Partial<TippySuggestionOptions>` and requires three specific properties: `editor` (the Editor instance), `search` (a function to search for mentions based on a term), and `getRelays` (a function that returns relay URLs for a given public key).

details:
This type alias combines optional TippySuggestion configuration with required mention-specific functionality. It's designed to work with the Nostr protocol, as evidenced by the `getRelays` function that returns relay URLs for a public key. The type is used by the `MentionSuggestion` function to create a specialized suggestion plugin for handling @mentions in a text editor with Nostr integration. The type ensures that implementations provide the necessary functions for searching mentions and retrieving relay information while making other TippySuggestion options optional.

related: TippySuggestionOptions

import/access examples:
import type { MentionSuggestionOptions } from '@welshman/editor';
import type { MentionSuggestionOptions } from '@welshman/editor/plugins';
import type { MentionSuggestionOptions } from '@welshman/editor/plugins/TippySuggestion';


=========================
workspace: packages/editor
file: packages/editor/src/plugins/TippySuggestion.ts
lines: 300:311
id: f0a9d7e59084ef4d2cffdc574b0223f1edaa1dd6b0040897e07b14f5c5381f2e
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/editor/src/plugins/TippySuggestion.ts#L300

declaration:
MentionSuggestion = (options: MentionSuggestionOptions) =>
  TippySuggestion({
    char: "@",
    name: "nprofile",
    select: (pubkey: string, props: any) => {
      const relays = options.getRelays(pubkey)
      const bech32 = nprofileEncode({pubkey, relays})

      return props.command(makeNProfileAttrs(bech32, {}))
    },
    ...options,
  })

summary:
A function that creates a mention suggestion plugin for a TipTap editor. It allows users to mention profiles using the '@' character. The function takes a `MentionSuggestionOptions` object that includes an editor instance, a search function to find profiles, and a function to get relays for a given pubkey. When a user selects a profile, it encodes the pubkey and relays into a bech32 nprofile format and inserts it into the editor.

details:
The implementation builds on top of the more generic `TippySuggestion` function with specific configuration for mentions:

1. It sets the trigger character to '@'
2. Sets the node name to 'nprofile'
3. Provides a custom select handler that:
   - Gets relays for the selected pubkey using the provided getRelays function
   - Encodes the pubkey and relays into a bech32 nprofile format using nprofileEncode
   - Creates node attributes using makeNProfileAttrs
   - Executes the command to insert the mention into the editor

The function spreads the remaining options from the input to allow customization of other TippySuggestion parameters.

related: __function,TippySuggestion,MentionSuggestionOptions

import/access examples:
import { MentionSuggestion } from '@welshman/editor';
import { MentionSuggestion } from '@welshman/editor/plugins';
import { MentionSuggestion } from '@welshman/editor/plugins/TippySuggestion';


=========================
type: file
workspace: packages/editor
path: packages/editor/src/extensions/BreakOrSubmit.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/editor/src/extensions/BreakOrSubmit.ts
summary: The BreakOrSubmit extension extends the HardBreak extension from Tiptap to provide functionality for handling Enter key presses. It exports a BreakOrSubmitOptions interface that extends HardBreakOptions with a submit callback function and an optional aggressive flag. The extension allows for submitting content on Enter or Mod+Enter, while Shift+Enter creates a hard break.

details: The implementation extends Tiptap's HardBreak extension by overriding the addKeyboardShortcuts method to provide custom behavior for three key combinations:
1. Shift-Enter: Creates a hard break (line break) in the editor
2. Mod-Enter (Ctrl/Cmd+Enter): Calls the provided submit function and returns true to prevent default behavior
3. Enter: If the aggressive option is true, calls the submit function and returns true; otherwise returns false to allow default behavior

The extension is simple but provides a flexible way to handle form submission or other actions within a Tiptap editor.

=========================
type: file
workspace: packages/editor
path: packages/editor/src/extensions/CodeInline.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/editor/src/extensions/CodeInline.ts
summary: The CodeInline extension defines a Node for inline code in a TipTap editor. It allows users to create inline code blocks using backticks (`code`), supports keyboard shortcuts for removing code blocks, and handles input rules and paste rules for converting text with backticks into code nodes.

details: Implementation details:
1. The extension is built on TipTap's Node.create method, configuring an inline code node.
2. It defines regex patterns for detecting inline code in both input (inputRegex) and paste (pasteRegex) operations.
3. The node is configured to only contain text with no marks, and is set as inline, code, and defining.
4. It implements HTML parsing and rendering for the <code> tag.
5. A keyboard shortcut handler for Backspace is implemented to delete the code block when at the end of the node.
6. Input and paste rules are defined to convert text surrounded by backticks into code nodes, with special handling to preserve leading spaces.

=========================
type: file
workspace: packages/editor
path: packages/editor/src/extensions/Welshman.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/editor/src/extensions/Welshman.ts
summary: The Welshman.ts file exports a TipTap extension called WelshmanExtension that builds on NostrExtension to provide a rich text editor with Nostr-specific functionality. It defines types for configuration options (WelshmanExtensionOptions and WelshmanOptions) and provides a way to customize various child extensions like code blocks, images, links, and Nostr-specific elements.

details: The implementation:
1. Imports various TipTap extensions and custom extensions from nostr-editor
2. Defines type structures for extension configuration options
3. Extends the NostrExtension with a custom implementation that:
   - Requires a submit callback function
   - Provides default configurations for various extensions (code formatting, node views, etc.)
   - Uses deepMergeLeft to combine user options with defaults
   - Implements a helper function (addExtension) to conditionally add extensions with their configurations
   - Adds a comprehensive set of extensions to support rich text editing, code blocks, media embedding, and Nostr-specific functionality
4. Sets up custom node views for different content types (Bolt11, Media, Event, Mention)
5. Configures various inline elements to display properly in the editor

=========================
type: file
workspace: packages/editor
path: packages/editor/src/extensions/WordCount.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/editor/src/extensions/WordCount.ts
summary: The WordCount extension for Tiptap provides functionality to count words and characters in the editor's content. It exports a single Extension that tracks and updates these counts whenever the editor content changes.

details: The implementation is straightforward:
1. Creates a Tiptap Extension named 'wordCount'
2. Adds storage with two properties: words and chars, both initialized to 0
3. Implements an onUpdate hook that:
   - Gets the text content from the editor's document
   - Counts words by splitting the text on whitespace and filtering out empty strings
   - Counts characters by measuring the text length
4. Updates the storage with these counts whenever the editor content changes

=========================
type: dir
workspace: packages/editor
path: packages/editor/src/extensions/
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/editor/src/extensions/
summary: The extensions directory contains TipTap editor extensions that enhance functionality for rich text editing with Nostr-specific features. The main exports include: BreakOrSubmit for handling line breaks and form submissions with keyboard shortcuts; CodeInline for inline code formatting with backtick support; Welshman, a comprehensive extension that builds on NostrExtension with configurable defaults for Nostr content; and WordCount for tracking text statistics. These extensions work together to provide a customizable editing experience with specialized behaviors for the Nostr protocol context.

=========================
type: file
workspace: packages/editor
path: packages/editor/src/nodeviews/Bolt11NodeView.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/editor/src/nodeviews/Bolt11NodeView.ts
summary: The Bolt11NodeView is a custom node view for the Tiptap editor that renders a Lightning Network Bitcoin (LNBC) invoice as a span element with a truncated display of the invoice string. It exports a function that takes NodeViewProps and returns a DOM element with selection handling capabilities.

details: The implementation creates a span element with the 'tiptap-object' class and displays a truncated version of the LNBC invoice (first 16 characters followed by '...'). It returns an object with:
1. The DOM element
2. A selectNode method that adds 'tiptap-active' class when the node is selected
3. A deselectNode method that removes the 'tiptap-active' class when the node is deselected

=========================
type: file
workspace: packages/editor
path: packages/editor/src/nodeviews/EventNodeView.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/editor/src/nodeviews/EventNodeView.ts
summary: EventNodeView is a function that creates a custom node view for Tiptap editor. It renders a Nostr event reference as a span element with a truncated event ID, and handles selection states by adding/removing CSS classes.

details: The implementation creates a DOM element (span) to represent a Nostr event in the editor. It:
1. Imports a utility function fromNostrURI to parse Nostr URIs
2. Creates a span element with 'tiptap-object' class
3. Sets the innerText to a truncated version of the parsed Nostr event ID
4. Implements selectNode and deselectNode methods to toggle the 'tiptap-active' class when the node is selected/deselected in the editor
5. Returns an object with the DOM element and selection handler methods

=========================
type: file
workspace: packages/editor
path: packages/editor/src/nodeviews/MediaNodeView.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/editor/src/nodeviews/MediaNodeView.ts
summary: MediaNodeView is an exported function that creates a node view for media elements in a Tiptap editor. It takes NodeViewProps as input and returns a DOM element with update, selectNode, and deselectNode methods to handle media representation and state changes.

details: The implementation creates a span element with 'tiptap-object' class and displays either the file name or source URL as text content. It includes a syncUploading helper function that adds or removes a 'tiptap-uploading' class based on the node's uploading attribute. The returned object provides:
1. A DOM element for rendering
2. An update method that syncs the uploading state
3. selectNode and deselectNode methods that toggle a 'tiptap-active' class for selection state

=========================
type: file
workspace: packages/editor
path: packages/editor/src/nodeviews/MentionNodeView.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/editor/src/nodeviews/MentionNodeView.ts
summary: MentionNodeView is an exported function that creates a custom node view for mentions in a Tiptap editor. It renders a mention as a span element with a truncated bech32 address prefixed with '@'.

details: The implementation creates a DOM span element with 'tiptap-object' class and displays a truncated version of the node's bech32 attribute (first 16 characters followed by '...'). It returns an object with the DOM element and methods to handle selection state (selectNode adds 'tiptap-active' class, deselectNode removes it). This is a simple implementation of the NodeViewProps interface from the Tiptap editor framework.

=========================
type: dir
workspace: packages/editor
path: packages/editor/src/nodeviews/
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/editor/src/nodeviews/
summary: The nodeviews directory contains custom node view implementations for the Tiptap editor, providing specialized rendering for various Nostr-related elements. It exports node views for Lightning Network invoices (Bolt11NodeView), Nostr events (EventNodeView), media attachments (MediaNodeView), and user mentions (MentionNodeView). Each implementation follows a similar pattern of creating DOM elements with appropriate styling and handling selection states, typically displaying truncated versions of longer identifiers with visual indicators for user interaction.

=========================
type: file
workspace: packages/editor
path: packages/editor/src/plugins/TippySuggestion.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/editor/src/plugins/TippySuggestion.ts
summary: TippySuggestion.ts provides a customizable suggestion/autocomplete system for TipTap editors. It exports the TippySuggestion function that creates a suggestion plugin with a dropdown menu powered by tippy.js. The file also includes a specialized MentionSuggestion function for handling Nostr profile mentions. The module defines interfaces for suggestion wrappers and provides a default implementation (DefaultSuggestionsWrapper) that handles rendering, keyboard navigation, and selection of suggestions.

details: The implementation consists of several key components:

1. DefaultSuggestionsWrapper class - manages the UI for suggestions, including:
   - Rendering a list of suggestion items
   - Handling keyboard navigation (arrow keys)
   - Managing selection and item creation
   - Throttled search functionality

2. TippySuggestion function - creates a Suggestion plugin with:
   - Tippy.js popover for displaying suggestions
   - Event handlers for keyboard interaction
   - Custom rendering of suggestion items
   - Support for inserting selected content into the editor

3. MentionSuggestion function - specializes TippySuggestion for Nostr profile mentions by:
   - Setting default character trigger to '@'
   - Converting selected pubkeys to nprofile format
   - Adding relay information to mentions

The implementation uses throttling for search operations and provides extensive customization options through interfaces and default implementations.

=========================
type: dir
workspace: packages/editor
path: packages/editor/src/plugins/
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/editor/src/plugins/
summary: The plugins directory contains utilities for extending editor functionality, primarily focused on suggestion systems. It exports the TippySuggestion module, which provides a framework for creating interactive dropdown suggestions in text editors using Tippy.js. This includes customizable suggestion interfaces with keyboard navigation, search capabilities, and specialized implementations like MentionSuggestion for Nostr profiles. The directory serves as a collection point for editor plugin components that enhance the core editing experience with additional interactive features.

=========================
type: dir
workspace: packages/editor
path: packages/editor/src/
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/editor/src/
summary: This directory contains components for a rich text editor with Nostr protocol integration. It exports specialized extensions (handling line breaks, code formatting, word counting), custom node views (for Lightning invoices, Nostr events, media, and user mentions), and plugins (primarily for suggestion systems using Tippy.js). Together, these modules create a comprehensive editing experience tailored for Nostr content creation with features like mentions, event embedding, and media attachments, all following consistent patterns for integration with the TipTap editor framework.

=========================
type: dir
workspace: packages/editor
path: packages/editor/
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/editor/
summary: This directory houses a rich text editor implementation with Nostr protocol integration, built on the TipTap editor framework. It exports three main component categories: extensions (for text formatting, word counting, and line break handling), node views (for rendering specialized content like Lightning invoices, Nostr events, media, and user mentions), and plugins (primarily for suggestion systems using Tippy.js). The components work together to create a comprehensive editing experience tailored for Nostr content creation with features like mentions, event embedding, and media attachments.

=========================
type: file
workspace: packages/feeds
file: packages/feeds/package.json
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/package.json
include: always
{
  "name": "@welshman/feeds",
  "version": "0.4.6",
  "author": "hodlbod",
  "license": "MIT",
  "description": "Utilities for building dynamic nostr feeds.",
  "publishConfig": {
    "access": "public"
  },
  "type": "module",
  "main": "dist/feeds/src/index.js",
  "types": "dist/feeds/src/index.d.ts",
  "files": [
    "dist"
  ],
  "scripts": {
    "build": "pnpm run clean && pnpm run compile --force",
    "clean": "rimraf ./dist",
    "compile": "tsc -b tsconfig.build.json",
    "prepublishOnly": "pnpm run build"
  },
  "dependencies": {
    "@welshman/lib": "workspace:*",
    "@welshman/net": "workspace:*",
    "@welshman/relay": "workspace:*",
    "@welshman/router": "workspace:*",
    "@welshman/signer": "workspace:*",
    "@welshman/util": "workspace:*",
    "trava": "^1.2.1"
  },
  "devDependencies": {
    "rimraf": "~6.0.0",
    "typescript": "~5.8.0"
  }
}


=========================
type: file
workspace: packages/feeds
file: packages/feeds/tsconfig.json
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/tsconfig.json
include: always
{
  "extends": "../../tsconfig.json"
}


=========================
workspace: packages/feeds
file: packages/feeds/src/core.ts
lines: 3:21
id: a6a74007a793dd5a5e31c7a8e21194ca8475e2fc7bdbc4bb12f874dae3d12e0b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/core.ts#L3

declaration:
export enum FeedType {
  Address = "address",
  Author = "author",
  CreatedAt = "created_at",
  DVM = "dvm",
  Difference = "difference",
  ID = "id",
  Intersection = "intersection",
  Global = "global",
  Kind = "kind",
  List = "list",
  Label = "label",
  WOT = "wot",
  Relay = "relay",
  Scope = "scope",
  Search = "search",
  Tag = "tag",
  Union = "union",
}

summary:
The `FeedType` enum defines the various types of feeds that can be used in the system. It provides a set of string constants representing different filtering and aggregation strategies for data feeds, such as filtering by address, author, creation time, or combining feeds through operations like union and intersection.

details:
This enum serves as a type-safe way to identify different feed types throughout the application. Each enum value is a string literal that matches its identifier name in lowercase. The enum includes basic filter types (address, author, kind, etc.), time-based filters (created_at), set operations (union, intersection, difference), and specialized feed types (dvm, wot, label, etc.). These values are likely used as discriminators in the various feed type definitions that follow in the file.

import/access examples:
import { FeedType } from '@welshman/feeds';
import { FeedType } from '@welshman/feeds/core';


=========================
workspace: packages/feeds
file: packages/feeds/src/core.ts
lines: 23:28
id: 687b471ec14e6b8bbc745b1691c23aa4c6767041718ade54f3658b033c275af7
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/core.ts#L23

declaration:
export enum Scope {
  Followers = "followers",
  Follows = "follows",
  Network = "network",
  Self = "self",
}

summary:
The `Scope` enum defines different scopes for filtering data in a feed system. It includes four possible values: `Followers`, `Follows`, `Network`, and `Self`, each represented by a string literal with the same name in lowercase.

details:
This enum is a simple type definition that provides a set of named constants for use in feed filtering operations. It's used in the `ScopeFeed` type (line 83) to specify the scope of data retrieval. The implementation is straightforward with no complex logic - just a standard TypeScript enum declaration with string literal values.

import/access examples:
import { Scope } from '@welshman/feeds';
import { Scope } from '@welshman/feeds/core';


=========================
workspace: packages/feeds
file: packages/feeds/src/core.ts
lines: 30:36
id: 056e9760d42e8ef358827e60096b678cd3efd027c06ffdf70640953a4d937a12
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/core.ts#L30

declaration:
export type FilterFeedType =
  | FeedType.ID
  | FeedType.Address
  | FeedType.Author
  | FeedType.Kind
  | FeedType.Relay
  | FeedType.Tag

summary:
FilterFeedType is a type alias that represents feed types that can be used in filters. It is a union type of specific FeedType enum values including ID, Address, Author, Kind, Relay, and Tag.

details:
This type alias is a subset of the FeedType enum, specifically selecting feed types that are compatible with filtering operations. It narrows down the complete FeedType enum to only include types that make sense in a filtering context (ID, Address, Author, Kind, Relay, and Tag), excluding more complex feed types like Union, Intersection, or DVM that would typically be used for feed composition rather than direct filtering.

related: ID,Address,Author,Kind,Relay,Tag

import/access examples:
import type { FilterFeedType } from '@welshman/feeds';
import type { FilterFeedType } from '@welshman/feeds/core';


=========================
workspace: packages/feeds
file: packages/feeds/src/core.ts
lines: 38:38
id: cfc59baa3a9d910e025df39d4499f5daae97a06e61b2151a73fa563d4c013b8d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/core.ts#L38

declaration:
export type TagFeedMapping = [string, Feed]

summary:
A type alias that defines a mapping between a tag string and a Feed. It's structured as a tuple with two elements: a string representing a tag and a Feed object.

details:
This type is used to create associations between tags and feeds, allowing for tag-based filtering or organization of feed content. It's a simple tuple type without complex implementation details.

related: Feed

import/access examples:
import type { TagFeedMapping } from '@welshman/feeds';
import type { TagFeedMapping } from '@welshman/feeds/core';


=========================
workspace: packages/feeds
file: packages/feeds/src/core.ts
lines: 40:45
id: 6fce7473c638aabad9b3d53906d8413356aee620fcd03e197341083ee5b51fd4
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/core.ts#L40

declaration:
export type DVMItem = {
  kind: number
  tags?: string[][]
  relays?: string[]
  mappings?: TagFeedMapping[]
}

summary:
DVMItem is a type that represents a configuration for a Decentralized Virtual Machine (DVM) feed. It includes properties for specifying the kind of event, optional tags, relays, and tag-to-feed mappings.

details:
The DVMItem type is a structured object with the following properties:
1. `kind`: A required number that specifies the event kind in the Nostr protocol
2. `tags`: An optional array of string arrays, representing Nostr event tags
3. `relays`: An optional array of strings, likely representing relay URLs
4. `mappings`: An optional array of TagFeedMapping tuples, which connect tags to feeds

This type appears to be part of a larger feed system, where DVMItem is used to configure how DVM-related events are processed or filtered.

related: TagFeedMapping

import/access examples:
import type { DVMItem } from '@welshman/feeds';
import type { DVMItem } from '@welshman/feeds/core';


=========================
workspace: packages/feeds
file: packages/feeds/src/core.ts
lines: 47:50
id: 15c5eb4727ee00b494cbc6475989157dfadc7f3fc6ef224438b39d4a6a972334
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/core.ts#L47

declaration:
export type ListItem = {
  addresses: string[]
  mappings?: TagFeedMapping[]
}

summary:
A type definition representing an item in a list feed. It contains an array of addresses and optional mappings between tags and feeds.

details:
The `ListItem` type is a simple structure used in list-based feeds (as seen in the `ListFeed` type). It consists of:
1. A required `addresses` property which is an array of strings, likely representing Nostr public keys or other address identifiers
2. An optional `mappings` property which is an array of `TagFeedMapping` tuples, where each tuple associates a tag string with a corresponding `Feed` object

related: TagFeedMapping

import/access examples:
import type { ListItem } from '@welshman/feeds';
import type { ListItem } from '@welshman/feeds/core';


=========================
workspace: packages/feeds
file: packages/feeds/src/core.ts
lines: 52:57
id: 94b918256b06ac31aad5c1f4c0be960804ba44b6fe749bbc2999c3467a5c0015
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/core.ts#L52

declaration:
export type LabelItem = {
  relays?: string[]
  authors?: string[]
  [key: `#${string}`]: string[]
  mappings?: TagFeedMapping[]
}

summary:
The `LabelItem` type represents a structure for labeling or categorizing content with specific metadata. It can include relay URLs, author public keys, custom tag-value pairs (with tags prefixed by '#'), and optional mappings to other feeds.

details:
This type definition serves as a flexible data structure for labeling content in what appears to be a Nostr-related application. It contains:
1. Optional `relays` property: An array of relay URLs where the labeled content might be found
2. Optional `authors` property: An array of author public keys associated with the labeled content
3. A dynamic index signature allowing for arbitrary tag-based properties in the format `#tagName` that hold arrays of string values
4. Optional `mappings` property: An array of `TagFeedMapping` tuples that can link tags to specific feeds

The structure allows for flexible categorization and filtering of content based on various metadata attributes.

related: TagFeedMapping

import/access examples:
import type { LabelItem } from '@welshman/feeds';
import type { LabelItem } from '@welshman/feeds/core';


=========================
workspace: packages/feeds
file: packages/feeds/src/core.ts
lines: 59:62
id: 4f85bbf5923b16fd6c8b314583020584b3532b84f627b2da0b7257138b69e786
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/core.ts#L59

declaration:
export type WOTItem = {
  min?: number
  max?: number
}

summary:
WOTItem is a type definition that represents configuration parameters for a Web of Trust (WOT) feed. It contains optional minimum and maximum values that likely define thresholds or limits within a trust network.

details:
This is a simple type definition with two optional numeric properties:
- `min?: number` - An optional minimum threshold value for WOT relationships
- `max?: number` - An optional maximum threshold value for WOT relationships

These properties are likely used to filter or limit connections in a Web of Trust network based on trust scores or connection depth.

import/access examples:
import type { WOTItem } from '@welshman/feeds';
import type { WOTItem } from '@welshman/feeds/core';


=========================
workspace: packages/feeds
file: packages/feeds/src/core.ts
lines: 64:68
id: 5c81760013a7497c497f9f9c4a5f320e058b7813659f8b806a77520bd6f28a2b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/core.ts#L64

declaration:
export type CreatedAtItem = {
  since?: number
  until?: number
  relative?: string[]
}

summary:
A type definition that represents parameters for filtering events by creation time in a feed. It includes optional properties for specifying time ranges with `since` (timestamp in seconds), `until` (timestamp in seconds), and `relative` (array of relative time expressions).

details:
This type is used as part of the CreatedAtFeed structure to filter Nostr events based on when they were created. The implementation is straightforward:

- `since`: Optional Unix timestamp (in seconds) representing the lower bound of the time range
- `until`: Optional Unix timestamp (in seconds) representing the upper bound of the time range
- `relative`: Optional array of strings that likely contain human-readable relative time expressions (e.g., "1d", "2h", etc.)

This type appears to be part of a larger feed filtering system, where CreatedAtItem instances are used in CreatedAtFeed to specify time-based filtering criteria.

import/access examples:
import type { CreatedAtItem } from '@welshman/feeds';
import type { CreatedAtItem } from '@welshman/feeds/core';


=========================
workspace: packages/feeds
file: packages/feeds/src/core.ts
lines: 70:70
id: b97058d0c98abebd558a76f10efd9ce4ba99f7a6d248973f0a46e3c77329ce6e
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/core.ts#L70

declaration:
export type AddressFeed = [type: FeedType.Address, ...addresses: string[]]

summary:
A type representing a feed filtered by addresses. It's a tuple where the first element is the FeedType.Address enum value, followed by one or more string addresses to filter by.

details:
This type is part of a feed filtering system. It's structured as a tuple type where:
1. The first element is always FeedType.Address (literal "address")
2. The rest of the elements are string addresses

The type is designed to be used in a discriminated union pattern where the first element acts as the discriminant.

related: Address

import/access examples:
import type { AddressFeed } from '@welshman/feeds';
import type { AddressFeed } from '@welshman/feeds/core';


=========================
workspace: packages/feeds
file: packages/feeds/src/core.ts
lines: 71:71
id: 2de74b3d4967294fd016a66e6ae3a2a56a22fa614b12b7ea15fa3ac360e99819
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/core.ts#L71

declaration:
export type AuthorFeed = [type: FeedType.Author, ...pubkeys: string[]]

summary:
A type alias representing a feed filtered by author public keys. It's structured as a tuple where the first element is the FeedType.Author enum value, followed by one or more public keys as strings.

details:
This type is part of a feed definition system where different feed types are represented as tuples with specific structures. The AuthorFeed specifically allows filtering content by the authors (identified by their public keys) who created it. The implementation is straightforward - it's a tuple type with a fixed first element (FeedType.Author) followed by a rest parameter of string type representing public keys.

related: Author

import/access examples:
import type { AuthorFeed } from '@welshman/feeds';
import type { AuthorFeed } from '@welshman/feeds/core';


=========================
workspace: packages/feeds
file: packages/feeds/src/core.ts
lines: 72:72
id: 1e2c249d6999ce97a02e00325ffad2fba6e2c8170833c709e9dcb4cef2a28d57
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/core.ts#L72

declaration:
export type CreatedAtFeed = [type: FeedType.CreatedAt, ...items: CreatedAtItem[]]

summary:
A type representing a feed filtered by creation time. It's a tuple where the first element is `FeedType.CreatedAt` followed by one or more `CreatedAtItem` objects that specify time constraints for filtering content.

details:
This type alias defines a tuple structure for time-based filtering in what appears to be a feed system. The structure allows for specifying multiple time range criteria through `CreatedAtItem` objects, which can include absolute timestamps (`since`, `until`) or relative time expressions. It's part of a larger feed filtering system where different feed types handle different filtering criteria.

related: CreatedAt,CreatedAtItem

import/access examples:
import type { CreatedAtFeed } from '@welshman/feeds';
import type { CreatedAtFeed } from '@welshman/feeds/core';


=========================
workspace: packages/feeds
file: packages/feeds/src/core.ts
lines: 73:73
id: 7dc2f557ab5e22e9eaa90fc1374b06ba8cfd2f768e487727960d6f9b4a7c8cbc
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/core.ts#L73

declaration:
export type DVMFeed = [type: FeedType.DVM, ...items: DVMItem[]]

summary:
A type representing a feed for Data Verification Method (DVM) content. It's structured as a tuple where the first element is the FeedType.DVM enum value, followed by one or more DVMItem objects that specify kind, optional tags, relays, and mappings.

details:
This type alias defines a specialized feed structure for DVM-related content. It follows the pattern of other feed types in the system, using a tuple structure where the first element identifies the feed type (FeedType.DVM) and subsequent elements are DVMItem objects. Each DVMItem can specify:
1. A kind number (required)
2. Optional tags as nested string arrays
3. Optional relay URLs as strings
4. Optional tag-to-feed mappings

The type is part of a larger feed type system used for filtering and organizing content.

related: DVM,DVMItem

import/access examples:
import type { DVMFeed } from '@welshman/feeds';
import type { DVMFeed } from '@welshman/feeds/core';


=========================
workspace: packages/feeds
file: packages/feeds/src/core.ts
lines: 74:74
id: fcf3c3934ec28df6a98e0195cf7a8e8058a976e99d5ffa9d8497b97d11724f3b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/core.ts#L74

declaration:
export type DifferenceFeed = [type: FeedType.Difference, ...feeds: Feed[]]

summary:
DifferenceFeed is a type representing a feed that computes the difference between multiple feeds. It's structured as a tuple where the first element is the FeedType.Difference enum value, followed by one or more Feed objects that will be used to calculate the difference.

details:
This type is part of a feed system that appears to handle various types of data filtering and composition. The DifferenceFeed type is specifically designed to represent a set operation that takes multiple feeds and returns items that exist in the first feed but not in any of the subsequent feeds. It's implemented as a tuple type with a specific discriminator (FeedType.Difference) followed by a rest parameter of Feed objects.

related: Difference,Feed

import/access examples:
import type { DifferenceFeed } from '@welshman/feeds';
import type { DifferenceFeed } from '@welshman/feeds/core';


=========================
workspace: packages/feeds
file: packages/feeds/src/core.ts
lines: 75:75
id: 69ee151706c663eb646d12502edf3ba2b364bd528c5c1991d179fedbca3b89cb
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/core.ts#L75

declaration:
export type IDFeed = [type: FeedType.ID, ...ids: string[]]

summary:
IDFeed is a type alias representing a feed that filters events by their IDs. It's structured as a tuple where the first element is the FeedType.ID enum value, followed by one or more event ID strings.

details:
This type is part of a feed system that appears to define various ways to filter Nostr events. The IDFeed specifically allows filtering events by their unique identifiers. The implementation is straightforward - it's a tuple type where:
1. The first element is always FeedType.ID (a discriminator)
2. The rest of the elements are string parameters representing event IDs

This type is exported from both core.ts and index.ts, suggesting it's part of the public API.

related: ID

import/access examples:
import type { IDFeed } from '@welshman/feeds';
import type { IDFeed } from '@welshman/feeds/core';


=========================
workspace: packages/feeds
file: packages/feeds/src/core.ts
lines: 76:76
id: 76cb9c0ef97d51f2245dee9cd502656fde5b9cdd6f3eaaab80387f51943d1354
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/core.ts#L76

declaration:
export type IntersectionFeed = [type: FeedType.Intersection, ...feeds: Feed[]]

summary:
IntersectionFeed is a type representing a feed that returns the intersection of multiple feeds. It's structured as a tuple where the first element is the FeedType.Intersection enum value, followed by one or more Feed objects whose results will be intersected.

details:
This type is part of a feed system that appears to be used for filtering or querying data. The IntersectionFeed type is implemented as a tuple type with a specific structure:

1. The first element is always FeedType.Intersection (a string literal "intersection")
2. The rest of the elements are Feed objects

When used, this feed type would return only items that appear in all of the specified feeds, effectively performing a logical AND operation across multiple feeds.

related: Intersection,Feed

import/access examples:
import type { IntersectionFeed } from '@welshman/feeds';
import type { IntersectionFeed } from '@welshman/feeds/core';


=========================
workspace: packages/feeds
file: packages/feeds/src/core.ts
lines: 77:77
id: 487d468a8151ce35af50f51c5c64ce03bce130b508eb9b3a25ca9dca323ca073
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/core.ts#L77

declaration:
export type GlobalFeed = [type: FeedType.Global, ...feeds: Feed[]]

summary:
GlobalFeed is a type alias representing a global feed in a feed system. It is structured as a tuple where the first element is the FeedType.Global enum value, followed by zero or more Feed objects. This type is used to define a feed that likely represents a global scope or context for retrieving data.

details:
This type is part of a larger feed type system in the application. It follows the pattern of other feed types where each is defined as a tuple with a specific FeedType as the first element. The GlobalFeed can contain any number of other Feed objects as its remaining elements, suggesting it might be used as a container or wrapper for other feeds in a global context.

related: Global,Feed

import/access examples:
import type { GlobalFeed } from '@welshman/feeds';
import type { GlobalFeed } from '@welshman/feeds/core';


=========================
workspace: packages/feeds
file: packages/feeds/src/core.ts
lines: 78:78
id: a6abe5986ffd887ef8dbd4a6b32b14fee4477ef992a83e1879be86db9d152ddc
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/core.ts#L78

declaration:
export type KindFeed = [type: FeedType.Kind, ...kinds: number[]]

summary:
KindFeed is a type alias representing a feed filtered by event kinds. It's structured as a tuple where the first element is the FeedType.Kind enum value, followed by one or more numeric kind values that specify which event kinds to include in the feed.

details:
This type is part of a feed definition system, likely for filtering Nostr events. The implementation is straightforward - it's a tuple type that starts with a discriminator (FeedType.Kind) followed by a rest parameter of numbers representing Nostr event kinds. This allows for creating filters that match events of specific kinds (e.g., [FeedType.Kind, 1, 4] would match events of kind 1 and 4).

related: Kind

import/access examples:
import type { KindFeed } from '@welshman/feeds';
import type { KindFeed } from '@welshman/feeds/core';


=========================
workspace: packages/feeds
file: packages/feeds/src/core.ts
lines: 79:79
id: fc1517ff9f9838def4c223db78205dd099fd1973eccde2a60ba5a66d0915755e
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/core.ts#L79

declaration:
export type ListFeed = [type: FeedType.List, ...items: ListItem[]]

summary:
ListFeed is a type alias representing a feed of list items. It's structured as a tuple where the first element is the FeedType.List enum value, followed by zero or more ListItem objects. This type is used to define a feed that contains lists of addresses with optional tag-to-feed mappings.

details:
The ListFeed type is implemented as a tuple type with a specific structure:

1. The first element is always FeedType.List (with value "list")
2. The rest of the elements are ListItem objects

Each ListItem contains:
- addresses: An array of string addresses
- mappings: An optional array of TagFeedMapping pairs that associate tags with feeds

This type is part of a larger feed type system in the application, where different feed types (Address, Author, Kind, etc.) are defined with specific structures to handle various filtering and data organization needs.

related: List,ListItem

import/access examples:
import type { ListFeed } from '@welshman/feeds';
import type { ListFeed } from '@welshman/feeds/core';


=========================
workspace: packages/feeds
file: packages/feeds/src/core.ts
lines: 80:80
id: 070761a5c16e2cce39d93d4756d3126212d78b71a852d190281410b60382bec9
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/core.ts#L80

declaration:
export type LabelFeed = [type: FeedType.Label, ...items: LabelItem[]]

summary:
LabelFeed is a type representing a feed filtered by labels. It's structured as a tuple where the first element is the FeedType.Label enum value, followed by one or more LabelItem objects that define the label filtering criteria.

details:
This type is part of a feed definition system and follows the pattern of other feed types in the codebase. It's implemented as a tuple type with a specific structure:

1. The first element is always FeedType.Label (a string literal "label")
2. The rest of the elements are LabelItem objects

The LabelItem objects can contain:
- Optional relay URLs
- Optional author public keys
- Custom tag filters (using the `#${string}` indexed signature)
- Optional mappings between tags and other feeds

related: Label,LabelItem

import/access examples:
import type { LabelFeed } from '@welshman/feeds';
import type { LabelFeed } from '@welshman/feeds/core';


=========================
workspace: packages/feeds
file: packages/feeds/src/core.ts
lines: 81:81
id: 596feef9d9585ffc47704e9220db55210ae251d2fb9b13c4d04e0fde9f6a1def
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/core.ts#L81

declaration:
export type WOTFeed = [type: FeedType.WOT, ...items: WOTItem[]]

summary:
WOTFeed is a type alias representing a Web of Trust feed configuration. It's structured as a tuple where the first element is the FeedType.WOT enum value, followed by zero or more WOTItem objects that define Web of Trust parameters.

details:
This type alias defines the structure for Web of Trust feeds in the system. It uses a tuple type where:
1. The first element is always FeedType.WOT (a string literal "wot")
2. The rest of the elements are WOTItem objects

The WOTItem type (defined on lines 59-62) contains optional min and max properties that likely define the boundaries for trust relationships in a Web of Trust network.

related: WOT,WOTItem

import/access examples:
import type { WOTFeed } from '@welshman/feeds';
import type { WOTFeed } from '@welshman/feeds/core';


=========================
workspace: packages/feeds
file: packages/feeds/src/core.ts
lines: 82:82
id: f957044e2fa144515f8a08f5cac4a756a032bbd3045ec97ec546ffe2b31121cc
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/core.ts#L82

declaration:
export type RelayFeed = [type: FeedType.Relay, ...urls: string[]]

summary:
RelayFeed is a type alias representing a feed filtered by relay URLs. It's structured as a tuple where the first element is the FeedType.Relay enum value, followed by one or more relay URL strings.

details:
This type is part of a larger feed type system in the application. It follows the pattern of other feed types where the first element identifies the feed type (in this case 'relay') and subsequent elements contain the filtering criteria (relay URLs). The RelayFeed type would be used when filtering events based on which relays they were received from or should be sent to.

related: Relay

import/access examples:
import type { RelayFeed } from '@welshman/feeds';
import type { RelayFeed } from '@welshman/feeds/core';


=========================
workspace: packages/feeds
file: packages/feeds/src/core.ts
lines: 83:83
id: 65891474b575245aed11b0129d5bfb7ce7aefe2917833484f768fdb44cb4bec0
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/core.ts#L83

declaration:
export type ScopeFeed = [type: FeedType.Scope, ...scopes: Scope[]]

summary:
ScopeFeed is a TypeScript type alias that represents a feed filtered by scope. It's structured as a tuple where the first element is the FeedType.Scope enum value, followed by one or more Scope enum values. This type is used to filter content based on social graph relationships like followers, follows, network, or self.

details:
The ScopeFeed type is implemented as a tuple type with a specific structure:

1. The first element is always FeedType.Scope, which serves as a type discriminator
2. The rest of the elements are Scope enum values that define the filtering criteria

This type is part of a larger union type called Feed, which represents various ways to filter and organize content in what appears to be a social networking or content discovery system.

related: Scope,Scope

import/access examples:
import type { ScopeFeed } from '@welshman/feeds';
import type { ScopeFeed } from '@welshman/feeds/core';


=========================
workspace: packages/feeds
file: packages/feeds/src/core.ts
lines: 84:84
id: 6ec0e7e8273761d5f286e87a555c8b0fe42a4229eecdfc979b1d634b0745723b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/core.ts#L84

declaration:
export type SearchFeed = [type: FeedType.Search, ...searches: string[]]

summary:
SearchFeed is a type alias that represents a feed for searching content. It's structured as a tuple where the first element is the FeedType.Search enum value, followed by one or more search strings. This type is used to define search criteria for filtering content in the system.

details:
The implementation is straightforward - it's a TypeScript tuple type definition that starts with a fixed FeedType.Search value followed by a rest parameter of strings that represent search terms. This type is part of a larger union type called Feed, which encompasses various feed types for different filtering scenarios.

related: Search

import/access examples:
import type { SearchFeed } from '@welshman/feeds';
import type { SearchFeed } from '@welshman/feeds/core';


=========================
workspace: packages/feeds
file: packages/feeds/src/core.ts
lines: 85:85
id: 7469de3d7c5756b0cd080c2159c2edea6feef7cd61660819c17bb17aba09474d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/core.ts#L85

declaration:
export type TagFeed = [type: FeedType.Tag, key: string, ...values: string[]]

summary:
TagFeed is a type representing a feed filtered by a specific tag. It's structured as a tuple where the first element is the FeedType.Tag enum value, followed by a string key representing the tag name, and then an array of string values that match the specified tag.

details:
This type is part of a larger feed system in the application. It follows the pattern of other feed types where the first element identifies the feed type (in this case 'tag'), followed by specific parameters for that feed type. For TagFeed, it requires a tag key (like 'e', 't', 'p', etc.) and then accepts multiple string values that should match that tag. This would typically be used to filter nostr events that contain specific tag values.

related: Tag

import/access examples:
import type { TagFeed } from '@welshman/feeds';
import type { TagFeed } from '@welshman/feeds/core';


=========================
workspace: packages/feeds
file: packages/feeds/src/core.ts
lines: 86:86
id: 52928d6cce54cfd6d7f8eae6f36a31f7c7fd2d0310c820f2e10789316c8dc170
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/core.ts#L86

declaration:
export type UnionFeed = [type: FeedType.Union, ...feeds: Feed[]]

summary:
The `UnionFeed` type represents a feed that combines multiple other feeds using a union operation. It is structured as a tuple where the first element is the `FeedType.Union` enum value, followed by any number of other `Feed` objects that will be combined.

details:
This type alias defines a tuple type with a specific structure:
1. The first element must be the literal value `FeedType.Union` (which is "union" as defined in the enum)
2. The rest of the tuple can contain any number of `Feed` objects

The `UnionFeed` is part of a type system for defining different kinds of feeds in what appears to be a social or content filtering system. When used, it would allow combining multiple different feed definitions into a single feed that includes items from any of the constituent feeds.

related: Union,Feed

import/access examples:
import type { UnionFeed } from '@welshman/feeds';
import type { UnionFeed } from '@welshman/feeds/core';


=========================
workspace: packages/feeds
file: packages/feeds/src/core.ts
lines: 88:105
id: ee198ca41b8f227e1123e7815dcdd74575417cd979a656f68a3fea19b17c8113
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/core.ts#L88

declaration:
export type Feed =
  | AddressFeed
  | AuthorFeed
  | CreatedAtFeed
  | DVMFeed
  | DifferenceFeed
  | IDFeed
  | IntersectionFeed
  | GlobalFeed
  | KindFeed
  | ListFeed
  | LabelFeed
  | WOTFeed
  | RelayFeed
  | ScopeFeed
  | SearchFeed
  | TagFeed
  | UnionFeed

summary:
A union type representing various feed types in a system. `Feed` can be one of multiple feed types including `AddressFeed`, `AuthorFeed`, `CreatedAtFeed`, `DVMFeed`, `DifferenceFeed`, `IDFeed`, `IntersectionFeed`, `GlobalFeed`, `KindFeed`, `ListFeed`, `LabelFeed`, `WOTFeed`, `RelayFeed`, `ScopeFeed`, `SearchFeed`, `TagFeed`, or `UnionFeed`. Each feed type is structured as a tuple with the first element being the feed type identifier from the `FeedType` enum.

details:
The `Feed` type is a comprehensive union type that serves as the core data structure for the feed system. It combines all possible feed types defined in the file:

1. Each feed type is represented as a tuple where the first element is a discriminator from the `FeedType` enum
2. The remaining elements in each tuple vary based on the specific feed type, containing the data relevant to that feed
3. Some feed types like `DifferenceFeed`, `IntersectionFeed`, and `UnionFeed` are recursive, containing other `Feed` instances
4. Other feed types contain specialized item types like `CreatedAtItem`, `DVMItem`, `ListItem`, etc.

This type system allows for a flexible yet type-safe way to represent different kinds of feeds in the application.

related: AddressFeed,AuthorFeed,CreatedAtFeed,DVMFeed,DifferenceFeed,IDFeed,IntersectionFeed,GlobalFeed,KindFeed,ListFeed,LabelFeed,WOTFeed,RelayFeed,ScopeFeed,SearchFeed,TagFeed,UnionFeed

import/access examples:
import type { Feed } from '@welshman/feeds';
import type { Feed } from '@welshman/feeds/core';


=========================
workspace: packages/feeds
file: packages/feeds/src/core.ts
lines: 107:110
id: ad6b356b0f7390a15fd495cd6478f87102e6597c603fd5bda5c3a4210900b0af
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/core.ts#L107

declaration:
export type RequestItem = {
  relays?: string[]
  filters?: Filter[]
}

summary:
The `RequestItem` type represents a request configuration for fetching data. It contains optional properties for specifying relays and filters. This type is exported from the module and can be used to define request parameters when querying data sources.

details:
This is a simple TypeScript type alias that defines a structure with two optional properties:
1. `relays`: An optional array of strings, likely representing relay URLs or identifiers
2. `filters`: An optional array of `Filter` objects imported from the '@welshman/util' package

The type appears to be part of a larger system for querying and filtering data across different feed types, as evidenced by the numerous feed-related types defined in the same file.

import/access examples:
import type { RequestItem } from '@welshman/feeds';
import type { RequestItem } from '@welshman/feeds/core';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 33:36
id: 17a20f9678a1b9f0edf37a52b0df2d24e82b698fa82b7a886067039817380b56
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L33

declaration:
makeAddressFeed = (...addresses: string[]): AddressFeed => [
  FeedType.Address,
  ...addresses,
]

summary:
Creates an AddressFeed from one or more address strings. An AddressFeed is a typed array that starts with FeedType.Address followed by the provided addresses.

details:
This function creates an array where the first element is the FeedType.Address enum value, followed by spreading all the address strings passed as arguments. The return type is AddressFeed which appears to be a tuple type with a specific structure for address-based feeds.

related: FeedType,Address,AddressFeed

import/access examples:
import { makeAddressFeed } from '@welshman/feeds';
import { makeAddressFeed } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 37:37
id: 53c940212689cfb3dd33193b1d2cc1a24deaf9d17daab48c2d36ee64114c9188
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L37

declaration:
makeAuthorFeed = (...pubkeys: string[]): AuthorFeed => [FeedType.Author, ...pubkeys]

summary:
Creates an AuthorFeed array with the specified author public keys. The function takes any number of public key strings as arguments and returns an array where the first element is FeedType.Author followed by the provided public keys.

details:
This is a simple arrow function that constructs an AuthorFeed array. It uses the rest parameter syntax (...pubkeys) to accept any number of string arguments, then creates and returns an array literal with FeedType.Author as the first element followed by all the provided public keys using the spread operator.

related: FeedType,Author,AuthorFeed

import/access examples:
import { makeAuthorFeed } from '@welshman/feeds';
import { makeAuthorFeed } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 38:41
id: 9b972c8004c6be777cc888179b9d258a4e40e0d637fbf8481800c7ba223011d0
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L38

declaration:
makeCreatedAtFeed = (...items: CreatedAtItem[]): CreatedAtFeed => [
  FeedType.CreatedAt,
  ...items,
]

summary:
Creates a CreatedAtFeed from the provided CreatedAtItem array. A CreatedAtFeed is used to filter events based on their creation time. Each CreatedAtItem can specify 'since' and/or 'until' timestamps to define a time range.

details:
This function creates a typed array where the first element is the FeedType.CreatedAt enum value, followed by the spread of all CreatedAtItem objects passed as arguments. The resulting array conforms to the CreatedAtFeed type, which can be used in feed-based filtering operations.

related: FeedType,CreatedAt,CreatedAtItem,CreatedAtFeed

import/access examples:
import { makeCreatedAtFeed } from '@welshman/feeds';
import { makeCreatedAtFeed } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 42:42
id: 548bb7c574bff8f43625afa0bdb145dc7472544547d210d20d40eeb0d1d10333
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L42

declaration:
makeDVMFeed = (...items: DVMItem[]): DVMFeed => [FeedType.DVM, ...items]

summary:
Creates a DVM (Decentralized Verification Method) feed from the provided DVM items. This function takes any number of DVMItem objects as arguments and returns a DVMFeed array with the FeedType.DVM as the first element followed by the provided items.

details:
This is a simple arrow function that constructs a DVMFeed array. It uses the spread operator to include all provided DVMItem arguments after the FeedType.DVM identifier in the resulting array. The implementation is straightforward with no complex logic.

related: FeedType,DVM,DVMItem,DVMFeed

import/access examples:
import { makeDVMFeed } from '@welshman/feeds';
import { makeDVMFeed } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 43:46
id: fecc7f4a252f4d5b1701292a31fb7cb733369ceae2b3436f52bed10e01bb1bc0
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L43

declaration:
makeDifferenceFeed = (...feeds: Feed[]): DifferenceFeed => [
  FeedType.Difference,
  ...feeds,
]

summary:
Creates a DifferenceFeed from the provided Feed arguments. A DifferenceFeed represents a set difference operation between multiple feeds, where the first feed is the base and subsequent feeds are subtracted from it.

details:
This function creates a DifferenceFeed array with FeedType.Difference as the first element, followed by the spread of all provided feed arguments. The implementation is straightforward - it returns an array literal with the difference feed type identifier followed by all the feed arguments.

related: FeedType,Difference,Feed,DifferenceFeed,AddressFeed,Address,AuthorFeed,Author,CreatedAtFeed,CreatedAt,CreatedAtItem,DVMFeed,DVM,DVMItem,IDFeed,ID,IntersectionFeed,Intersection,GlobalFeed,Global,KindFeed,Kind,ListFeed,List,ListItem,LabelFeed,Label,LabelItem,WOTFeed,WOT,WOTItem,RelayFeed,Relay,ScopeFeed,Scope,Scope,Followers,Follows,Network,Self,SearchFeed,Search,TagFeed,Tag,UnionFeed,Union

import/access examples:
import { makeDifferenceFeed } from '@welshman/feeds';
import { makeDifferenceFeed } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 47:47
id: 58786891a58ddf63d19be5a90e96272103640478b8872b67a740056b1bc8776d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L47

declaration:
makeIDFeed = (...ids: string[]): IDFeed => [FeedType.ID, ...ids]

summary:
Creates an ID feed from a list of string IDs. This function takes any number of string IDs as arguments and returns an IDFeed array with FeedType.ID as the first element followed by the provided IDs.

details:
This is a simple arrow function that constructs an IDFeed array. It uses the rest parameter syntax to accept any number of string IDs, then returns an array where the first element is the FeedType.ID enum value and the remaining elements are the spread IDs passed as arguments.

related: FeedType,ID,IDFeed

import/access examples:
import { makeIDFeed } from '@welshman/feeds';
import { makeIDFeed } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 48:51
id: 7c2915bf9061778266f4b1dbae79a0b1f3269920b7d2e05f5f4e4fbc2caf114c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L48

declaration:
makeIntersectionFeed = (...feeds: Feed[]): IntersectionFeed => [
  FeedType.Intersection,
  ...feeds,
]

summary:
Creates an IntersectionFeed from multiple Feed objects. An IntersectionFeed represents a logical AND operation between multiple feeds, meaning it will only include items that are present in all of the provided feeds.

details:
This function creates an array with FeedType.Intersection as the first element, followed by all the provided feed arguments using the spread operator. The resulting array conforms to the IntersectionFeed type, which is used to represent the intersection of multiple feeds in the system.

related: FeedType,Intersection,Feed,IntersectionFeed,AddressFeed,Address,AuthorFeed,Author,CreatedAtFeed,CreatedAt,CreatedAtItem,DVMFeed,DVM,DVMItem,DifferenceFeed,Difference,IDFeed,ID,GlobalFeed,Global,KindFeed,Kind,ListFeed,List,ListItem,LabelFeed,Label,LabelItem,WOTFeed,WOT,WOTItem,RelayFeed,Relay,ScopeFeed,Scope,Scope,Followers,Follows,Network,Self,SearchFeed,Search,TagFeed,Tag,UnionFeed,Union

import/access examples:
import { makeIntersectionFeed } from '@welshman/feeds';
import { makeIntersectionFeed } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 52:52
id: 02ed1598dfd6f541a233ac0560ec4e1460128687bd6c7f8fd2e048eea8303bce
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L52

declaration:
makeGlobalFeed = (): GlobalFeed => [FeedType.Global]

summary:
Creates a GlobalFeed array with FeedType.Global as its only element. This function takes no parameters and returns a GlobalFeed type, which is used to represent a global feed in the system.

related: FeedType,Global,GlobalFeed,Feed,AddressFeed,Address,AuthorFeed,Author,CreatedAtFeed,CreatedAt,CreatedAtItem,DVMFeed,DVM,DVMItem,DifferenceFeed,Difference,IDFeed,ID,IntersectionFeed,Intersection,KindFeed,Kind,ListFeed,List,ListItem,LabelFeed,Label,LabelItem,WOTFeed,WOT,WOTItem,RelayFeed,Relay,ScopeFeed,Scope,Scope,Followers,Follows,Network,Self,SearchFeed,Search,TagFeed,Tag,UnionFeed,Union

import/access examples:
import { makeGlobalFeed } from '@welshman/feeds';
import { makeGlobalFeed } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 53:53
id: 12fa5e97a8e3e32e25948b1c00dace8d482b9b67e1cd853e13748a0a6bbf1f57
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L53

declaration:
makeKindFeed = (...kinds: number[]): KindFeed => [FeedType.Kind, ...kinds]

summary:
Creates a KindFeed array with the specified event kinds. This function takes any number of numeric kind values and returns a typed array where the first element is FeedType.Kind followed by the provided kind numbers.

details:
This is a simple arrow function that creates a KindFeed array. It uses the rest parameter syntax to accept any number of kind values as numbers, then constructs and returns an array with FeedType.Kind as the first element followed by spreading the provided kind numbers into the rest of the array.

related: FeedType,Kind,KindFeed

import/access examples:
import { makeKindFeed } from '@welshman/feeds';
import { makeKindFeed } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 54:54
id: 91b9f4571ae2cfeee08478d0a55e17bc8129b7941199a151e5d46374bce91dac
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L54

declaration:
makeListFeed = (...items: ListItem[]): ListFeed => [FeedType.List, ...items]

summary:
Creates a ListFeed from the provided ListItem array. A ListFeed is a specialized feed type that contains a list of ListItem objects. The function takes any number of ListItem parameters and returns a ListFeed array with FeedType.List as the first element followed by the provided items.

details:
This is a simple arrow function that creates a ListFeed array. It uses the rest parameter syntax (...items) to accept any number of ListItem objects and then constructs an array with FeedType.List as the first element followed by spreading the items into the rest of the array. The implementation is straightforward with no complex logic.

related: FeedType,List,ListItem,ListFeed

import/access examples:
import { makeListFeed } from '@welshman/feeds';
import { makeListFeed } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 55:55
id: 78c22167ca88757617a75abe2838cee4872de762b9d7beac16c6a7923172d646
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L55

declaration:
makeLabelFeed = (...items: LabelItem[]): LabelFeed => [FeedType.Label, ...items]

summary:
Creates a LabelFeed array with the specified LabelItem elements. The function takes any number of LabelItem objects as arguments and returns a typed array where the first element is FeedType.Label followed by the provided items.

details:
This is a simple arrow function that constructs a LabelFeed array. It uses the rest parameter syntax (...items) to accept any number of LabelItem objects, then creates and returns an array with FeedType.Label as the first element followed by spreading all the provided items into the rest of the array.

related: FeedType,Label,LabelItem,LabelFeed

import/access examples:
import { makeLabelFeed } from '@welshman/feeds';
import { makeLabelFeed } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 56:56
id: 4c913c3f8650fd8ff7bc02b4d64ab0dbdfc541aacd4371e705b31c456e366a56
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L56

declaration:
makeWOTFeed = (...items: WOTItem[]): WOTFeed => [FeedType.WOT, ...items]

summary:
Creates a Web of Trust (WOT) feed from the provided WOT items. This function takes any number of WOT items as arguments and returns a WOTFeed array with the FeedType.WOT as the first element followed by the provided items.

details:
This is a simple arrow function that constructs a WOTFeed array. It uses the spread operator to include all provided WOTItem arguments after the FeedType.WOT identifier in the resulting array. The implementation follows the pattern used by other feed creation functions in this utility module.

related: FeedType,WOT,WOTItem,WOTFeed

import/access examples:
import { makeWOTFeed } from '@welshman/feeds';
import { makeWOTFeed } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 57:57
id: be8e7013c9bbfd2f7f1b2391995c0434bc34285da839766c8f0f1dd7cc23b747
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L57

declaration:
makeRelayFeed = (...urls: string[]): RelayFeed => [FeedType.Relay, ...urls]

summary:
Creates a RelayFeed array with the specified relay URLs. The function takes any number of string parameters representing relay URLs and returns a typed array where the first element is the FeedType.Relay enum value followed by the provided URLs.

details:
This is a simple arrow function that constructs a RelayFeed array. It uses the rest parameter syntax to accept any number of string arguments, then creates an array literal with FeedType.Relay as the first element followed by spreading all the provided URL strings into the rest of the array.

related: FeedType,Relay,RelayFeed

import/access examples:
import { makeRelayFeed } from '@welshman/feeds';
import { makeRelayFeed } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 58:58
id: 417f50259bddee7630a014b44038a414ac25f0a26abbddd2bc3a24a11aeabc09
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L58

declaration:
makeScopeFeed = (...scopes: Scope[]): ScopeFeed => [FeedType.Scope, ...scopes]

summary:
Creates a ScopeFeed array with the provided scope values. A ScopeFeed is a specialized Feed type that begins with the FeedType.Scope identifier followed by the provided scope values.

details:
This is a simple arrow function that creates a ScopeFeed array. It takes any number of Scope objects as arguments (using the rest parameter syntax), and returns an array where the first element is FeedType.Scope and the remaining elements are the provided scope values spread into the array.

related: FeedType,Scope,Scope,ScopeFeed,Followers,Follows,Network,Self

import/access examples:
import { makeScopeFeed } from '@welshman/feeds';
import { makeScopeFeed } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 59:59
id: c05b6c484c2665217b04e9286341d5aa5fbcacab5771ed1debe1a0654136835d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L59

declaration:
makeSearchFeed = (...searches: string[]): SearchFeed => [FeedType.Search, ...searches]

summary:
Creates a SearchFeed from one or more search strings. A SearchFeed is used to filter content based on search terms.

details:
This function creates a SearchFeed array where the first element is the FeedType.Search enum value, followed by the provided search strings. It uses the rest parameter syntax to accept any number of search strings and spreads them into the resulting array.

related: FeedType,Search,SearchFeed

import/access examples:
import { makeSearchFeed } from '@welshman/feeds';
import { makeSearchFeed } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 60:64
id: 8db331fdb7d6f7f48e92163aaa076eefa78ca992590dcaf515975dd6a950b7e4
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L60

declaration:
makeTagFeed = (key: string, ...values: string[]): TagFeed => [
  FeedType.Tag,
  key,
  ...values,
]

summary:
Creates a TagFeed array with the specified tag key and values. A TagFeed is a specialized feed type that filters content based on a specific tag key and its associated values.

details:
This function creates a TagFeed array where the first element is the FeedType.Tag enum value, followed by the tag key, and then spreading all the provided tag values. The resulting array structure follows the pattern [FeedType.Tag, key, ...values] which represents a feed that can be used to filter content based on specific tags.

related: FeedType,Tag,TagFeed

import/access examples:
import { makeTagFeed } from '@welshman/feeds';
import { makeTagFeed } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 65:65
id: 52ed267caf448711594fe5d73f6647605d37c153c051a7ffd747719065dcd7e5
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L65

declaration:
makeUnionFeed = (...feeds: Feed[]): UnionFeed => [FeedType.Union, ...feeds]

summary:
Creates a UnionFeed by combining multiple Feed objects. A UnionFeed represents a logical OR operation between feeds, where events matching any of the provided feeds will be included in the result.

details:
This function creates a UnionFeed array with FeedType.Union as the first element followed by all the provided feed arguments. The implementation is a simple arrow function that returns an array literal with the Union feed type followed by spreading all the provided feeds into the array.

related: FeedType,Union,Feed,UnionFeed,AddressFeed,Address,AuthorFeed,Author,CreatedAtFeed,CreatedAt,CreatedAtItem,DVMFeed,DVM,DVMItem,DifferenceFeed,Difference,IDFeed,ID,IntersectionFeed,Intersection,GlobalFeed,Global,KindFeed,Kind,ListFeed,List,ListItem,LabelFeed,Label,LabelItem,WOTFeed,WOT,WOTItem,RelayFeed,Relay,ScopeFeed,Scope,Scope,Followers,Follows,Network,Self,SearchFeed,Search,TagFeed,Tag

import/access examples:
import { makeUnionFeed } from '@welshman/feeds';
import { makeUnionFeed } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 67:67
id: cf7bfe401717a441ceb2e928d105723704f6739a3ccaa87f48ea6b24b5d26cce
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L67

declaration:
isAddressFeed = (feed: Feed): feed is AddressFeed => feed[0] === FeedType.Address

summary:
A type guard function that checks if a given feed is an AddressFeed. Returns true if the feed's first element is FeedType.Address, indicating it's an AddressFeed type.

details:
This is a simple type predicate function that examines the first element (index 0) of the feed array and compares it to the FeedType.Address enum value. It uses TypeScript's type narrowing feature to tell the compiler that if this function returns true, the feed parameter should be treated as an AddressFeed type.

related: FeedType,Address,Feed

import/access examples:
import { isAddressFeed } from '@welshman/feeds';
import { isAddressFeed } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 68:68
id: f82eb4a6ed2738171c07b6d1843ac9e847f0a57b9ea3b2651846fe8ebce88566
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L68

declaration:
isAuthorFeed = (feed: Feed): feed is AuthorFeed => feed[0] === FeedType.Author

summary:
A type guard function that checks if a given feed is an AuthorFeed. It returns true if the first element of the feed array matches FeedType.Author, confirming the feed is specifically an AuthorFeed type.

details:
This is a simple type predicate function that implements a type guard pattern in TypeScript. It examines the first element (index 0) of the feed array and compares it to the FeedType.Author enum value. The function uses TypeScript's type narrowing capability with the 'feed is AuthorFeed' return type annotation to help the compiler understand the type of the feed in conditional blocks after this function is used.

related: FeedType,Author,Feed

import/access examples:
import { isAuthorFeed } from '@welshman/feeds';
import { isAuthorFeed } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 69:69
id: 980da466a4330e3a4662459226810425ede402f0c7dcf42c56a51e3295928046
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L69

declaration:
isCreatedAtFeed = (feed: Feed): feed is CreatedAtFeed => feed[0] === FeedType.CreatedAt

summary:
A type guard function that checks if a given feed is a CreatedAtFeed. It returns true if the first element of the feed array matches FeedType.CreatedAt, confirming the feed is of type CreatedAtFeed.

details:
This is a simple type predicate function that implements a type guard pattern in TypeScript. It examines the first element (index 0) of the feed array and compares it with the FeedType.CreatedAt enum value. The function uses TypeScript's type narrowing feature through the 'feed is CreatedAtFeed' return type annotation to help the compiler understand the type of the feed in conditional blocks after this check is performed.

related: FeedType,CreatedAt,Feed

import/access examples:
import { isCreatedAtFeed } from '@welshman/feeds';
import { isCreatedAtFeed } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 70:70
id: de1cda14fde48e2ed0f99a7ec3103863dd2061033d1023884f13acc95b5548b7
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L70

declaration:
isDVMFeed = (feed: Feed): feed is DVMFeed => feed[0] === FeedType.DVM

summary:
A type guard function that checks if a given feed is a DVM (Decentralized Virtual Machine) feed. It returns true if the feed's first element matches the FeedType.DVM enum value, confirming the feed is of type DVMFeed.

details:
This is a simple type predicate function that performs a type check by examining the first element of the feed array. It uses TypeScript's type narrowing capabilities through the 'feed is DVMFeed' return type annotation to help the compiler understand the type of the feed in conditional blocks after this function is used.

related: FeedType,DVM,Feed

import/access examples:
import { isDVMFeed } from '@welshman/feeds';
import { isDVMFeed } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 71:72
id: 8f6260720dbde2d9871568b61280bd1cc449bf086b6876ae7c886d45a5c368d9
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L71

declaration:
isDifferenceFeed = (feed: Feed): feed is DifferenceFeed =>
  feed[0] === FeedType.Difference

summary:
A type guard function that checks if a given feed is a DifferenceFeed. It returns true if the first element of the feed array matches FeedType.Difference, confirming the feed is of type DifferenceFeed.

details:
This is a simple type predicate function that implements a type guard pattern in TypeScript. It examines the first element (index 0) of the feed array and compares it to the FeedType.Difference enum value. The function uses an arrow function with a straightforward comparison expression that returns a boolean result.

related: FeedType,Difference,Feed

import/access examples:
import { isDifferenceFeed } from '@welshman/feeds';
import { isDifferenceFeed } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 73:73
id: 6bd32abafd3ca88ac8bc1f1790b3d5daa9b79794b66a8deff122300af0446980
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L73

declaration:
isIDFeed = (feed: Feed): feed is IDFeed => feed[0] === FeedType.ID

summary:
A type guard function that checks if a given feed is an IDFeed. It returns true if the first element of the feed array matches FeedType.ID, confirming the feed is specifically an IDFeed type.

details:
This is a simple type predicate function that performs a runtime check on the feed's discriminant (the first element of the array). It uses TypeScript's type narrowing capabilities through the 'feed is IDFeed' return type annotation to help the compiler understand the type of the feed in conditional blocks after this check is performed.

related: FeedType,ID,Feed

import/access examples:
import { isIDFeed } from '@welshman/feeds';
import { isIDFeed } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 74:75
id: 869504fba2066ac89d2aee8c2886fad16609698ca5c6397dca9e098fa946c2b0
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L74

declaration:
isIntersectionFeed = (feed: Feed): feed is IntersectionFeed =>
  feed[0] === FeedType.Intersection

summary:
A type guard function that checks if a given feed is an IntersectionFeed. It returns true if the first element of the feed array is FeedType.Intersection, confirming that the feed is of type IntersectionFeed.

details:
This is a simple type predicate function that implements a type guard pattern in TypeScript. It examines the first element of the feed array (feed[0]) and compares it to the FeedType.Intersection enum value. The function is implemented as an arrow function with a straightforward boolean expression.

related: FeedType,Intersection,Feed

import/access examples:
import { isIntersectionFeed } from '@welshman/feeds';
import { isIntersectionFeed } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 76:76
id: f782adebd42984fcafe0a2babc084041363ada4e9c2ada211ed4c29f6efb6f69
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L76

declaration:
isGlobalFeed = (feed: Feed): feed is GlobalFeed => feed[0] === FeedType.Global

summary:
A type guard function that checks if a given feed is a GlobalFeed. It returns true if the first element of the feed array is FeedType.Global, confirming the feed is of type GlobalFeed.

details:
This is a simple type predicate function that examines the first element (index 0) of the feed array and compares it to the FeedType.Global enum value. It uses TypeScript's type narrowing capabilities through the 'feed is GlobalFeed' return type annotation to help the compiler understand the type of the feed when this function returns true.

related: FeedType,Global,Feed

import/access examples:
import { isGlobalFeed } from '@welshman/feeds';
import { isGlobalFeed } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 77:77
id: 556b5981d9055cdf7cf411a7003e55a415cce9070c6749d7d3f76b71dd2acad5
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L77

declaration:
isKindFeed = (feed: Feed): feed is KindFeed => feed[0] === FeedType.Kind

summary:
A type guard function that checks if a given feed is a KindFeed. It returns true if the first element of the feed array matches FeedType.Kind, confirming the feed is specifically a KindFeed type.

details:
This is a simple type predicate function that implements a type guard pattern in TypeScript. It examines the first element (index 0) of the feed array and compares it to the FeedType.Kind enum value. When this function returns true, TypeScript will narrow the type of the feed parameter from the generic Feed type to the more specific KindFeed type in the scope where the check is performed.

related: FeedType,Kind,Feed

import/access examples:
import { isKindFeed } from '@welshman/feeds';
import { isKindFeed } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 78:78
id: cf06bdb80e7f667e9fb3a6fcb1470687f01d3d598b33bdcfb0695bcc4fd8d443
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L78

declaration:
isListFeed = (feed: Feed): feed is ListFeed => feed[0] === FeedType.List

summary:
A type guard function that checks if a given feed is a ListFeed. It returns true if the feed's first element matches FeedType.List, confirming the feed is of ListFeed type.

details:
This is a simple type predicate function that examines the first element (index 0) of the feed array and compares it to the FeedType.List enum value. TypeScript uses this return type (feed is ListFeed) to narrow the type in conditional blocks where this function returns true.

related: FeedType,List,Feed

import/access examples:
import { isListFeed } from '@welshman/feeds';
import { isListFeed } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 79:79
id: 22b159d99dbc3ab5c4da0ee641af030d5a10f503f7c9fdbd623d8d1b055991c3
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L79

declaration:
isLabelFeed = (feed: Feed): feed is LabelFeed => feed[0] === FeedType.Label

summary:
A type guard function that checks if a given feed is a LabelFeed. It returns true if the first element of the feed array matches FeedType.Label, confirming the feed is specifically a LabelFeed type.

details:
This is a simple type predicate function that implements a type guard pattern in TypeScript. It examines the first element (index 0) of the feed array and compares it with the FeedType.Label enum value. The function uses TypeScript's type narrowing feature through the 'feed is LabelFeed' return type annotation to help the compiler understand the type of the feed in conditional blocks after this function is used.

related: FeedType,Label,Feed

import/access examples:
import { isLabelFeed } from '@welshman/feeds';
import { isLabelFeed } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 80:80
id: d08338fc3596f2209f0e0e94a7b64ab17d2303c4434735d3e6d7c2a03307da67
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L80

declaration:
isWOTFeed = (feed: Feed): feed is WOTFeed => feed[0] === FeedType.WOT

summary:
A type guard function that checks if a given feed is a WOT (Web of Trust) feed. It returns true if the feed's first element matches the FeedType.WOT enum value, confirming the feed is of WOT type.

details:
This is a simple type predicate function that performs a type check by examining the first element of the feed array. It uses TypeScript's type narrowing capabilities to assert that if the condition is true, the feed parameter can be safely treated as a WOTFeed in the scope where this function returns true.

related: FeedType,WOT,Feed

import/access examples:
import { isWOTFeed } from '@welshman/feeds';
import { isWOTFeed } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 81:81
id: d7a0dcc71e5d2aaa876e306f96683e970756aeba24a38817f7a318d507c83d8e
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L81

declaration:
isRelayFeed = (feed: Feed): feed is RelayFeed => feed[0] === FeedType.Relay

summary:
A type guard function that checks if a given feed is a RelayFeed. It returns true if the feed's first element is of type FeedType.Relay, confirming that the feed is specifically a RelayFeed type.

details:
This is a simple type predicate function that performs a type check by examining the first element of the feed array. It compares this element against the FeedType.Relay enum value. The function uses TypeScript's type narrowing capabilities through the 'feed is RelayFeed' return type annotation to help the compiler understand the type of the feed in subsequent code when this function returns true.

related: FeedType,Relay,Feed

import/access examples:
import { isRelayFeed } from '@welshman/feeds';
import { isRelayFeed } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 82:82
id: 56e4a6afce16989f47a21d8071d5930ed87d75a475075ffa82f91c73b11b10c4
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L82

declaration:
isScopeFeed = (feed: Feed): feed is ScopeFeed => feed[0] === FeedType.Scope

summary:
A type guard function that checks if a given feed is a ScopeFeed. It returns true if the feed's first element is of type FeedType.Scope, confirming that the feed parameter is indeed a ScopeFeed.

details:
This is a simple type predicate function that examines the first element of the feed array to determine if it matches the FeedType.Scope enum value. It uses TypeScript's type narrowing capabilities through the 'feed is ScopeFeed' return type annotation to help the compiler understand the type of the feed in conditional blocks after this function is used.

related: FeedType,Scope,Feed

import/access examples:
import { isScopeFeed } from '@welshman/feeds';
import { isScopeFeed } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 83:83
id: 7693a911569c37ea53d8007b3888441ab495ce0101e484da681072ee440b74cb
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L83

declaration:
isSearchFeed = (feed: Feed): feed is SearchFeed => feed[0] === FeedType.Search

summary:
A type guard function that checks if a given feed is a SearchFeed. It returns true if the first element of the feed array is FeedType.Search, confirming the feed is specifically a SearchFeed type.

details:
This is a simple type predicate function that implements a type guard pattern in TypeScript. It examines the first element (index 0) of the feed array and compares it to the FeedType.Search enum value. The function uses TypeScript's type narrowing capability with the 'feed is SearchFeed' return type annotation to help the compiler understand the type of the feed in conditional blocks after this function is used.

related: FeedType,Search,Feed

import/access examples:
import { isSearchFeed } from '@welshman/feeds';
import { isSearchFeed } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 84:84
id: 837995aa89b159e8ecd25e1cf077a80f68a47aceb5aa506f0412b198ee41d026
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L84

declaration:
isTagFeed = (feed: Feed): feed is TagFeed => feed[0] === FeedType.Tag

summary:
A type guard function that checks if a given feed is a TagFeed. It returns true if the feed's first element is of type FeedType.Tag, confirming that the feed is a TagFeed.

details:
This is a simple type predicate function that examines the first element of the feed array to determine if it matches the FeedType.Tag enum value. It uses TypeScript's type narrowing capabilities to assert that if the function returns true, the feed parameter can be safely treated as a TagFeed in the calling code.

related: FeedType,Tag,Feed

import/access examples:
import { isTagFeed } from '@welshman/feeds';
import { isTagFeed } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 85:85
id: 7a0bea614582924c5eccff5971d763b6c16db752698edbf238013831aa5fc6ec
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L85

declaration:
isUnionFeed = (feed: Feed): feed is UnionFeed => feed[0] === FeedType.Union

summary:
A type guard function that checks if a given feed is a UnionFeed. It returns true if the first element of the feed array matches FeedType.Union, confirming the feed is of UnionFeed type.

details:
This is a simple type predicate function that performs a runtime check on the feed parameter by examining the first element (index 0) of the array. It compares this value with FeedType.Union enum value. The TypeScript type system uses this function to narrow the type of the feed parameter from the generic Feed type to the more specific UnionFeed type when the condition is true.

related: FeedType,Union,Feed

import/access examples:
import { isUnionFeed } from '@welshman/feeds';
import { isUnionFeed } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 87:87
id: b52579546e06fa1bee46c379eba1cb0754ab9bb610eab35987f4c99fde556d1f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L87

declaration:
export function getFeedArgs(feed: IntersectionFeed | UnionFeed | DifferenceFeed): Feed[]

summary:
Extracts and returns the arguments from a feed based on its type. This function is overloaded to handle different feed types and return their respective argument types. For example, it returns Feed[] for IntersectionFeed, UnionFeed, or DifferenceFeed, string[] for AddressFeed, AuthorFeed, etc., and specialized item arrays for other feed types.

details:
The implementation uses a switch statement to handle different feed types. For each feed type, it slices the feed array starting from index 1 (skipping the feed type identifier at index 0) and casts the result to the appropriate return type. The function handles all feed types defined in the FeedType enum and throws an error for invalid feed types.

The function is implemented with multiple overload signatures to provide proper type checking and intellisense for different feed types, ensuring type safety when working with the returned values.

related: IntersectionFeed,UnionFeed,DifferenceFeed,Feed

import/access examples:
import { getFeedArgs } from '@welshman/feeds';
import { getFeedArgs } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 88:90
id: 217e90c23a991d15f348871ca409c539d58a216fdb04b54f307436c3c23c643d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L88

declaration:
export function getFeedArgs(
  feed: AddressFeed | AuthorFeed | IDFeed | RelayFeed | SearchFeed,
): string[]

summary:
Extracts the arguments from a feed based on its type. This overload specifically handles AddressFeed, AuthorFeed, IDFeed, RelayFeed, and SearchFeed types, returning their arguments as an array of strings.

details:
This function is part of a larger set of overloads for the `getFeedArgs` function. The implementation (defined at lines 100-139) uses a switch statement to determine the feed type and returns the appropriate slice of the feed array, casting it to the correct type. For the feed types in this specific overload (Address, Author, ID, Relay, Search), it returns the feed elements after the first element (which is the feed type) as an array of strings.

import/access examples:
import { getFeedArgs } from '@welshman/feeds';
import { getFeedArgs } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 91:91
id: 7d2213849be20e8d478137fcca593d734eedf3cd47955ba033d8332ebb93a295
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L91

declaration:
export function getFeedArgs(feed: CreatedAtFeed): CreatedAtItem[]

summary:
Extracts the arguments from a CreatedAtFeed. This function takes a CreatedAtFeed as input and returns an array of CreatedAtItem objects that were used to create the feed. CreatedAtItem objects typically contain timestamp constraints like 'since' and 'until'.

details:
This is one of multiple overloads for the getFeedArgs function, which extracts the arguments from different types of feeds. For CreatedAtFeed specifically, it returns the array of CreatedAtItem objects by slicing off the first element of the feed array (which is the feed type identifier) and casting the result to the appropriate type. The implementation is part of a switch statement in the main getFeedArgs function body that handles all feed types.

import/access examples:
import { getFeedArgs } from '@welshman/feeds';
import { getFeedArgs } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 92:92
id: 0c316af4b0488a1c37b01f6d9a216c901be1f23fb1a638636c4130d3b4cb3a19
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L92

declaration:
export function getFeedArgs(feed: ListFeed): ListItem[]

summary:
Extracts and returns the list items from a ListFeed. This function is part of a larger set of overloaded functions that extract arguments from different feed types.

details:
This function is one of multiple overloaded implementations of `getFeedArgs`, which extracts the arguments from different feed types. For a ListFeed specifically, it returns the list items by slicing off the first element (the feed type) from the feed array. The actual implementation is in the function body starting at line 100, where a switch statement handles all feed types. For ListFeed (case FeedType.List at line 122), it returns `feed.slice(1) as ListItem[]`.

import/access examples:
import { getFeedArgs } from '@welshman/feeds';
import { getFeedArgs } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 93:93
id: 7fca3e9c7cef1069f57631484bda5cf81c57ae6f514bacf53210a6518ff6503d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L93

declaration:
export function getFeedArgs(feed: LabelFeed): LabelItem[]

summary:
Extracts and returns the arguments from a LabelFeed. This function takes a LabelFeed as input and returns an array of LabelItem objects that were used to create the feed.

details:
This is one of multiple overloaded implementations of the `getFeedArgs` function. The actual implementation is in lines 100-139, which handles all feed types through a switch statement. For a LabelFeed specifically, it returns the feed array elements after the first element (which is the feed type identifier) cast to LabelItem[]. The implementation slices the array starting from index 1 to extract all the label items that were passed when creating the feed.

import/access examples:
import { getFeedArgs } from '@welshman/feeds';
import { getFeedArgs } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 94:94
id: 77e01bc8319bc2593464af0592d1ad07a02b4b2f3236ab6b57af5f00825cbeb2
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L94

declaration:
export function getFeedArgs(feed: DVMFeed): DVMItem[]

summary:
Extracts the arguments from a DVMFeed. This function takes a DVMFeed as input and returns an array of DVMItem objects that were used to create the feed.

details:
This is one of multiple overloaded implementations of the `getFeedArgs` function. The actual implementation is in lines 100-139, which handles all feed types through a switch statement. For DVMFeed specifically, it returns the feed array elements after the first element (which is the feed type) cast to DVMItem[].

import/access examples:
import { getFeedArgs } from '@welshman/feeds';
import { getFeedArgs } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 95:95
id: 7fa3b4771313f4baa22c302c2d494318fe45d8df040045b33d78a9da3ef6b29f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L95

declaration:
export function getFeedArgs(feed: WOTFeed): WOTItem[]

summary:
Extracts and returns the arguments from a WOTFeed. This function takes a WOTFeed as input and returns an array of WOTItem objects that were used to create the feed.

details:
This function is part of a larger overloaded function that handles different feed types. For WOTFeed specifically (case FeedType.WOT in the implementation), it slices the feed array starting from index 1 to extract all WOTItems that were passed when creating the feed. The implementation uses array slicing and type casting to return the appropriate data type.

import/access examples:
import { getFeedArgs } from '@welshman/feeds';
import { getFeedArgs } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 96:96
id: e300aa0e7058884f9a8c78e5283cc59bb7137724c706fa8dfaaf459aaa71732b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L96

declaration:
export function getFeedArgs(feed: ScopeFeed): Scope[]

summary:
Extracts and returns the arguments from a ScopeFeed. This function takes a ScopeFeed as input and returns an array of Scope objects that were used to create the feed, excluding the feed type identifier.

details:
This is one of multiple overloaded declarations for the `getFeedArgs` function, which is implemented at lines 100-139. The implementation extracts the arguments from different types of feeds by slicing off the first element (which is the feed type) and casting the result to the appropriate type. For ScopeFeed specifically, it returns the feed elements starting from index 1, cast as Scope[].

import/access examples:
import { getFeedArgs } from '@welshman/feeds';
import { getFeedArgs } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 97:97
id: 6586910f4ca443503546f76192ae55d364813b0f295a28ec5a34978da73a3f30
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L97

declaration:
export function getFeedArgs(feed: KindFeed): number[]

summary:
Extracts and returns the arguments from a KindFeed. This function takes a KindFeed object and returns an array of kind numbers that were used to create the feed.

details:
This is one of multiple overloaded implementations of the `getFeedArgs` function. When called with a KindFeed, it returns the array of kind numbers by slicing off the first element (the feed type) from the feed array. The actual implementation is in the function body starting at line 100, where a switch statement handles different feed types. For KindFeed specifically, the case at line 132-133 handles the extraction by returning `feed.slice(1) as number[]`.

import/access examples:
import { getFeedArgs } from '@welshman/feeds';
import { getFeedArgs } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 98:98
id: a41a682d473a4f4a3dc47816a85cf3776f2af69b5f9f1275a24bd817a98c95a8
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L98

declaration:
export function getFeedArgs(feed: TagFeed): [string, ...string[]]

summary:
Extracts the arguments from a TagFeed. This function takes a TagFeed as input and returns a tuple containing the tag key as the first element followed by any tag values.

details:
This is one of multiple overloaded implementations of the `getFeedArgs` function, which extracts the arguments from different types of feeds. For TagFeed specifically, it returns a tuple with the tag key as the first element followed by any tag values. The actual implementation is in the main function body (lines 100-139) where it uses a switch statement to handle different feed types, and for TagFeed (case FeedType.Tag), it returns `feed.slice(1)` cast to the appropriate type `[string, ...string[]]`.

import/access examples:
import { getFeedArgs } from '@welshman/feeds';
import { getFeedArgs } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 99:99
id: 752a555a4a0d4dcacc33b0aa94f055bee49a6ceac168b0cb62ec32db6c5ccd57
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L99

declaration:
export function getFeedArgs(feed: GlobalFeed): []

summary:
Extracts the arguments from a GlobalFeed. This function is part of a larger overloaded function that extracts arguments from various feed types. For a GlobalFeed, it returns an empty array since GlobalFeed doesn't have any arguments.

details:
This is one of the overload signatures for the `getFeedArgs` function, which handles different feed types. The implementation of this function is in the body starting at line 100. For GlobalFeed specifically, it returns an empty array by slicing the feed array starting from index 1, which effectively removes the FeedType.Global element at index 0 and returns the rest (which is empty for GlobalFeed).

import/access examples:
import { getFeedArgs } from '@welshman/feeds';
import { getFeedArgs } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 100:139
id: e04e5c30a500c0932e941502cf6cb01a3bb35e30adc4b39f5f6319168783472b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L100

declaration:
export function getFeedArgs(feed: Feed)

summary:
Extracts and returns the arguments from a given feed based on its type. This function handles various feed types (Intersection, Union, Difference, Address, Author, etc.) and returns the appropriate data type for each feed type. It removes the feed type indicator (first element) and returns the remaining elements cast to the appropriate type.

details:
This function implements a type-safe way to extract arguments from different feed types. It:

1. Uses a switch statement to handle each possible FeedType
2. For each case, it slices the feed array starting from index 1 (skipping the feed type indicator)
3. Casts the sliced array to the appropriate return type based on the feed type
4. Throws an error for invalid feed types

The function is heavily overloaded (as seen in lines 87-99) to provide proper type safety for different feed types, ensuring that the returned value has the correct TypeScript type for each feed variant.

code:
export function getFeedArgs(feed: Feed) {
  switch (feed[0]) {
    case FeedType.Intersection:
      return feed.slice(1) as Feed[]
    case FeedType.Union:
      return feed.slice(1) as Feed[]
    case FeedType.Difference:
      return feed.slice(1) as Feed[]
    case FeedType.Address:
      return feed.slice(1) as string[]
    case FeedType.Author:
      return feed.slice(1) as string[]
    case FeedType.ID:
      return feed.slice(1) as string[]
    case FeedType.Relay:
      return feed.slice(1) as string[]
    case FeedType.Search:
      return feed.slice(1) as string[]
    case FeedType.Tag:
      return feed.slice(1) as [string, ...string[]]
    case FeedType.CreatedAt:
      return feed.slice(1) as CreatedAtItem[]
    case FeedType.List:
      return feed.slice(1) as ListItem[]
    case FeedType.Label:
      return feed.slice(1) as LabelItem[]
    case FeedType.DVM:
      return feed.slice(1) as DVMItem[]
    case FeedType.WOT:
      return feed.slice(1) as WOTItem[]
    case FeedType.Scope:
      return feed.slice(1) as Scope[]
    case FeedType.Kind:
      return feed.slice(1) as number[]
    case FeedType.Global:
      return feed.slice(1) as never[]
    default:
      throw new Error(`Invalid feed type ${feed[0]}`)
  }
}

import/access examples:
import { getFeedArgs } from '@welshman/feeds';
import { getFeedArgs } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 141:142
id: 46be01ee3d3026100e74ef9aeed789f65f305621aeef960c9cc3b73c3ca33e9b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L141

declaration:
hasSubFeeds = (feed: Feed): feed is IntersectionFeed | UnionFeed | DifferenceFeed =>
  [FeedType.Union, FeedType.Intersection, FeedType.Difference].includes(feed[0])

summary:
The `hasSubFeeds` function is a type guard that checks if a feed is a composite feed type (IntersectionFeed, UnionFeed, or DifferenceFeed). It returns a boolean indicating whether the feed contains sub-feeds that can be further processed or traversed.

details:
This function implements a simple type predicate that examines the first element of the feed array (which represents the feed type) and checks if it's one of the composite feed types (Union, Intersection, or Difference). It uses the JavaScript `includes()` method to perform this check against an array of the relevant FeedType enum values. The function is used in feed traversal operations like `walkFeed` and `findFeed` to determine whether a feed needs to be recursively processed.

related: FeedType,Union,Intersection,Difference,Feed

import/access examples:
import { hasSubFeeds } from '@welshman/feeds';
import { hasSubFeeds } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 144:150
id: 4e98d50e177a380aa9ac2269c18dce967a3ffc72433a88bb797fd9532fe5e0c1
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L144

declaration:
defaultTagFeedMappings: TagFeedMapping[] = [
  ["a", [FeedType.Address]],
  ["e", [FeedType.ID]],
  ["p", [FeedType.Author]],
  ["r", [FeedType.Relay]],
  ["t", [FeedType.Tag, "#t"]],
]

summary:
A constant array of default tag feed mappings used to convert Nostr tags to feed types. Each mapping is a tuple where the first element is a tag name (like 'a', 'e', 'p', etc.) and the second element is a template feed that specifies how to interpret the tag values. These mappings are used by functions like `feedsFromTags` to convert tag arrays into appropriate feed objects.

details:
The `defaultTagFeedMappings` array contains standard Nostr tag mappings:

1. 'a' tags map to Address feeds
2. 'e' tags map to ID feeds
3. 'p' tags map to Author feeds
4. 'r' tags map to Relay feeds
5. 't' tags map to Tag feeds with '#t' prefix

These mappings follow Nostr protocol conventions where specific single-letter tags have standardized meanings. The array is used as a default parameter in functions that convert between tag formats and feed objects when no custom mappings are provided.

related: FeedType,Address,ID,Author,Relay,Tag,TagFeedMapping

import/access examples:
import { defaultTagFeedMappings } from '@welshman/feeds';
import { defaultTagFeedMappings } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 152:168
id: ab2bb85d54fbb4c77fc62ff35f0be679ab9247c2786b4810d548f4886386d188
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L152

declaration:
feedsFromTags = (tags: string[][], mappings?: TagFeedMapping[]) => {
  const feeds = []

  for (const [tagName, templateFeed] of mappings || defaultTagFeedMappings) {
    let values: any[] = getTagValues(tagName, tags)

    if (values.length > 0) {
      if (isKindFeed(templateFeed)) {
        values = values.map(ensureNumber) as number[]
      }

      feeds.push([...templateFeed, ...values] as Feed)
    }
  }

  return feeds
}

summary:
Converts an array of tags into an array of Feed objects based on provided mappings. Each tag is transformed into a specific feed type according to the mapping rules. If no mappings are provided, it uses defaultTagFeedMappings. The function processes each tag name in the mappings, extracts values for that tag, and creates appropriate feed objects.

details:
Implementation details:
1. Takes an array of string arrays (tags) and optional tag feed mappings
2. Uses defaultTagFeedMappings if no mappings are provided
3. Iterates through each mapping (tagName and templateFeed)
4. For each mapping:
   - Gets values for the specific tag name using getTagValues
   - If values exist:
     - Converts values to numbers if the template is a KindFeed
     - Creates a new feed by combining the template feed with the values
5. Returns an array of constructed Feed objects

The function handles special case for KindFeed where string values need to be converted to numbers using ensureNumber.

related: TagFeedMapping,AddressFeed,Address,AuthorFeed,Author,CreatedAtFeed,CreatedAt,CreatedAtItem,DVMFeed,DVM,DVMItem,DifferenceFeed,Difference,Feed,IDFeed,ID,IntersectionFeed,Intersection,GlobalFeed,Global,KindFeed,Kind,ListFeed,List,ListItem,LabelFeed,Label,LabelItem,WOTFeed,WOT,WOTItem,RelayFeed,Relay,ScopeFeed,Scope,Scope,Followers,Follows,Network,Self,SearchFeed,Search,TagFeed,Tag,UnionFeed,Union

import/access examples:
import { feedsFromTags } from '@welshman/feeds';
import { feedsFromTags } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 170:171
id: cec5949b713bf815838c83ea418175db8113b5187a198bff2962f060f5e3e42a
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L170

declaration:
feedFromTags = (tags: string[][], mappings?: TagFeedMapping[]) =>
  makeIntersectionFeed(...feedsFromTags(tags, mappings))

summary:
The `feedFromTags` function creates an intersection feed from a collection of tags. It takes an array of string arrays (`tags`) representing tag data and an optional array of tag feed mappings (`mappings`). It returns a feed that represents the intersection of all feeds generated from the provided tags.

details:
This function is a simple wrapper around two other functions:

1. It first calls `feedsFromTags(tags, mappings)` to convert the tag data into an array of feeds based on the provided mappings (or default mappings if none are provided)
2. Then it spreads these feeds as arguments to `makeIntersectionFeed()` to create a single intersection feed that combines all the individual feeds

The implementation is a one-liner that chains these operations together, making it a convenient utility for creating intersection feeds from tag data.

related: __function,makeIntersectionFeed,TagFeedMapping,IntersectionFeed,Intersection,Feed,AddressFeed,Address,AuthorFeed,Author,CreatedAtFeed,CreatedAt,CreatedAtItem,DVMFeed,DVM,DVMItem,DifferenceFeed,Difference,IDFeed,ID,GlobalFeed,Global,KindFeed,Kind,ListFeed,List,ListItem,LabelFeed,Label,LabelItem,WOTFeed,WOT,WOTItem,RelayFeed,Relay,ScopeFeed,Scope,Scope,Followers,Follows,Network,Self,SearchFeed,Search,TagFeed,Tag,UnionFeed,Union

import/access examples:
import { feedFromTags } from '@welshman/feeds';
import { feedFromTags } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 173:193
id: c597f663d4f138b8f0b0fffc902ea3255b931e1aab62d6a5f3da619407343724
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L173

declaration:
feedsFromFilter = ({since, until, ...filter}: Filter) => {
  const feeds = []

  if (since && until) {
    feeds.push(makeCreatedAtFeed({since, until}))
  } else if (since) {
    feeds.push(makeCreatedAtFeed({since}))
  } else if (until) {
    feeds.push(makeCreatedAtFeed({until}))
  }

  for (const [k, v] of Object.entries(filter)) {
    if (k === "ids") feeds.push(makeIDFeed(...(v as string[])))
    else if (k === "kinds") feeds.push(makeKindFeed(...(v as number[])))
    else if (k === "authors") feeds.push(makeAuthorFeed(...(v as string[])))
    else if (k.startsWith("#")) feeds.push(makeTagFeed(k as string, ...(v as string[])))
    else throw new Error(`Unable to create feed from filter ${k}: ${v}`)
  }

  return feeds
}

summary:
The `feedsFromFilter` function converts a Filter object into an array of Feed objects. It handles time-based filters (since, until) by creating CreatedAtFeed objects, and processes standard filter fields (ids, kinds, authors) and tag filters (starting with '#') by creating appropriate Feed objects. The function throws an error for unrecognized filter keys.

details:
The implementation works in two main steps:

1. First, it handles time-based filters by checking for `since` and `until` properties:
   - If both exist, creates a CreatedAtFeed with both parameters
   - If only one exists, creates a CreatedAtFeed with just that parameter

2. Then it iterates through the remaining filter properties using Object.entries():
   - For standard fields (ids, kinds, authors), it creates corresponding Feed objects using helper functions
   - For tag filters (keys starting with '#'), it creates TagFeed objects
   - For any other filter key, it throws an error with details about the unrecognized filter

The function returns an array of all created Feed objects, which can later be combined into more complex feed structures.

related: AuthorFeed,Author,CreatedAtFeed,CreatedAt,CreatedAtItem,IDFeed,ID,KindFeed,Kind,TagFeed,Tag

import/access examples:
import { feedsFromFilter } from '@welshman/feeds';
import { feedsFromFilter } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 195:199
id: ee43f3ae110cad2e356488d0fa6af28f81894cf6f052088b5a58499538c309a8
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L195

declaration:
feedFromFilter = (filter: Filter) => {
  const feeds = feedsFromFilter(filter)

  return feeds.length === 1 ? feeds[0] : makeIntersectionFeed(...feeds)
}

summary:
Converts a Filter object into a Feed. If the filter results in multiple feeds, they are combined into an IntersectionFeed. If only one feed is generated, it is returned directly.

details:
This function works by:
1. Calling `feedsFromFilter` to convert the Filter object into an array of Feed objects
2. Checking the length of the resulting feeds array
3. If there's only one feed, returning it directly
4. If there are multiple feeds, combining them into an IntersectionFeed using the makeIntersectionFeed function

This creates a feed that represents the intersection of all conditions specified in the filter.

related: AuthorFeed,Author,CreatedAtFeed,CreatedAt,CreatedAtItem,IDFeed,ID,IntersectionFeed,Intersection,Feed,AddressFeed,Address,DVMFeed,DVM,DVMItem,DifferenceFeed,Difference,GlobalFeed,Global,KindFeed,Kind,ListFeed,List,ListItem,LabelFeed,Label,LabelItem,WOTFeed,WOT,WOTItem,RelayFeed,Relay,ScopeFeed,Scope,Scope,Followers,Follows,Network,Self,SearchFeed,Search,TagFeed,Tag,UnionFeed,Union

import/access examples:
import { feedFromFilter } from '@welshman/feeds';
import { feedFromFilter } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 201:205
id: f77ee3b9ffd63ba4c3e7180036f3731016aebf2bd9052b18cec82f790ad177db
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L201

declaration:
feedFromFilters = (filters: Filter[]) => {
  const feeds = unionFilters(filters).map(filter => feedFromFilter(filter))

  return feeds.length === 1 ? feeds[0] : makeUnionFeed(...feeds)
}

summary:
Creates a feed from an array of filters. The function takes an array of Filter objects, combines them using unionFilters, converts each filter to a feed, and returns either a single feed (if only one exists) or a union of multiple feeds.

details:
The implementation works in three steps:
1. It uses the unionFilters utility to combine the array of filters into a unified set
2. Maps each filter to a feed using the feedFromFilter function
3. Returns either the single feed (if only one exists) or creates a union feed with makeUnionFeed if multiple feeds exist

This function effectively transforms filter-based queries into the feed data structure, handling the case of multiple filters by creating a union relationship between them.

related: AuthorFeed,Author,CreatedAtFeed,CreatedAt,CreatedAtItem,IDFeed,ID,IntersectionFeed,Intersection,Feed,AddressFeed,Address,DVMFeed,DVM,DVMItem,DifferenceFeed,Difference,GlobalFeed,Global,KindFeed,Kind,ListFeed,List,ListItem,LabelFeed,Label,LabelItem,WOTFeed,WOT,WOTItem,RelayFeed,Relay,ScopeFeed,Scope,Scope,Followers,Follows,Network,Self,SearchFeed,Search,TagFeed,Tag,UnionFeed,Union

import/access examples:
import { feedFromFilters } from '@welshman/feeds';
import { feedFromFilters } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 207:215
id: 10a153c06f1e7dfb9cbe3ae7342ac79256af0073798b7c6d70a1868123caabf1
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L207

declaration:
walkFeed = (feed: Feed, visit: (feed: Feed) => void) => {
  visit(feed)

  if (hasSubFeeds(feed)) {
    for (const subFeed of getFeedArgs(feed)) {
      walkFeed(subFeed, visit)
    }
  }
}

summary:
The `walkFeed` function traverses a feed structure recursively, applying a visitor function to each feed encountered. It takes two parameters: a `feed` object representing the feed structure to traverse, and a `visit` callback function that will be called for each feed node in the structure. This function is useful for performing operations on all feeds in a potentially nested feed structure.

details:
The implementation uses a depth-first traversal approach:

1. First, it calls the visitor function on the current feed
2. Then, it checks if the current feed has sub-feeds using the `hasSubFeeds` helper function
3. If sub-feeds exist, it retrieves them using `getFeedArgs` and recursively calls `walkFeed` on each sub-feed

This allows for complete traversal of complex feed structures that may contain nested union, intersection, or difference feeds.

related: Feed

import/access examples:
import { walkFeed } from '@welshman/feeds';
import { walkFeed } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 217:229
id: 22b628678abd317abc5d01de59b02a117db49c6cb9f5549562186c93d0e62c1d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L217

declaration:
findFeed = (feed: Feed, match: (feed: Feed) => boolean): Feed | undefined => {
  if (match(feed)) return feed

  if (hasSubFeeds(feed)) {
    for (const subFeed of getFeedArgs(feed)) {
      const found = findFeed(subFeed, match)

      if (found) {
        return found
      }
    }
  }
}

summary:
The `findFeed` function recursively searches through a feed structure to find the first feed that matches a given predicate. It takes two parameters: a `feed` to search through and a `match` function that returns a boolean when applied to a feed. The function returns the first matching feed or undefined if no match is found.

details:
The implementation uses a depth-first search approach:

1. First checks if the current feed matches the predicate, returning it immediately if it does
2. If the current feed has sub-feeds (determined by `hasSubFeeds`), it recursively searches through each sub-feed
3. For each sub-feed, it calls `findFeed` recursively and returns the first match found
4. If no match is found in any sub-feed, the function implicitly returns undefined

The function leverages `hasSubFeeds` and `getFeedArgs` utility functions to determine if a feed contains nested feeds and to extract those nested feeds for traversal.

related: Feed,AddressFeed,Address,AuthorFeed,Author,CreatedAtFeed,CreatedAt,CreatedAtItem,DVMFeed,DVM,DVMItem,DifferenceFeed,Difference,IDFeed,ID,IntersectionFeed,Intersection,GlobalFeed,Global,KindFeed,Kind,ListFeed,List,ListItem,LabelFeed,Label,LabelItem,WOTFeed,WOT,WOTItem,RelayFeed,Relay,ScopeFeed,Scope,Scope,Followers,Follows,Network,Self,SearchFeed,Search,TagFeed,Tag,UnionFeed,Union

import/access examples:
import { findFeed } from '@welshman/feeds';
import { findFeed } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/utils.ts
lines: 231:287
id: 399270e4c8f1fa2d57f3fdc01b7b9db41eaa4e6adf814070ab2376089ffcdd07
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts#L231

declaration:
simplifyFeed = (feed: Feed): Feed => {
  if (isUnionFeed(feed)) {
    const args = getFeedArgs(feed)

    if (args.length === 1) return simplifyFeed(args[0])

    const modified: Feed[] = []

    for (const sub of args.map(simplifyFeed)) {
      if (isUnionFeed(sub)) {
        modified.push(...getFeedArgs(sub))
      } else {
        modified.push(sub)
      }
    }

    return makeUnionFeed(...modified)
  }

  if (isIntersectionFeed(feed)) {
    const args = getFeedArgs(feed)

    if (args.length === 1) return simplifyFeed(args[0])

    const modified: Feed[] = []

    for (const sub of args.map(simplifyFeed)) {
      if (isIntersectionFeed(sub)) {
        modified.push(...getFeedArgs(sub))
      } else {
        modified.push(sub)
      }
    }

    return makeIntersectionFeed(...modified)
  }

  if (isDifferenceFeed(feed)) {
    const args = getFeedArgs(feed)

    if (args.length === 1) return simplifyFeed(args[0])

    const modified: Feed[] = []

    for (const sub of args.map(simplifyFeed)) {
      if (isDifferenceFeed(sub)) {
        modified.push(...getFeedArgs(sub))
      } else {
        modified.push(sub)
      }
    }

    return makeDifferenceFeed(...modified)
  }

  return feed
}

summary:
Simplifies a Feed structure by flattening nested feeds of the same type. Takes a Feed object as input and returns a simplified Feed. It handles UnionFeed, IntersectionFeed, and DifferenceFeed types by collapsing nested feeds of the same type into a single level. If a feed contains only one argument, it's replaced with that argument after simplification.

details:
The implementation recursively processes feed structures with three main cases:

1. For UnionFeed types:
   - If the feed has only one argument, simplify and return that argument
   - Otherwise, create a new array and process each sub-feed
   - If a sub-feed is also a UnionFeed, extract and add its arguments directly
   - Otherwise, add the simplified sub-feed to the array
   - Return a new UnionFeed with the flattened arguments

2. For IntersectionFeed types:
   - Similar logic to UnionFeed but for intersection operations

3. For DifferenceFeed types:
   - Similar logic to the other feed types but for difference operations

If the feed is not one of these composite types, it's returned unchanged. The function uses type guards (isUnionFeed, isIntersectionFeed, isDifferenceFeed) and getFeedArgs to handle the different feed types appropriately.

related: Feed,AddressFeed,Address,AuthorFeed,Author,CreatedAtFeed,CreatedAt,CreatedAtItem,DVMFeed,DVM,DVMItem,DifferenceFeed,Difference,IDFeed,ID,IntersectionFeed,Intersection,GlobalFeed,Global,KindFeed,Kind,ListFeed,List,ListItem,LabelFeed,Label,LabelItem,WOTFeed,WOT,WOTItem,RelayFeed,Relay,ScopeFeed,Scope,Scope,Followers,Follows,Network,Self,SearchFeed,Search,TagFeed,Tag,UnionFeed,Union

import/access examples:
import { simplifyFeed } from '@welshman/feeds';
import { simplifyFeed } from '@welshman/feeds/utils';


=========================
workspace: packages/feeds
file: packages/feeds/src/request.ts
lines: 17:25
id: 6836ca2b4138fd148e7f557ef81157f3e20654a586aba014b31bd7c34e0bef83
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/request.ts#L17

declaration:
export type RequestPageOptions = {
  filters: Filter[]
  onEvent: (event: TrustedEvent) => void
  relays?: string[]
  tracker?: Tracker
  signal?: AbortSignal
  context?: AdapterContext
  autoClose?: boolean
}

summary:
A type definition that specifies options for requesting a page of events from Nostr relays. It includes properties for filters to apply, a callback for handling events, optional relay URLs, a tracker for monitoring request progress, an abort signal for cancellation, a context for the adapter, and an autoClose flag to determine if connections should be closed after completion.

details:
This type alias defines the configuration object structure used by the `requestPage` function. It contains the following properties:
1. `filters`: An array of Filter objects that define what events to request
2. `onEvent`: A callback function that processes each trusted event as it arrives
3. `relays`: Optional array of relay URLs to query
4. `tracker`: Optional Tracker instance to monitor request progress
5. `signal`: Optional AbortSignal for cancellation support
6. `context`: Optional AdapterContext for network adapter configuration
7. `autoClose`: Optional boolean to control whether connections should be closed after completion

import/access examples:
import type { RequestPageOptions } from '@welshman/feeds/request';


=========================
workspace: packages/feeds
file: packages/feeds/src/request.ts
lines: 27:91
id: 6743a0a44b2697990e919e0fdc5b837168e2b0f0cd2c66df125d4360fa5b025a
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/request.ts#L27

declaration:
requestPage = async ({
  filters,
  onEvent,
  relays = [],
  tracker = new Tracker(),
  signal,
  context,
  autoClose,
}: RequestPageOptions) => {
  if (relays.length > 0) {
    return request({tracker, signal, context, onEvent, relays, filters, autoClose})
  }

  const promises: Promise<TrustedEvent[]>[] = []
  const [withSearch, withoutSearch] = partition(f => Boolean(f.search), filters)

  if (withSearch.length > 0) {
    promises.push(
      request({
        tracker,
        signal,
        context,
        onEvent,
        threshold: 0.1,
        autoClose,
        filters: withSearch,
        relays: Router.get().Search().getUrls(),
      }),
    )
  }

  if (withoutSearch.length > 0) {
    promises.push(
      ...getFilterSelections(filters).flatMap(({relays, filters}) =>
        request({
          tracker,
          signal,
          context,
          onEvent,
          relays,
          filters,
          threshold: 0.8,
          autoClose,
        }),
      ),
    )
  }

  // Break out selections by relay so we can complete early after a certain number
  // of requests complete for faster load times
  await race(withSearch.length > 0 ? 0.1 : 0.8, promises)

  // Wait until after we've queried the network to access our local cache. This results in less
  // snappy response times, but is necessary to prevent stale stuff that the user has already seen
  // from showing up at the top of the feed
  await request({
    tracker,
    signal,
    context,
    onEvent,
    filters,
    relays: [LOCAL_RELAY_URL],
    autoClose,
  })
}

summary:
An asynchronous function that requests events from relays based on provided filters. It accepts options including filters, an event handler, optional relay URLs, a tracker, abort signal, context, and auto-close flag. The function fetches events from specified relays or uses a smart routing strategy if no relays are provided, handling search filters separately and optimizing for faster load times.

details:
The implementation works in several stages:

1. If specific relays are provided, it simply forwards the request to those relays.
2. Otherwise, it uses a more sophisticated approach:
   - Splits filters into those with search parameters and those without
   - For search filters, it queries dedicated search relays with a low completion threshold (0.1)
   - For non-search filters, it uses router's filter selections to determine optimal relays with a higher completion threshold (0.8)
   - Uses the race function to allow early completion based on thresholds for faster response times
3. Finally, it queries the local relay cache (LOCAL_RELAY_URL) after network requests to prevent stale content from appearing at the top of results.

The function leverages the router system to intelligently select relays based on filter types and optimizes for both search and regular queries with different completion thresholds.

related: RequestPageOptions

import/access examples:
import { requestPage } from '@welshman/feeds/request';


=========================
workspace: packages/feeds
file: packages/feeds/src/request.ts
lines: 93:100
id: ee3edee549fdeb2ed41303f1833235be5c6da10a529b0e7bf4e49ff34b263a68
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/request.ts#L93

declaration:
export type RequestDVMOptions = {
  kind: number
  tags?: string[][]
  relays?: string[]
  signer?: ISigner
  context?: AdapterContext
  onResult: (event: TrustedEvent) => void
}

summary:
A type alias that defines the options for requesting a Data Verification Method (DVM) service. It includes properties for specifying the kind of request, optional tags, relays, signer, context, and a callback function to handle the result events.

details:
The `RequestDVMOptions` type defines the configuration parameters for the `requestDVM` function. It contains the following properties:

1. `kind`: A number representing the Nostr event kind to be used in the request
2. `tags`: Optional array of string arrays representing Nostr event tags
3. `relays`: Optional array of relay URLs to send the request to
4. `signer`: Optional ISigner interface implementation for signing the request (defaults to ephemeral signer)
5. `context`: Optional AdapterContext for network operations
6. `onResult`: A callback function that receives trusted events as they arrive

import/access examples:
import type { RequestDVMOptions } from '@welshman/feeds/request';


=========================
workspace: packages/feeds
file: packages/feeds/src/request.ts
lines: 102:146
id: 6797d598aea8de5d342893b81b1722a20f75f3b3a67cc0285fd4906015a4995f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/request.ts#L102

declaration:
requestDVM = async ({
  kind,
  onResult,
  tags = [],
  relays = [],
  signer = Nip01Signer.ephemeral(),
  context,
}: RequestDVMOptions) => {
  if (relays.length === 0) {
    const events = await request({
      autoClose: true,
      filters: [{kinds: [RELAYS], authors: getPubkeyTagValues(tags)}],
      relays: Router.get().Index().policy(addMinimalFallbacks).getUrls(),
    })

    relays = Router.get()
      .FromRelays(events.flatMap(e => getRelaysFromList(readList(asDecryptedEvent(e)))))
      .policy(addMinimalFallbacks)
      .getUrls()
  }

  if (!tags.some(nthEq(0, "expiration"))) {
    tags.push(["expiration", String(now() + 60)])
  }

  if (!tags.some(nthEq(0, "relays"))) {
    tags.push(["relays", ...relays])
  }

  if (!tags.some(nthEq(1, "user"))) {
    tags.push(["param", "user", await signer.getPubkey()])
  }

  if (!tags.some(nthEq(1, "max_results"))) {
    tags.push(["param", "max_results", "200"])
  }

  const event = await signer.sign(makeEvent(kind, {tags}))
  const filters = [{kinds: [event.kind + 1000], since: now() - 60, "#e": [event.id]}]

  return Promise.all([
    publish({event, relays, context}),
    request({filters, relays, context, autoClose: true, onEvent: onResult}),
  ])
}

summary:
Requests data from a Decentralized Virtual Machine (DVM) by creating and publishing an event, then listening for responses. Takes options including the event kind, callback for results, optional tags, relays, signer, and context. Returns a Promise that resolves when both the publish operation and request for responses complete.

details:
The implementation:

1. First determines which relays to use:
   - If no relays are provided, it fetches relay information from authors in the tags
   - Then constructs a relay list from the fetched events using Router policies

2. Ensures required tags are present by checking and adding if missing:
   - Expiration tag (set to current time + 60 seconds)
   - Relays tag (includes all relay URLs)
   - User parameter (with the signer's public key)
   - Max results parameter (set to 200)

3. Creates and signs an event with the specified kind and prepared tags

4. Sets up filters to listen for responses (using kind+1000 convention for responses)

5. Simultaneously publishes the request event and listens for responses, returning a Promise that resolves when both operations complete

related: RequestDVMOptions

import/access examples:
import { requestDVM } from '@welshman/feeds/request';


=========================
workspace: packages/feeds
file: packages/feeds/src/compiler.ts
lines: 27:33
id: 1ea81c7b72bd2e4ad49737b0c0220adac88497ec9755c2d346a5452506db6a69
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/compiler.ts#L27

declaration:
export type FeedCompilerOptions = {
  signer?: ISigner
  signal?: AbortSignal
  context?: AdapterContext
  getPubkeysForScope: (scope: Scope) => string[]
  getPubkeysForWOTRange: (minWOT: number, maxWOT: number) => string[]
}

summary:
FeedCompilerOptions is a type definition that specifies configuration options for the FeedCompiler class. It includes optional properties for a signer, abort signal, and context, as well as required functions for retrieving public keys based on scope or WOT (Web of Trust) range criteria.

details:
The FeedCompilerOptions type contains five properties:
1. `signer?: ISigner` - An optional signer interface, likely used for authentication or signing operations
2. `signal?: AbortSignal` - An optional abort signal to cancel ongoing operations
3. `context?: AdapterContext` - An optional context for network adapters
4. `getPubkeysForScope: (scope: Scope) => string[]` - A required function that returns an array of public keys for a given scope
5. `getPubkeysForWOTRange: (minWOT: number, maxWOT: number) => string[]` - A required function that returns public keys within a specified Web of Trust range

This type is exported both directly from compiler.ts and re-exported through index.ts.

related: Scope

import/access examples:
import type { FeedCompilerOptions } from '@welshman/feeds';
import type { FeedCompilerOptions } from '@welshman/feeds/compiler';


=========================
workspace: packages/feeds
file: packages/feeds/src/compiler.ts
lines: 35:336
id: 1e5791b26cd73b07446a08616974918ac0fc3f915db6c926b94ffbedc00207ae
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/compiler.ts#L35

declaration:
export class FeedCompiler{
  constructor(readonly options: FeedCompilerOptions);
  canCompile(feed: Feed): boolean;
  async compile(feed: Feed): Promise<RequestItem[]>;
  _compileAddresses(addresses: string[]);
  _compileFilter(key: string, value: any);
  _compileCreatedAt(items: CreatedAtItem[]);
  _compileScopes(scopes: Scope[]);
  _compileSearches(searches: string[]);
  _compileWot(wotItems: WOTItem[]);
  async _compileDvms(items: DVMItem[]): Promise<RequestItem[]>;
  async _compileIntersection(feeds: Feed[]): Promise<RequestItem[]>;
  async _compileUnion(feeds: Feed[]): Promise<RequestItem[]>;
  async _compileLists(listItems: ListItem[]): Promise<RequestItem[]>;
  async _compileLabels(labelItems: LabelItem[]): Promise<RequestItem[]>;
}

summary:
The `FeedCompiler` class is responsible for compiling different types of feeds into request items that can be used to fetch data from Nostr relays. It supports various feed types like Union, Intersection, Address, Author, CreatedAt, DVM, ID, Global, Kind, List, Label, Relay, Scope, Search, Tag, and WOT. The class provides methods to check if a feed can be compiled and to perform the actual compilation. It requires options including functions to get public keys for scopes and WOT ranges, and optionally a signer, abort signal, and adapter context.

details:
The implementation works by recursively processing feed structures and converting them into appropriate filter objects that can be used in Nostr relay requests. Key aspects include:

1. The `canCompile` method checks if a feed type is supported, recursively validating nested feeds for union and intersection types.

2. The `compile` method is the main entry point that dispatches to specialized handlers based on feed type:
   - Simple filters (ID, Kind, Author, etc.) are handled by creating basic filter objects
   - Complex types like Union and Intersection require combining multiple filters
   - DVM, List, and Label types involve fetching external data before creating filters

3. For intersection feeds, the implementation finds matching groups across all feeds and combines their filters using filter intersection.

4. For union feeds, it organizes filters by relay and combines them appropriately, handling cases with and without relay specifications.

5. The DVM, List, and Label compilers make network requests to fetch data that is then transformed into feeds and compiled using the union compiler.

6. The implementation handles time-based filters with relative time support in the CreatedAt compiler.

related: FeedCompilerOptions,Feed,RequestItem,DVMItem,ListItem,LabelItem

code:
export class FeedCompiler {
  constructor(readonly options: FeedCompilerOptions) {}

  canCompile(feed: Feed): boolean {
    switch (feed[0]) {
      case FeedType.Union:
      case FeedType.Intersection:
        return getFeedArgs(feed).every(f => this.canCompile(f))
      case FeedType.Address:
      case FeedType.Author:
      case FeedType.CreatedAt:
      case FeedType.DVM:
      case FeedType.ID:
      case FeedType.Global:
      case FeedType.Kind:
      case FeedType.List:
      case FeedType.Label:
      case FeedType.Relay:
      case FeedType.Scope:
      case FeedType.Search:
      case FeedType.Tag:
      case FeedType.WOT:
        return true
      default:
        return false
    }
  }

  async compile(feed: Feed): Promise<RequestItem[]> {
    switch (feed[0]) {
      case FeedType.ID:
        return this._compileFilter("ids", getFeedArgs(feed))
      case FeedType.Kind:
        return this._compileFilter("kinds", getFeedArgs(feed))
      case FeedType.Author:
        return this._compileFilter("authors", getFeedArgs(feed))
      case FeedType.DVM:
        return await this._compileDvms(getFeedArgs(feed))
      case FeedType.Intersection:
        return await this._compileIntersection(getFeedArgs(feed))
      case FeedType.List:
        return await this._compileLists(getFeedArgs(feed))
      case FeedType.Label:
        return await this._compileLabels(getFeedArgs(feed))
      case FeedType.Union:
        return await this._compileUnion(getFeedArgs(feed))
      case FeedType.Address:
        return this._compileAddresses(getFeedArgs(feed))
      case FeedType.CreatedAt:
        return this._compileCreatedAt(getFeedArgs(feed))
      case FeedType.Scope:
        return this._compileScopes(getFeedArgs(feed))
      case FeedType.Search:
        return this._compileSearches(getFeedArgs(feed))
      case FeedType.WOT:
        return this._compileWot(getFeedArgs(feed))
      case FeedType.Relay:
        return [{relays: getFeedArgs(feed)}]
      case FeedType.Global:
        return [{filters: [{}]}]
      case FeedType.Tag: {
        const [key, ...value] = getFeedArgs(feed)

        return this._compileFilter(key, value)
      }
      default:
        throw new Error(`Unable to convert feed of type ${feed[0]} to filters`)
    }
  }

  _compileAddresses(addresses: string[]) {
    return [{filters: getIdFilters(addresses)}]
  }

  _compileFilter(key: string, value: any) {
    return [{filters: [{[key]: value} as Filter]}]
  }

  _compileCreatedAt(items: CreatedAtItem[]) {
    const filters = items
      .map(({since, until, relative = []}) => {
        if (since && relative.includes("since")) {
          since = now() - since
        }

        if (until && relative.includes("until")) {
          until = now() - until
        }

        if (since && until) return {since, until}
        if (since) return {since}
        if (until) return {until}

        return null
      })
      .filter(identity)

    return [{filters: filters as Filter[]}]
  }

  _compileScopes(scopes: Scope[]) {
    return [{filters: [{authors: uniq(scopes.flatMap(this.options.getPubkeysForScope))}]}]
  }

  _compileSearches(searches: string[]) {
    return [{filters: searches.map(search => ({search}))}]
  }

  _compileWot(wotItems: WOTItem[]) {
    return [
      {
        filters: wotItems.map(({min = 0, max = 1}) => ({
          authors: this.options.getPubkeysForWOTRange(min, max),
        })),
      },
    ]
  }

  async _compileDvms(items: DVMItem[]): Promise<RequestItem[]> {
    const feeds: Feed[] = []

    await Promise.all(
      items.map(({mappings, ...request}) =>
        requestDVM({
          ...request,
          signer: this.options.signer,
          context: this.options.context,
          onResult: async (e: TrustedEvent) => {
            const tags = (await tryCatch(() => JSON.parse(e.content))) || []

            for (const feed of feedsFromTags(tags, mappings)) {
              feeds.push(feed)
            }
          },
        }),
      ),
    )

    return await this._compileUnion(feeds)
  }

  async _compileIntersection(feeds: Feed[]): Promise<RequestItem[]> {
    const [head, ...tail] = await Promise.all(feeds.map(f => this.compile(f)))

    const result = []

    for (let {filters, relays} of head || []) {
      const matchingGroups = tail
        .map(items =>
          items.filter(
            it =>
              (!relays || !it.relays || intersection(relays, it.relays).length > 0) &&
              (!filters || !it.filters || intersectFilters([filters, it.filters]).length > 0),
          ),
        )
        .filter(items => items.length > 0)

      if (matchingGroups.length < tail.length) {
        continue
      }

      for (const items of matchingGroups) {
        for (const item of items) {
          if (relays && item.relays) {
            relays = relays.filter(r => item.relays!.includes(r))
          } else if (item.relays) {
            relays = item.relays
          }

          if (filters && item.filters) {
            filters = intersectFilters([filters, item.filters])
          } else if (item.filters) {
            filters = item.filters
          }
        }
      }

      result.push({relays, filters})
    }

    return result
  }

  async _compileUnion(feeds: Feed[]): Promise<RequestItem[]> {
    const filtersByRelay = new Map<string, Filter[]>()
    const filtersWithoutRelay: Filter[] = []
    const relaysWithoutFilter: string[] = []

    await Promise.all(
      feeds.map(async feed => {
        for (const item of await this.compile(feed)) {
          if (item.relays) {
            for (const relay of item.relays) {
              if (item.filters) {
                for (const filter of item.filters) {
                  pushToMapKey(filtersByRelay, relay, filter)
                }
              } else {
                relaysWithoutFilter.push(relay)
              }
            }
          } else if (item.filters) {
            for (const filter of item.filters) {
              filtersWithoutRelay.push(filter)
            }
          }
        }
      }),
    )

    const items: RequestItem[] = []

    for (const [relay, filters] of filtersByRelay.entries()) {
      items.push({
        relays: [relay],
        filters: unionFilters(filters),
      })
    }

    if (filtersWithoutRelay.length > 0) {
      items.push({filters: unionFilters(filtersWithoutRelay)})
    }

    if (relaysWithoutFilter.length > 0) {
      items.push({relays: uniq(relaysWithoutFilter)})
    }

    return items
  }

  async _compileLists(listItems: ListItem[]): Promise<RequestItem[]> {
    const addresses = uniq(listItems.flatMap(({addresses}) => addresses))
    const eventsByAddress = new Map<string, TrustedEvent>()

    await requestPage({
      autoClose: true,
      signal: this.options.signal,
      context: this.options.context,
      filters: getIdFilters(addresses),
      onEvent: (e: TrustedEvent) => eventsByAddress.set(getAddress(e), e),
    })

    const feeds = flatten(
      await Promise.all(
        listItems.map(({addresses, mappings}) => {
          const feeds: Feed[] = []

          for (const address of addresses) {
            const event = eventsByAddress.get(address)

            if (event) {
              for (const feed of feedsFromTags(event.tags, mappings)) {
                feeds.push(feed)
              }
            }
          }

          return feeds
        }),
      ),
    )

    return this._compileUnion(feeds)
  }

  async _compileLabels(labelItems: LabelItem[]): Promise<RequestItem[]> {
    const events: TrustedEvent[] = []

    await Promise.all(
      labelItems.map(({mappings, relays, ...filter}) =>
        requestPage({
          relays,
          autoClose: true,
          signal: this.options.signal,
          context: this.options.context,
          filters: [{kinds: [1985], ...filter}],
          onEvent: (e: TrustedEvent) => events.push(e),
        }),
      ),
    )

    const feeds = flatten(
      await Promise.all(
        labelItems.map(({mappings, relays, ...filter}) => {
          const tags: string[][] = []

          for (const event of events) {
            if (matchFilter(filter, event)) {
              for (const tag of event.tags) {
                tags.push(tag)
              }
            }
          }

          return feedsFromTags(tags, mappings)
        }),
      ),
    )

    return this._compileUnion(feeds)
  }
}

import/access examples:
import { FeedCompiler } from '@welshman/feeds';
import { FeedCompiler } from '@welshman/feeds/compiler';


=========================
workspace: packages/feeds
file: packages/feeds/src/controller.ts
lines: 19:25
id: 07422a1bbb7aaeff1ebe1f0346a3e4e26f14ffe1177d62f5234784cc37a7b025
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/controller.ts#L19

declaration:
export type FeedControllerOptions = FeedCompilerOptions & {
  feed: Feed
  tracker?: Tracker
  onEvent?: (event: TrustedEvent) => void
  onExhausted?: () => void
  useWindowing?: boolean
}

summary:
FeedControllerOptions is a type alias that extends FeedCompilerOptions and defines the configuration options for a FeedController. It includes properties for specifying the feed to be controlled, an optional tracker for monitoring network requests, callback functions for handling events and feed exhaustion, and a flag to enable windowing behavior for pagination.

details:
This type combines compiler options with controller-specific options:

1. `feed`: Required Feed object that defines what data to fetch
2. `tracker`: Optional Tracker instance for monitoring network activity
3. `onEvent`: Optional callback function that receives TrustedEvent objects
4. `onExhausted`: Optional callback function called when a feed is exhausted
5. `useWindowing`: Optional boolean flag that enables time-window based pagination

The type is exported both directly from controller.ts and re-exported through index.ts, making it part of the public API.

related: FeedCompilerOptions,Feed

import/access examples:
import type { FeedControllerOptions } from '@welshman/feeds';
import type { FeedControllerOptions } from '@welshman/feeds/controller';


=========================
workspace: packages/feeds
file: packages/feeds/src/controller.ts
lines: 27:447
id: 581563a4838c9435e89817a721a875555b7560493fed063a5891115380e5f4f1
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/controller.ts#L27

declaration:
export class FeedController{
  compiler: FeedCompiler;
  constructor(readonly options: FeedControllerOptions);
  getRequestItems: (...args: any[]) => Promise<RequestItem[] | undefined>;
  getLoader: (...args: any[]) => Promise<(limit: number) => Promise<void>>;
  load: (limit: number) => Promise<void>;
  getListener: (...args: any[]) => Promise<() => () => void>;
  listen: () => () => Promise<void>;
  async _getRequestsLoader(requests: RequestItem[]);
  async _getRequestLoader(
      {relays, filters}: RequestItem,
      {onEvent, onExhausted}: Pick<FeedControllerOptions, "onEvent" | "onExhausted">,
    );
  _getDifferenceLoader(feeds: Feed[]);
  _getIntersectionLoader(feeds: Feed[]);
  _getUnionLoader(feeds: Feed[]);
  async _getRequestsListener(requests: RequestItem[]);
  async _getRequestListener(
      {relays, filters}: RequestItem,
      {onEvent}: Pick<FeedControllerOptions, "onEvent">,
    );
  _getDifferenceListener(feeds: Feed[]);
  _getIntersectionListener(feeds: Feed[]);
  _getUnionListener(feeds: Feed[]);
}

summary:
FeedController is a class responsible for managing and controlling feeds of events. It provides functionality to load and listen to different types of feeds (Difference, Intersection, Union) or compiled request items. The controller handles event deduplication, feed exhaustion, and windowing for pagination. It accepts options including a feed definition, tracker, event handlers, and windowing preferences.

details:
The FeedController implementation consists of several key components:

1. Core functionality:
   - Memoized methods for getting request items, loaders, and listeners
   - Main public methods: `load()` and `listen()` for interacting with feeds

2. Request handling:
   - `_getRequestsLoader` and `_getRequestsListener` manage collections of request items
   - `_getRequestLoader` and `_getRequestListener` handle individual requests with windowing logic
   - Uses windowing strategy with exponential window sizing for efficient pagination

3. Feed type handling:
   - Implements specialized loaders and listeners for three feed types:
     - Difference: Events from the first feed that don't appear in other feeds
     - Intersection: Events that appear in all feeds
     - Union: All unique events from any feed
   - Each feed type has its own tracking mechanism for seen events

4. Event deduplication:
   - Uses Set objects to track seen event IDs
   - Ensures events are only processed once

5. Resource management:
   - Properly handles AbortController signals for cancellation
   - Returns unsubscribe functions for cleanup

related: FeedCompiler,FeedControllerOptions

code:
export class FeedController {
  compiler: FeedCompiler

  constructor(readonly options: FeedControllerOptions) {
    this.compiler = new FeedCompiler(options)
  }

  getRequestItems = memoize(async () => {
    return this.compiler.canCompile(this.options.feed)
      ? this.compiler.compile(this.options.feed)
      : undefined
  })

  getLoader = memoize(async () => {
    const [type, ...feed] = this.options.feed
    const requestItems = await this.getRequestItems()

    if (requestItems) {
      return this._getRequestsLoader(requestItems)
    }

    switch (type) {
      case FeedType.Difference:
        return this._getDifferenceLoader(feed as Feed[])
      case FeedType.Intersection:
        return this._getIntersectionLoader(feed as Feed[])
      case FeedType.Union:
        return this._getUnionLoader(feed as Feed[])
      default:
        throw new Error(`Unable to convert feed of type ${type} to loader`)
    }
  })

  load = async (limit: number) => (await this.getLoader())(limit)

  getListener = memoize(async () => {
    const [type, ...feed] = this.options.feed
    const requestItems = await this.getRequestItems()

    if (requestItems) {
      return this._getRequestsListener(requestItems)
    }

    switch (type) {
      case FeedType.Difference:
        return this._getDifferenceListener(feed as Feed[])
      case FeedType.Intersection:
        return this._getIntersectionListener(feed as Feed[])
      case FeedType.Union:
        return this._getUnionListener(feed as Feed[])
      default:
        throw new Error(`Unable to convert feed of type ${type} to listener`)
    }
  })

  listen = () => {
    const promise = this.getListener().then(call)

    return () => promise.then(call)
  }

  async _getRequestsLoader(requests: RequestItem[]) {
    const seen = new Set()
    const exhausted = new Set()
    const loaders = await Promise.all(
      requests.map(request =>
        this._getRequestLoader(request, {
          onExhausted: () => exhausted.add(request),
          onEvent: e => {
            if (!seen.has(e.id)) {
              this.options.onEvent?.(e)
              seen.add(e.id)
            }
          },
        }),
      ),
    )

    return async (limit: number) => {
      await Promise.all(loaders.map(loader => loader(limit)))

      if (exhausted.size === requests.length) {
        this.options?.onExhausted?.()
      }
    }
  }

  async _getRequestLoader(
    {relays, filters}: RequestItem,
    {onEvent, onExhausted}: Pick<FeedControllerOptions, "onEvent" | "onExhausted">,
  ) {
    // Make sure we have some kind of filter to send if we've been given an empty one, as happens with relay feeds
    if (!filters || filters.length === 0) {
      filters = [{}]
    }

    const untils = filters.flatMap((filter: Filter) => (filter.until ? [filter.until] : []))
    const sinces = filters.flatMap((filter: Filter) => (filter.since ? [filter.since] : []))
    const maxUntil = untils.length === filters.length ? max(untils) : now()
    const minSince = sinces.length === filters.length ? min(sinces) : EPOCH
    const initialDelta = guessFilterDelta(filters)

    let promise: Deferred<void> | undefined
    let delta = initialDelta
    let since = this.options.useWindowing ? maxUntil - delta : 0
    let until = maxUntil

    return async (limit: number) => {
      if (promise) {
        return promise
      }

      promise = defer()

      const requestFilters = filters!
        // Remove filters that don't fit our window
        .filter((filter: Filter) => {
          const filterSince = filter.since || minSince
          const filterUntil = filter.until || maxUntil

          return filterSince < until && filterUntil > since
        })
        // Modify the filters to define our window
        .map((filter: Filter) => ({since, until, limit, ...filter}))

      if (requestFilters.length === 0) {
        return onExhausted?.()
      }

      let count = 0

      await requestPage(
        omitVals([undefined], {
          relays,
          autoClose: true,
          filters: trimFilters(requestFilters),
          signal: this.options.signal,
          tracker: this.options.tracker,
          context: this.options.context,
          onEvent: (event: TrustedEvent) => {
            count += 1
            until = Math.min(until, event.created_at - 1)
            onEvent?.(event)
          },
        }),
      )

      if (this.options.useWindowing) {
        if (since === minSince) {
          onExhausted?.()
        }

        // Relays can't be relied upon to return events in descending order, do exponential
        // windowing to ensure we get the most recent stuff on first load, but eventually find it all
        if (count < limit) {
          delta = delta * Math.round(100 * (2 - inc(count) / inc(limit)))
          until = since
        }

        since = Math.max(minSince, until - delta)
      } else if (count === 0) {
        onExhausted?.()
      }

      promise.resolve()
      promise = undefined
    }
  }

  _getDifferenceLoader(feeds: Feed[]) {
    const exhausted = new Set<number>()
    const skip = new Set<string>()
    const events: TrustedEvent[] = []
    const seen = new Set()

    const controllers = feeds.map(
      (thisFeed: Feed, i: number) =>
        new FeedController({
          ...this.options,
          feed: thisFeed,
          onExhausted: () => exhausted.add(i),
          onEvent: (event: TrustedEvent) => {
            if (i === 0) {
              events.push(event)
            } else {
              skip.add(event.id)
            }
          },
        }),
    )

    return async (limit: number) => {
      await Promise.all(
        controllers.map(async (controller: FeedController, i: number) => {
          if (exhausted.has(i)) {
            return
          }

          await controller.load(limit)
        }),
      )

      for (const event of events.splice(0)) {
        if (!skip.has(event.id) && !seen.has(event.id)) {
          this.options.onEvent?.(event)
          seen.add(event.id)
        }
      }

      if (exhausted.size === controllers.length) {
        this.options.onExhausted?.()
      }
    }
  }

  _getIntersectionLoader(feeds: Feed[]) {
    const exhausted = new Set<number>()
    const counts = new Map<string, number>()
    const events: TrustedEvent[] = []
    const seen = new Set()

    const controllers = feeds.map(
      (thisFeed: Feed, i: number) =>
        new FeedController({
          ...this.options,
          feed: thisFeed,
          onExhausted: () => exhausted.add(i),
          onEvent: (event: TrustedEvent) => {
            events.push(event)
            counts.set(event.id, inc(counts.get(event.id)))
          },
        }),
    )

    return async (limit: number) => {
      await Promise.all(
        controllers.map(async (controller: FeedController, i: number) => {
          if (exhausted.has(i)) {
            return
          }

          await controller.load(limit)
        }),
      )

      for (const event of events.splice(0)) {
        if (counts.get(event.id) === controllers.length && !seen.has(event.id)) {
          this.options.onEvent?.(event)
          seen.add(event.id)
        }
      }

      if (exhausted.size === controllers.length) {
        this.options.onExhausted?.()
      }
    }
  }

  _getUnionLoader(feeds: Feed[]) {
    const exhausted = new Set<number>()
    const seen = new Set()

    const controllers = feeds.map(
      (thisFeed: Feed, i: number) =>
        new FeedController({
          ...this.options,
          feed: thisFeed,
          onExhausted: () => exhausted.add(i),
          onEvent: (event: TrustedEvent) => {
            if (!seen.has(event.id)) {
              this.options.onEvent?.(event)
              seen.add(event.id)
            }
          },
        }),
    )

    return async (limit: number) => {
      await Promise.all(
        controllers.map(async (controller: FeedController, i: number) => {
          if (exhausted.has(i)) {
            return
          }

          await controller.load(limit)
        }),
      )

      if (exhausted.size === controllers.length) {
        this.options.onExhausted?.()
      }
    }
  }

  async _getRequestsListener(requests: RequestItem[]) {
    const seen = new Set()
    const listeners = await Promise.all(
      requests.map(request =>
        this._getRequestListener(request, {
          onEvent: e => {
            if (!seen.has(e.id)) {
              this.options.onEvent?.(e)
              seen.add(e.id)
            }
          },
        }),
      ),
    )

    return () => {
      const unsubscribers = listeners.map(call)

      return () => unsubscribers.forEach(call)
    }
  }

  async _getRequestListener(
    {relays, filters}: RequestItem,
    {onEvent}: Pick<FeedControllerOptions, "onEvent">,
  ) {
    // Make sure we have some kind of filter to send if we've been given an empty one, as happens with relay feeds
    if (!filters || filters.length === 0) {
      filters = [{}]
    }

    return () => {
      const controller = new AbortController()
      const signal = AbortSignal.any(removeNil([controller.signal, this.options.signal]))
      const requestFilters = filters!.map((filter: Filter) => ({...filter, limit: 0}))

      requestPage(
        omitVals([undefined], {
          relays,
          signal,
          onEvent: (event: TrustedEvent) => onEvent?.(event),
          filters: trimFilters(requestFilters),
          tracker: this.options.tracker,
          context: this.options.context,
        }),
      )

      return () => controller.abort()
    }
  }

  _getDifferenceListener(feeds: Feed[]) {
    const skip = new Set<string>()

    const controllers = feeds.map(
      (thisFeed: Feed, i: number) =>
        new FeedController({
          ...this.options,
          feed: thisFeed,
          onEvent: (event: TrustedEvent) => {
            if (i === 0 && !skip.has(event.id)) {
              this.options.onEvent?.(event)
            } else {
              skip.add(event.id)
            }
          },
        }),
    )

    return () => {
      const unsubscribers = controllers.map(controller => controller.listen())

      return () => unsubscribers.forEach(call)
    }
  }

  _getIntersectionListener(feeds: Feed[]) {
    const counts = new Map<string, number>()

    const controllers = feeds.map(
      (thisFeed: Feed, i: number) =>
        new FeedController({
          ...this.options,
          feed: thisFeed,
          onEvent: (event: TrustedEvent) => {
            const count = inc(counts.get(event.id))

            if (count === feeds.length) {
              this.options.onEvent?.(event)
            }

            counts.set(event.id, count)
          },
        }),
    )

    return () => {
      const unsubscribers = controllers.map(controller => controller.listen())

      return () => unsubscribers.forEach(call)
    }
  }

  _getUnionListener(feeds: Feed[]) {
    const seen = new Set()

    const controllers = feeds.map(
      (thisFeed: Feed, i: number) =>
        new FeedController({
          ...this.options,
          feed: thisFeed,
          onEvent: (event: TrustedEvent) => {
            if (!seen.has(event.id)) {
              this.options.onEvent?.(event)
              seen.add(event.id)
            }
          },
        }),
    )

    return () => {
      const unsubscribers = controllers.map(controller => controller.listen())

      return () => unsubscribers.forEach(call)
    }
  }
}

import/access examples:
import { FeedController } from '@welshman/feeds';
import { FeedController } from '@welshman/feeds/controller';


=========================
workspace: packages/feeds
file: packages/feeds/src/display.ts
lines: 25:29
id: 320882204cd155695921c80904bd908440b7bce8fb05c31bf2dc0f73180e55c6
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/display.ts#L25

declaration:
displayAddressFeed = (feed: AddressFeed) => {
  const n = getFeedArgs(feed).length

  return `${n} replaceable {n === 1 ? 'event' : 'events'}`
}

summary:
A function that generates a human-readable description of an AddressFeed. It returns a string indicating the number of replaceable events in the feed, with proper singular/plural form.

details:
The implementation counts the number of items in the feed by extracting the arguments using getFeedArgs() and getting the length. It then returns a template string with the count followed by either 'event' or 'events' depending on whether the count is 1 or not. However, there appears to be a bug in the template string - it uses curly braces for the conditional expression instead of proper template string syntax (which would be `${n} replaceable ${n === 1 ? 'event' : 'events'}`). This would cause the literal text '{n === 1 ? 'event' : 'events'}' to appear in the output rather than the intended conditional text.

related: AddressFeed

import/access examples:
import { displayAddressFeed } from '@welshman/feeds';
import { displayAddressFeed } from '@welshman/feeds/display';


=========================
workspace: packages/feeds
file: packages/feeds/src/display.ts
lines: 31:35
id: 97b80e1faab509dca770bb1dc68f1b0afd00d6208cde2ddf24953d9563299575
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/display.ts#L31

declaration:
displayAuthorFeed = (feed: AuthorFeed) => {
  const n = getFeedArgs(feed).length

  return `from ${n} replaceable {n === 1 ? 'person' : 'people'}`
}

summary:
Formats a human-readable description of an AuthorFeed. The function takes an AuthorFeed object and returns a string that describes the number of authors in the feed, using singular or plural form based on the count.

details:
The implementation:
1. Extracts the number of authors from the feed by calling getFeedArgs() and getting the length of the returned array
2. Returns a formatted string that includes the count and uses proper grammar ('person' for singular, 'people' for plural)
3. Note that there appears to be a template literal syntax error in the return statement - it uses curly braces for the conditional instead of ${} syntax

related: AuthorFeed

import/access examples:
import { displayAuthorFeed } from '@welshman/feeds';
import { displayAuthorFeed } from '@welshman/feeds/display';


=========================
workspace: packages/feeds
file: packages/feeds/src/display.ts
lines: 37:70
id: 08c39e9685f68995d45cfb847160fef93025d55590468a475dc9b72df4227bb8
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/display.ts#L37

declaration:
displayCreatedAtFeed = (feed: CreatedAtFeed) => {
  const items = getFeedArgs(feed)
  const descriptions: string[] = []

  for (const {since, until, relative = []} of items) {
    const parts: string[] = []

    if (since) {
      if (relative.includes("since")) {
        parts.push(`after ${formatTimestampRelative(now() - since)}`)
      } else {
        parts.push(`after ${formatTimestampAsDate(since)}`)
      }
    }

    if (until) {
      if (relative.includes("until")) {
        parts.push(`before ${formatTimestampRelative(now() - until)}`)
      } else {
        parts.push(`before ${formatTimestampAsDate(until)}`)
      }
    }

    if (parts.length > 0) {
      descriptions.push(parts.join(" and "))
    }
  }

  if (descriptions.length === 0) {
    return "from any time"
  }

  return displayList(descriptions, "or")
}

summary:
A function that generates a human-readable description of a CreatedAtFeed. It takes a CreatedAtFeed object as input and returns a string that describes the time constraints of the feed, such as 'after [date]', 'before [date]', or 'from any time' if no constraints are specified. The function supports both absolute dates and relative time formatting.

details:
The implementation processes each item in the feed to build descriptive strings about time constraints:

1. It extracts feed arguments using getFeedArgs()
2. For each item, it checks for 'since' (start time) and 'until' (end time) properties
3. Depending on whether the 'relative' array includes 'since' or 'until', it formats timestamps as:
   - Relative time (e.g., '2 hours ago') using formatTimestampRelative()
   - Absolute date (e.g., 'Jan 1, 2023') using formatTimestampAsDate()
4. It combines multiple time constraints with 'and' within each item
5. If multiple items exist, they're combined with 'or' using the displayList() utility
6. Returns 'from any time' if no time constraints are found

related: CreatedAtFeed

import/access examples:
import { displayCreatedAtFeed } from '@welshman/feeds';
import { displayCreatedAtFeed } from '@welshman/feeds/display';


=========================
workspace: packages/feeds
file: packages/feeds/src/display.ts
lines: 72:93
id: 48111e528855aa16bdbec9617cbbc9ae071d6588200e958783694e37a31d67e1
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/display.ts#L72

declaration:
displayDVMFeed = (feed: DVMFeed) => {
  const items = getFeedArgs(feed)
  const descriptions: string[] = []

  for (const {kind, tags = [], relays = []} of items) {
    const parts: string[] = []

    parts.push(`kind ${kind}`)

    if (tags.length > 0) {
      parts.push(`with ${tags.length} tag${tags.length === 1 ? "" : "s"}`)
    }

    if (relays.length > 0) {
      parts.push(`from ${displayList(relays)}`)
    }

    descriptions.push(parts.join(" "))
  }

  return `from DVM requests of ${displayList(descriptions)}`
}

summary:
A function that generates a human-readable string description of a DVMFeed. It takes a DVMFeed object as input and returns a formatted string that describes the DVM (Decentralized Virtual Machine) requests, including their kinds, tags, and relays.

details:
The implementation:
1. Extracts the feed arguments using getFeedArgs(feed)
2. Creates an empty array to store descriptions
3. Iterates through each item in the feed, destructuring kind, tags, and relays (with default empty arrays)
4. For each item, builds a description by:
   - Adding the kind information
   - Adding tag count information if tags exist
   - Adding relay information if relays exist
   - Joining these parts with spaces
5. Finally returns a formatted string that combines all descriptions using the displayList helper

The function handles pluralization correctly for tags and uses the displayList utility to format lists of relays and the final combined description.

related: DVMFeed

import/access examples:
import { displayDVMFeed } from '@welshman/feeds';
import { displayDVMFeed } from '@welshman/feeds/display';


=========================
workspace: packages/feeds
file: packages/feeds/src/display.ts
lines: 95:99
id: ca24fdcd89fe54e426172340236f6a61327fbf811c51b72237db2899f55307e7
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/display.ts#L95

declaration:
displayDifferenceFeed = (feed: DifferenceFeed) => {
  const [base, ...excluded] = getFeedArgs(feed)

  return `${displayFeed(base)}, excluding ${displayList(excluded.map(displayFeed))}`
}

summary:
A function that generates a human-readable description of a DifferenceFeed. It takes a DifferenceFeed object as input and returns a string that describes the feed as the base feed excluding other feeds.

details:
The implementation:
1. Extracts the feed arguments using getFeedArgs(feed)
2. Destructures the result into a base feed and an array of excluded feeds
3. Returns a formatted string that displays the base feed (using displayFeed) followed by the excluded feeds (mapped through displayFeed and joined with displayList)

The function effectively creates a readable representation of a difference operation between feeds, showing what's in the base feed but not in the excluded feeds.

related: DifferenceFeed

import/access examples:
import { displayDifferenceFeed } from '@welshman/feeds';
import { displayDifferenceFeed } from '@welshman/feeds/display';


=========================
workspace: packages/feeds
file: packages/feeds/src/display.ts
lines: 101:101
id: 88d4a17adb613c0e7d21e21d87d3bcd43ea99d33910a122bc5735e19f580129d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/display.ts#L101

declaration:
displayIDFeed = (feed: IDFeed) => `matching ${getFeedArgs(feed).length} IDs`

summary:
A function that generates a human-readable description of an IDFeed. It takes an IDFeed object as input and returns a string that describes the feed as 'matching X IDs' where X is the number of IDs in the feed.

details:
This is a simple arrow function that uses template literals to create a descriptive string. It calls the `getFeedArgs` utility function to extract the arguments from the feed and then counts them using the `.length` property. The implementation is straightforward with no complex logic.

related: IDFeed

import/access examples:
import { displayIDFeed } from '@welshman/feeds';
import { displayIDFeed } from '@welshman/feeds/display';


=========================
workspace: packages/feeds
file: packages/feeds/src/display.ts
lines: 103:104
id: 747ca66dfbecf9ef3632ca1f9ffd36fcc9299397a51e16aae1969cf2873180e1
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/display.ts#L103

declaration:
displayIntersectionFeed = (feed: IntersectionFeed) =>
  displayList(getFeedArgs(feed).map(displayFeed))

summary:
A function that generates a human-readable string representation of an IntersectionFeed. It takes an IntersectionFeed object as input and returns a formatted string that displays all the feeds in the intersection, joined together in a readable list format.

details:
The implementation is straightforward:
1. It takes the IntersectionFeed as input
2. Uses getFeedArgs() to extract the feed arguments from the input
3. Maps each feed argument through the displayFeed function to get a string representation of each feed
4. Finally uses the displayList utility to join all these string representations into a single readable list

This creates a human-friendly description of what feeds are being intersected.

related: displayList,IntersectionFeed

import/access examples:
import { displayIntersectionFeed } from '@welshman/feeds';
import { displayIntersectionFeed } from '@welshman/feeds/display';


=========================
workspace: packages/feeds
file: packages/feeds/src/display.ts
lines: 106:106
id: da36fbbe01512366ecfa56a85dbf62c66bafcd54d12d40c049c680cc09a1a400
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/display.ts#L106

declaration:
displayGlobalFeed = (feed: GlobalFeed) => "anything"

summary:
A function that generates a display string for a GlobalFeed. It always returns the string "anything" regardless of the feed's content.

details:
This is a simple arrow function that takes a GlobalFeed parameter but doesn't actually use it. The implementation is trivial - it just returns the hardcoded string "anything" to represent that a global feed matches any content without restrictions.

related: GlobalFeed

import/access examples:
import { displayGlobalFeed } from '@welshman/feeds';
import { displayGlobalFeed } from '@welshman/feeds/display';


=========================
workspace: packages/feeds
file: packages/feeds/src/display.ts
lines: 108:108
id: f3fa6e184dac5f937fcc13d313e23aec38575f24047210e0251f3fb2b9c2c83d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/display.ts#L108

declaration:
displayKindFeed = (feed: KindFeed) => `of kind ${displayList(getFeedArgs(feed))}`

summary:
A function that generates a human-readable string description for a KindFeed. It takes a KindFeed object as input and returns a formatted string that describes the feed as 'of kind' followed by a list of the feed arguments.

details:
This is a simple arrow function that:
1. Takes a KindFeed parameter
2. Extracts the feed arguments using the getFeedArgs utility function
3. Formats those arguments into a readable list using the displayList utility
4. Returns a template string in the format 'of kind [list of kinds]'

The implementation is straightforward with no complex logic - it's primarily focused on creating a user-friendly representation of the KindFeed data.

related: KindFeed

import/access examples:
import { displayKindFeed } from '@welshman/feeds';
import { displayKindFeed } from '@welshman/feeds/display';


=========================
workspace: packages/feeds
file: packages/feeds/src/display.ts
lines: 110:114
id: fd73dac8894423bb99dda46b12a3f08a3b747e2b6d0bc89f0b4f50231b9ea2d2
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/display.ts#L110

declaration:
displayListFeed = (feed: ListFeed) => {
  const addresses = uniq(getFeedArgs(feed).flatMap(({addresses}) => addresses))

  return `from ${addresses.length} list${addresses.length === 1 ? "" : "s"}`
}

summary:
Formats a human-readable description of a ListFeed. Takes a ListFeed object as input and returns a string that describes the number of lists in the feed, with proper singular/plural handling.

details:
The function works by:
1. Extracting the feed arguments using getFeedArgs(feed)
2. Flattening the addresses arrays from each feed item using flatMap
3. Removing duplicates with the uniq utility function
4. Constructing a string that shows the count of unique addresses with proper singular/plural form

The returned string will be in the format "from X list" or "from X lists" depending on whether there's one or multiple lists.

related: ListFeed

import/access examples:
import { displayListFeed } from '@welshman/feeds';
import { displayListFeed } from '@welshman/feeds/display';


=========================
workspace: packages/feeds
file: packages/feeds/src/display.ts
lines: 116:143
id: 87e56c81f7a6492953bbe16967b09e826ef0b9ccf86fc95f7192d8870b55c621
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/display.ts#L116

declaration:
displayLabelFeed = (feed: LabelFeed) => {
  const items = getFeedArgs(feed)
  const descriptions: string[] = []

  for (const item of items) {
    const parts: string[] = []

    if (item.authors?.length) {
      parts.push(`by ${item.authors.length} author${item.authors.length === 1 ? "" : "s"}`)
    }

    const tags = Object.entries(item)
      .filter(([key]) => key.startsWith("#"))
      .map(([key, values]) => `${key}=${displayList(values as string[])}`)

    if (tags.length) {
      parts.push(`with tags ${displayList(tags)}`)
    }

    if (item.relays?.length) {
      parts.push(`from ${displayList(item.relays)}`)
    }

    descriptions.push(parts.join(" "))
  }

  return displayList(descriptions)
}

summary:
A function that generates a human-readable description of a LabelFeed. It takes a LabelFeed object as input and returns a string that describes the feed's contents, including information about authors, tags, and relays.

details:
The implementation:
1. Extracts feed arguments using getFeedArgs(feed)
2. Creates an empty array to store descriptions
3. Iterates through each item in the feed arguments and builds description parts:
   - Adds author information if present ("by X authors")
   - Extracts tags that start with '#' and formats them as "#tag=value1,value2"
   - Adds relay information if present ("from relay1,relay2")
4. Joins all parts with spaces to form complete descriptions
5. Finally uses displayList() to format all descriptions into a comma-separated list

related: LabelFeed

import/access examples:
import { displayLabelFeed } from '@welshman/feeds';
import { displayLabelFeed } from '@welshman/feeds/display';


=========================
workspace: packages/feeds
file: packages/feeds/src/display.ts
lines: 145:151
id: cd71f8689d5004830a60cbef18e55f4f9dec8301463f3dafce6d7800abcb8f3f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/display.ts#L145

declaration:
displayWOTFeed = (feed: WOTFeed) => {
  const descriptions = getFeedArgs(feed).map(({min = 0, max = 1}) =>
    min === max ? `WOT score of ${min}` : `WOT score between ${min} and ${max}`,
  )

  return `from authors with ${displayList(descriptions)}`
}

summary:
Formats a WOTFeed into a human-readable string description. Takes a WOTFeed object as input and returns a string that describes the Web of Trust (WOT) score criteria for authors in the feed.

details:
This function works by:
1. Extracting the feed arguments using getFeedArgs()
2. Mapping each WOT criteria object (containing min and max values) to a descriptive string
3. For each criteria, it creates either:
   - A simple "WOT score of X" if min equals max
   - A range description "WOT score between X and Y" if min and max differ
4. It uses default values (min=0, max=1) if not specified
5. Finally combines all descriptions into a single string using the displayList helper function

related: WOTFeed

import/access examples:
import { displayWOTFeed } from '@welshman/feeds';
import { displayWOTFeed } from '@welshman/feeds/display';


=========================
workspace: packages/feeds
file: packages/feeds/src/display.ts
lines: 153:153
id: 5bf968bd8403aad72f9aeda04cf059982636a810baad4262a54021ff6b0771dd
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/display.ts#L153

declaration:
displayRelayFeed = (feed: RelayFeed) => `from ${displayList(getFeedArgs(feed))}`

summary:
A function that generates a human-readable string description of a RelayFeed. It takes a RelayFeed object as input and returns a formatted string that describes the feed as coming from a list of relays.

details:
The implementation is straightforward:
1. It takes a RelayFeed object as input
2. Uses the getFeedArgs utility function to extract the relay arguments from the feed
3. Formats these relay arguments into a readable string using the displayList utility
4. Returns a string in the format "from [list of relays]"

related: RelayFeed

import/access examples:
import { displayRelayFeed } from '@welshman/feeds';
import { displayRelayFeed } from '@welshman/feeds/display';


=========================
workspace: packages/feeds
file: packages/feeds/src/display.ts
lines: 155:156
id: 03a23737b82c0ba651d444421186e5d888d8d3e222a415f5047e6322d98e440d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/display.ts#L155

declaration:
displayScopeFeed = (feed: ScopeFeed) =>
  `from ${displayList(getFeedArgs(feed).map(s => s.toLowerCase()))}`

summary:
A function that generates a human-readable string description of a ScopeFeed. It takes a ScopeFeed object as input and returns a formatted string that describes the scope of the feed, with all scope values converted to lowercase.

details:
This function works by:
1. Taking a ScopeFeed object as input
2. Extracting the feed arguments using getFeedArgs(feed)
3. Mapping each scope string to its lowercase version using .map(s => s.toLowerCase())
4. Using the displayList utility function to format the lowercase scope strings into a readable list
5. Returning a template string in the format "from [list of scopes]"

related: ScopeFeed

import/access examples:
import { displayScopeFeed } from '@welshman/feeds';
import { displayScopeFeed } from '@welshman/feeds/display';


=========================
workspace: packages/feeds
file: packages/feeds/src/display.ts
lines: 158:159
id: 8ace9c115b47e633ee837f583b8d5cc676c8ba6edc2d5e921078bdf1497942a4
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/display.ts#L158

declaration:
displaySearchFeed = (feed: SearchFeed) =>
  `matching ${displayList(getFeedArgs(feed).map(term => `"${term}"`))}`

summary:
A function that generates a human-readable description of a SearchFeed. It takes a SearchFeed object as input and returns a string that describes the feed as matching one or more search terms.

details:
The implementation:
1. Takes a SearchFeed parameter
2. Uses getFeedArgs() to extract the search terms from the feed
3. Maps each search term to a quoted string format (`"${term}"`)
4. Uses the displayList utility function to join the quoted terms into a readable list
5. Returns a template string in the format "matching [list of quoted terms]"

related: SearchFeed

import/access examples:
import { displaySearchFeed } from '@welshman/feeds';
import { displaySearchFeed } from '@welshman/feeds/display';


=========================
workspace: packages/feeds
file: packages/feeds/src/display.ts
lines: 161:165
id: c28a661fdeb699c2044419dad4805e8091161926f35a61e00ce0e521a1685f44
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/display.ts#L161

declaration:
displayTagFeed = (feed: TagFeed) => {
  const [key, ...values] = getFeedArgs(feed)

  return `with ${key} tag matching ${displayList(values, "or")}`
}

summary:
Formats a TagFeed into a human-readable string description. Takes a TagFeed object as input and returns a string that describes the feed in the format 'with [key] tag matching [values]', where values are joined with 'or'.

details:
The function works by:
1. Extracting the feed arguments using getFeedArgs(feed)
2. Destructuring the result to separate the first element (key) from the rest (values)
3. Constructing a readable string using template literals
4. Using the displayList utility with 'or' as the conjunction to format the values list

The implementation is straightforward and relies on the getFeedArgs utility to extract the relevant data from the feed object.

related: TagFeed

import/access examples:
import { displayTagFeed } from '@welshman/feeds';
import { displayTagFeed } from '@welshman/feeds/display';


=========================
workspace: packages/feeds
file: packages/feeds/src/display.ts
lines: 167:167
id: c2d16bd24fb1f41ee750295442a41100c37cc6587582dd5c898d75e5fb3db8f5
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/display.ts#L167

declaration:
displayUnionFeed = (feed: UnionFeed) => displayList(getFeedArgs(feed).map(displayFeed))

summary:
A function that generates a human-readable string representation of a UnionFeed. It takes a UnionFeed object as input and returns a formatted string that displays all the feeds in the union, separated by appropriate delimiters.

details:
The implementation is straightforward:
1. It extracts the feed arguments from the UnionFeed using getFeedArgs(feed)
2. Maps each feed in the union to its string representation using displayFeed
3. Combines all these string representations into a single string using the displayList utility function

This function is part of a larger system for displaying different types of feeds in a human-readable format.

related: displayList,UnionFeed

import/access examples:
import { displayUnionFeed } from '@welshman/feeds';
import { displayUnionFeed } from '@welshman/feeds/display';


=========================
workspace: packages/feeds
file: packages/feeds/src/display.ts
lines: 169:208
id: c90169d9583d7f0052fd87c300f6ed952b0cdc4a2a63d67776cae954bad21f0b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/display.ts#L169

declaration:
displayFeed = (feed: Feed): string => {
  switch (feed[0]) {
    case FeedType.Address:
      return displayAddressFeed(feed)
    case FeedType.Author:
      return displayAuthorFeed(feed)
    case FeedType.CreatedAt:
      return displayCreatedAtFeed(feed)
    case FeedType.DVM:
      return displayDVMFeed(feed)
    case FeedType.Difference:
      return displayDifferenceFeed(feed)
    case FeedType.ID:
      return displayIDFeed(feed)
    case FeedType.Intersection:
      return displayIntersectionFeed(feed)
    case FeedType.Global:
      return displayGlobalFeed(feed)
    case FeedType.Kind:
      return displayKindFeed(feed)
    case FeedType.List:
      return displayListFeed(feed)
    case FeedType.Label:
      return displayLabelFeed(feed)
    case FeedType.WOT:
      return displayWOTFeed(feed)
    case FeedType.Relay:
      return displayRelayFeed(feed)
    case FeedType.Scope:
      return displayScopeFeed(feed)
    case FeedType.Search:
      return displaySearchFeed(feed)
    case FeedType.Tag:
      return displayTagFeed(feed)
    case FeedType.Union:
      return displayUnionFeed(feed)
    default:
      return "[unknown feed type]"
  }
}

summary:
Converts a Feed object into a human-readable string representation. Takes a Feed parameter and returns a string that describes the feed in natural language. The function handles all feed types defined in the FeedType enum, providing appropriate descriptions based on the feed's structure and content.

details:
The implementation uses a switch statement to route each feed type to its specific display function. The function:

1. Examines the first element of the feed array (feed[0]) which contains the FeedType enum value
2. Calls the corresponding display function for that feed type (e.g., displayAddressFeed, displayAuthorFeed, etc.)
3. Each specialized display function formats the feed's arguments into a human-readable string
4. Returns a default message "[unknown feed type]" for unrecognized feed types

The implementation relies on a collection of helper display functions, each tailored to format a specific feed type with appropriate grammar and structure. These helper functions extract feed arguments using getFeedArgs() and often use displayList() for formatting lists of items.

related: Feed

import/access examples:
import { displayFeed } from '@welshman/feeds';
import { displayFeed } from '@welshman/feeds/display';


=========================
workspace: packages/feeds
file: packages/feeds/src/display.ts
lines: 210:210
id: 9f4632dfc1760b3233752022eb64359ef4c167f1c09acff5c8bd73141a3c0655
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/display.ts#L210

declaration:
displayFeeds = (feeds: Feed[]) => displayList(feeds.map(displayFeed))

summary:
Creates a human‑readable description for a collection of feeds. It accepts an array of `Feed` objects and returns a single formatted string that lists each feed’s description, using the library’s list‑formatting rules.

details:
The implementation maps each `Feed` in the input array through `displayFeed`, a dispatcher that selects the appropriate `display*` function based on the feed’s `FeedType`. The resulting array of description strings is then passed to `displayList`, which joins them with commas and appropriate conjunctions. No external side effects are performed; the function purely composes strings using existing display utilities.

related: displayList,Feed

import/access examples:
import { displayFeeds } from '@welshman/feeds';
import { displayFeeds } from '@welshman/feeds/display';


=========================
workspace: packages/feeds
file: packages/feeds/src/validate.ts
lines: 7:7
id: d624f3a07b2e06380ee80fe6c35dca0befbfe6593ace48ff1b9a48869fd94cfc
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/validate.ts#L7

declaration:
{ValidationError, Compose, Check, Each, Optional, Keys} = Trava

summary:
A destructured import from the Trava library that extracts several validation-related utilities: ValidationError (for validation errors), Compose (for combining validators), Check (for creating custom validators), Each (for validating array items), Optional (for optional fields), and Keys (for validating object properties).

details:
This is a simple destructuring assignment that extracts specific validation utilities from the Trava library. These utilities are used throughout the file to create and compose various validators for different types of feed data. The destructured components form the foundation of the validation system implemented in this file.

import/access examples:
import { ValidationError } from '@welshman/feeds';
import { ValidationError } from '@welshman/feeds/validate';


=========================
workspace: packages/feeds
file: packages/feeds/src/validate.ts
lines: 7:7
id: d624f3a07b2e06380ee80fe6c35dca0befbfe6593ace48ff1b9a48869fd94cfc
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/validate.ts#L7

declaration:
{ValidationError, Compose, Check, Each, Optional, Keys} = Trava

summary:
A destructured import from the Trava library that extracts several validation-related utilities: ValidationError (for validation errors), Compose (for combining validators), Check (for creating custom validators), Each (for validating array items), Optional (for optional fields), and Keys (for validating object properties).

details:
This is a simple destructuring assignment that extracts specific validation utilities from the Trava library. These utilities are used throughout the file to create and compose various validators for different types of feed data. The destructured components form the foundation of the validation system implemented in this file.

import/access examples:
import { ValidationError } from '@welshman/feeds';
import { ValidationError } from '@welshman/feeds/validate';


=========================
workspace: packages/feeds
file: packages/feeds/src/validate.ts
lines: 7:7
id: d624f3a07b2e06380ee80fe6c35dca0befbfe6593ace48ff1b9a48869fd94cfc
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/validate.ts#L7

declaration:
{ValidationError, Compose, Check, Each, Optional, Keys} = Trava

summary:
A destructured import from the Trava library that extracts several validation-related utilities: ValidationError (for validation errors), Compose (for combining validators), Check (for creating custom validators), Each (for validating array items), Optional (for optional fields), and Keys (for validating object properties).

details:
This is a simple destructuring assignment that extracts specific validation utilities from the Trava library. These utilities are used throughout the file to create and compose various validators for different types of feed data. The destructured components form the foundation of the validation system implemented in this file.

import/access examples:
import { ValidationError } from '@welshman/feeds';
import { ValidationError } from '@welshman/feeds/validate';


=========================
workspace: packages/feeds
file: packages/feeds/src/validate.ts
lines: 7:7
id: d624f3a07b2e06380ee80fe6c35dca0befbfe6593ace48ff1b9a48869fd94cfc
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/validate.ts#L7

declaration:
{ValidationError, Compose, Check, Each, Optional, Keys} = Trava

summary:
A destructured import from the Trava library that extracts several validation-related utilities: ValidationError (for validation errors), Compose (for combining validators), Check (for creating custom validators), Each (for validating array items), Optional (for optional fields), and Keys (for validating object properties).

details:
This is a simple destructuring assignment that extracts specific validation utilities from the Trava library. These utilities are used throughout the file to create and compose various validators for different types of feed data. The destructured components form the foundation of the validation system implemented in this file.

import/access examples:
import { ValidationError } from '@welshman/feeds';
import { ValidationError } from '@welshman/feeds/validate';


=========================
workspace: packages/feeds
file: packages/feeds/src/validate.ts
lines: 7:7
id: d624f3a07b2e06380ee80fe6c35dca0befbfe6593ace48ff1b9a48869fd94cfc
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/validate.ts#L7

declaration:
{ValidationError, Compose, Check, Each, Optional, Keys} = Trava

summary:
A destructured import from the Trava library that extracts several validation-related utilities: ValidationError (for validation errors), Compose (for combining validators), Check (for creating custom validators), Each (for validating array items), Optional (for optional fields), and Keys (for validating object properties).

details:
This is a simple destructuring assignment that extracts specific validation utilities from the Trava library. These utilities are used throughout the file to create and compose various validators for different types of feed data. The destructured components form the foundation of the validation system implemented in this file.

import/access examples:
import { ValidationError } from '@welshman/feeds';
import { ValidationError } from '@welshman/feeds/validate';


=========================
workspace: packages/feeds
file: packages/feeds/src/validate.ts
lines: 7:7
id: d624f3a07b2e06380ee80fe6c35dca0befbfe6593ace48ff1b9a48869fd94cfc
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/validate.ts#L7

declaration:
{ValidationError, Compose, Check, Each, Optional, Keys} = Trava

summary:
A destructured import from the Trava library that extracts several validation-related utilities: ValidationError (for validation errors), Compose (for combining validators), Check (for creating custom validators), Each (for validating array items), Optional (for optional fields), and Keys (for validating object properties).

details:
This is a simple destructuring assignment that extracts specific validation utilities from the Trava library. These utilities are used throughout the file to create and compose various validators for different types of feed data. The destructured components form the foundation of the validation system implemented in this file.

import/access examples:
import { ValidationError } from '@welshman/feeds';
import { ValidationError } from '@welshman/feeds/validate';


=========================
workspace: packages/feeds
file: packages/feeds/src/validate.ts
lines: 9:9
id: 0e569350846793e131acf2de481f2dcee63c237467d23ec9152d197878dabf46
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/validate.ts#L9

declaration:
validateNumber = Check((x: any) => typeof x === "number", "Value must be a number")

summary:
A validator function that checks if a value is a number. It uses the Trava validation library's Check function to create a validator that returns an error message 'Value must be a number' if the input is not a number.

details:
This is a simple validator implementation that uses the Check function from the Trava validation library. It takes any value as input and checks if its type is 'number' using JavaScript's typeof operator. If the check fails, it returns the specified error message. This validator is used as a building block for more complex validation scenarios throughout the module.

related: Check

=========================
workspace: packages/feeds
file: packages/feeds/src/validate.ts
lines: 11:11
id: 7ab9ece71583bcd3bb5ec5df0e50543c6cacd0c36ac0b5c99277a1ca15eb6cf5
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/validate.ts#L11

declaration:
validateString = Check((x: any) => typeof x === "string", "Value must be a string")

summary:
A validator function that checks if a value is a string. It uses the Trava validation library's Check function to create a validator that returns an error message 'Value must be a string' if the input is not a string.

details:
This is a simple validator implementation that uses the Trava library's Check function to create a validator. It takes any value as input and checks if its type is 'string' using JavaScript's typeof operator. If the check passes, the original value is returned; otherwise, a ValidationError with the message 'Value must be a string' is returned. This validator is used throughout the module for validating string inputs in various feed validation functions.

related: Check

=========================
workspace: packages/feeds
file: packages/feeds/src/validate.ts
lines: 13:13
id: dbeb6ac5090b8f4328a28f24d17069ffb36c2dbfed32a92c18bc6669a7121fe3
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/validate.ts#L13

declaration:
validateRelay = Check((x: any) => typeof x === "string" && isRelayUrl(x), "Invalid relay url")

summary:
A validator function that checks if a value is a valid relay URL. It uses the `Check` function from Trava to create a validator that ensures the input is a string and passes the `isRelayUrl` test. Returns the input value if valid, or a ValidationError with the message 'Invalid relay url' if invalid.

details:
This validator is implemented using the Trava validation library's `Check` function. It creates a validator that performs two checks:
1. Verifies the input is a string using `typeof x === "string"`
2. Validates that the string is a valid relay URL using the `isRelayUrl` function imported from `@welshman/util`

The validator is used in various feed validation functions throughout the file, particularly in `validateRelayFeed` and as part of the `validateLabelFeed` implementation.

related: Check

=========================
workspace: packages/feeds
file: packages/feeds/src/validate.ts
lines: 15:15
id: f3ea4d3919a46076ae2b5246e3c877914ec4c649480d7c06a821d61b91a95b6c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/validate.ts#L15

declaration:
validateScope = Check((x: any) => Object.values(Scope).includes(x), "Invalid scope")

summary:
A validator function that checks if a value is a valid scope from the Scope enum. It uses the Trava validation library's Check function to verify that the input value is included in the values of the Scope enum. Returns the input value if valid, or a ValidationError with the message 'Invalid scope' if invalid.

details:
This is a simple validator implementation that uses the Trava library's Check function to create a validator. It takes any input value and checks if it exists in the Object.values(Scope) array, which contains all the possible enum values from the Scope enum imported from './core.js'. The implementation is straightforward with no complex logic.

related: Check

=========================
workspace: packages/feeds
file: packages/feeds/src/validate.ts
lines: 17:17
id: 4260fc46029634cd0708be37180c7eaec70fc2c347fbe38fd3df073ccbe6c0da
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/validate.ts#L17

declaration:
validateHex = Check((x: any) => typeof x === "string" && x.length === 64, "Invalid hex value")

summary:
A validator function that checks if a value is a valid hexadecimal string of exactly 64 characters. Returns the original value if valid, or throws a ValidationError with the message 'Invalid hex value' if invalid.

details:
This validator is implemented using the Trava library's Check function. It performs two validations:
1. Checks if the input is a string using typeof
2. Verifies the string length is exactly 64 characters (which corresponds to a 32-byte/256-bit value in hex representation)

This is commonly used to validate Nostr event IDs, public keys, and other cryptographic values that are represented as 32-byte hex strings.

related: Check

=========================
workspace: packages/feeds
file: packages/feeds/src/validate.ts
lines: 19:22
id: de5c1c81e6dab9874194a38f27cbffa24a0cb135dc4138fc43a5156673768322
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/validate.ts#L19

declaration:
validateAddress = Check(
  (x: any) => typeof x === "string" && Address.isAddress(x),
  "Invalid address",
)

summary:
A validator function that checks if a value is a valid address. It uses the Trava validation library's Check function to verify that the input is a string and passes the Address.isAddress check. Returns the input value if valid, or a ValidationError with the message 'Invalid address' if invalid.

details:
This validator is implemented using the Trava library's Check function, which creates a validator that tests the input against a predicate function. The predicate checks two conditions:
1. The input is a string type
2. The input passes the Address.isAddress validation from the @welshman/util package

If both conditions are met, the original value is returned. Otherwise, a ValidationError with the message 'Invalid address' is returned. This validator is used as part of a larger validation system for different feed types in the application.

related: Check

=========================
workspace: packages/feeds
file: packages/feeds/src/validate.ts
lines: 24:24
id: f6da7d9f9ca24cd610318061de82781441c86d76621418b44b6db25f745e798a
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/validate.ts#L24

declaration:
validateArray = Check((x: any) => Array.isArray(x), "Value must be an array")

summary:
A validator function that checks if a value is an array. It returns the original value if it's an array, or a ValidationError if it's not.

details:
This is a simple validator created using the Trava library's `Check` function. It uses JavaScript's native `Array.isArray()` method to determine if the input is an array. If the check fails, it returns a ValidationError with the message "Value must be an array".

related: Check

=========================
workspace: packages/feeds
file: packages/feeds/src/validate.ts
lines: 26:26
id: bb87e77c26d115c69f1ef3afc5b18d2f2f9797c50fb2a0f31d7f39b0c78f8b0f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/validate.ts#L26

declaration:
validateObject = Check((x: any) => isPojo(x), "Value must be an object")

summary:
A validator function that checks if a value is a plain JavaScript object (POJO). It uses the `Check` function from the Trava validation library and the `isPojo` utility from '@welshman/lib'. Returns the input value if it's a POJO, otherwise returns a ValidationError with the message 'Value must be an object'.

details:
This is a simple validator implementation that uses the Trava validation library's `Check` function to create a validator that verifies if a value is a plain JavaScript object. It delegates the actual validation logic to the imported `isPojo` function from '@welshman/lib'. The validator is used as part of a larger validation system for different types of feed data in the application.

related: Check

=========================
workspace: packages/feeds
file: packages/feeds/src/validate.ts
lines: 30:35
id: 566d7cd0f07532a04da0d7f9e4de082405827c79b35ca4449aef7f602231eb2f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/validate.ts#L30

declaration:
validateTagFeedMapping = Compose([
  validateArray,
  Check(spec({length: 2}), "Tag feed mappings must have two entries"),
  (a: any[]) => validateString(a[0]),
  (a: any[]) => validateFeed(a[1]),
])

summary:
A validator function that checks if a value is a valid tag feed mapping. A valid tag feed mapping is an array of exactly two elements, where the first element is a string and the second element is a valid feed. Returns the validated tag feed mapping or a ValidationError if validation fails.

details:
This validator is implemented as a composition of multiple validation steps using Trava's Compose utility:
1. First checks if the input is an array using validateArray
2. Then verifies the array has exactly 2 elements using spec({length: 2})
3. Validates that the first element (a[0]) is a string
4. Validates that the second element (a[1]) is a valid feed structure

The function relies on other validators defined in the file (validateArray, validateString, validateFeed) and uses the Compose pattern to chain these validations together.

related: Compose

import/access examples:
import { validateTagFeedMapping } from '@welshman/feeds';
import { validateTagFeedMapping } from '@welshman/feeds/validate';


=========================
workspace: packages/feeds
file: packages/feeds/src/validate.ts
lines: 37:47
id: 483b8dfe9810c379863b6c556d397dd3dad3a619616a653c939427a6a71a395e
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/validate.ts#L37

declaration:
validateFeedArgs = (validateArgument: Trava.Validator) => (feed: any) => {
  let error = validateArray(feed)
  if (error instanceof ValidationError) return error

  for (const argument of getFeedArgs(feed)) {
    error = validateArgument(argument)
    if (error instanceof ValidationError) return error
  }

  return feed
}

summary:
A higher-order validator function that creates feed validators. It takes a validator function for feed arguments and returns a new validator function that validates an array-based feed structure. The returned validator checks if the input is an array and then applies the provided argument validator to each argument in the feed. Returns either the validated feed or a ValidationError.

details:
The implementation:
1. Takes a validator function as input parameter
2. Returns a new function that accepts a feed to validate
3. First validates that the feed is an array using the validateArray helper
4. If the feed is not an array, returns the validation error
5. Uses getFeedArgs (imported from ./utils.js) to extract the arguments from the feed
6. Iterates through each argument and applies the provided validator
7. If any argument fails validation, immediately returns the validation error
8. If all validations pass, returns the original feed unchanged

import/access examples:
import { validateFeedArgs } from '@welshman/feeds';
import { validateFeedArgs } from '@welshman/feeds/validate';


=========================
workspace: packages/feeds
file: packages/feeds/src/validate.ts
lines: 49:49
id: 282a2eb812e4472ce81d9211118f3a8b88790aadaf8d688c6c7b945a7ef58a8c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/validate.ts#L49

declaration:
validateAddressFeed = validateFeedArgs(validateAddress)

summary:
A validator function that checks if a feed array contains valid address arguments. It uses the `validateFeedArgs` higher-order function with the `validateAddress` validator to ensure all arguments in the feed are valid addresses.

details:
This function is implemented as a specialized validator created by calling the `validateFeedArgs` higher-order function with the `validateAddress` validator. It extracts arguments from the feed using `getFeedArgs` and applies the address validation to each argument. The function returns either the original feed if validation passes or a `ValidationError` if any argument fails validation. The address validation checks if the string is a valid address format using the `Address.isAddress` utility.

related: __function,validateFeedArgs

import/access examples:
import { validateAddressFeed } from '@welshman/feeds';
import { validateAddressFeed } from '@welshman/feeds/validate';


=========================
workspace: packages/feeds
file: packages/feeds/src/validate.ts
lines: 51:51
id: fd7d6b20fdf501f13be36cd784825dcaa7685902323d520be842ac014098f25c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/validate.ts#L51

declaration:
validateAuthorFeed = validateFeedArgs(validateHex)

summary:
A validator function that checks if a feed array contains valid author hexadecimal values. It ensures that each argument in the feed is a valid 64-character hexadecimal string.

details:
This function is an application of the `validateFeedArgs` higher-order function with the `validateHex` validator. It extracts arguments from the feed using `getFeedArgs` and applies the hex validation to each argument. The implementation leverages the Trava validation library to perform the checks and return appropriate validation errors when the input doesn't meet the requirements.

related: __function,validateFeedArgs

import/access examples:
import { validateAuthorFeed } from '@welshman/feeds';
import { validateAuthorFeed } from '@welshman/feeds/validate';


=========================
workspace: packages/feeds
file: packages/feeds/src/validate.ts
lines: 53:59
id: fdfa329faf2b18584a4fa68281146d100b1c8560501e4410916041a7c1bdd932
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/validate.ts#L53

declaration:
validateCreatedAtFeed = validateFeedArgs(
  Keys({
    since: Optional(validateNumber),
    until: Optional(validateNumber),
    relative: Optional(Each(validateString)),
  }),
)

summary:
A validator function for created-at feed arguments. It validates that the feed is an array and that any arguments conform to the expected structure: an object that may contain 'since' and 'until' properties (which must be numbers if present) and a 'relative' property (which must be an array of strings if present).

details:
This validator is implemented using the `validateFeedArgs` higher-order function, which applies a specific validator to each argument in a feed. The validator used here is created with the `Keys` function from Trava, which validates an object against a schema.

The schema specifies three optional properties:
1. `since`: An optional number (validated by `validateNumber`)  
2. `until`: An optional number (validated by `validateNumber`)
3. `relative`: An optional array of strings (validated by `Each(validateString)`)

Each property is wrapped in `Optional()` to indicate they aren't required.

related: __function,validateFeedArgs

import/access examples:
import { validateCreatedAtFeed } from '@welshman/feeds';
import { validateCreatedAtFeed } from '@welshman/feeds/validate';


=========================
workspace: packages/feeds
file: packages/feeds/src/validate.ts
lines: 61:68
id: 9a6db0f7b631a109ed6730fed0f2d6dce0609de770a58f9deedcbf3f8de14be3
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/validate.ts#L61

declaration:
validateDVMFeed = validateFeedArgs(
  Keys({
    kind: validateNumber,
    tags: Optional(Each(validateString)),
    relays: Optional(Each(validateString)),
    mappings: Optional(Each(validateTagFeedMapping)),
  }),
)

summary:
A validator function for DVM (Distributed Virtual Machine) feed data. It ensures that the feed array contains valid arguments where each argument must have a 'kind' property as a number, and may optionally include 'tags' (array of strings), 'relays' (array of strings), and 'mappings' (array of tag feed mappings).

details:
This function is implemented using the `validateFeedArgs` higher-order function which creates a validator for feed arguments. It uses the Trava validation library's `Keys` validator to define the expected structure of each DVM feed argument:

1. 'kind' - Required number value
2. 'tags' - Optional array of strings
3. 'relays' - Optional array of strings
4. 'mappings' - Optional array of tag feed mappings (validated by validateTagFeedMapping)

The implementation leverages the composition pattern where validators are combined to create more complex validation rules.

related: __function,validateFeedArgs

import/access examples:
import { validateDVMFeed } from '@welshman/feeds';
import { validateDVMFeed } from '@welshman/feeds/validate';


=========================
workspace: packages/feeds
file: packages/feeds/src/validate.ts
lines: 70:70
id: 24455bc640a71fea7c217ab50cddeccb77358a683e84add4ff09020fef3cede8
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/validate.ts#L70

declaration:
validateDifferenceFeed = validateFeedArgs((x: any) => validateFeed(x))

summary:
A validator function that checks if a feed is a valid difference feed. It ensures the feed is an array and validates each argument in the feed by passing it to the validateFeed function. Returns the feed if valid or a ValidationError if invalid.

details:
This function is implemented using the validateFeedArgs higher-order function, which creates a validator that checks if the input is an array and then applies a specific validator to each argument in the feed. In this case, it uses validateFeed as the argument validator, meaning each argument in a difference feed must itself be a valid feed. This enables validation of nested feed structures where a difference feed contains other feeds as its arguments.

related: __function,validateFeedArgs

import/access examples:
import { validateDifferenceFeed } from '@welshman/feeds';
import { validateDifferenceFeed } from '@welshman/feeds/validate';


=========================
workspace: packages/feeds
file: packages/feeds/src/validate.ts
lines: 72:72
id: 4ff7b305f74b54803d913e86d3b1651a8de950fdb884e8f547c9b8536de014d6
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/validate.ts#L72

declaration:
validateIDFeed = validateFeedArgs(validateHex)

summary:
A validator function that checks if a feed is a valid ID feed. It ensures the feed is an array and that all arguments in the feed are valid hexadecimal strings of length 64.

details:
This function is implemented by using the `validateFeedArgs` higher-order function, which applies the `validateHex` validator to each argument in the feed. The `validateHex` function checks if a value is a string with exactly 64 characters, which is the standard length for a hexadecimal identifier in this system. This validator is used in the main `validateFeed` function to validate feeds of type `FeedType.ID`.

related: __function,validateFeedArgs

import/access examples:
import { validateIDFeed } from '@welshman/feeds';
import { validateIDFeed } from '@welshman/feeds/validate';


=========================
workspace: packages/feeds
file: packages/feeds/src/validate.ts
lines: 74:74
id: 0e9b2b8399e607eb261e091f3e4be84f7417b5a68f51ae34584e2bf6f7def3a5
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/validate.ts#L74

declaration:
validateIntersectionFeed = validateFeedArgs((x: any) => validateFeed(x))

summary:
A validator function that checks if a feed is a valid intersection feed. It ensures the feed is an array and that each argument in the feed is a valid feed itself. Returns the feed if valid, or a ValidationError if invalid.

details:
This function is implemented using the `validateFeedArgs` higher-order function, which applies a validator to each argument in a feed. In this case, it applies the `validateFeed` function to each argument, ensuring that each item in the intersection feed is itself a valid feed. The implementation is straightforward - it's a composition of two existing validators without additional logic.

related: __function,validateFeedArgs

import/access examples:
import { validateIntersectionFeed } from '@welshman/feeds';
import { validateIntersectionFeed } from '@welshman/feeds/validate';


=========================
workspace: packages/feeds
file: packages/feeds/src/validate.ts
lines: 76:76
id: 5da97f19da23e53aa3ded899862c5886c0198039ca8d6a26116db4b541749733
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/validate.ts#L76

declaration:
validateGlobalFeed = validateFeedArgs((x: any) => validateFeed(x))

summary:
A validator function that checks if a global feed is valid. It takes a feed array as input and validates that each argument in the feed is itself a valid feed structure. Returns the feed if valid, or a ValidationError if any validation fails.

details:
This function is an implementation of the validateFeedArgs higher-order function, which creates a validator for feed arguments. It specifically validates global feeds by ensuring:
1. The input is an array (handled by validateFeedArgs)
2. Each argument in the feed is itself a valid feed structure by recursively calling validateFeed on each argument

The implementation is straightforward - it's a direct application of validateFeedArgs with a validator function that calls validateFeed on each argument.

related: __function,validateFeedArgs

import/access examples:
import { validateGlobalFeed } from '@welshman/feeds';
import { validateGlobalFeed } from '@welshman/feeds/validate';


=========================
workspace: packages/feeds
file: packages/feeds/src/validate.ts
lines: 78:78
id: 54a56ba606b1028232c74fc08a271b956af68e4d2ab676c8694f0be630c94330
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/validate.ts#L78

declaration:
validateKindFeed = validateFeedArgs(validateNumber)

summary:
A validator function that checks if a feed array has a valid 'kind' parameter. It ensures that the feed is an array and that all arguments in the feed are valid numbers.

details:
This function is an implementation of `validateFeedArgs` with `validateNumber` as the argument validator. It validates that:
1. The input is an array (using `validateArray`)
2. Each argument extracted from the feed (via `getFeedArgs`) is a number

It's a simple composition that reuses the `validateFeedArgs` higher-order function to create a specialized validator for kind feeds.

related: __function,validateFeedArgs

import/access examples:
import { validateKindFeed } from '@welshman/feeds';
import { validateKindFeed } from '@welshman/feeds/validate';


=========================
workspace: packages/feeds
file: packages/feeds/src/validate.ts
lines: 80:85
id: cbf6ffe4fb3f7920d51cb5b26b590ab1d08f7eead3b130262c58597de256bc84
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/validate.ts#L80

declaration:
validateListFeed = validateFeedArgs(
  Keys({
    addresses: Optional(Each(validateString)),
    mappings: Optional(Each(validateTagFeedMapping)),
  }),
)

summary:
A validator function for list feeds that ensures the feed arguments conform to the expected structure. It validates that the feed is an array and that any arguments in the feed match the specified schema. The schema allows for optional 'addresses' (an array of strings) and optional 'mappings' (an array of tag feed mappings).

details:
This function is implemented using the `validateFeedArgs` higher-order function, which creates a validator that checks each argument in a feed against a provided validator. In this case, the argument validator is created using the `Keys` validator from the Trava library, which validates an object against a schema.

The schema specifies two optional properties:
1. `addresses`: An array of strings, validated with `Each(validateString)`
2. `mappings`: An array of tag feed mappings, validated with `Each(validateTagFeedMapping)`

The implementation leverages the Trava validation library's composition capabilities to create a clean, declarative validation pipeline.

related: __function,validateFeedArgs

import/access examples:
import { validateListFeed } from '@welshman/feeds';
import { validateListFeed } from '@welshman/feeds/validate';


=========================
workspace: packages/feeds
file: packages/feeds/src/validate.ts
lines: 87:116
id: abcca22e51e3a0955a91a3a4ad85418062dc89cd3f4e19d7df92a63440368abc
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/validate.ts#L87

declaration:
validateLabelFeed = validateFeedArgs(
  Compose([
    validateObject,
    (item: any) => {
      const validateRelays = Each(validateRelay)
      const validateAuthors = Each(validateHex)
      const validateStrings = Each(validateString)
      const validateMappings = Each(validateTagFeedMapping)

      for (const [key, value] of Object.entries(item)) {
        let error
        if (key === "relays") {
          error = validateRelays(value)
        } else if (key === "authors") {
          error = validateAuthors(value)
        } else if (key === "mappings") {
          error = validateMappings(value)
        } else if (key.match("^#.$")) {
          error = validateStrings(value)
        } else {
          error = new ValidationError("Invalid label item")
        }

        if (error instanceof ValidationError) return error
      }

      return item
    },
  ]),
)

summary:
A validator function for label feeds that ensures the feed arguments conform to expected structure. It validates that the feed is an array and that each item in the feed is an object with valid properties. Valid properties include 'relays' (must be valid relay URLs), 'authors' (must be valid hex values), 'mappings' (must be valid tag feed mappings), and tag properties (starting with '#' followed by a character, must be strings).

details:
The implementation uses the `validateFeedArgs` higher-order function to create a validator that processes each argument in a feed. Inside, it applies a composition of validators:

1. First checks if the item is a valid object using `validateObject`
2. Then performs detailed validation on each property of the object:
   - For 'relays': validates each value is a valid relay URL
   - For 'authors': validates each value is a valid hex string
   - For 'mappings': validates each value is a valid tag feed mapping
   - For properties matching the pattern '^#.$' (tag properties): validates each value is a string
   - For any other property: returns a ValidationError

The function returns either the validated item or a ValidationError if validation fails at any point.

related: __function,validateFeedArgs

import/access examples:
import { validateLabelFeed } from '@welshman/feeds';
import { validateLabelFeed } from '@welshman/feeds/validate';


=========================
workspace: packages/feeds
file: packages/feeds/src/validate.ts
lines: 118:123
id: 8110c9afcabec5275f2eccb80d3ab04aba7d602bc7a962e2e013a28ea57df9e4
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/validate.ts#L118

declaration:
validateWOTFeed = validateFeedArgs(
  Keys({
    min: Optional(validateNumber),
    max: Optional(validateNumber),
  }),
)

summary:
A validator function for Web of Trust (WOT) feeds. It validates that the feed is an array and that any arguments provided conform to the expected structure, which may include optional 'min' and 'max' numeric parameters.

details:
This function is implemented using the `validateFeedArgs` higher-order function, which creates a validator that checks:
1. If the input is an array
2. If all arguments in the feed (extracted via `getFeedArgs`) pass validation

For WOT feeds specifically, it validates the arguments using the `Keys` validator from Trava, which checks that the object has the correct structure with optional 'min' and 'max' properties that must be numbers if present.

The implementation leverages the Trava validation library's composition pattern to create a reusable validator for WOT feed structures.

related: __function,validateFeedArgs

import/access examples:
import { validateWOTFeed } from '@welshman/feeds';
import { validateWOTFeed } from '@welshman/feeds/validate';


=========================
workspace: packages/feeds
file: packages/feeds/src/validate.ts
lines: 125:125
id: 9e68faf73627aa44e90fcb4536d2d63006d22ab18c500452c072860875f9f01f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/validate.ts#L125

declaration:
validateRelayFeed = validateFeedArgs(validateRelay)

summary:
A validator function that checks if a feed array contains valid relay URLs. It uses the `validateFeedArgs` higher-order function to validate each argument in the feed against the `validateRelay` validator, which ensures each value is a string and a valid relay URL.

details:
This function is implemented using the `validateFeedArgs` higher-order function, which applies the `validateRelay` validator to each argument in the feed. The implementation is straightforward:

1. It first validates that the input is an array
2. Then it extracts the feed arguments using the `getFeedArgs` utility
3. Finally, it applies the `validateRelay` validator to each argument

The `validateRelay` validator checks that each value is a string and passes the `isRelayUrl` test from the `@welshman/util` package.

related: __function,validateFeedArgs

import/access examples:
import { validateRelayFeed } from '@welshman/feeds';
import { validateRelayFeed } from '@welshman/feeds/validate';


=========================
workspace: packages/feeds
file: packages/feeds/src/validate.ts
lines: 127:127
id: 2bc6c0e23902260bd4f9aeca00ea1b721cc957aa9a3270244679f95677014b9d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/validate.ts#L127

declaration:
validateScopeFeed = validateFeedArgs(validateScope)

summary:
A validator function that checks if a feed array contains valid scope values. It uses the `validateFeedArgs` higher-order function with the `validateScope` validator to ensure all arguments in the feed are valid scope values as defined in the `Scope` enum.

details:
This is a specialized validator created by applying the `validateFeedArgs` higher-order function to the `validateScope` validator. The implementation is straightforward:

1. It takes a feed array as input
2. First validates that the input is an array
3. Then extracts all arguments from the feed using the `getFeedArgs` utility
4. Applies the `validateScope` validator to each argument
5. Returns either the original feed if validation passes or a ValidationError if any check fails

The `validateScope` validator checks if a value is included in the `Scope` enum values.

related: __function,validateFeedArgs

import/access examples:
import { validateScopeFeed } from '@welshman/feeds';
import { validateScopeFeed } from '@welshman/feeds/validate';


=========================
workspace: packages/feeds
file: packages/feeds/src/validate.ts
lines: 129:129
id: 6695088b872f1c0f172af514383dfe8b54a09ffc4027d723d33a8b460991acda
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/validate.ts#L129

declaration:
validateSearchFeed = validateFeedArgs(validateString)

summary:
A validator function that checks if a search feed is valid. It ensures the feed is an array and that all arguments in the feed are strings. Returns the feed if valid, or a ValidationError if invalid.

details:
This function is implemented using the `validateFeedArgs` higher-order function, which creates a validator that checks each argument in a feed against a provided validator function. In this case, it uses the `validateString` validator to ensure all arguments in the search feed are strings.

The implementation is straightforward - it's a direct application of the `validateFeedArgs` function with the `validateString` validator as its parameter.

related: __function,validateFeedArgs

import/access examples:
import { validateSearchFeed } from '@welshman/feeds';
import { validateSearchFeed } from '@welshman/feeds/validate';


=========================
workspace: packages/feeds
file: packages/feeds/src/validate.ts
lines: 131:131
id: 5bfd7df4adf45f412aa81aef50f24f2d7ea60334602abc42435dc21554a5e7c2
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/validate.ts#L131

declaration:
validateTagFeed = validateFeedArgs(validateString)

summary:
A validator function that checks if a given feed is a valid tag feed. It ensures the feed is an array where the first element is a feed type and subsequent arguments are strings. This function is exported and can be used to validate tag feeds in the application.

details:
This function is implemented using the `validateFeedArgs` higher-order function, which creates a validator that checks each argument in a feed array. It specifically uses the `validateString` validator to ensure that each argument in the tag feed is a string. The implementation is straightforward, leveraging the existing validation infrastructure without complex logic.

related: __function,validateFeedArgs

import/access examples:
import { validateTagFeed } from '@welshman/feeds';
import { validateTagFeed } from '@welshman/feeds/validate';


=========================
workspace: packages/feeds
file: packages/feeds/src/validate.ts
lines: 133:133
id: b302d251989f59c3bd676c8039c3d0d12614da777c5c226cec53df4285bb43c9
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/validate.ts#L133

declaration:
validateUnionFeed = validateFeedArgs((x: any) => validateFeed(x))

summary:
A validator function that validates a union feed. It ensures the feed is an array and that each argument in the feed is a valid feed itself. Returns the feed if validation passes, or a ValidationError if validation fails.

details:
This function is implemented using the `validateFeedArgs` higher-order function, which applies a validator to each argument in a feed. In this case, the validator is a function that calls `validateFeed` on each argument, ensuring that each item in the union feed is itself a valid feed. This creates a recursive validation pattern where union feeds can contain other feeds, including other union feeds.

related: __function,validateFeedArgs

import/access examples:
import { validateUnionFeed } from '@welshman/feeds';
import { validateUnionFeed } from '@welshman/feeds/validate';


=========================
workspace: packages/feeds
file: packages/feeds/src/validate.ts
lines: 135:177
id: a2ea856e988f73a2c99f6f15ea313ea17abc752f3db89106c46a1a1cac89c34c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/validate.ts#L135

declaration:
validateFeed = (feed: any) => {
  const error = validateArray(feed)
  if (error instanceof ValidationError) return error

  switch (feed[0]) {
    case FeedType.Address:
      return validateAddressFeed(feed)
    case FeedType.Author:
      return validateAuthorFeed(feed)
    case FeedType.CreatedAt:
      return validateCreatedAtFeed(feed)
    case FeedType.DVM:
      return validateDVMFeed(feed)
    case FeedType.Difference:
      return validateDifferenceFeed(feed)
    case FeedType.ID:
      return validateIDFeed(feed)
    case FeedType.Intersection:
      return validateIntersectionFeed(feed)
    case FeedType.Global:
      return validateGlobalFeed(feed)
    case FeedType.Kind:
      return validateKindFeed(feed)
    case FeedType.List:
      return validateListFeed(feed)
    case FeedType.Label:
      return validateLabelFeed(feed)
    case FeedType.WOT:
      return validateWOTFeed(feed)
    case FeedType.Relay:
      return validateRelayFeed(feed)
    case FeedType.Scope:
      return validateScopeFeed(feed)
    case FeedType.Search:
      return validateSearchFeed(feed)
    case FeedType.Tag:
      return validateTagFeed(feed)
    case FeedType.Union:
      return validateUnionFeed(feed)
    default:
      return new ValidationError("Unknown feed type")
  }
}

summary:
Validates a feed array by checking if it's a valid array and then routing validation to the appropriate feed type validator based on the first element of the array. Takes a feed of any type as input and returns either the validated feed or a ValidationError if validation fails. This function serves as the main entry point for feed validation in the system.

details:
The implementation works by:
1. First checking if the input is an array using the validateArray helper
2. If valid, it uses a switch statement to determine the feed type based on the first element (feed[0])
3. For each feed type (from the FeedType enum), it calls the corresponding specialized validator function (e.g., validateAddressFeed, validateAuthorFeed, etc.)
4. Each specialized validator has been defined earlier in the file to handle the specific validation rules for that feed type
5. If the feed type is not recognized, it returns a ValidationError with "Unknown feed type" message

The function relies on a collection of specialized validator functions that are composed using the Trava validation library, with each validator handling the specific requirements of different feed types.

import/access examples:
import { validateFeed } from '@welshman/feeds';
import { validateFeed } from '@welshman/feeds/validate';


=========================
type: file
workspace: packages/feeds
path: packages/feeds/src/compiler.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/compiler.ts
summary: The FeedCompiler class is responsible for converting various feed types into request items that can be used to fetch data from Nostr relays. It supports multiple feed types like Union, Intersection, Author, DVM, List, Label, and more. The class provides methods to check if a feed can be compiled and to compile feeds into RequestItem arrays, which contain filters and relay information for data retrieval.

details: Implementation details:

1. The FeedCompiler takes options including a signer, abort signal, context, and functions to get pubkeys for scopes and WOT ranges.

2. The main compile method uses a switch statement to handle different feed types, delegating to specialized private methods for each type.

3. Simple feed types (ID, Kind, Author, etc.) are compiled into basic filter objects.

4. More complex types like Union and Intersection involve combining multiple feeds:
   - Union combines filters across relays using a Map to track filters by relay
   - Intersection finds overlapping filters and relays between feeds

5. DVM, List, and Label types involve fetching external data:
   - DVM requests data from Data Verification Methods
   - List fetches list events by address and extracts feeds from tags
   - Label fetches kind 1985 events and extracts feeds from tags

6. The implementation uses helper functions from external libraries for operations like intersection, union, and filtering.

=========================
type: file
workspace: packages/feeds
path: packages/feeds/src/controller.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/controller.ts
summary: The FeedController class manages the loading and listening of events from various feed types. It supports compiling feeds, handling different feed types (Difference, Intersection, Union), and provides methods for loading events with pagination and subscribing to real-time updates. The controller processes events through request items, applies filters, and handles callbacks for events and feed exhaustion.

details: The implementation revolves around these key components:

1. Feed handling - The controller works with different feed types (Difference, Intersection, Union) and compiled request items.

2. Memoized getters - `getRequestItems()`, `getLoader()`, and `getListener()` are memoized to avoid redundant processing.

3. Loading mechanism - The controller implements windowing for pagination with adaptive window sizing based on event counts.

4. Request handling - For direct requests, it manages filters, tracks seen events to avoid duplicates, and handles exhaustion states.

5. Set operations - For compound feeds (Difference, Intersection, Union), it creates nested controllers for each sub-feed and implements the appropriate set logic:
   - Difference: Shows events from the first feed that don't appear in other feeds
   - Intersection: Shows events that appear in all feeds
   - Union: Shows events from any feed

6. Real-time listening - Similar patterns are implemented for subscription-based event listening with proper cleanup functions.

=========================
type: file
workspace: packages/feeds
path: packages/feeds/src/core.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/core.ts
summary: This file defines a type system for feed filtering in what appears to be a Nostr-related application. It exports enums for FeedType and Scope, along with various feed-related type definitions. The core export is the Feed type, which is a union of different feed types (AddressFeed, AuthorFeed, etc.), each representing a different filtering strategy. Additional types like DVMItem, ListItem, and LabelItem provide structure for specific feed configurations.

details: The implementation consists of:
1. Two main enums: FeedType (defining all possible feed filtering types like Address, Author, Kind, etc.) and Scope (defining visibility scopes like Followers, Follows, etc.)
2. A type system built around these enums where each feed type is represented as a tuple with the feed type as the first element followed by type-specific parameters
3. Helper types for complex feed items like DVMItem, ListItem, LabelItem, WOTItem, and CreatedAtItem that define the structure of data needed for those specific feed types
4. The main Feed type which is a union of all possible feed type tuples
5. A RequestItem type that appears to be used for making requests with relay information and filters

The file imports a Filter type from an external utility package but doesn't contain any implementation logic itself - it's purely a type definition file.

=========================
type: file
workspace: packages/feeds
path: packages/feeds/src/display.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/display.ts
summary: This file exports functions for displaying human-readable descriptions of various feed types in a Nostr application. The main exported functions are `displayFeed` which converts any feed type to a string representation, and `displayFeeds` which handles multiple feeds. Each feed type (Address, Author, CreatedAt, etc.) has its own dedicated display function that formats the feed's parameters into readable text.

details: The implementation consists of specialized display functions for each feed type defined in the core.js module. Each function:
1. Takes a specific feed type as input
2. Extracts arguments using the `getFeedArgs` utility function
3. Formats these arguments into human-readable strings

The file handles various feed types including time-based feeds (with relative or absolute timestamps), author feeds, kind feeds, search feeds, and more complex types like intersection, union, and difference feeds. The implementation uses helper functions like `displayList` for formatting lists of items with appropriate conjunctions. The main `displayFeed` function works as a dispatcher that routes each feed to its appropriate display function based on the feed type enum value at index 0 of the feed array.

=========================
type: file
workspace: packages/feeds
path: packages/feeds/src/request.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/request.ts
summary: The request.ts file exports two main functions: `requestPage` and `requestDVM`. `requestPage` handles fetching events from relays based on provided filters, with special handling for search queries and local cache. `requestDVM` facilitates interaction with Decentralized Virtual Machines (DVMs) by creating and publishing a request event and then listening for responses.

details: Implementation details:

1. `requestPage` function:
   - Handles different request strategies based on whether filters contain search parameters
   - For search filters, it queries search-specific relays
   - For non-search filters, it uses the Router to determine appropriate relays
   - Uses a race mechanism to improve load times by completing after a certain threshold of requests finish
   - Queries the local relay cache last to prevent stale content from appearing first

2. `requestDVM` function:
   - Automatically discovers appropriate relays if none are provided by querying for relay lists
   - Adds necessary tags to the request if they're missing (expiration, relays, user, max_results)
   - Signs and publishes an event of the specified kind
   - Sets up a listener for responses (events with kind = original kind + 1000)
   - Returns a promise that resolves when both publishing and receiving responses are complete

=========================
type: dir
workspace: packages/feeds
path: packages/feeds/src/
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/
summary: This directory implements a comprehensive feed management system for Nostr applications. It provides a type-safe way to define, compile, validate, display, and interact with various feed types. The core functionality revolves around the 'Feed' type system defined in core.ts, which supports filtering strategies like Author, Kind, Tag, Union, Intersection, and more complex types like DVM, List, and Label feeds. The FeedCompiler converts these feed definitions into request items that can be used to fetch data from Nostr relays, while the FeedController manages loading and real-time listening of feeds with support for pagination, windowing, and deduplication. Additional utilities include human-readable feed display functions, feed validation, and helper functions for creating and manipulating feed structures. Together, these components provide a flexible and type-safe system for defining and working with complex feed filtering in Nostr applications.

=========================
type: file
workspace: packages/feeds
path: packages/feeds/src/utils.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/utils.ts
summary: This file provides utility functions for creating, manipulating, and working with various types of feeds in a Nostr-like system. It exports factory functions (make*Feed) for creating different feed types, type guards (is*Feed) for checking feed types, and utilities for extracting feed arguments, converting between tags and feeds, walking feed structures, and simplifying complex nested feeds. The module also includes functions to convert between filters and feeds.

details: The implementation consists of several groups of functions:

1. Feed creation functions (lines 33-65): A set of factory functions that create typed feed arrays with the appropriate FeedType enum as the first element.

2. Type guards (lines 67-85): Functions that check if a feed is of a specific type by examining the first element of the feed array.

3. Argument extraction (lines 87-139): An overloaded getFeedArgs function that extracts the arguments from different feed types, returning them with the correct type.

4. Feed conversion utilities (lines 141-205): Functions to convert between tags and feeds, filters and feeds, including:
   - hasSubFeeds: Checks if a feed contains sub-feeds
   - defaultTagFeedMappings: Maps tag names to feed types
   - feedsFromTags/feedFromTags: Convert tag arrays to feeds
   - feedsFromFilter/feedFromFilter/feedFromFilters: Convert filters to feeds

5. Feed traversal and manipulation (lines 207-287): Functions for working with feed structures:
   - walkFeed: Traverses a feed structure and applies a visitor function
   - findFeed: Searches for a feed matching a predicate
   - simplifyFeed: Flattens nested feed structures of the same type

=========================
type: file
workspace: packages/feeds
path: packages/feeds/src/validate.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/src/validate.ts
summary: This file provides validation utilities for different types of feeds in a system. It exports various validator functions for specific feed types (like address, author, tag, etc.) and a general `validateFeed` function that can validate any feed based on its type. It also re-exports the `ValidationError` class from the Trava library for error handling.

details: The implementation uses the Trava validation library to create composable validators. The file:

1. Defines basic validators for common types (numbers, strings, hex values, etc.)
2. Creates specialized validators for each feed type using the `validateFeedArgs` higher-order function
3. Implements a main `validateFeed` function that uses a switch statement to route validation to the appropriate specialized validator based on the feed type
4. Uses composition patterns to build complex validators from simpler ones
5. Handles validation errors by returning Trava's ValidationError instances

The validation logic checks both the structure of feeds (arrays with specific formats) and the content of their arguments based on the feed type requirements.

=========================
type: dir
workspace: packages/feeds
path: packages/feeds/
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/feeds/
summary: This directory implements a comprehensive feed management system for Nostr applications, providing a type-safe framework for defining, compiling, validating, and displaying various feed types. The main exports include the core 'Feed' type system with filtering strategies (Author, Kind, Tag, etc.), the FeedCompiler for converting feed definitions into request items, the FeedController for managing feed loading and real-time updates, and various utilities for feed validation and manipulation. The system supports complex feed types like DVM, List, and Label feeds, along with features for pagination, windowing, and deduplication, enabling flexible and type-safe feed filtering in Nostr applications.

=========================
type: file
workspace: packages/lib
file: packages/lib/package.json
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/package.json
include: always
{
  "name": "@welshman/lib",
  "version": "0.4.6",
  "author": "hodlbod",
  "license": "MIT",
  "description": "A collection of utilities.",
  "publishConfig": {
    "access": "public"
  },
  "engines": {
    "node": ">=12.0.0"
  },
  "type": "module",
  "files": [
    "dist"
  ],
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "pnpm run clean && pnpm run compile --force",
    "clean": "rimraf ./dist",
    "compile": "tsc -b tsconfig.build.json",
    "prepublishOnly": "pnpm run build"
  },
  "dependencies": {
    "@scure/base": "^1.1.6",
    "@types/events": "^3.0.3",
    "events": "^3.3.0"
  },
  "devDependencies": {
    "rimraf": "~6.0.0",
    "typescript": "~5.8.0"
  }
}


=========================
type: file
workspace: packages/lib
file: packages/lib/tsconfig.json
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/tsconfig.json
include: always
{
  "extends": "../../tsconfig.json"
}


=========================
type: file
workspace: packages/lib
file: packages/lib/src/normalize-url/readme.md
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/normalize-url/readme.md
# normalize-url [![Coverage Status](https://codecov.io/gh/sindresorhus/normalize-url/branch/main/graph/badge.svg)](https://codecov.io/gh/sindresorhus/normalize-url)

> [Normalize](https://en.wikipedia.org/wiki/URL_normalization) a URL

Useful when you need to display, store, deduplicate, sort, compare, etc, URLs.

**Note:** This package does **not** do URL sanitization. [Garbage in, garbage out.](https://en.wikipedia.org/wiki/Garbage_in,_garbage_out) If you use this in a server context and accept URLs as user input, it's up to you to protect against invalid URLs, [path traversal attacks](https://owasp.org/www-community/attacks/Path_Traversal), etc.

## Install

```sh
npm install normalize-url
```

*If you need Safari support, use version 4: `npm i normalize-url@4`*

## Usage

```js
import normalizeUrl from 'normalize-url';

normalizeUrl('sindresorhus.com');
//=> 'http://sindresorhus.com'

normalizeUrl('//www.sindresorhus.com:80/../baz?b=bar&a=foo');
//=> 'http://sindresorhus.com/baz?a=foo&b=bar'
```

## API

### normalizeUrl(url, options?)

URLs with custom protocols are not normalized and just passed through by default. Supported protocols are: `https`, `http`, `file`, and `data`.

#### url

Type: `string`

URL to normalize, including [data URL](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs).

#### options

Type: `object`

##### defaultProtocol

Type: `string`\
Default: `'http'`\
Values: `'https' | 'http'`

##### normalizeProtocol

Type: `boolean`\
Default: `true`

Prepend `defaultProtocol` to the URL if it's protocol-relative.

```js
normalizeUrl('//sindresorhus.com');
//=> 'http://sindresorhus.com'

normalizeUrl('//sindresorhus.com', {normalizeProtocol: false});
//=> '//sindresorhus.com'
```

##### forceHttp

Type: `boolean`\
Default: `false`

Normalize HTTPS to HTTP.

```js
normalizeUrl('https://sindresorhus.com');
//=> 'https://sindresorhus.com'

normalizeUrl('https://sindresorhus.com', {forceHttp: true});
//=> 'http://sindresorhus.com'
```

##### forceHttps

Type: `boolean`\
Default: `false`

Normalize HTTP to HTTPS.

```js
normalizeUrl('http://sindresorhus.com');
//=> 'http://sindresorhus.com'

normalizeUrl('http://sindresorhus.com', {forceHttps: true});
//=> 'https://sindresorhus.com'
```

This option cannot be used with the `forceHttp` option at the same time.

##### stripAuthentication

Type: `boolean`\
Default: `true`

Strip the [authentication](https://en.wikipedia.org/wiki/Basic_access_authentication) part of the URL.

```js
normalizeUrl('user:password@sindresorhus.com');
//=> 'https://sindresorhus.com'

normalizeUrl('user:password@sindresorhus.com', {stripAuthentication: false});
//=> 'https://user:password@sindresorhus.com'
```

##### stripHash

Type: `boolean`\
Default: `false`

Strip the hash part of the URL.

```js
normalizeUrl('sindresorhus.com/about.html#contact');
//=> 'http://sindresorhus.com/about.html#contact'

normalizeUrl('sindresorhus.com/about.html#contact', {stripHash: true});
//=> 'http://sindresorhus.com/about.html'
```

##### stripProtocol

Type: `boolean`\
Default: `false`

Remove the protocol from the URL: `http://sindresorhus.com` → `sindresorhus.com`.

It will only remove `https://` and `http://` protocols.

```js
normalizeUrl('https://sindresorhus.com');
//=> 'https://sindresorhus.com'

normalizeUrl('https://sindresorhus.com', {stripProtocol: true});
//=> 'sindresorhus.com'
```

##### stripTextFragment

Type: `boolean`\
Default: `true`

Strip the [text fragment](https://web.dev/text-fragments/) part of the URL.

**Note:** The text fragment will always be removed if the `stripHash` option is set to `true`, as the hash contains the text fragment.

```js
normalizeUrl('http://sindresorhus.com/about.html#:~:text=hello');
//=> 'http://sindresorhus.com/about.html#'

normalizeUrl('http://sindresorhus.com/about.html#section:~:text=hello');
//=> 'http://sindresorhus.com/about.html#section'

normalizeUrl('http://sindresorhus.com/about.html#:~:text=hello', {stripTextFragment: false});
//=> 'http://sindresorhus.com/about.html#:~:text=hello'

normalizeUrl('http://sindresorhus.com/about.html#section:~:text=hello', {stripTextFragment: false});
//=> 'http://sindresorhus.com/about.html#section:~:text=hello'
```

##### stripWWW

Type: `boolean`\
Default: `true`

Remove `www.` from the URL.

```js
normalizeUrl('http://www.sindresorhus.com');
//=> 'http://sindresorhus.com'

normalizeUrl('http://www.sindresorhus.com', {stripWWW: false});
//=> 'http://www.sindresorhus.com'
```

##### removeQueryParameters

Type: `Array<RegExp | string> | boolean`\
Default: `[/^utm_\w+/i]`

Remove query parameters that matches any of the provided strings or regexes.

```js
normalizeUrl('www.sindresorhus.com?foo=bar&ref=test_ref', {
	removeQueryParameters: ['ref']
});
//=> 'http://sindresorhus.com/?foo=bar'
```

If a boolean is provided, `true` will remove all the query parameters.

```js
normalizeUrl('www.sindresorhus.com?foo=bar', {
	removeQueryParameters: true
});
//=> 'http://sindresorhus.com'
```

`false` will not remove any query parameter.

```js
normalizeUrl('www.sindresorhus.com?foo=bar&utm_medium=test&ref=test_ref', {
	removeQueryParameters: false
});
//=> 'http://www.sindresorhus.com/?foo=bar&ref=test_ref&utm_medium=test'
```

##### keepQueryParameters

Type: `Array<RegExp | string>`\
Default: `undefined`

Keeps only query parameters that matches any of the provided strings or regexes.

**Note:** It overrides the `removeQueryParameters` option.

```js
normalizeUrl('https://sindresorhus.com?foo=bar&ref=unicorn', {
	keepQueryParameters: ['ref']
});
//=> 'https://sindresorhus.com/?ref=unicorn'
```

##### removeTrailingSlash

Type: `boolean`\
Default: `true`

Remove trailing slash.

**Note:** Trailing slash is always removed if the URL doesn't have a pathname unless the `removeSingleSlash` option is set to `false`.

```js
normalizeUrl('http://sindresorhus.com/redirect/');
//=> 'http://sindresorhus.com/redirect'

normalizeUrl('http://sindresorhus.com/redirect/', {removeTrailingSlash: false});
//=> 'http://sindresorhus.com/redirect/'

normalizeUrl('http://sindresorhus.com/', {removeTrailingSlash: false});
//=> 'http://sindresorhus.com'
```

##### removeSingleSlash

Type: `boolean`\
Default: `true`

Remove a sole `/` pathname in the output. This option is independent of `removeTrailingSlash`.

```js
normalizeUrl('https://sindresorhus.com/');
//=> 'https://sindresorhus.com'

normalizeUrl('https://sindresorhus.com/', {removeSingleSlash: false});
//=> 'https://sindresorhus.com/'
```

##### removeDirectoryIndex

Type: `boolean | Array<RegExp | string>`\
Default: `false`

Removes the default directory index file from path that matches any of the provided strings or regexes. When `true`, the regex `/^index\.[a-z]+$/` is used.

```js
normalizeUrl('www.sindresorhus.com/foo/default.php', {
	removeDirectoryIndex: [/^default\.[a-z]+$/]
});
//=> 'http://sindresorhus.com/foo'
```

##### removeExplicitPort

Type: `boolean`\
Default: `false`

Removes an explicit port number from the URL.

Port 443 is always removed from HTTPS URLs and 80 is always removed from HTTP URLs regardless of this option.

```js
normalizeUrl('sindresorhus.com:123', {
	removeExplicitPort: true
});
//=> 'http://sindresorhus.com'
```

##### sortQueryParameters

Type: `boolean`\
Default: `true`

Sorts the query parameters alphabetically by key.

```js
normalizeUrl('www.sindresorhus.com?b=two&a=one&c=three', {
	sortQueryParameters: false
});
//=> 'http://sindresorhus.com/?b=two&a=one&c=three'
```

## Related

- [compare-urls](https://github.com/sindresorhus/compare-urls) - Compare URLs by first normalizing them

---

<div align="center">
	<b>
		<a href="https://tidelift.com/subscription/pkg/npm-normalize-url?utm_source=npm-normalize-url&utm_medium=referral&utm_campaign=readme">Get professional support for this package with a Tidelift subscription</a>
	</b>
	<br>
	<sub>
		Tidelift helps make open source sustainable for maintainers while giving companies<br>assurances about security, maintenance, and licensing for their dependencies.
	</sub>
</div>


=========================
workspace: packages/lib
file: packages/lib/src/Deferred.ts
lines: 1:4
id: 8c883d8dd35bf6b782ff576b01b704b6b3fe1140b142d2eb736844c7ec90eb57
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Deferred.ts#L1

declaration:
export type CustomPromise<T, E> = Promise<T> & {
  __errorType: E
}

summary:
A type alias that extends the standard Promise type with a strongly typed error. `CustomPromise<T, E>` represents a Promise that resolves to type T and rejects with an error of type E. The `__errorType` property is used to carry the error type information at the type level.

details:
This is a simple type alias that extends the native Promise interface by adding a phantom property `__errorType` which doesn't exist at runtime but serves as a type marker to carry the error type information through the TypeScript type system. This enables better type checking and intellisense for error handling when working with promises.

import/access examples:
import type { CustomPromise } from '@welshman/lib';
import type { CustomPromise } from '@welshman/lib/Deferred';


=========================
workspace: packages/lib
file: packages/lib/src/Deferred.ts
lines: 6:15
id: 934e49161e44760de4c116f13bd6ce957adcf9592528ba5a8bff8bace8c2d25c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Deferred.ts#L6

declaration:
export function makePromise<T, E>(
  executor: (resolve: (value: T | PromiseLike<T>) => void, reject: (reason: E) => void) => void,
): CustomPromise<T, E>

summary:
Creates a Promise with strongly typed error handling. This function allows you to create a Promise where the error type is explicitly defined in the type system.

@param executor - A standard Promise executor function that receives resolve and reject callbacks
@returns A Promise that has its error type explicitly defined as E in the type system

details:
The implementation is straightforward - it simply creates a standard Promise with the provided executor function and then type casts it to CustomPromise<T, E>. This is a type-level enhancement that doesn't change runtime behavior but provides better type safety by tracking the error type in the TypeScript type system.

The function doesn't add any additional logic beyond the standard Promise constructor, it just adds the type information through the cast to CustomPromise<T, E>.

related: CustomPromise

code:
export function makePromise<T, E>(
  executor: (resolve: (value: T | PromiseLike<T>) => void, reject: (reason: E) => void) => void,
): CustomPromise<T, E> {
  return new Promise(executor) as CustomPromise<T, E>
}

import/access examples:
import { makePromise } from '@welshman/lib';
import { makePromise } from '@welshman/lib/Deferred';


=========================
workspace: packages/lib
file: packages/lib/src/Deferred.ts
lines: 17:21
id: 0d54c40c46a139dac2ca3c3a167865620281bed1e838744d329926015681679b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Deferred.ts#L17

declaration:
export type Deferred<T, E = T> = CustomPromise<T, E> & {
  resolve: (arg: T) => void
  reject: (arg: E) => void
}

summary:
A type alias that represents a Promise with strongly typed error handling and exposed resolve/reject functions. The `Deferred<T, E>` type extends `CustomPromise<T, E>` by adding accessible `resolve` and `reject` methods, allowing external control over the promise's state. The generic type `T` represents the resolved value type, while `E` (defaulting to `T` if not specified) represents the error type.

details:
This type combines the `CustomPromise<T, E>` type with additional properties for controlling the promise state externally. It's designed to be used with the `defer()` function which creates instances of this type. The implementation allows for better TypeScript type checking of promise errors and provides a way to resolve or reject promises from outside the promise executor function, which is useful for coordinating asynchronous operations.

related: CustomPromise

import/access examples:
import type { Deferred } from '@welshman/lib';
import type { Deferred } from '@welshman/lib/Deferred';


=========================
workspace: packages/lib
file: packages/lib/src/Deferred.ts
lines: 27:35
id: 56ccdb79d822669731144b5bc3d7581a9e1c5d8c7d710576808671df4288b522
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Deferred.ts#L27

declaration:
defer = <T, E = T>(): Deferred<T, E> => {
  let resolve, reject
  const p = makePromise((resolve_, reject_) => {
    resolve = resolve_
    reject = reject_
  })

  return Object.assign(p, {resolve, reject}) as unknown as Deferred<T, E>
}

summary:
Creates a Deferred promise that exposes its resolve and reject functions. This allows controlling the promise resolution from outside the executor function.

The function takes no parameters and returns a Deferred<T, E> object, which is a Promise with strongly typed error E (defaulting to T) and exposed resolve/reject methods.

@returns A Promise object with attached resolve and reject methods that can be called externally to settle the promise.

details:
The implementation:
1. Declares uninitialized resolve and reject variables
2. Creates a promise using the makePromise helper function, capturing the resolve and reject functions from the executor
3. Uses Object.assign to attach the resolve and reject functions to the promise object itself
4. Returns the enhanced promise object after type casting it to Deferred<T, E>

This pattern is commonly known as the "deferred pattern" and allows for more flexible promise handling by separating promise creation from resolution.

related: Deferred

import/access examples:
import { defer } from '@welshman/lib';
import { defer } from '@welshman/lib/Deferred';


=========================
workspace: packages/lib
file: packages/lib/__tests__/Deferred.test.ts
lines: 9:9
id: 3563b707e4eb0c6c28f8cd438c0e808f6032d8949309cfa882f4a35594159c84
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/__tests__/Deferred.test.ts#L9

declaration:
eventId: string

summary:
A property named `eventId` of type `string` within the `SuccessResponse` interface. It represents an identifier for an event in the response object.

details:
This property is part of the `SuccessResponse` type definition used in the test suite. It's initialized in test cases with a repeated hexadecimal string (`"ff".repeat(32)`) to simulate an event identifier. The property is used throughout the test suite to verify that deferred promises correctly handle and preserve data structures when resolving.

=========================
workspace: packages/lib
file: packages/lib/__tests__/Deferred.test.ts
lines: 10:10
id: aaaa56af5d4795d06e2722b404ee75f46e39520de5746da53ffd4186c1ca6f41
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/__tests__/Deferred.test.ts#L10

declaration:
pubkey: string

summary:
pubkey is a constant string used in the test suite representing a dummy public key. It is a 64‑character hex‑like string created by repeating "ee" 32 times. It is not exported and only used within the test file for constructing mock success and error responses.

details:
Declared as a const on line 5 of __tests__/Deferred.test.ts. The value is computed by calling the built‑in String.prototype.repeat method: "ee".repeat(32), resulting in a string of 64 characters. It has no side effects and is only referenced by the test cases to populate the `pubkey` field of mock response objects.

=========================
workspace: packages/lib
file: packages/lib/__tests__/Deferred.test.ts
lines: 11:11
id: 197c8913430433e568f4e6f1b550a8c2e722a1a91953dc6b0af30672022a004f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/__tests__/Deferred.test.ts#L11

declaration:
success: true

summary:
A property signature that defines a boolean property named 'success' with a literal value of 'true'. This property is part of the SuccessResponse type and indicates a successful operation.

details:
This is a simple property signature within the SuccessResponse type definition. It uses a literal type 'true' to ensure that all SuccessResponse objects must have this exact value for the success property, making it function as a discriminant property for type narrowing when working with union types (likely with ErrorResponse which has success: false).

=========================
workspace: packages/lib
file: packages/lib/__tests__/Deferred.test.ts
lines: 15:15
id: 680bdd9ba58418c27a85a774bfd040031b3013dbf40b1672f040064fbf3ddf3b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/__tests__/Deferred.test.ts#L15

declaration:
code: number

summary:
The `code` property is a numeric field within the `ErrorResponse` type that represents an error code. It's used to identify the type or category of error that occurred.

=========================
workspace: packages/lib
file: packages/lib/__tests__/Deferred.test.ts
lines: 16:16
id: a6cae0d3d41428577139202793fba6d6ccb67dba8bd8fa3e23a269a15cc61e44
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/__tests__/Deferred.test.ts#L16

declaration:
message: string

summary:
The `message` property is a string field within the `ErrorResponse` type that represents an error message describing what went wrong in an operation.

=========================
workspace: packages/lib
file: packages/lib/__tests__/Deferred.test.ts
lines: 17:17
id: b3b5488e0a5449e97a127aac8813044668eab06858e71c086ce6fae8f9f62709
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/__tests__/Deferred.test.ts#L17

declaration:
success: false

summary:
A property signature in the `ErrorResponse` type that indicates the operation failed. It is a boolean literal type with a value of `false`.

=========================
workspace: packages/lib
file: packages/lib/src/Emitter.ts
lines: 3:19
id: 5834b7ccf1ccf4f1509dbc6b2267b0bdb369483646326b7a7f446fbc535661f9
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Emitter.ts#L3

declaration:
/**
 * Extended EventEmitter that also emits all events to '*' listeners
 */
export class Emitter extends EventEmitter{
  /**
     * Emits an event to listeners and to '*' listeners
     * @param type - Event type/name
     * @param args - Arguments to pass to listeners
     * @returns True if event had listeners
     */
    emit(type: string, ...args: any[]);
}

summary:
Emitter is a class that extends Node.js EventEmitter to provide enhanced event handling. In addition to standard event emission, it automatically broadcasts all events to special '*' listeners, allowing for global event monitoring. This makes it useful for implementing logging, debugging, or centralized event handling in applications.

details:
The implementation is straightforward - it overrides the standard `emit` method from EventEmitter to:
1. First emit the event to specific listeners using the parent class implementation
2. Then emit the same event to '*' listeners, passing the event type as the first argument
3. Return true only if both emissions had listeners (logical AND of both results)

This dual-emission approach ensures that both targeted and global listeners receive events while maintaining the expected return value semantics of the original EventEmitter.

code:
export class Emitter extends EventEmitter {
  /**
   * Emits an event to listeners and to '*' listeners
   * @param type - Event type/name
   * @param args - Arguments to pass to listeners
   * @returns True if event had listeners
   */
  emit(type: string, ...args: any[]) {
    const a = super.emit(type, ...args)
    const b = super.emit("*", type, ...args)

    return a && b
  }
}

import/access examples:
import { Emitter } from '@welshman/lib';
import { Emitter } from '@welshman/lib/Emitter';


=========================
workspace: packages/lib
file: packages/lib/src/LRUCache.ts
lines: 1:46
id: 279298b05b99dea23b970c7c374e0e007e2a57e5d4d6f09592cccfdaa42c8ede
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/LRUCache.ts#L1

declaration:
/**
 * Least Recently Used (LRU) cache implementation
 * @template T - Type of cache keys
 * @template U - Type of cache values
 */
export class LRUCache<T, U>{
  map: Map<T, U>;
  keys: T[];
  constructor(readonly maxSize: number = Infinity);
  has(k: T);
  get(k: T);
  set(k: T, v: U);
  pop(k: T);
}

summary:
LRUCache is a generic class that implements a Least Recently Used (LRU) cache. It stores key-value pairs and automatically evicts the least recently used items when the cache exceeds its maximum size. The class provides methods to check if a key exists (has), retrieve values (get), add new entries (set), and remove entries while returning their values (pop).

details:
The implementation uses two main data structures:
1. A Map<T, U> to store the actual key-value pairs for O(1) lookups
2. An array of keys to track usage order

When retrieving items with get(), the key is pushed to the end of the keys array to mark it as recently used. If the keys array grows too large (more than twice the maxSize), it's trimmed to keep only the most recent maxSize entries.

When setting new items with set(), if the cache exceeds maxSize, the oldest key (from the beginning of the keys array) is removed from both the array and the map.

The implementation is simple but has a potential inefficiency: the keys array can contain duplicates, as keys are pushed to the end on each access rather than being removed from their previous position first.

code:
export class LRUCache<T, U> {
  map = new Map<T, U>()
  keys: T[] = []

  constructor(readonly maxSize: number = Infinity) {}

  has(k: T) {
    return this.map.has(k)
  }

  get(k: T) {
    const v = this.map.get(k)

    if (v !== undefined) {
      this.keys.push(k as T)

      if (this.keys.length > this.maxSize * 2) {
        this.keys = this.keys.splice(-this.maxSize)
      }
    }

    return v
  }

  set(k: T, v: U) {
    this.map.set(k, v)
    this.keys.push(k)

    if (this.map.size > this.maxSize) {
      this.map.delete(this.keys.shift() as T)
    }
  }

  pop(k: T) {
    const v = this.get(k)

    this.map.delete(k)

    return v
  }
}

import/access examples:
import { LRUCache } from '@welshman/lib';
import { LRUCache } from '@welshman/lib/LRUCache';


=========================
workspace: packages/lib
file: packages/lib/src/LRUCache.ts
lines: 48:87
id: bb9ebe3a3698283db40db48a483c5abb14bd5c03dc571b6aed53112b5e599cba
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/LRUCache.ts#L48

declaration:
export function cached<T, V, Args extends any[]>({
  maxSize,
  getKey,
  getValue,
}: {
  maxSize: number
  getKey: (args: Args) => T
  getValue: (args: Args) => V
})

summary:
Creates a memoized function with LRU (Least Recently Used) caching. The function takes an object with three parameters: `maxSize` (the maximum cache size), `getKey` (a function to generate cache keys from arguments), and `getValue` (a function to compute values when not found in cache). Returns a memoized function that automatically caches results based on input arguments. The returned function also exposes the cache instance, the key and value generator functions, and a `pop` method to retrieve and remove items from the cache.

details:
Implementation details:
1. Creates a new LRUCache instance with the specified maximum size
2. Defines a `get` function that:
   - Generates a key from the arguments using the provided `getKey` function
   - Checks if the key exists in the cache
   - If not found, computes the value using `getValue` and stores it in the cache
   - Returns the cached value
3. Defines a `pop` function that retrieves and removes an item from the cache
4. Attaches additional properties to the `get` function:
   - `cache`: reference to the LRUCache instance
   - `getKey`: reference to the key generation function
   - `getValue`: reference to the value computation function
   - `pop`: the pop function for retrieving and removing items
5. Returns the enhanced `get` function as the memoized function

code:
export function cached<T, V, Args extends any[]>({
  maxSize,
  getKey,
  getValue,
}: {
  maxSize: number
  getKey: (args: Args) => T
  getValue: (args: Args) => V
}) {
  const cache = new LRUCache<T, V>(maxSize)

  const get = (...args: Args) => {
    const k = getKey(args)

    if (!cache.has(k)) {
      cache.set(k, getValue(args))
    }

    return cache.get(k)!
  }

  const pop = (...args: Args) => {
    const k = getKey(args)

    return cache.has(k) ? cache.pop(k)! : getValue(args)
  }

  get.cache = cache
  get.getKey = getKey
  get.getValue = getValue
  get.pop = pop

  return get
}

import/access examples:
import { cached } from '@welshman/lib';
import { cached } from '@welshman/lib/LRUCache';


=========================
workspace: packages/lib
file: packages/lib/src/LRUCache.ts
lines: 89:96
id: 03fd76892034777daffeb3d8e4793e8805edfaddb111351e7f70ed2e9b2b331a
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/LRUCache.ts#L89

declaration:
export function simpleCache<V, Args extends any[]>(getValue: (args: Args) => V)

summary:
Creates a simple memoized function with default settings. This utility function provides a convenient way to cache function results based on their arguments, using a Least Recently Used (LRU) caching strategy with sensible defaults. It takes a function that computes values and returns a memoized version that will cache results for repeated calls with the same arguments.

@template V - The type of values returned by the function
@template Args - The types of arguments the function accepts
@param getValue - The original function that computes values from arguments
@returns A memoized version of the function with built-in caching

details:
The implementation wraps the `cached` function with simplified defaults:

1. Sets a default maximum cache size of 100,000 entries
2. Uses a simple string-based key generation strategy by joining all arguments with a colon
3. Passes through the provided `getValue` function

This is essentially a convenience wrapper around the more configurable `cached` function, making it easier to use for common caching scenarios without needing to specify all the configuration options.

code:
export function simpleCache<V, Args extends any[]>(getValue: (args: Args) => V) {
  return cached({maxSize: 10 ** 5, getKey: xs => xs.join(":"), getValue})
}

import/access examples:
import { simpleCache } from '@welshman/lib';
import { simpleCache } from '@welshman/lib/LRUCache';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 3:3
id: 7256c4e08f2941248235a642fd97592ef44bcc3f6058bc5cf72ecdf6ef6abc83
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L3

declaration:
type Obj<T = any> = Record<string, T>

summary:
A generic type alias for objects with string keys and values of type T. It's defined as `Record<string, T>` where T defaults to `any` if not specified.

details:
This is a simple type alias that provides a shorthand way to define object types with string keys. It uses TypeScript's built-in `Record` utility type to create a type that represents an object with string keys and values of the specified type T. If no type parameter is provided, it defaults to `any`.

=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 9:9
id: d06ad78033866e41e4434048c4fdaaad0f44bbf48cbbd558eee50294e9130a47
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L9

declaration:
export type Nil = null | undefined

summary:
A type alias representing null or undefined values. This type is useful for explicitly handling cases where a value might be absent or uninitialized.

import/access examples:
import type { Nil } from '@welshman/lib';
import type { Nil } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 11:11
id: f145061018a4f97b9b86dcb18cb47bc449ef46f3435decf8d41ffc901edc63fd
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L11

declaration:
isNil = <T>(x: T, ...args: unknown[]) => x === undefined || x === null

summary:
A utility function that checks if a value is null or undefined. It takes a value of any type and returns a boolean indicating whether the value is null or undefined (i.e., 'nil').

details:
This function implements a simple nil check by using a direct comparison with both `undefined` and `null` using the strict equality operator (`===`). It accepts additional arguments through rest parameters (`...args`) but doesn't use them in the implementation. The function is generic, accepting a type parameter `<T>` to maintain type information of the input value.

import/access examples:
import { isNil } from '@welshman/lib';
import { isNil } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 13:13
id: 3e4912a5178ef97bcfbe20f433607de6e6670360b99f2126b31f8604ed46ceeb
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L13

declaration:
isNotNil = <T>(x: T, ...args: unknown[]) => x !== undefined && x !== null

summary:
A type-safe function that checks if a value is neither null nor undefined. Returns true if the value is defined and not null, false otherwise.

details:
This is a simple utility function that performs a strict inequality check against both undefined and null values. It accepts a generic type parameter T to maintain type information of the input value, and also accepts additional arguments via rest parameters (...args) which are not used in the implementation. The function uses a logical AND (&&) to ensure both conditions are met.

import/access examples:
import { isNotNil } from '@welshman/lib';
import { isNotNil } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 15:15
id: 215e29f9db6997ef4104db340001f08e7b8226cc7837f154d64631e9d7eebf60
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L15

declaration:
assertNotNil = <T>(x: T, ...args: unknown[]) => x!

summary:
A utility function that asserts a value is not null or undefined. It takes a value of any type and returns the same value with the non-null assertion operator, telling TypeScript to treat the value as non-nullable even if it might be null or undefined.

details:
This is a simple pass-through function that uses TypeScript's non-null assertion operator (!) to force the compiler to treat a potentially nullable value as definitely non-null. It doesn't actually perform any runtime checks - it just returns the input value unchanged. The function accepts additional arguments but doesn't use them. This is primarily a type-level utility to help with TypeScript's type checking.

import/access examples:
import { assertNotNil } from '@welshman/lib';
import { assertNotNil } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 21:21
id: d5237621b1feb6986775c3421e67007bb12f0b8f474dd57d49c62ccf2e9b5262
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L21

declaration:
export type Override<T, R> = Omit<T, keyof R> & R

summary:
A utility type that creates a new type by overriding properties from type T with properties from type R. It removes properties from T that exist in R, then combines the remaining properties with all properties from R.

details:
This type uses TypeScript's built-in utility types to create a new type that merges two types with precedence given to the second type. It works by:
1. Using `Omit<T, keyof R>` to remove all properties from T that have keys in R
2. Using the intersection operator `&` to combine the remaining properties from T with all properties from R

This is useful for creating modified versions of existing types where you want to override specific properties while keeping the rest intact.

import/access examples:
import type { Override } from '@welshman/lib';
import type { Override } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 23:23
id: a08fc8fc252d1a1649a63d030a061343fb45df310ea57cb6d7d07acccbcc6b0e
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L23

declaration:
export type MakeOptional<T, K extends keyof T> = Override<T, Partial<Pick<T, K>>>

summary:
A utility type that makes specific properties of a type optional. It takes a type `T` and a union of keys `K` that are keys of `T`, and returns a new type where the properties specified by `K` are optional while the rest remain as they were in the original type.

details:
This type uses TypeScript's utility types to create a new type with optional properties. It works by:
1. Using `Omit<T, keyof R>` to create a type without the properties we want to make optional
2. Using `Partial<Pick<T, K>>` to create a type with just the optional properties
3. Using `Override<T, R>` (defined earlier in the file) to merge these two types together

The result is a type that has all the same properties as the original, but with the specified keys made optional.

related: Override

import/access examples:
import type { MakeOptional } from '@welshman/lib';
import type { MakeOptional } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 30:30
id: b648d0303d75e86b7c323e6c76b19ff9dc5a7cdf9a7204b556c43268be36d647
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L30

declaration:
noop = (...args: unknown[]) => undefined

summary:
A function that does nothing and returns undefined. It accepts any number of arguments but ignores them all.

details:
This is a simple utility function that serves as a no-operation placeholder. It's commonly used in situations where a function is required but no action should be taken, such as in default callbacks or when temporarily disabling functionality. The implementation is trivial - it accepts any number of arguments via rest parameters and explicitly returns undefined.

import/access examples:
import { noop } from '@welshman/lib';
import { noop } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 37:37
id: e3914b678d734efc3f4404103be47134a65c936dbf1b59c843c884a018135028
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L37

declaration:
identity = <T>(x: T, ...args: unknown[]) => x

summary:
Returns the input value unchanged without any modifications. This is a simple identity function that takes a value of any type and returns the same value. It also accepts additional arguments which are ignored.

details:
This is a simple implementation of the identity function, a fundamental concept in functional programming. It takes a generic type parameter T to ensure type safety, allowing it to work with any data type. The function also accepts rest parameters (...args: unknown[]) which are ignored in the implementation, making it flexible for use in higher-order function contexts where additional arguments might be passed but not needed.

import/access examples:
import { identity } from '@welshman/lib';
import { identity } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 44:47
id: e456a775056d7fb1fab3bfcfb7fda23aa51b961eb86aeaf894e7d62638b4d325
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L44

declaration:
always =
  <T>(x: T, ...args: unknown[]) =>
  () =>
    x

summary:
Creates a function that always returns the same value, regardless of what arguments are passed to it when called.

@param x - Value to return
@returns Function that returns x

details:
This is a higher-order function that implements a common functional programming pattern. It takes a value and returns a new function that, when called, will always return that original value regardless of any arguments passed to it. The implementation is straightforward:

1. It accepts a generic type parameter T to preserve the type of the input value
2. It takes the value x and ignores any additional arguments via rest parameters
3. It returns a function that takes no parameters and simply returns the captured value x
4. The returned function creates a closure over the original value

import/access examples:
import { always } from '@welshman/lib';
import { always } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 54:54
id: a0eb32e178a3107e333c7dd5cc521c32207bc63220170c2819e5341b6c258753
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L54

declaration:
not = (x: any, ...args: unknown[]) => !x

summary:
Returns the logical NOT of a value. This function takes any value and returns its boolean negation using the JavaScript `!` operator.

@param x - Value to negate
@returns !x - The boolean negation of the input value

details:
A simple utility function that applies JavaScript's logical NOT operator to any input value. The function accepts additional arguments via rest parameters (...args) but ignores them, focusing only on negating the first argument. This is a straightforward implementation with no complex logic.

import/access examples:
import { not } from '@welshman/lib';
import { not } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 62:114
id: ab1333847c43349dd4525600bd08bab00e4af2536c1116ef0c86f568a19a279c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L62

declaration:
equals = (a: any, b: any) => {
  if (a === b) return true

  if (a instanceof Set && b instanceof Set) {
    a = Array.from(a)
    b = Array.from(b)
  }

  if (a instanceof Set) {
    if (!(b instanceof Set) || a.size !== b.size) {
      return false
    }

    return Array.from(a).every(x => b.has(x))
  }

  if (Array.isArray(a)) {
    if (!Array.isArray(b) || a.length !== b.length) {
      return false
    }

    for (let i = 0; i < a.length; i++) {
      if (!equals(a[i], b[i])) {
        return false
      }
    }

    return true
  }

  if (isPojo(a)) {
    if (!isPojo(b)) {
      return false
    }

    const aKeys = Object.keys(a)
    const bKeys = Object.keys(b)

    if (aKeys.length !== bKeys.length) {
      return false
    }

    for (const k of aKeys) {
      if (!equals(a[k], b[k])) {
        return false
      }
    }

    return true
  }

  return false
}

summary:
Deep equality comparison function that checks if two values are structurally equal. It handles primitive values, Sets, Arrays, and plain objects (POJOs). For complex data structures, it recursively compares their contents rather than just checking reference equality.

details:
The implementation follows a hierarchical approach to equality checking:

1. First checks for strict equality (===) for quick return
2. Handles Sets by converting them to arrays and checking if every element in one set exists in the other
3. For Arrays, checks length equality and recursively compares each element
4. For plain objects (POJOs), checks:
   - If both are POJOs
   - If they have the same number of keys
   - If each key-value pair is deeply equal using recursive calls
5. Returns false for any other type combinations

The function uses the `isPojo` helper to identify plain objects. The recursive nature allows it to handle nested data structures of arbitrary depth.

import/access examples:
import { equals } from '@welshman/lib';
import { equals } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 121:121
id: 8f1af55a29e7c790bca34ab38f5cea0a81544e05dd2bf1bcb341fb0bfcc27c9e
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L121

declaration:
ensureNumber = (x: number | string) => parseFloat(x as string)

summary:
Converts a value to a number, handling both number and string inputs. This function ensures that the input is treated as a number by using parseFloat.

details:
This is a simple utility function that takes either a number or string parameter and converts it to a number using JavaScript's parseFloat function. The implementation casts the input to string before parsing, which ensures consistent behavior regardless of whether the input is already a number or a string representation of a number.

import/access examples:
import { ensureNumber } from '@welshman/lib';
import { ensureNumber } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 124:124
id: 1d9c81134a55086fe725c8ffd39aa405db214f848a266f523a765e847fe70832
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L124

declaration:
num = (x: number | undefined) => x || 0

summary:
Converts a `number | undefined` to a number, defaulting to 0. If the input is undefined or evaluates to a falsy value, it returns 0, otherwise it returns the input number.

details:
This is a simple utility function that handles undefined values in numeric operations by providing a default value of 0. It uses JavaScript's logical OR operator (||) which returns the right-hand operand if the left-hand operand is falsy (undefined, null, 0, '', etc.). This makes it useful in calculations where you want to treat undefined values as zeros.

import/access examples:
import { num } from '@welshman/lib';
import { num } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 127:127
id: cce208e52b6691a7de044a1b17322a6a79b7e0b8f9e26f6abe436ed9b26437a0
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L127

declaration:
add = (x: number | undefined, y: number | undefined) => num(x) + num(y)

summary:
Adds two numbers, handling undefined values. This function takes two parameters that can be either numbers or undefined, and returns their sum. If either parameter is undefined, it will be treated as 0.

details:
The implementation uses the `num()` helper function to convert any undefined values to 0 before performing addition. This ensures that the function always returns a number even when given undefined inputs.

related: __function,num

import/access examples:
import { add } from '@welshman/lib';
import { add } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 130:130
id: f7dd1b206334e12149f500b594e7efed4fd6223f5c3731a57e5b954f15aac69e
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L130

declaration:
sub = (x: number | undefined, y: number | undefined) => num(x) - num(y)

summary:
Subtracts two numbers, handling undefined values. This function takes two parameters that can be either numbers or undefined, and returns their difference. If either parameter is undefined, it will be treated as 0 using the `num` function.

details:
The implementation is a simple arrow function that uses the `num` helper function to convert any undefined values to 0 before performing subtraction. This ensures the function always returns a number even when given undefined inputs.

related: __function,num

import/access examples:
import { sub } from '@welshman/lib';
import { sub } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 133:133
id: 38610db41932cba3c3a35815b7ab8e7d90efe6324d12d4f1ce5ff70a56764a36
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L133

declaration:
mul = (x: number | undefined, y: number | undefined) => num(x) * num(y)

summary:
Multiplies two numbers, handling undefined values by converting them to 0. Takes two parameters: `x` and `y`, both of type `number | undefined`, and returns their product as a number.

details:
This function uses the `num()` helper function to convert any undefined values to 0 before performing multiplication. It's a simple utility that ensures safe multiplication even when dealing with potentially undefined inputs.

related: __function,num

import/access examples:
import { mul } from '@welshman/lib';
import { mul } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 136:136
id: 81d4969c7600376fad4841b4be5eba9c350c9cf7ab0dc67a3c7391e10927426d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L136

declaration:
div = (x: number | undefined, y: number) => num(x) / y

summary:
Divides two numbers, handling undefined values. The function takes a numerator (which can be a number or undefined) and a denominator (which must be a number), and returns their quotient. If the numerator is undefined, it's treated as 0.

details:
This function uses the `num()` helper function to convert the potentially undefined numerator to a number (defaulting to 0 if undefined), then performs standard division with the denominator. Unlike other arithmetic functions in this library, the denominator parameter doesn't accept undefined values, likely to avoid division by zero issues.

related: __function,num

import/access examples:
import { div } from '@welshman/lib';
import { div } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 139:139
id: 296fbc31358930545f47dd7846a93bd4327c001343d9ebf279bbd228269f9a90
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L139

declaration:
inc = (x: number | undefined) => add(x, 1)

summary:
Increments a number by 1, handling undefined values. Takes a number or undefined as input and returns the number incremented by 1. If the input is undefined, it treats it as 0 before incrementing.

details:
This function is a simple wrapper around the `add` function, passing the input value and the constant 1. It leverages the `add` function's ability to handle undefined values by converting them to 0 before performing the addition operation.

related: __function,add

import/access examples:
import { inc } from '@welshman/lib';
import { inc } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 142:142
id: f9615352af6e378b361c91741413f611db63be1c95532f035ee7a15f405255f6
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L142

declaration:
dec = (x: number | undefined) => sub(x, 1)

summary:
Decrements a number by 1, handling undefined values. Takes a number or undefined as input and returns the number decreased by 1. If the input is undefined, it treats it as 0 before decrementing.

details:
This function is a simple wrapper around the `sub` function, passing the input value and 1 as arguments. It leverages the `sub` function's ability to handle undefined values by converting them to 0 before performing the subtraction operation. The implementation is trivial and relies on the `sub` function defined earlier in the file.

related: __function,sub

import/access examples:
import { dec } from '@welshman/lib';
import { dec } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 145:145
id: bf6a69dda07dcc69c568b571448b537af591398826244983018a4a816260c84b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L145

declaration:
lt = (x: number | undefined, y: number | undefined) => num(x) < num(y)

summary:
A function that performs a less than comparison between two numbers, handling undefined values by converting them to 0. Returns true if the first number is less than the second number.

details:
This function uses the `num()` utility function to convert any undefined values to 0 before performing the comparison. It's a simple wrapper that ensures safe comparison even when dealing with potentially undefined numeric values.

related: __function,num

import/access examples:
import { lt } from '@welshman/lib';
import { lt } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 148:148
id: 964777944aa662744e2b448debec2fee0256978fbb34f622c76ead85c5f22123
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L148

declaration:
lte = (x: number | undefined, y: number | undefined) => num(x) <= num(y)

summary:
A function that performs a less than or equal comparison between two numbers, handling undefined values by converting them to 0. Returns true if the first number is less than or equal to the second number.

details:
This function uses the `num()` utility function to safely convert potentially undefined values to numbers (defaulting to 0) before performing the comparison. It's part of a collection of mathematical comparison operators that handle undefined values gracefully.

related: __function,num

import/access examples:
import { lte } from '@welshman/lib';
import { lte } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 151:151
id: a3bab70a11403c736d8a156dc7e2905ba27c8bd74966386c5927ac7f4bda35d1
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L151

declaration:
gt = (x: number | undefined, y: number | undefined) => num(x) > num(y)

summary:
A function that performs a greater than comparison between two numbers, handling undefined values by converting them to 0. Returns true if the first number is greater than the second number.

details:
This function uses the `num()` utility function to convert any undefined values to 0 before performing the comparison. It's a simple wrapper that makes number comparisons safer by handling potential undefined inputs gracefully.

related: __function,num

import/access examples:
import { gt } from '@welshman/lib';
import { gt } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 154:154
id: bead9506d6610394fd0a033faa1c0c6b1147952e7e56c6445381e252ba2b9d75
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L154

declaration:
gte = (x: number | undefined, y: number | undefined) => num(x) >= num(y)

summary:
A function that performs a greater than or equal comparison between two numbers, handling undefined values by converting them to 0. Returns true if the first number is greater than or equal to the second number.

details:
This function uses the `num()` helper function to safely convert potentially undefined values to numbers (defaulting to 0) before performing the comparison. It's part of a collection of mathematical utility functions that handle undefined values gracefully.

related: __function,num

import/access examples:
import { gte } from '@welshman/lib';
import { gte } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 157:158
id: 482debd1e57e53f3f82a56c31ae340876b48641adb06d0c1429afdbf8d020d36
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L157

declaration:
max = (xs: (number | undefined)[]) =>
  xs.reduce((a: number, b) => Math.max(num(a), num(b)), 0)

summary:
Returns the maximum value in an array, handling undefined values by converting them to 0. The function takes an array of numbers or undefined values and returns a single number representing the maximum value found.

details:
The implementation uses the Array.reduce() method to iterate through the array and find the maximum value. For each element, it uses the num() helper function (defined elsewhere in the file) to convert any undefined values to 0, then uses Math.max() to compare with the accumulator. The initial value for the accumulator is 0, which means if the array is empty or contains only undefined values, the function will return 0.

import/access examples:
import { max } from '@welshman/lib';
import { max } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 161:167
id: 6c3744a44005455081e8d1a2c3248e6fad5d3bd703d0fc8c5675fa5aa4e185d3
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L161

declaration:
min = (xs: (number | undefined)[]) => {
  const [head, ...tail] = xs.filter(x => x !== undefined) as number[]

  if (tail.length === 0) return head || 0

  return tail.reduce((a: number, b) => Math.min(a, b), head)
}

summary:
Returns the minimum value in an array, handling undefined values. The function filters out undefined values, then uses reduce to find the minimum value. If the array is empty or contains only undefined values, it returns 0.

details:
The implementation works by first filtering out undefined values from the input array and casting the result to number[]. It then destructures this array into a head (first element) and tail (remaining elements). If there are no elements in the tail (meaning the filtered array had 0 or 1 elements), it returns the head or 0 if head is falsy. Otherwise, it uses Array.reduce() with Math.min() to find the minimum value in the tail, starting with the head as the initial accumulator value.

import/access examples:
import { min } from '@welshman/lib';
import { min } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 170:170
id: fe31ac64b927d6972b4a22f9d236964b9d2fbae15532a723c7987a3e2e6da363
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L170

declaration:
sum = (xs: (number | undefined)[]) => xs.reduce((a: number, b) => add(a, b), 0)

summary:
Returns the sum of all values in an array, handling undefined values by treating them as 0. This function reduces the array by adding each element to an accumulator, starting with 0.

details:
The implementation uses the `reduce` method to iterate through the array, applying the `add` function to each element and the accumulator. The `add` function (defined elsewhere in the file) handles undefined values by converting them to 0 before addition. This ensures that undefined values in the input array don't cause errors and are effectively treated as zeros in the summation.

import/access examples:
import { sum } from '@welshman/lib';
import { sum } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 173:173
id: 90dae8da135169a3dc545102c702c0a12b77bc89e602a46b6d19e21523cf33fa
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L173

declaration:
avg = (xs: (number | undefined)[]) => sum(xs) / xs.length

summary:
Returns the average value of an array of numbers, handling undefined values by treating them as 0. The function calculates the sum of all values in the array and divides by the array length.

details:
This function uses the `sum()` utility function to add up all the values in the array, which internally handles undefined values by converting them to 0. It then divides the sum by the total number of elements in the array (including any undefined values) to calculate the average. This is a simple implementation that doesn't filter out undefined values from the length calculation.

related: __function,sum

import/access examples:
import { avg } from '@welshman/lib';
import { avg } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 181:181
id: f62011c9b94d8b37b1d5a84d6b6fdd9b5980756a953606fb9f65f529eddc4723
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L181

declaration:
between = ([low, high]: [number, number], n: number) => n > low && n < high

summary:
Checks if a number is between two values (exclusive). The function takes a tuple of lower and upper bounds and a number to check, then returns true if the number is greater than the lower bound and less than the upper bound (not including the bounds themselves).

details:
This is a simple utility function that performs a basic range check. It destructures the first parameter as a tuple containing [low, high] values, then performs a logical AND operation between two comparisons: n > low and n < high. The function returns true only if the number is strictly between the bounds (exclusive of the bounds themselves).

import/access examples:
import { between } from '@welshman/lib';
import { between } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 189:189
id: 48577e0ff5fb8b929e3afa5d620d2ce62b9554f741ccaae7e35a2c4871d19608
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L189

declaration:
within = ([low, high]: [number, number], n: number) => n >= low && n <= high

summary:
Checks if a number is between two values (inclusive). The function takes a tuple of lower and upper bounds and a number to check, then returns true if the number is greater than or equal to the lower bound and less than or equal to the upper bound.

details:
This is a simple utility function that performs a range check with inclusive boundaries. It destructures the first parameter as a tuple of [low, high] values, then performs a compound boolean check using the >= and <= operators to determine if the provided number falls within the specified range (including the boundary values themselves).

import/access examples:
import { within } from '@welshman/lib';
import { within } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 197:197
id: c5cb2e247be684db2395a8b825cb629042671901c984ef35e6531e4c5d2dc815
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L197

declaration:
clamp = ([min, max]: [number, number], n: number) => Math.min(max, Math.max(min, n))

summary:
Constrains a number between minimum and maximum values.

@param bounds - A tuple containing [min, max] values
@param n - The number to constrain
@returns A number that is guaranteed to be within the specified bounds

details:
The implementation uses a simple but effective approach by combining Math.min and Math.max functions:
1. First applies Math.max(min, n) to ensure the value is at least the minimum
2. Then applies Math.min(max, ...) to ensure the result doesn't exceed the maximum

This creates a value that is guaranteed to be within the inclusive range [min, max].

import/access examples:
import { clamp } from '@welshman/lib';
import { clamp } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 205:206
id: c7377250e55d94f16af5d56f12e51085736e75df0ae9db93a3448f7f9e1f5a8d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L205

declaration:
round = (precision: number, x: number) =>
  Math.round(x * Math.pow(10, precision)) / Math.pow(10, precision)

summary:
Rounds a number to a specified decimal precision.

@param precision - Number of decimal places to round to
@param x - Number to round
@returns Number rounded to the specified precision

details:
The implementation uses a common mathematical technique for rounding to decimal places:
1. Multiplies the number by 10^precision to shift the decimal point
2. Uses Math.round() to round to the nearest integer
3. Divides by 10^precision to shift the decimal point back

This approach avoids floating-point precision issues that can occur with simpler methods.

import/access examples:
import { round } from '@welshman/lib';
import { round } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 214:214
id: e157300cbddfe52e7d17507da27d213e657002fc12482f442bf75aa76cea0730
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L214

declaration:
MINUTE = 60

summary:
A constant representing one minute in seconds (60). This value is used as a base unit for time calculations throughout the application.

import/access examples:
import { MINUTE } from '@welshman/lib';
import { MINUTE } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 217:217
id: 7825c5520a9c97204e99cb8c84441ee81d9489422eff975927963603e6224646
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L217

declaration:
HOUR = 60 * MINUTE

summary:
A constant representing one hour in seconds. It is calculated as 60 times the MINUTE constant (which is 60 seconds), resulting in a value of 3600 seconds.

details:
This constant is part of a set of time unit constants (MINUTE, HOUR, DAY, etc.) that provide standardized time measurements in seconds. It uses the MINUTE constant as a base to maintain consistency and readability in time calculations throughout the codebase.

related: MINUTE

import/access examples:
import { HOUR } from '@welshman/lib';
import { HOUR } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 220:220
id: e41b1dc1f81a09c78741c87ab0106b783c64806063cbaf9bb05234deeabe70fb
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L220

declaration:
DAY = 24 * HOUR

summary:
A constant representing one day in seconds. It is calculated as 24 hours, where each hour is 60 minutes and each minute is 60 seconds.

details:
This constant is defined by multiplying the HOUR constant (which is 60 * MINUTE, or 3600 seconds) by 24, resulting in 86,400 seconds. It's part of a series of time-related constants in the library that provide standard time units for calculations.

related: HOUR

import/access examples:
import { DAY } from '@welshman/lib';
import { DAY } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 223:223
id: f75b7883cbc96d2411b5c2ec71d85eec32eedf5aef1e7d6660aca8cf420dcc5e
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L223

declaration:
WEEK = 7 * DAY

summary:
A constant representing one week in seconds. It is calculated as 7 times the value of the DAY constant, providing a standardized time unit for week-based calculations.

details:
This constant is part of a series of time unit constants in the Tools.ts file. It builds upon the DAY constant (which is 24 * HOUR, where HOUR is 60 * MINUTE, and MINUTE is 60 seconds). The value equals 604,800 seconds (7 * 24 * 60 * 60). This constant is exported and can be used throughout the application for consistent time calculations.

related: DAY

import/access examples:
import { WEEK } from '@welshman/lib';
import { WEEK } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 226:226
id: 82ffa4463d47fe6711687490a6304bbc1f6a2622a418c494666f6ecfec8eb8ba
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L226

declaration:
MONTH = 30 * DAY

summary:
A constant representing one month in seconds (approximately). It is calculated as 30 days, where each day is 24 hours of 60 minutes of 60 seconds.

details:
This constant is defined as 30 * DAY, where DAY is another constant defined earlier in the file (line 220) as 24 * HOUR. It provides an approximate value for a month in seconds, using the simplification that a month is 30 days. This is useful for time-based calculations where precise calendar month lengths aren't required.

related: DAY

import/access examples:
import { MONTH } from '@welshman/lib';
import { MONTH } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 229:229
id: ca2e80e161e86d4c5208f9c45fc9c0b204235b9dfe7ad2c6e46d543724235340
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L229

declaration:
QUARTER = 90 * DAY

summary:
A constant representing one quarter (approximately 90 days) in seconds. This is a time unit constant that can be used for time-based calculations.

details:
This constant is calculated by multiplying the DAY constant (which is 24 hours * 60 minutes * 60 seconds = 86,400 seconds) by 90, resulting in approximately 7,776,000 seconds. It's part of a series of time unit constants in the library (MINUTE, HOUR, DAY, WEEK, MONTH, QUARTER, YEAR) that provide standardized time periods for calculations.

related: DAY

import/access examples:
import { QUARTER } from '@welshman/lib';
import { QUARTER } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 232:232
id: 1daca19996fd6cb8f75ff10866128fdc6f72eb2f12cd8930313f78d866fa2f4f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L232

declaration:
YEAR = 365 * DAY

summary:
A constant representing one year in seconds (approximately 365 days). This value is used for time-based calculations throughout the application.

details:
This constant is calculated by multiplying the DAY constant (defined earlier in the file as 24 * HOUR, which is 86,400 seconds) by 365, resulting in 31,536,000 seconds. It provides an approximation of a year's duration in seconds, which is useful for timestamp calculations, date arithmetic, and setting time-based thresholds or expirations.

related: DAY

import/access examples:
import { YEAR } from '@welshman/lib';
import { YEAR } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 235:235
id: bed69ff9c619351ee3c7a5033b6668816fb674ab432d695efaf57d4fb80bfd10
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L235

declaration:
LOCALE = new Intl.DateTimeFormat().resolvedOptions().locale

summary:
A constant that holds the user's default locale string, obtained from the browser's Intl.DateTimeFormat API. This locale value represents the user's language and region preferences, which can be used for internationalization purposes throughout the application.

details:
The implementation retrieves the user's locale by creating a new Intl.DateTimeFormat object without parameters (which uses the system default), then accessing the locale property from its resolvedOptions() method. This is a common pattern for detecting the user's preferred locale in browser environments. The value is stored as a constant and exported for use in formatting dates, numbers, and other locale-sensitive operations throughout the application.

import/access examples:
import { LOCALE } from '@welshman/lib';
import { LOCALE } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 238:242
id: fa7b1cbcbd9d187b27eed18c713f94918f06164f035465bae1c8503b50f42336
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L238

declaration:
TIMEZONE = (() => {
  const [_, sign = "+", offset] = new Date().toString().match(/GMT([-\+]?)(\d+)/)!

  return sign + offset.slice(0, 2) + ":" + offset.slice(2)
})()

summary:
A constant that represents the user's default timezone in the format '+HH:MM' or '-HH:MM'. It extracts the timezone information from the current date's string representation.

details:
This constant is implemented as an immediately invoked function expression (IIFE) that:
1. Gets the string representation of the current date using `new Date().toString()`
2. Uses a regular expression to extract the GMT offset information with pattern `/GMT([-\+]?)(\d+)/`
3. Destructures the regex match result to get the sign (defaulting to '+') and the numeric offset
4. Formats the timezone string by combining the sign with the hours (first 2 digits) and minutes (remaining digits), separated by a colon
5. Returns the formatted timezone string like '+01:00' or '-05:00'

related: __function

import/access examples:
import { TIMEZONE } from '@welshman/lib';
import { TIMEZONE } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 250:250
id: e304be11a1c2910d4d079c39b754f8917ab01de9070acee7ef01618b67611fef
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L250

declaration:
int = (unit: number, count = 1) => unit * count

summary:
Multiplies a time unit by a specified count to calculate total seconds. This function is useful for working with time durations in a readable way.

@param unit - Time unit in seconds
@param count - Number of units (defaults to 1)
@returns Total seconds

details:
A simple utility function that performs basic multiplication between a time unit (in seconds) and a count. It's designed to work with the time constants defined earlier in the file (like MINUTE, HOUR, DAY, etc.) to make time calculations more readable. The implementation is straightforward - it just returns the product of the unit and count parameters.

import/access examples:
import { int } from '@welshman/lib';
import { int } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 253:253
id: 4b2cef0138e91151c6cbe27f461004540667fa3fbcbe3533d40f3938be666407
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L253

declaration:
now = () => Math.round(Date.now() / 1000)

summary:
Returns the current Unix timestamp in seconds. This function provides a convenient way to get the current time as a Unix timestamp (seconds since January 1, 1970).

details:
The implementation uses JavaScript's built-in `Date.now()` method, which returns the current time in milliseconds, then divides by 1000 and rounds to the nearest integer to convert to seconds. This is a simple wrapper that standardizes timestamp handling throughout the application to use seconds rather than milliseconds.

import/access examples:
import { now } from '@welshman/lib';
import { now } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 261:261
id: 09a265e577393ccc486b06f9f53d127c92bdae9b4437e1d4cef6ffdf09768249
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L261

declaration:
ago = (unit: number, count = 1) => now() - int(unit, count)

summary:
Returns a Unix timestamp (in seconds) representing a point in time that is a specified duration in the past. The function calculates this by subtracting a time interval from the current timestamp.

@param unit - Time unit in seconds (e.g., MINUTE, HOUR, DAY constants)
@param count - Number of units to go back in time (defaults to 1)
@returns Timestamp in seconds representing the time in the past

details:
The implementation is straightforward:
1. It calls the `now()` function to get the current Unix timestamp in seconds
2. It uses the `int()` utility function to multiply the time unit by the count
3. It subtracts this calculated duration from the current timestamp

The function works with time constants defined elsewhere in the file (like MINUTE, HOUR, DAY) to create human-readable time calculations.

related: __function,now,__function,int

import/access examples:
import { ago } from '@welshman/lib';
import { ago } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 268:268
id: 4d5d3b070dad325e60a703e5363e39faecae2d4df6c7325d3caa4bc3b0eb0e0a
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L268

declaration:
ms = (seconds: number) => seconds * 1000

summary:
Converts a time value from seconds to milliseconds by multiplying by 1000.

@param seconds - Time value in seconds
@returns The equivalent time value in milliseconds

details:
A simple utility function that performs a basic multiplication operation. It takes a number representing seconds and returns the equivalent value in milliseconds by multiplying by 1000 (since 1 second = 1000 milliseconds).

import/access examples:
import { ms } from '@welshman/lib';
import { ms } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 275:275
id: c30643ec7b7ce1c8de661c50944035500fd8587f83469ba1ad34b19bd1f4af42
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L275

declaration:
secondsToDate = (seconds: number) => new Date(seconds * 1000)

summary:
Converts a timestamp in seconds to a JavaScript Date object.

Parameters:
- seconds: number - A Unix timestamp in seconds

Returns:
- Date object representing the timestamp

details:
This is a simple utility function that multiplies the seconds by 1000 to convert to milliseconds (which is what the Date constructor expects) and returns a new Date object. The implementation is straightforward with no side effects or complex logic.

import/access examples:
import { secondsToDate } from '@welshman/lib';
import { secondsToDate } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 282:282
id: a318b6294b35c192a544bb6e9140c3bfb5c873df07f042713ec436fd9229a4d8
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L282

declaration:
dateToSeconds = (date: Date) => Math.round(date.valueOf() / 1000)

summary:
Converts a Date object to a Unix timestamp in seconds.

@param date - Date object to convert
@returns Number representing the timestamp in seconds (rounded to the nearest integer)

details:
This function takes a Date object and converts it to a Unix timestamp (seconds since January 1, 1970, 00:00:00 UTC). It works by:
1. Using the Date.valueOf() method to get the time in milliseconds
2. Dividing by 1000 to convert from milliseconds to seconds
3. Using Math.round() to ensure the result is an integer

import/access examples:
import { dateToSeconds } from '@welshman/lib';
import { dateToSeconds } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 290:291
id: c4f188ccce936cf7b3ca1b6116c0ad6ffe7d35e64efbedf2d439823f619d23a7
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L290

declaration:
createLocalDate = (dateString: any, timezone = TIMEZONE) =>
  new Date(`${dateString} GMT${timezone}`)

summary:
Creates a local date object from a date string with timezone awareness. The function takes a date string and an optional timezone parameter (defaulting to the user's timezone) and returns a Date object that correctly represents the date in the specified timezone.

details:
This function works by concatenating the provided date string with a GMT timezone offset string to create a timezone-aware date. It:

1. Accepts a date string in any format that JavaScript's Date constructor can parse
2. Takes an optional timezone parameter that defaults to the user's local timezone (TIMEZONE constant)
3. Constructs a new Date by combining the date string with the timezone in the format: "dateString GMT+XX:XX"
4. Returns the resulting Date object that properly represents the date in the specified timezone

The implementation is simple but effective for creating dates that respect a specific timezone rather than defaulting to UTC or the local system timezone.

import/access examples:
import { createLocalDate } from '@welshman/lib';
import { createLocalDate } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 294:297
id: e37af168674ef7bfdcb5ee316d6d29f4f0837491eb5ffd8da569d54ff593bfb4
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L294

declaration:
dateTimeFormatter = new Intl.DateTimeFormat(LOCALE, {
  dateStyle: "short",
  timeStyle: "short",
})

summary:
A pre-configured Intl.DateTimeFormat instance for formatting dates and times in the user's locale with short date and time styles. This formatter is used to convert timestamps into human-readable date and time strings.

details:
This variable creates an instance of JavaScript's built-in Intl.DateTimeFormat with the following configuration:
1. It uses the user's default locale (from the LOCALE constant)
2. It sets both dateStyle and timeStyle to "short" for concise formatting
3. The formatter is used by functions like formatTimestamp to convert Unix timestamps to readable datetime strings

import/access examples:
import { dateTimeFormatter } from '@welshman/lib';
import { dateTimeFormatter } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 304:304
id: e74c2ebc0e775772734b7cda8c90d1c10f08cc50705a23010e6889e4977500e3
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L304

declaration:
formatTimestamp = (seconds: number) => dateTimeFormatter.format(secondsToDate(seconds))

summary:
Formats a Unix timestamp (in seconds) as a localized date and time string. This function converts the timestamp to a Date object and then formats it using the user's locale settings with a short date and time style.

details:
The implementation uses three main components:
1. The `secondsToDate` function to convert the Unix timestamp from seconds to a JavaScript Date object
2. The `dateTimeFormatter` Intl.DateTimeFormat instance (defined earlier in the file) which is configured with the user's locale and short date/time styles
3. The formatter's format method to convert the Date object to a localized string

This provides a simple one-line utility for displaying timestamps in a user-friendly format.

related: dateTimeFormatter

import/access examples:
import { formatTimestamp } from '@welshman/lib';
import { formatTimestamp } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 307:311
id: 2b7d9f63682b36e4db5d9d8309296c19554232d59c9710aeacfa76c9ccb8e9ef
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L307

declaration:
dateFormatter = new Intl.DateTimeFormat(LOCALE, {
  year: "numeric",
  month: "long",
  day: "numeric",
})

summary:
A constant that provides an Intl.DateTimeFormat instance configured to format dates with the user's locale. The formatter displays the year numerically, the month as a full name, and the day numerically.

details:
This formatter uses the user's default locale (accessed via the LOCALE constant) and configures the DateTimeFormat with specific formatting options:
1. year: "numeric" - Shows the year as a number (e.g., 2023)
2. month: "long" - Shows the full month name (e.g., "January")
3. day: "numeric" - Shows the day as a number (e.g., 15)

This formatter is used by the formatTimestampAsDate function to convert Unix timestamps to human-readable date strings.

import/access examples:
import { dateFormatter } from '@welshman/lib';
import { dateFormatter } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 318:318
id: c4f325c60f65392662e5597e9ebd8375c9288d6cf3901624ca1f1c767259c687
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L318

declaration:
formatTimestampAsDate = (ts: number) => dateFormatter.format(secondsToDate(ts))

summary:
Formats a Unix timestamp (in seconds) as a human-readable date string using the user's locale settings. This function converts the timestamp to a Date object and then formats it using the dateFormatter, which displays the year, month, and day in a localized format.

details:
The implementation is straightforward:
1. Takes a timestamp in seconds as input
2. Uses the secondsToDate utility function to convert the timestamp to a JavaScript Date object
3. Applies the dateFormatter (an Intl.DateTimeFormat instance configured with the user's locale and formatting options for year, month, and day) to format the date
4. Returns the formatted date string

The dateFormatter is defined earlier in the file as a DateTimeFormat with "numeric" year, "long" month, and "numeric" day options.

related: dateFormatter

import/access examples:
import { formatTimestampAsDate } from '@welshman/lib';
import { formatTimestampAsDate } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 321:323
id: a0f44559864334bd65cccc09a12751cca235aee6b4065278949dafb7e510d619
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L321

declaration:
timeFormatter = new Intl.DateTimeFormat(LOCALE, {
  timeStyle: "short",
})

summary:
A constant that provides a time formatter using the Intl.DateTimeFormat API. It creates a formatter configured with the user's default locale and a 'short' time style, which typically displays time in a concise format (e.g., '3:42 PM').

details:
This constant initializes an Intl.DateTimeFormat instance with the user's locale (obtained from the LOCALE constant) and configures it to display only the time component in a short format. The formatter can be used to format Date objects into localized time strings. It's used by the formatTimestampAsTime function to convert Unix timestamps to human-readable time strings.

import/access examples:
import { timeFormatter } from '@welshman/lib';
import { timeFormatter } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 330:330
id: 06c6f2f1a4f9fcc208825c34496e7a22f77e165e25cc67dd2743b7b99e3ccf48
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L330

declaration:
formatTimestampAsTime = (ts: number) => timeFormatter.format(secondsToDate(ts))

summary:
Formats a Unix timestamp (in seconds) as a time string using the user's locale settings. This function converts the timestamp to a Date object and then formats it using the Intl.DateTimeFormat with 'timeStyle: "short"' option.

details:
The implementation uses two helper functions:
1. `secondsToDate()` - Converts seconds to a JavaScript Date object by multiplying by 1000 (to convert to milliseconds)
2. `timeFormatter` - A pre-configured Intl.DateTimeFormat instance with timeStyle set to "short"

The function takes a numeric timestamp, converts it to a Date object, and then formats it according to the user's locale settings to display only the time portion in a short format.

related: timeFormatter

import/access examples:
import { formatTimestampAsTime } from '@welshman/lib';
import { formatTimestampAsTime } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 337:359
id: c3f79bccf8f8a5e57a73282d1be40a37c3a10136676b1ff97a88175ab1bdabbc
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L337

declaration:
formatTimestampRelative = (ts: number) => {
  let unit
  let delta = now() - ts
  if (delta < int(MINUTE)) {
    unit = "second"
  } else if (delta < int(HOUR)) {
    unit = "minute"
    delta = Math.round(delta / int(MINUTE))
  } else if (delta < int(DAY, 2)) {
    unit = "hour"
    delta = Math.round(delta / int(HOUR))
  } else {
    unit = "day"
    delta = Math.round(delta / int(DAY))
  }

  const locale = new Intl.RelativeTimeFormat().resolvedOptions().locale
  const formatter = new Intl.RelativeTimeFormat(locale, {
    numeric: "auto",
  })

  return formatter.format(-delta, unit as Intl.RelativeTimeFormatUnit)
}

summary:
Formats a Unix timestamp (in seconds) as a human-readable relative time string (e.g., '2 minutes ago', 'yesterday'). The function automatically selects the most appropriate time unit (seconds, minutes, hours, or days) based on the time difference between the provided timestamp and the current time.

details:
The implementation works by:

1. Calculating the time difference (delta) between current time and the provided timestamp
2. Determining the appropriate time unit based on the magnitude of the difference:
   - Less than a minute: uses 'second' unit
   - Less than an hour: uses 'minute' unit and converts delta to minutes
   - Less than 2 days: uses 'hour' unit and converts delta to hours
   - Otherwise: uses 'day' unit and converts delta to days
3. Uses the browser's Intl.RelativeTimeFormat API with 'numeric: "auto"' setting to generate natural language relative time strings
4. Returns the formatted string with negative delta (to indicate time in the past)

import/access examples:
import { formatTimestampRelative } from '@welshman/lib';
import { formatTimestampRelative } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 370:374
id: 7407c1723933b077bee2a2739f944e740b7d3b9c273659940ff33ff92cc425ed
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L370

declaration:
first = <T>(xs: Iterable<T>, ...args: unknown[]) => {
  for (const x of xs) {
    return x
  }
}

summary:
Returns the first element of an array or iterable. This function iterates through the provided iterable and returns the first element it encounters. If the iterable is empty, the function returns undefined.

details:
The implementation uses a for...of loop to iterate through the provided iterable. As soon as it encounters the first element, it immediately returns that element without processing the rest of the iterable. This makes it efficient for large collections since it only needs to access the first element.

The function accepts any type that implements the Iterable interface, not just arrays, making it versatile for different collection types like Sets, Maps, or custom iterables.

It also includes a rest parameter (...args: unknown[]) which isn't used in the implementation, likely for consistency with other utility functions in the library.

import/access examples:
import { first } from '@welshman/lib';
import { first } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 381:387
id: 35bd4be8ea8cfc4a83f351056447942c5c8e619afc058798f1a5be8e3f9065a8
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L381

declaration:
ffirst = <T>(xs: Iterable<Iterable<T>>, ...args: unknown[]) => {
  for (const chunk of xs) {
    for (const x of chunk) {
      return x
    }
  }
}

summary:
Returns the first element of the first array in a nested array structure. This function iterates through the outer iterable, then through the first inner iterable it encounters, and returns the first element found. If either the outer or inner iterable is empty, the function returns undefined.

details:
The implementation uses nested for...of loops to efficiently traverse the nested structure:

1. The outer loop iterates through the first level of the iterable (xs)
2. For the first item found (chunk), it starts a second loop to iterate through that inner iterable
3. As soon as it finds the first element in the inner iterable, it immediately returns it
4. If either iterable is empty, the function will implicitly return undefined

The function accepts a generic type parameter T which represents the type of elements in the inner iterables. It also accepts additional arguments via rest parameters (...args) though these aren't used in the implementation.

import/access examples:
import { ffirst } from '@welshman/lib';
import { ffirst } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 394:398
id: bb3d031cd057492949c8024b64fbae257300f5af7ae343c132b3bedc9bc9400c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L394

declaration:
last = <T>(xs: Iterable<T>, ...args: unknown[]) => {
  const a = Array.from(xs)

  return a[a.length - 1]
}

summary:
Returns the last element of an array or iterable collection. If the collection is empty, it returns undefined.

details:
The function works by first converting the input iterable to an array using Array.from(), which handles any iterable data structure (arrays, sets, maps, etc.). It then accesses the last element using standard array indexing with the length property minus 1. The function accepts additional arguments through rest parameters (...args: unknown[]) but doesn't use them, suggesting compatibility with higher-order functions that might pass additional parameters.

import/access examples:
import { last } from '@welshman/lib';
import { last } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 406:406
id: 2c6b4e9f079a937eb81f7a75aad9ad0729cd65c0da8d3f6fb4a1abfb6f073781
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L406

declaration:
drop = <T>(n: number, xs: Iterable<T>) => Array.from(xs).slice(n)

summary:
Returns a new array with the first n elements removed from the input iterable.

@param n - Number of elements to drop from the beginning
@param xs - Input iterable collection
@returns A new array containing all elements after the first n elements

details:
This function converts the input iterable to an array using Array.from() and then uses the slice() method to create a new array starting from index n. It's a simple utility that handles any iterable data structure, not just arrays, making it more flexible than a direct slice operation.

import/access examples:
import { drop } from '@welshman/lib';
import { drop } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 414:414
id: bd11c31d3f9ac2dfae351101bf5a6de0a41ab5d3390df40304ef6fbbd763d0de
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L414

declaration:
take = <T>(n: number, xs: Iterable<T>) => Array.from(xs).slice(0, n)

summary:
Returns the first n elements of an array or iterable collection. This function creates a new array containing only the specified number of elements from the beginning of the input collection.

details:
The implementation converts the input iterable to an array using Array.from() and then uses the slice() method to extract the first n elements. This approach works with any iterable data structure, not just arrays. The function is generic, preserving the type of the elements in the returned array.

import/access examples:
import { take } from '@welshman/lib';
import { take } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 421:421
id: 3dada7b76ef3ba097c23a32e1ee1c3e84aa9e5ead98e8406a88d9ba5adbdd957
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L421

declaration:
concat = <T>(...xs: T[][]) => xs.flatMap(x => (x === undefined ? [] : x))

summary:
Concatenates multiple arrays into a single array, filtering out any null or undefined values. This function takes any number of arrays as arguments and returns a new array containing all elements from the input arrays, excluding undefined values.

details:
The implementation uses `flatMap` to process each input array. For each array, it checks if the array itself is undefined - if it is, it returns an empty array (effectively skipping it), otherwise it includes the array's elements in the result. This ensures that undefined arrays are handled gracefully while preserving all valid elements from the input arrays.

import/access examples:
import { concat } from '@welshman/lib';
import { concat } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 429:429
id: cf5eb86c31ba59117aabcb4ab97d68a6f4c2e4c78c5290114e3f83ae93b3d9e0
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L429

declaration:
append = <T>(x: T, xs: T[]) => concat(xs, [x])

summary:
Appends an element to an array and returns a new array with the element added at the end. This function is non-mutating - it doesn't modify the original array but returns a new one with the element appended.

details:
The implementation uses the `concat` function to combine the original array with a new array containing just the element to append. This ensures the original array remains unchanged while creating a new array with the appended element. The function is generic, working with arrays of any type T.

related: __function,concat

import/access examples:
import { append } from '@welshman/lib';
import { append } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 437:437
id: d84f70cd5b74df2eb45a69d6e455b2ecc92a1667ae14077759148e68c1f4dbd7
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L437

declaration:
union = <T>(a: T[], b: T[]) => uniq([...a, ...b])

summary:
Creates a union of two arrays by combining them and removing duplicates. The function takes two arrays as input and returns a new array containing all unique elements from both arrays.

details:
The implementation uses the spread operator to combine both arrays into a single array, then passes this combined array to the `uniq` function which removes duplicate elements. This creates a mathematical set union operation where each element appears exactly once in the result, regardless of how many times it appears in either input array.

related: __function,uniq

import/access examples:
import { union } from '@welshman/lib';
import { union } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 445:449
id: ba1e05cdad606367d794e44f34df3393788fc5ed1c9f43521a045d9767010ddc
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L445

declaration:
intersection = <T>(a: T[], b: T[]) => {
  const s = new Set(b)

  return a.filter(x => s.has(x))
}

summary:
Returns elements common to both arrays. This function finds the intersection of two arrays, returning a new array containing only the elements that appear in both input arrays.

@param a - First array
@param b - Second array
@returns Array of elements present in both inputs

details:
The implementation uses a Set for efficient lookup:
1. Creates a Set from the second array (b) for O(1) lookups
2. Uses filter() on the first array (a) to keep only elements that exist in the Set
3. Returns the filtered array containing only common elements

This approach has O(n+m) time complexity where n and m are the lengths of the input arrays.

import/access examples:
import { intersection } from '@welshman/lib';
import { intersection } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 457:461
id: 3c178295495cd873c326e1d264e9cb52a9d23fad1d6a10331ef22c9cef90abba
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L457

declaration:
difference = <T>(a: T[], b: T[]) => {
  const s = new Set(b)

  return a.filter(x => !s.has(x))
}

summary:
Returns elements in the first array that are not present in the second array.

@param a - Source array from which to select elements
@param b - Array of elements to exclude
@returns A new array containing only elements from array 'a' that don't appear in array 'b'

details:
The implementation uses a Set data structure for efficient lookups:
1. Creates a Set from array 'b' for O(1) membership testing
2. Uses Array.filter() to keep only elements from array 'a' that are not in the Set
3. This approach is more efficient than using Array.includes() which would result in O(n²) complexity

import/access examples:
import { difference } from '@welshman/lib';
import { difference } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 469:469
id: 5ed23c866c80c6260ce1d1382f32270c48e5b61d3c199b293fec606b1fb49951
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L469

declaration:
remove = <T>(a: T, xs: T[]) => xs.filter(x => x !== a)

summary:
Removes all instances of a specific element from an array. This function creates a new array without modifying the original array.

@param a - Element to remove from the array
@param xs - Source array to filter
@returns A new array with all instances of the specified element removed

details:
The implementation uses the Array.filter() method to create a new array containing only elements that don't match the specified element. It compares each element using strict equality (!==) to determine which elements to keep.

import/access examples:
import { remove } from '@welshman/lib';
import { remove } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 477:477
id: 151d55c00bfcb207e116c3a4401452983e9681b88a74b9e417d09a9d631bc02e
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L477

declaration:
removeAt = <T>(i: number, xs: T[]) => [...xs.slice(0, i), ...xs.slice(i + 1)]

summary:
Removes an element at the specified index from an array and returns a new array without modifying the original array.

@param i - The index of the element to remove
@param xs - The source array to remove from
@returns A new array with the element at index i removed

details:
The implementation uses the spread operator and array slicing to create a new array that contains all elements from the original array except the one at the specified index. It works by:
1. Taking all elements before the index using `xs.slice(0, i)`
2. Taking all elements after the index using `xs.slice(i + 1)`
3. Combining these two slices into a new array using the spread operator

import/access examples:
import { removeAt } from '@welshman/lib';
import { removeAt } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 485:485
id: 169ee18112b0e496a99e7dbadc3169d72c79975f358506783b4783ac5a4d48ee
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L485

declaration:
without = <T>(a: T[], b: T[]) => b.filter(x => !a.includes(x))

summary:
Returns elements from the second array that are not present in the first array.

@param a - Array of elements to exclude
@param b - Source array
@returns A new array containing only elements from b that are not in a

details:
This function implements a set difference operation where it filters the second array to only include elements that don't exist in the first array. It uses the Array.filter() method combined with !Array.includes() to check for non-membership. The implementation is straightforward and leverages JavaScript's built-in array methods for efficient filtering.

import/access examples:
import { without } from '@welshman/lib';
import { without } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 493:493
id: 0f08346a2ca1672a8a4372fda40669f262be101ff011d1aa629e610d6f69cefd
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L493

declaration:
toggle = <T>(x: T, xs: T[]) => (xs.includes(x) ? remove(x, xs) : append(x, xs))

summary:
Toggles the presence of an element in an array. If the element exists in the array, it removes it; if it doesn't exist, it adds it to the array.

details:
This function implements a toggle mechanism by first checking if the element exists in the array using `includes()`. If the element is found, it calls the `remove()` function to filter out the element. If the element is not found, it calls the `append()` function to add the element to the array. Both operations return a new array without modifying the original.

related: __function,remove,__function,append

import/access examples:
import { toggle } from '@welshman/lib';
import { toggle } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 495:506
id: 70e2504fe0f5d4428261e3045d696fbbcf4d546d09bd80c3fb5c04e044496aa2
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L495

declaration:
export function* range(a: number, b: number, step = 1)

summary:
A generator function that creates a sequence of numbers from a starting value to an ending value with a specified step increment. The sequence includes the start value (a) but excludes the end value (b).

details:
The implementation uses a generator function (denoted by the * after function) to yield numbers in sequence. It employs a standard for loop that:

1. Initializes a counter i with the start value a
2. Continues as long as i is less than the end value b
3. Increments i by the step value (which defaults to 1 if not specified)
4. Yields each value in the sequence one at a time

This allows for memory-efficient iteration as values are generated on demand rather than creating an entire array upfront.

code:
export function* range(a: number, b: number, step = 1) {
  for (let i = a; i < b; i += step) {
    yield i
  }
}

import/access examples:
import { range } from '@welshman/lib';
import { range } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 508:517
id: 542459a871d4f1098003dc391e7ac66d61c220b2c59ee9d4883a63e29fd9c360
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L508

declaration:
export function* enumerate<T>(items: T[])

summary:
A generator function that yields pairs of index and item from an array. It allows iterating through an array while keeping track of the current index.

details:
The implementation uses a generator function with a for loop to iterate through each item in the array. For each item, it yields a tuple containing the current index and the corresponding item. This provides a convenient way to access both the position and value during iteration, similar to Python's enumerate function.

1. Takes an array of items as input
2. Uses a for loop with index counter
3. For each iteration, yields a tuple of [index, item]
4. Uses TypeScript generics to preserve the item type

code:
export function* enumerate<T>(items: T[]) {
  for (let i = 0; i < items.length; i += 1) {
    yield [i, items[i]] as [number, T]
  }
}

import/access examples:
import { enumerate } from '@welshman/lib';
import { enumerate } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 520:520
id: 01d352eb4d601f9259410effed878216e7243a6a35e35a658e8ee3048e3bebf2
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L520

declaration:
pluck = <T>(k: string, xs: Record<string, unknown>[]) => xs.map(x => x[k] as T)

summary:
Returns a function that extracts a specific property value from an array of objects. The function maps over the array and returns an array containing the values of the specified property from each object.

details:
This is a simple utility function that takes a property name and an array of objects, then uses JavaScript's Array.map() method to extract the specified property from each object in the array. The function includes a generic type parameter T to provide type safety for the extracted values. The implementation casts the extracted property to type T using the 'as T' type assertion.

import/access examples:
import { pluck } from '@welshman/lib';
import { pluck } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 527:537
id: 54e371cef6c5888d9afab5dfff32805a4d638d0a5e4b1213df74c25c11bd3709
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L527

declaration:
fromPairs = <T>(pairs: [k?: string, v?: T, ...args: unknown[]][]) => {
  const r: Record<string, T> = {}

  for (const [k, v] of pairs) {
    if (k && v) {
      r[k] = v
    }
  }

  return r
}

summary:
Creates an object from an array of key-value pairs. The function takes an array of tuples where each tuple contains a key (string) and a value of type T, and returns an object with those keys and values. Keys and values that are undefined or null are filtered out.

details:
The implementation iterates through each pair in the input array, destructuring each pair into key and value. It only adds entries to the result object when both the key and value are truthy (not null, undefined, false, 0, NaN, or empty string). The function maintains type safety by using a generic type parameter T for the values and returning a Record<string, T>.

The function handles potential undefined values in the input pairs by checking if both k and v exist before adding them to the result object, effectively filtering out incomplete or invalid pairs.

import/access examples:
import { fromPairs } from '@welshman/lib';
import { fromPairs } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 544:544
id: f1d19a7c9d0eaf7c69e75eb0edd83246bbcd5f917704cc1f836d8a8ec1429844
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L544

declaration:
flatten = <T>(xs: (T | T[])[], ...args: unknown[]) => xs.flatMap(identity)

summary:
Flattens array of arrays into single array. Takes an array that may contain nested arrays and returns a new array with all elements at a single level.

@param xs - Array of arrays to flatten
@returns Flattened array

details:
This function uses the built-in `flatMap` method with the `identity` function to flatten an array of arrays. The implementation is concise and leverages the fact that `flatMap` will automatically flatten arrays returned by the mapping function. The `identity` function simply returns its input unchanged, so when used with `flatMap`, it effectively flattens one level of nesting.

The function accepts a generic type parameter `T` to maintain type safety, and the input can contain either elements of type `T` or arrays of type `T[]`. The additional `...args` parameter is unused but allows for consistent function signatures across the utility library.

import/access examples:
import { flatten } from '@welshman/lib';
import { flatten } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 552:565
id: 3368d53c7bff18057e3f8af5fabc06487c6d5b66820b93a2c7171e7fd4c5d9bf
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L552

declaration:
partition = <T>(f: (x: T) => boolean, xs: T[]) => {
  const a: T[] = []
  const b: T[] = []

  for (const x of xs) {
    if (f(x)) {
      a.push(x)
    } else {
      b.push(x)
    }
  }

  return [a, b]
}

summary:
Splits an array into two arrays based on a predicate function. The function takes a predicate function and an array as input, and returns a tuple containing two arrays: the first array contains all elements that satisfy the predicate, and the second array contains all elements that don't satisfy the predicate.

details:
The implementation uses a straightforward approach:

1. It initializes two empty arrays `a` and `b` to store matching and non-matching elements respectively
2. It iterates through each element of the input array
3. For each element, it applies the predicate function:
   - If the predicate returns true, the element is pushed to array `a`
   - If the predicate returns false, the element is pushed to array `b`
4. Finally, it returns both arrays as a tuple [a, b]

This is a common functional programming utility that allows for efficient separation of elements based on a condition without modifying the original array.

import/access examples:
import { partition } from '@welshman/lib';
import { partition } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 572:572
id: 9727b7c22760dfe822ff5879055bc197518909ca505c49433f7921bd2714c428
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L572

declaration:
uniq = <T>(xs: T[]) => Array.from(new Set(xs))

summary:
Returns a new array with all duplicate elements removed from the input array. This function preserves the order of elements while ensuring each value appears only once in the result.

details:
The implementation uses JavaScript's Set data structure, which only stores unique values. The function works by:
1. Creating a new Set from the input array, which automatically removes duplicates
2. Converting the Set back to an array using Array.from()

This is a more efficient approach than using array methods like filter() with indexOf() which would have O(n²) complexity.

import/access examples:
import { uniq } from '@welshman/lib';
import { uniq } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 580:596
id: da623dca85261cf74987d4b8eaaab1e81b898765567214903497ff1c08327fdd
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L580

declaration:
uniqBy = <T>(f: (x: T) => any, xs: T[]) => {
  const s = new Set<any>()
  const r = []

  for (const x of xs) {
    const k = f(x)

    if (s.has(k)) {
      continue
    }

    s.add(k)
    r.push(x)
  }

  return r
}

summary:
Returns an array with elements that are unique based on a key function. This function takes a key generator function and an array, and returns a new array where only the first occurrence of each unique key is kept.

details:
The implementation uses a Set to track which keys have been seen:

1. It creates an empty Set to store keys and an empty array for results
2. For each element in the input array:
   - Generates a key for the element using the provided function
   - Checks if the key is already in the Set
   - If the key is new, adds it to the Set and pushes the element to the result array
   - If the key is already in the Set, skips the element (continues to next iteration)
3. Returns the filtered array containing only elements with unique keys

This is more flexible than the standard `uniq` function because it allows deduplication based on a derived property rather than direct equality comparison.

import/access examples:
import { uniqBy } from '@welshman/lib';
import { uniqBy } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 603:603
id: bb52021561351337ceac560ebdae427a1e7770213d535c81e73ca702f680865b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L603

declaration:
sort = <T>(xs: T[]) => [...xs].sort()

summary:
Returns a new sorted copy of an array without modifying the original array. The function uses JavaScript's default sorting behavior, which converts elements to strings and sorts them in lexicographical order.

details:
The implementation creates a shallow copy of the input array using the spread operator (`[...xs]`) and then applies JavaScript's built-in `sort()` method to this copy. This ensures the original array remains unchanged while returning a sorted version. Since no custom comparator function is provided, the default string comparison is used.

import/access examples:
import { sort } from '@welshman/lib';
import { sort } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 611:617
id: 9b2132fa7f871670f2655fd3b64f09e39ee5d06de957aa92a3e2d5f0a489cb3b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L611

declaration:
sortBy = <T>(f: (x: T) => any, xs: T[]) =>
  [...xs].sort((a: T, b: T) => {
    const x = f(a)
    const y = f(b)

    return x < y ? -1 : x > y ? 1 : 0
  })

summary:
Returns a new array sorted by a key function. The function takes two parameters: a key function that extracts a sort value from each element, and an array to sort. It returns a new sorted array without modifying the original array.

details:
The implementation creates a shallow copy of the input array using the spread operator (`[...xs]`), then applies JavaScript's built-in `sort()` method with a custom comparator function. The comparator extracts sort keys from each pair of elements using the provided key function, then performs a three-way comparison:
1. If the first key is less than the second, returns -1
2. If the first key is greater than the second, returns 1
3. If keys are equal, returns 0

This creates a stable sort based on the values returned by the key function rather than comparing the array elements directly.

import/access examples:
import { sortBy } from '@welshman/lib';
import { sortBy } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 625:641
id: 20e1b253168e815ee68ca1f12db3d099cf514bf325ebbcf635647d2279a4626c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L625

declaration:
groupBy = <T, K>(f: (x: T) => K, xs: T[]) => {
  const r = new Map<K, T[]>()

  for (const x of xs) {
    const k = f(x)
    let v = r.get(k)

    if (!v) {
      v = []
      r.set(k, v)
    }

    v.push(x)
  }

  return r
}

summary:
Groups array elements by a key function. Takes a function that generates a key for each element and an array to group, returning a Map where keys are the result of applying the key function to each element and values are arrays of elements that produced that key.

details:
The implementation creates a new Map to store the grouped elements. It iterates through each element in the input array, applying the key function to determine which group the element belongs to. For each element:

1. It gets the key by applying the key function
2. It retrieves the existing array for that key from the Map (or undefined if none exists)
3. If no array exists for that key, it creates a new empty array and sets it in the Map
4. It pushes the current element to the array for that key

Finally, it returns the Map containing all the grouped elements. The function preserves the original order of elements within each group.

import/access examples:
import { groupBy } from '@welshman/lib';
import { groupBy } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 649:656
id: a4e2e0b54335450aad7a1304290e7acdfac50ed69a802dd480363428c9febc98
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L649

declaration:
countBy = <T, K>(f: (x: T) => K, xs: T[]) => {
  const r = new Map<K, number>()
  for (const [k, items] of groupBy(f, xs)) {
    r.set(k, items.length)
  }

  return r
}

summary:
Counts array elements by key function. This function groups elements in an array based on a key function, then returns a Map where each key maps to the count of elements in that group.

@param f - Function to generate group key for each element
@param xs - Array to count entries from
@returns Map of keys to counts

details:
The implementation works by:
1. Creating a new Map to store the counts
2. Leveraging the groupBy function to first group the array elements by the key function
3. Iterating through each group from groupBy
4. Setting each key in the result Map to the length of its corresponding group
5. Returning the Map with counts

The function depends on the groupBy utility which handles the actual grouping logic.

import/access examples:
import { countBy } from '@welshman/lib';
import { countBy } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 664:672
id: b6bf146f929ffab04f98b1bbac85394a1612cb057728e15c62481e5b828c0745
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L664

declaration:
indexBy = <T, K>(f: (x: T) => K, xs: T[]) => {
  const r = new Map<K, T>()

  for (const x of xs) {
    r.set(f(x), x)
  }

  return r
}

summary:
Creates a Map from an array using a key function. This function transforms an array into a Map where each value is indexed by a key derived from the value itself using the provided function.

@param f - Function that generates a key for each element
@param xs - Array to be indexed
@returns Map where keys are generated by applying f to each element, and values are the original elements

details:
The implementation creates a new Map and iterates through each element in the input array. For each element:
1. It applies the key function f to the element to generate a key
2. It sets the element as the value in the Map with the generated key
3. Finally returns the populated Map

This creates a lookup table where elements can be efficiently retrieved by their generated keys. If multiple elements produce the same key, later elements will overwrite earlier ones in the Map.

import/access examples:
import { indexBy } from '@welshman/lib';
import { indexBy } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 680:688
id: c3c93042953a33d779dabd9eb1b9d36365c761eef0240333ddb2114d3e7a9cb6
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L680

declaration:
initArray = <T>(n: number, f: () => T) => {
  const result = []

  for (let i = 0; i < n; i++) {
    result.push(f())
  }

  return result
}

summary:
Creates an array of specified length where each element is generated by a provided function. This utility is useful for initializing arrays with dynamic content rather than static values.

details:
The implementation is straightforward:
1. Creates an empty array called `result`
2. Uses a for loop to iterate from 0 to n-1
3. For each iteration, calls the generator function `f()` and pushes its return value to the result array
4. Returns the populated array

The function is generic, allowing type safety for the generated elements through the type parameter `<T>`.

import/access examples:
import { initArray } from '@welshman/lib';
import { initArray } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 696:714
id: 90284d5bd0f228a4fc1aeede84c75d312f6779977ae1acb00ad13b05172cf978
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L696

declaration:
chunk = <T>(chunkLength: number, xs: T[]) => {
  const result: T[][] = []
  const current: T[] = []

  for (const item of xs) {
    if (current.length < chunkLength) {
      current.push(item)
    } else {
      result.push(current.splice(0))
      current.push(item)
    }
  }

  if (current.length > 0) {
    result.push(current)
  }

  return result
}

summary:
Splits an array into chunks of a specified maximum length. Each chunk will contain at most `chunkLength` elements from the original array.

@param chunkLength - Maximum length of each chunk
@param xs - Array to split
@returns Array of chunks, where each chunk is an array of elements from the original array

details:
The implementation works by:

1. Creating an empty result array to hold the chunks
2. Creating a temporary array to accumulate elements for the current chunk
3. Iterating through each item in the input array:
   - If the current chunk has room (length < chunkLength), add the item to it
   - Otherwise, push the current chunk to the result array (using splice(0) to clear it), then add the item to the now-empty current chunk
4. After processing all items, if the current chunk has any elements, add it to the result
5. Return the array of chunks

The function uses splice(0) to efficiently clear the current array while adding its contents to the result.

import/access examples:
import { chunk } from '@welshman/lib';
import { chunk } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 722:730
id: f55eb2e09429bd0c384ff62a323b43abd0192468585c28f5304fdecf822970ad
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L722

declaration:
chunks = <T>(n: number, xs: T[]) => {
  const result: T[][] = initArray(n, () => [])

  for (let i = 0; i < xs.length; i++) {
    result[i % n].push(xs[i])
  }

  return result
}

summary:
Splits an array into a specified number of chunks, distributing elements evenly across the chunks. This is different from the `chunk` function which creates chunks of a specific length.

@param n - Number of chunks to create
@param xs - Array to split into chunks
@returns Array containing n arrays, with elements distributed evenly

details:
The implementation works by:
1. Creating an array of n empty arrays using the `initArray` utility function
2. Iterating through each element of the input array
3. Distributing elements across the chunks using modulo arithmetic (i % n) to determine which chunk gets each element
4. This creates a round-robin distribution where elements are assigned to chunks in sequence

Unlike the `chunk` function which creates chunks of equal size (except possibly the last one), this function ensures there are exactly n chunks with elements distributed as evenly as possible.

import/access examples:
import { chunks } from '@welshman/lib';
import { chunks } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 733:733
id: 7f1f3eb690d388b30a22f617c301c9e077077af620b633aca2e0cb17b3cda4f9
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L733

declaration:
splitAt = <T>(n: number, xs: T[]) => [xs.slice(0, n), xs.slice(n)]

summary:
Splits an array into two parts at a specified index.

@param n - The index at which to split the array
@param xs - The array to split
@returns A tuple containing two arrays: [elements before index n, elements from index n onward]

details:
A simple utility function that creates a tuple of two arrays by slicing the original array at the specified index. It uses the native JavaScript `slice()` method twice:
1. First slice from index 0 to n (exclusive)
2. Second slice from index n to the end

The function is generic, preserving the type of array elements.

import/access examples:
import { splitAt } from '@welshman/lib';
import { splitAt } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 736:736
id: ba5621be2668bd9fc8526d26bf031f6d9d3aa9c4e8d0be47a77670f2a236b1aa
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L736

declaration:
insertAt = <T>(n: number, x: T, xs: T[]) => [...xs.slice(0, n), x, ...xs.slice(n)]

summary:
Inserts an element into an array at a specified index position, returning a new array without modifying the original array.

@param n - The index position where the element should be inserted
@param x - The element to insert into the array
@param xs - The original array
@returns A new array with the element inserted at the specified position

details:
This function creates a new array by using the spread operator to combine three parts:
1. The elements from the original array before the insertion point (using slice(0, n))
2. The new element to insert
3. The elements from the original array after the insertion point (using slice(n))

The implementation is immutable - it doesn't modify the original array but returns a new one.

import/access examples:
import { insertAt } from '@welshman/lib';
import { insertAt } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 739:739
id: 77d774265f2567bab802fd1df4dd397ab9aa8c34dbcedd5d99a2a9b178fb56b1
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L739

declaration:
replaceAt = <T>(n: number, x: T, xs: T[]) => [...xs.slice(0, n), x, ...xs.slice(n + 1)]

summary:
Replaces an element at a specific index in an array with a new value, returning a new array without modifying the original array.

@param n - The index at which to replace the element
@param x - The new value to insert at the specified index
@param xs - The source array
@returns A new array with the element at index n replaced with x

details:
This function creates a new array by combining three parts:
1. The elements before the specified index (using slice(0, n))
2. The new element to insert
3. The elements after the specified index (using slice(n + 1))

It uses the spread operator (...) to create a shallow copy, ensuring the original array remains unchanged.

import/access examples:
import { replaceAt } from '@welshman/lib';
import { replaceAt } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 742:742
id: f34797a9536a9eb73a6ba0f466ceb81b315de37d831438a3c94c7dece60d6534
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L742

declaration:
choice = <T>(xs: T[]): T => xs[Math.floor(xs.length * Math.random())]

summary:
Returns a random element from an array. This function takes an array of type T and returns a single element of type T selected randomly from the array.

details:
The implementation uses Math.random() to generate a random number between 0 and 1, multiplies it by the length of the array to get a random index within the array bounds, and then uses Math.floor() to ensure the index is an integer. It then returns the element at that random index.

import/access examples:
import { choice } from '@welshman/lib';
import { choice } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 745:746
id: b4d76e9b3967a24d260e55b92f93fb12cdeb2ef9e5ab45721b941ce793e1cf33
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L745

declaration:
shuffle = <T>(xs: Iterable<T>): T[] =>
  Array.from(xs).sort(() => (Math.random() > 0.5 ? 1 : -1))

summary:
Returns a new array containing all elements from the input iterable in a random order. This function creates a shuffled copy without modifying the original collection.

details:
The implementation converts the input iterable to an array using Array.from(), then uses the sort() method with a randomized comparison function. The comparison function returns either 1 or -1 based on a random boolean (Math.random() > 0.5), which effectively randomizes the sort order. This is a simple implementation of the Fisher-Yates shuffle algorithm, though it's worth noting that using sort() with random comparators isn't statistically perfect for shuffling as it doesn't guarantee uniform distribution across all possible permutations.

import/access examples:
import { shuffle } from '@welshman/lib';
import { shuffle } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 749:749
id: 1764670bb77abc7111a22a2126958cf2c0aa89a5c54ffe6ce14423613b962444
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L749

declaration:
sample = <T>(n: number, xs: T[]) => shuffle(xs).slice(0, n)

summary:
Returns n random elements from an array without replacement. The function takes a number parameter specifying how many elements to sample and an array to sample from, then returns a new array containing the randomly selected elements.

details:
The implementation works by first shuffling the entire input array using the `shuffle` function (which randomizes the order of elements), and then taking the first n elements from the shuffled array using `slice(0, n)`. This approach ensures that each element has an equal probability of being selected and that no element is selected more than once.

related: __function,shuffle

import/access examples:
import { sample } from '@welshman/lib';
import { sample } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 752:752
id: 2687bbd7e2421f1b6ff148807e85d5f36bf503c79e14317429103e6c99786ae2
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L752

declaration:
isIterable = (x: any) => Symbol.iterator in Object(x)

summary:
Checks if a value is iterable by testing whether it has a Symbol.iterator property. This function determines if an object can be used in a for...of loop or with spread syntax.

details:
The implementation uses the `Symbol.iterator in Object(x)` expression to check if the value has an iterator protocol implementation. The `Object(x)` wrapper ensures that primitive values are properly converted to their object equivalents before checking for the iterator property. This handles both built-in iterables (arrays, strings, maps, sets) and custom objects that implement the iterable protocol.

import/access examples:
import { isIterable } from '@welshman/lib';
import { isIterable } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 755:755
id: eb5d4cc0ebcc2cd9506bdb66d81bf4eb917704e8e16a72df78e2facca1a1eee0
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L755

declaration:
toIterable = (x: any) => (isIterable(x) ? x : [x])

summary:
Ensures a value is iterable by returning it if it's already iterable, or wrapping it in an array if it's not. This utility function helps standardize handling of both single values and collections in functions that expect iterables.

details:
The implementation is straightforward - it uses the `isIterable` function to check if the input value implements the iterable protocol (has a Symbol.iterator property). If the value is already iterable, it returns it unchanged. Otherwise, it wraps the value in an array to make it iterable. This is useful when writing functions that should work with both single values and collections without requiring the caller to manually wrap single values.

import/access examples:
import { toIterable } from '@welshman/lib';
import { toIterable } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 758:758
id: d2645a46311a733eb53130aa12344c6b0d6f5f464916fc8598ce21e8326a9474
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L758

declaration:
ensurePlural = <T>(x: T | T[]) => (x instanceof Array ? x : [x])

summary:
Ensures that a value is an array by wrapping it in an array if it's not already one. This utility function is useful when you need to handle both single values and arrays uniformly.

details:
The implementation is straightforward - it uses the `instanceof Array` check to determine if the input is already an array. If it is, it returns the input unchanged. If not, it wraps the single value in an array and returns it. This allows code to consistently work with arrays regardless of whether the original input was a single value or an array.

import/access examples:
import { ensurePlural } from '@welshman/lib';
import { ensurePlural } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 761:761
id: 52cf6c0c60ecfd1dbe461e818f0a15a34b89026064ea30d469392f4daecb824a
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L761

declaration:
removeNil = <T>(xs: T[]) => xs.filter(isNotNil).map(assertNotNil)

summary:
A utility function that filters out null or undefined values from an array and ensures the TypeScript type system recognizes the remaining values as non-null. It returns a new array containing only the defined values from the input array.

details:
The implementation uses a two-step process:
1. First, it filters the input array using the `isNotNil` function to remove any null or undefined values
2. Then it maps over the filtered array with `assertNotNil` to tell TypeScript that the remaining values are definitely not null or undefined

This function relies on two other utility functions from the same module:
- `isNotNil` - checks if a value is neither null nor undefined
- `assertNotNil` - a type assertion function that helps TypeScript understand the value is non-null

import/access examples:
import { removeNil } from '@welshman/lib';
import { removeNil } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 764:771
id: 7f73619307339fe424159d7a4a56949efafbcdaf475c980fbf81fbe4b734f6a1
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L764

declaration:
overlappingPairs = <T>(xs: T[]): T[][] => {
  const result: T[][] = []
  for (let i = 0; i < xs.length - 1; i++) {
    result.push([xs[i], xs[i + 1]])
  }

  return result
}

summary:
Returns a list of overlapping pairs of elements from an array. For each adjacent pair of elements in the input array, it creates a new array containing those two elements. The function returns an array of these pairs.

details:
The implementation creates an empty array to store the result, then iterates through the input array from the first element to the second-to-last element. For each position i, it creates a pair containing the element at position i and the element at position i+1, and pushes this pair to the result array. The function handles generic types through the type parameter T, allowing it to work with arrays of any type.

import/access examples:
import { overlappingPairs } from '@welshman/lib';
import { overlappingPairs } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 782:788
id: db59b9a475b1805051cdaeeedc400fd97d74b48d60b27535484ee80cd93aa220
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L782

declaration:
isPojo = (obj: any) => {
  if (obj === null || typeof obj !== "object") {
    return false
  }

  return Object.getPrototypeOf(obj) === Object.prototype
}

summary:
Checks if a value is a plain JavaScript object (POJO). A plain object is one that is created using object literal notation or Object.create(null), and not an instance of a class or other constructor function.

details:
The function performs two checks to determine if a value is a plain object:
1. First, it checks if the value is null or not an object type, returning false in these cases
2. Then it checks if the object's prototype is exactly the Object prototype (Object.prototype), which is the defining characteristic of a plain object

This is useful for distinguishing regular objects from arrays, dates, or other specialized object types that have different prototypes.

import/access examples:
import { isPojo } from '@welshman/lib';
import { isPojo } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 796:806
id: 14266930ab9aa1a05ea769c1b2abb1e7b9d5b43f5bb78cde91b344d3c419164b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L796

declaration:
pick = <T extends Obj>(ks: string[], x: T) => {
  const r: T = {...x}

  for (const k of Object.keys(x)) {
    if (!ks.includes(k)) {
      delete r[k]
    }
  }

  return r
}

summary:
Creates a new object with only the specified keys from the source object.

Parameters:
- `ks`: An array of strings representing the keys to keep in the resulting object
- `x`: The source object from which to pick properties

Returns:
A new object containing only the properties from the original object whose keys are included in the `ks` array.

details:
The implementation creates a shallow copy of the source object using the spread operator, then iterates through all keys of the original object. For each key, it checks if the key is not included in the specified keys array. If a key is not in the array, it deletes that property from the copy. This approach ensures that only the specified keys remain in the returned object.

Time complexity is O(n) where n is the number of keys in the source object, as it needs to check each key against the array of keys to keep.

import/access examples:
import { pick } from '@welshman/lib';
import { pick } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 814:822
id: 69c77de63826199b8c2d497371bf935f66fbd61d9a6a7195830a085962005cd1
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L814

declaration:
omit = <T extends Obj>(ks: string[], x: T) => {
  const r: T = {...x}

  for (const k of ks) {
    delete r[k]
  }

  return r
}

summary:
Creates a new object with specified keys removed from the source object.

@param ks - Array of keys to remove from the object
@param x - Source object to remove keys from
@returns A new object that contains all properties from the source object except those specified in the keys array

details:
The implementation creates a shallow copy of the source object using the spread operator, then iterates through the provided keys array and deletes each key from the copy. This approach preserves the original object while returning a new object without the specified keys.

The function is generic, maintaining the type of the original object while removing the specified keys from both the object and its type definition.

import/access examples:
import { omit } from '@welshman/lib';
import { omit } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 830:840
id: 4f3404d9b81f9d3da01a022db282afb8b33819adfdba13a73291072ca5947f1c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L830

declaration:
omitVals = <T extends Obj>(xs: any[], x: T) => {
  const r: Obj = {}

  for (const [k, v] of Object.entries(x)) {
    if (!xs.includes(v)) {
      r[k] = v
    }
  }

  return r as T
}

summary:
Creates a new object excluding entries with specified values. This function filters out key-value pairs where the value matches any value in the provided exclusion list.

@param xs - Array of values to exclude
@param x - Source object to filter
@returns A new object containing only key-value pairs whose values are not in the exclusion list

details:
The implementation works by:
1. Creating an empty result object
2. Iterating through all key-value pairs in the source object using Object.entries()
3. For each pair, checking if the value is included in the exclusion array using Array.includes()
4. If the value is not in the exclusion list, adding the key-value pair to the result object
5. Finally, casting the result object back to the original type T and returning it

The function preserves the original object's type through generic type parameter T which extends Obj (a Record<string, any>).

import/access examples:
import { omitVals } from '@welshman/lib';
import { omitVals } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 848:858
id: f8033c3cc6c3061f93b5c1a4d73ae68b0c0222fbbbfb5a520f3025754fa5a76c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L848

declaration:
filterVals = <T extends Record<string, any>>(f: (v: any) => boolean, x: T) => {
  const r = {} as T

  for (const k in x) {
    if (f(x[k])) {
      r[k] = x[k]
    }
  }

  return r
}

summary:
Filters object values based on a predicate function. This function creates a new object containing only the key-value pairs where the value passes the predicate test.

@param f - Function that tests each value and returns a boolean
@param x - Source object to filter
@returns A new object containing only the key-value pairs where f(value) returns true

details:
The implementation creates a new empty object of the same type as the input, then iterates through all keys in the source object using a for...in loop. For each key-value pair, it applies the predicate function to the value. If the predicate returns true, it copies that key-value pair to the result object. This approach preserves the original object's structure while filtering out values that don't meet the criteria.

import/access examples:
import { filterVals } from '@welshman/lib';
import { filterVals } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 866:874
id: 3b451106dd34a5d10977afaba02cdeb0da4d3239cb1b28946ccbc71dc124e9b8
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L866

declaration:
mapKeys = <T extends Obj>(f: (v: string) => string, x: T) => {
  const r: Obj = {}

  for (const [k, v] of Object.entries(x)) {
    r[f(k)] = v
  }

  return r as T
}

summary:
Creates a new object with transformed keys by applying a function to each key in the source object. The values remain unchanged.

@param f - Function to transform keys
@param x - Source object
@returns Object with transformed keys but same values as the original

details:
The implementation creates a new empty object, then iterates through all key-value pairs in the source object using Object.entries(). For each pair, it applies the transformation function to the key, assigns the original value to this new key in the result object, and finally casts the result back to the original object type. This is a non-mutating operation that preserves the original object while creating a new one with transformed keys.

import/access examples:
import { mapKeys } from '@welshman/lib';
import { mapKeys } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 882:890
id: 3ff985021e4897e5a65609a4c9390cd55e188edfcc6b26aca91d234057bfe02a
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L882

declaration:
mapVals = <V, U>(f: (v: V) => U, x: Record<string, V>) => {
  const r: Record<string, U> = {}

  for (const [k, v] of Object.entries(x)) {
    r[k] = f(v)
  }

  return r
}

summary:
Creates a new object with transformed values by applying a function to each value in the source object while keeping the keys unchanged.

@param f - Function to transform values from type V to type U
@param x - Source object with string keys and values of type V
@returns A new object with the same keys but values transformed by function f

details:
The implementation iterates through each key-value pair in the source object using Object.entries(), applies the transformation function to each value, and builds a new object with the same keys but transformed values. The function maintains the original object structure while allowing type transformation from V to U for all values.

import/access examples:
import { mapVals } from '@welshman/lib';
import { mapVals } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 898:901
id: b28497050e4e56ab4899013b24f5f5eb903693e1536cefb77c9c0de5501f8fad
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L898

declaration:
mergeLeft = <T extends Obj>(a: T, b: T) => ({
  ...b,
  ...a,
})

summary:
Merges two objects, with the left object taking precedence. This function combines properties from both objects, but when there are duplicate keys, the values from the first object (a) will override those from the second object (b).

details:
The implementation uses JavaScript's object spread syntax to create a new object. It first spreads all properties from object b, then spreads all properties from object a on top of that. This ensures that properties from object a will override any properties with the same key from object b. The function is generic, accepting any type T that extends the Obj type, and returns an object of the same type.

import/access examples:
import { mergeLeft } from '@welshman/lib';
import { mergeLeft } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 909:912
id: 90049d1e04cd650836e4e43b41961d1d982de1505e98e2be226cd70387b7432d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L909

declaration:
mergeRight = <T extends Obj>(a: T, b: T) => ({
  ...a,
  ...b,
})

summary:
Merges two objects, with the right object taking precedence. This function combines properties from both objects, where values from the second object (b) will override any properties with the same key in the first object (a).

details:
The implementation uses JavaScript's object spread syntax to create a new object. It first spreads all properties from object 'a', then spreads all properties from object 'b', which ensures that any duplicate keys will have the value from 'b'. This is a shallow merge that only combines top-level properties without recursively merging nested objects.

import/access examples:
import { mergeRight } from '@welshman/lib';
import { mergeRight } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 915:915
id: 813cee617209b9192853e9f28aa443b8475d143cce1d57544ee14a871d71b045
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L915

declaration:
deepMergeLeft = (a: Obj, b: Obj) => deepMergeRight(b, a)

summary:
Deep merges two objects, prioritizing the first argument. This function combines properties from both objects, with values from the first object taking precedence over values from the second object when there are conflicts. For nested objects, it performs a recursive merge rather than simple replacement.

details:
This function is a simple wrapper around `deepMergeRight` that swaps the arguments to change which object takes priority. It calls `deepMergeRight(b, a)` to ensure that properties from object `a` override those from object `b`. The actual deep merging logic is implemented in the `deepMergeRight` function, which recursively merges nested objects while giving priority to the second argument.

related: __function,deepMergeRight,Obj

import/access examples:
import { deepMergeLeft } from '@welshman/lib';
import { deepMergeLeft } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 918:930
id: 4c2350a38cd1b9b7efd0a2d30974097dfa4a717d680acf6827e12b46a972dcd6
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L918

declaration:
deepMergeRight = (a: Obj, b: Obj) => {
  a = {...a}

  for (const [k, v] of Object.entries(b)) {
    if (isPojo(v) && isPojo(a[k])) {
      a[k] = deepMergeRight(a[k], v)
    } else {
      a[k] = v
    }
  }

  return a
}

summary:
Deep merges two objects, prioritizing the second argument. This function recursively combines properties from both objects, with values from the second object overriding those from the first when there are conflicts. For nested objects, it performs a recursive merge rather than simple replacement.

details:
Implementation details:
1. Creates a shallow copy of the first object (`a`) to avoid mutating the original
2. Iterates through all entries in the second object (`b`)
3. For each key-value pair in `b`:
   - If both the value in `b` and the corresponding value in `a` are plain objects (checked with `isPojo()`), recursively calls `deepMergeRight` on those nested objects
   - Otherwise, simply assigns the value from `b` to the corresponding key in `a`
4. Returns the merged object

The function relies on the `isPojo()` helper to determine if values are plain objects that should be recursively merged rather than replaced.

related: Obj

import/access examples:
import { deepMergeRight } from '@welshman/lib';
import { deepMergeRight } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 938:939
id: f434dbaad20c4a96def33104ac054f924c4be1d229256613401b1c2746f26fc8
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L938

declaration:
switcher = <T>(k: string, m: Record<string, T>) =>
  m[k] === undefined ? m.default : m[k]

summary:
Switches on a key in an object, with a default fallback. This function looks up a value in an object by key and returns either the value at that key or a default value if the key doesn't exist. The default value is expected to be stored at the 'default' property of the object.

details:
A simple implementation that checks if the value at the given key is undefined. If it is, it returns the value at the 'default' property of the object. Otherwise, it returns the value at the specified key. This is a type-safe alternative to a switch statement that works with objects as lookup tables.

import/access examples:
import { switcher } from '@welshman/lib';
import { switcher } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 946:949
id: 6a50f5901d5361ad8a27af37d42a8643d82614d2f33be67e884a7492d04b3dd6
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L946

declaration:
complement =
  <T extends unknown[]>(f: (...args: T) => any) =>
  (...args: T) =>
    !f(...args)

summary:
Returns a function that returns the boolean negation of the given function. This is a higher-order function that takes a function as input and returns a new function that, when called, will return the logical NOT of the original function's result.

details:
This function implements the complement pattern from functional programming. It uses generic type parameters to preserve the argument types of the original function. The implementation is a curried function that:
1. Takes a function `f` with generic argument types `T`
2. Returns a new function that accepts the same arguments
3. When called, invokes the original function with those arguments
4. Returns the boolean negation (`!`) of whatever the original function returned

import/access examples:
import { complement } from '@welshman/lib';
import { complement } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 957:971
id: b81055de1ff06528c38777e86c6cc749e9e1e1dd9bc9b1c77f1c290abb750882
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L957

declaration:
tryCatch = <T>(f: () => T, onError?: (e: Error) => void): T | undefined => {
  try {
    const r = f()

    if (r instanceof Promise) {
      r.catch(e => onError?.(e as Error))
    }

    return r
  } catch (e) {
    onError?.(e as Error)
  }

  return undefined
}

summary:
Safely executes a function and handles any errors that occur. It takes a function to execute and an optional error handler, returning the function's result or undefined if an error occurs. The function also handles promises by attaching a catch handler.

details:
The implementation works by:

1. Wrapping the function execution in a try-catch block
2. Executing the provided function and storing its result
3. Checking if the result is a Promise - if so, attaching a catch handler that calls the onError callback
4. Returning the result from the try block
5. If an exception occurs, calling the onError callback with the error and returning undefined
6. Providing an explicit undefined return at the end to ensure consistent return type

The function is generic, allowing it to preserve the return type of the executed function while also allowing for undefined in case of errors.

import/access examples:
import { tryCatch } from '@welshman/lib';
import { tryCatch } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 978:987
id: 670e867417a117f8015388dc49f05dff556c26f83a7f9e1095f858a6da0858c3
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L978

declaration:
once = (f: (...args: any) => void) => {
  let called = false

  return (...args: any) => {
    if (!called) {
      called = true
      f(...args)
    }
  }
}

summary:
Creates a function that only executes once. When the returned function is called multiple times, it will only execute the wrapped function on the first call and ignore subsequent calls.

@param f - Function to wrap
@returns Function that executes f only on first call

details:
The implementation uses a closure to maintain state between function calls:

1. It creates a boolean flag `called` initialized to false
2. Returns a new function that:
   - Checks if the function has been called before
   - If not called yet, sets the flag to true and executes the original function
   - If already called, does nothing

This is a common pattern for creating one-time event handlers or initialization functions that should only run once regardless of how many times they're invoked.

import/access examples:
import { once } from '@welshman/lib';
import { once } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 994:994
id: dfe4f9e185420fd314c922418760f8066d3eead77c829d806e3373764605e806
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L994

declaration:
call = <T>(f: () => T, ...args: unknown[]) => f()

summary:
Calls a function and returns its result. This utility function provides a simple way to invoke a function without arguments.

details:
A very simple implementation that takes a function `f` and any number of additional arguments (which are ignored), then immediately calls the function `f` with no arguments and returns whatever it returns. The function is generic, preserving the return type `T` of the provided function.

import/access examples:
import { call } from '@welshman/lib';
import { call } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1001:1013
id: 52110bd6f59f26be5f1dd7306f7774c20eb1d9236372559f5273450d4c2d2e53
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1001

declaration:
memoize = <T>(f: (...args: any[]) => T) => {
  let prevArgs: any[]
  let result: T

  return (...args: any[]) => {
    if (!equals(prevArgs, args)) {
      prevArgs = args
      result = f(...args)
    }

    return result
  }
}

summary:
Memoizes a function by caching its result based on the arguments passed. When the function is called with the same arguments again, it returns the cached result instead of recomputing it. This optimization is useful for expensive calculations that are called repeatedly with the same inputs.

details:
The implementation uses a simple caching mechanism that stores:
1. The previous arguments (`prevArgs`) that were passed to the function
2. The result (`result`) that was returned for those arguments

When the function is called:
1. It compares the current arguments with the stored previous arguments using the `equals` function (which performs deep equality checking)
2. If the arguments are different, it calls the original function with the new arguments and updates both the stored arguments and result
3. If the arguments are the same, it returns the cached result without calling the original function

Note that this implementation only caches the most recent call, not all previous calls with different arguments.

import/access examples:
import { memoize } from '@welshman/lib';
import { memoize } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1021:1022
id: 2afe3502732917940fb96dac6e7a3c16987c8bd4b2333b21ba1715eafa126f13
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1021

declaration:
ifLet = <T>(x: T | undefined, f: (x: T) => void) =>
  x === undefined ? undefined : f(x)

summary:
Executes a function if the value is defined. Takes a potentially undefined value and a function, then calls the function with the value if it's defined, otherwise returns undefined.

details:
This is a simple utility function that implements a common pattern in functional programming. It checks if the provided value `x` is undefined, and if not, it applies the function `f` to that value. The implementation uses a ternary operator for concise conditional execution, returning either `undefined` or the result of calling `f(x)`.

import/access examples:
import { ifLet } from '@welshman/lib';
import { ifLet } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1034:1034
id: f9e8dc5e811c1e96bbea34541fead0a84d452603d0b023f21434c9a68679d9a5
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1034

declaration:
randomInt = (min = 0, max = 9) => min + Math.round(Math.random() * (max - min))

summary:
Generates a random integer between the specified minimum and maximum values (inclusive).

Parameters:
- min: The minimum value (defaults to 0)
- max: The maximum value (defaults to 9)

Returns:
A random integer between min and max (inclusive).

details:
The implementation uses JavaScript's Math.random() to generate a random decimal between 0 and 1, then scales it to the desired range by multiplying by (max - min). Math.round() is applied to convert the result to an integer, and finally the minimum value is added to shift the range appropriately.

The formula ensures that both the minimum and maximum values can be returned, making this an inclusive range generator.

import/access examples:
import { randomInt } from '@welshman/lib';
import { randomInt } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1040:1040
id: 65f39882dcee7a465d32a1019c029682d8c23078c59aaf3c232dd819a2148c8c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1040

declaration:
randomId = (): string => Math.random().toString().slice(2)

summary:
Generates a random string ID by converting a random number to a string and slicing off the first two characters (typically '0.'). This function is useful for creating unique identifiers without requiring complex UUID generation.

details:
The implementation is very simple but effective for non-cryptographic purposes:
1. Uses JavaScript's built-in `Math.random()` to generate a random number between 0 and 1
2. Converts the number to a string with `toString()`
3. Uses `slice(2)` to remove the first two characters (the '0.' prefix of the decimal)

The result is a string of digits that can serve as a simple unique identifier. Note that this is not cryptographically secure and shouldn't be used where security is critical.

import/access examples:
import { randomId } from '@welshman/lib';
import { randomId } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1051:1051
id: 511b3716c7c883a4482464b068804bc55acfbbf8bf290e6a6892793929826557
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1051

declaration:
sleep = (t: number) => new Promise(resolve => setTimeout(resolve, t))

summary:
Creates a promise that resolves after a specified time delay. This function is useful for introducing delays in asynchronous code execution.

details:
The implementation uses JavaScript's setTimeout function wrapped in a Promise. When called with a time parameter (in milliseconds), it returns a new Promise that will resolve after the specified delay. The Promise's resolve function is passed as the callback to setTimeout, ensuring the Promise resolves when the timer completes. This is a simple but effective way to pause execution in async/await code flows.

import/access examples:
import { sleep } from '@welshman/lib';
import { sleep } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1053:1057
id: 247d8c2ee83639b45cdbcc93289c7b89edcf872768b6cd460f0e707fa6cb53fa
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1053

declaration:
export type PollOptions = {
  signal: AbortSignal
  condition: () => boolean
  interval?: number
}

summary:
The `PollOptions` type defines the configuration options for the `poll` function. It includes required properties for controlling polling behavior: a signal to abort the polling, a condition function that determines when polling should stop, and an optional interval that specifies the time between polling attempts in milliseconds.

details:
This type contains three properties:
1. `signal: AbortSignal` - An AbortSignal instance that can be used to cancel the polling operation
2. `condition: () => boolean` - A function that returns a boolean indicating whether the polling should continue (false) or stop (true)
3. `interval?: number` - An optional parameter specifying the time in milliseconds between polling attempts

This type is used by the `poll` function (defined around line 1064) which creates a promise that resolves when the condition becomes true or when the signal is aborted.

import/access examples:
import type { PollOptions } from '@welshman/lib';
import type { PollOptions } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1064:1082
id: e4bdd25cc42d4cd458af693bf43a9713d2feb9b9e631a97e06e155451dce7012
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1064

declaration:
poll = ({interval = 300, condition, signal}: PollOptions) =>
  new Promise<void>(resolve => {
    const int = setInterval(() => {
      if (condition()) {
        resolve()
        clearInterval(int)
      }
    }, interval)

    if (condition()) {
      resolve()
      clearInterval(int)
    }

    signal.addEventListener("abort", () => {
      resolve()
      clearInterval(int)
    })
  })

summary:
Creates a promise that resolves when a specified condition becomes true or when the operation is aborted. The function polls the condition at regular intervals until it returns true or the provided AbortSignal is triggered. This is useful for waiting for asynchronous conditions to be met without blocking the main thread.

details:
Implementation details:
1. Takes an options object with three properties:
   - `condition`: A function that returns a boolean indicating if the polling should complete
   - `signal`: An AbortSignal to cancel the polling
   - `interval`: Optional polling frequency in milliseconds (defaults to 300ms)

2. Returns a Promise that resolves when:
   - The condition function returns true
   - The AbortSignal is triggered

3. Uses setInterval to periodically check the condition

4. Performs an immediate check of the condition before starting the interval

5. Properly cleans up the interval when the promise resolves to prevent memory leaks

related: PollOptions

import/access examples:
import { poll } from '@welshman/lib';
import { poll } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1088:1100
id: b02ccb3fde080bbcbe031f4709ec398f68757cc218ff0fcf80a0c5722839d090
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1088

declaration:
yieldThread = () => {
  if (
    typeof window !== "undefined" &&
    "scheduler" in window &&
    "yield" in (window as any).scheduler
  ) {
    return (window as any).scheduler.yield()
  }

  return new Promise<void>(resolve => {
    setTimeout(resolve, 0)
  })
}

summary:
Creates a microtask that yields to other tasks in the event loop by returning a Promise that resolves after yielding control. This allows other pending tasks to execute before continuing execution of the current code path.

details:
The implementation first checks if the browser's scheduler API is available (which is a modern API for yielding control). If available, it uses `window.scheduler.yield()` which is the preferred method.

If the scheduler API is not available, it falls back to a traditional approach using `setTimeout(resolve, 0)` wrapped in a Promise. This creates a new task in the event loop with a 0ms delay, effectively deferring execution until after all other synchronous code and microtasks have completed in the current execution cycle.

The function handles both modern browsers with the scheduler API and older environments that don't support it.

import/access examples:
import { yieldThread } from '@welshman/lib';
import { yieldThread } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1108:1135
id: 534f114e854a7cc2cff0ed0af686515c906a987f002438f5ab18c053b4910693
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1108

declaration:
throttle = <F extends (...args: any[]) => any>(ms: number, f: F) => {
  if (ms === 0) {
    return f
  }

  let paused = false
  let nextArgs: Parameters<F> | undefined

  const unpause = () => {
    if (nextArgs) {
      f(...nextArgs)
      nextArgs = undefined
      setTimeout(unpause, ms)
    } else {
      paused = false
    }
  }

  return (...thisArgs: Parameters<F>) => {
    if (!paused) {
      f(...thisArgs)
      paused = true
      setTimeout(unpause, ms)
    } else {
      nextArgs = thisArgs
    }
  }
}

summary:
Creates a throttled version of a function that limits how often the function can be called. The throttled function will execute immediately when called, then ignore subsequent calls until the specified time has passed. If called during the cooldown period, it will queue the most recent arguments to be executed when the cooldown ends.

details:
Implementation details:
1. If ms is 0, returns the original function without throttling.
2. Uses two state variables:
   - `paused`: Boolean flag indicating if function is in cooldown period
   - `nextArgs`: Stores the most recent arguments received during cooldown
3. Contains an `unpause` helper function that:
   - Executes the function with queued arguments if available
   - Resets the queue and schedules another unpause if arguments were processed
   - Otherwise marks the function as no longer paused
4. The returned throttled function:
   - Immediately executes if not paused, then sets paused=true and schedules unpause
   - If paused, stores the current arguments to be executed when unpause occurs
5. Uses setTimeout for timing rather than requestAnimationFrame
6. Only remembers the most recent call during throttling (doesn't queue multiple calls)

import/access examples:
import { throttle } from '@welshman/lib';
import { throttle } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1143:1155
id: 79c5a01eb454a9b0c7b68dcbf915ce5a7e29e18e9441249628b0adc658740909
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1143

declaration:
throttleWithValue = <T>(ms: number, f: () => T) => {
  let value: T

  const update = throttle(ms, () => {
    value = f()
  })

  return () => {
    update()

    return value
  }
}

summary:
Creates a throttled function that returns a cached value. The function will only update the cached value at most once every `ms` milliseconds, regardless of how often the returned function is called. This is useful for expensive computations that need to be accessed frequently but only need to be recalculated periodically.

details:
The implementation works by:

1. Maintaining a cached `value` variable in closure scope
2. Creating a throttled `update` function using the existing `throttle` utility
3. The update function, when called, executes the provided function `f` and stores its result in the cached value
4. Returns a function that calls the throttled update function and then returns the cached value

This creates a pattern where the first call initiates an update, but subsequent calls within the throttle window will return the previously cached value without triggering recalculation. The value is only updated when the throttle period has elapsed.

import/access examples:
import { throttleWithValue } from '@welshman/lib';
import { throttleWithValue } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1165:1173
id: bd9a03dbe7dce742ad4f738931879a9a146be388b3ec3375f68d007c88abd471
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1165

declaration:
batch = <T>(t: number, f: (xs: T[]) => void) => {
  const xs: T[] = []
  const cb = throttle(t, () => xs.length > 0 && f(xs.splice(0)))

  return (x: T) => {
    xs.push(x)
    cb()
  }
}

summary:
Creates a batching function that collects items within a specified time window. Unlike some batching implementations, this function processes the first item immediately and batches subsequent items. The returned function adds items to the batch and triggers processing when the time window elapses.

details:
The implementation works by:

1. Creating an array to store the batch items
2. Using the `throttle` function to create a callback that processes the batch when triggered
3. The throttled callback checks if there are items in the batch and calls the processing function with those items, using `splice(0)` to empty the array
4. The returned function adds items to the batch and triggers the throttled callback

The key aspect is that it leverages the `throttle` function to control the timing of batch processing, ensuring that items are collected within the specified time window before being processed together.

import/access examples:
import { batch } from '@welshman/lib';
import { batch } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1181:1205
id: 734d39074d49049f863c54f3371158ac6f1ddda91b98297f2882ff04053e86c8
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1181

declaration:
batcher = <T, U>(t: number, execute: (request: T[]) => U[] | Promise<U[]>) => {
  const queue: {request: T; resolve: (x: U) => void; reject: (reason?: string) => void}[] = []

  const _execute = async () => {
    const items = queue.splice(0)
    const results = await execute(items.map(item => item.request))

    results.forEach(async (r, i) => {
      if (results.length === items.length) {
        items[i].resolve(await r)
      } else {
        items[i].reject("Execute must return a result for each request")
      }
    })
  }

  return (request: T): Promise<U> =>
    new Promise((resolve, reject) => {
      if (queue.length === 0) {
        setTimeout(_execute, t)
      }

      queue.push({request, resolve, reject})
    })
}

summary:
Creates a function that batches multiple requests within a time window and processes them together, returning individual results to each caller. This is useful for optimizing operations that can be more efficiently executed in batches.

Parameters:
- `t`: Number of milliseconds to wait before processing the batch
- `execute`: Function that takes an array of requests and returns an array or promise of results (must return one result per request)

Returns a function that accepts a single request and returns a promise that resolves with the corresponding result when the batch is processed.

details:
Implementation details:

1. Maintains a queue of pending requests, each with its own resolve/reject functions
2. When the first request arrives, schedules batch processing after the specified time window
3. Additional requests within the time window are added to the queue without resetting the timer
4. When the timer fires, the `_execute` function:
   - Takes all queued items
   - Calls the provided execute function with the mapped requests
   - Distributes results back to individual callers via their resolve functions
   - Validates that the execute function returned the correct number of results
5. Uses Promise-based architecture to handle asynchronous batch processing
6. Provides error handling if the execute function doesn't return the expected number of results

import/access examples:
import { batcher } from '@welshman/lib';
import { batcher } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1213:1231
id: a2882c3ea77642e0179d850a8b5964591a323dca74a24ee44510bd410aeef013
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1213

declaration:
race = (threshold: number, promises: Promise<unknown>[]) => {
  let count = 0

  if (threshold === 0) {
    return Promise.resolve()
  }

  return new Promise<void>((resolve, reject) => {
    promises.forEach(p => {
      p.then(() => {
        count++

        if (count >= threshold * promises.length) {
          resolve()
        }
      }).catch(reject)
    })
  })
}

summary:
Returns a promise that resolves after a specified proportion of promises in an array have completed successfully. The function takes a threshold value (between 0 and 1) that determines what percentage of promises must resolve before the returned promise resolves. If the threshold is 0, the function immediately resolves.

details:
The implementation works by:

1. Maintaining a counter of completed promises
2. Immediately resolving if threshold is 0
3. Creating a new Promise that:
   - Attaches then/catch handlers to each input promise
   - Increments the counter when promises resolve
   - Resolves the returned promise when the counter reaches or exceeds threshold * promises.length
   - Rejects if any promise rejects

The function doesn't handle empty arrays specially and will resolve immediately if the threshold is 0, regardless of the input array.

import/access examples:
import { race } from '@welshman/lib';
import { race } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1242:1242
id: 7503d25c5430527a79c9b32247222232c9baeb840177ff944bf8c4c8d4d711c4
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1242

declaration:
stripProtocol = (url: string) => url.replace(/.*:\/\//, "")

summary:
Removes protocol (http://, https://, etc) from a URL string. This function takes a URL as input and returns the URL with the protocol part removed.

details:
The implementation uses a regular expression to replace any characters followed by '://' with an empty string. The regex pattern '.*:\/\/' matches everything from the start of the string up to and including the '://' sequence, effectively removing protocols like 'http://', 'https://', 'ftp://', etc.

import/access examples:
import { stripProtocol } from '@welshman/lib';
import { stripProtocol } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1249:1252
id: 88e1aa25a29aa15278f148c491e4948835e9b7df7c9c374f6af472555965f6da
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1249

declaration:
displayUrl = (url: string) =>
  stripProtocol(url)
    .replace(/^(www\.)?/i, "")
    .replace(/\/$/, "")

summary:
Formats a URL for display by removing the protocol (http://, https://), 'www.' prefix, and trailing slash. This creates a cleaner, more user-friendly URL representation.

details:
The function works by applying a series of transformations to the input URL:
1. First calls `stripProtocol()` to remove any protocol prefix (like 'http://' or 'https://')
2. Then uses regex to remove any 'www.' prefix at the beginning of the string (case insensitive)
3. Finally removes any trailing slash with another regex replacement

For example:
- 'https://www.example.com/' becomes 'example.com'
- 'http://subdomain.example.com/' becomes 'subdomain.example.com'
- 'https://www.example.com/path/' becomes 'example.com/path'

related: __function,stripProtocol

import/access examples:
import { displayUrl } from '@welshman/lib';
import { displayUrl } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1259:1259
id: f2b127f604c7d7e38f5f454f5c01f6ca21e311237b2f0d107639b6723a3ea7fc
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1259

declaration:
displayDomain = (url: string) => displayUrl(first(url.split(/[\/\?]/)) || "")

summary:
Extracts and formats the domain name from a URL by removing protocol, 'www.' prefix, and trailing slash. This function takes a URL string as input and returns a clean, formatted domain name.

details:
The implementation works by:
1. First splitting the URL at forward slashes or question marks to isolate the domain portion
2. Taking only the first part of this split using the `first()` utility function
3. Providing an empty string fallback if the split result is empty
4. Passing this domain portion to `displayUrl()` which handles removing protocol, www prefix, and trailing slash

related: __function,displayUrl

import/access examples:
import { displayDomain } from '@welshman/lib';
import { displayDomain } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1270:1278
id: 07afa481b66b374af5f0eb9fa5977fd340b12fbbaa01437969a3fac3d929b3d0
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1270

declaration:
parseJson = (json: string | undefined) => {
  if (!json) return undefined

  try {
    return JSON.parse(json)
  } catch (e) {
    return undefined
  }
}

summary:
Safely parses a JSON string into an object. This function handles potential errors during parsing and returns undefined if the input is invalid or missing.

details:
The function works by:
1. First checking if the input string exists - returns undefined if it's falsy
2. Using a try-catch block to safely attempt JSON.parse
3. Returning the parsed object if successful
4. Returning undefined if any parsing error occurs

This provides a convenient way to parse JSON without having to handle exceptions every time.

import/access examples:
import { parseJson } from '@welshman/lib';
import { parseJson } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1285:1285
id: 171d933af197aaf2ed2fe087b4dcf3c83c94c785950f199fa36ace8992761349
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1285

declaration:
getJson = (k: string) => parseJson(localStorage.getItem(k) || "")

summary:
Gets and parses JSON data from localStorage. This function retrieves a value from localStorage using the provided key, then attempts to parse it as JSON. If the value doesn't exist or isn't valid JSON, it returns undefined.

details:
The implementation is a simple one-liner that combines two operations:
1. First retrieves the item from localStorage using the provided key
2. Handles the case where the key doesn't exist by defaulting to an empty string
3. Passes the result to the parseJson function which safely parses JSON and returns undefined for invalid inputs

This function depends on the parseJson utility function defined earlier in the file, which handles error catching during JSON parsing.

related: __function,parseJson

import/access examples:
import { getJson } from '@welshman/lib';
import { getJson } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1292:1292
id: ffc9ea71e286154f6393e30ee554408a2915c1fdf2626240ef573ee491ebcdeb
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1292

declaration:
setJson = (k: string, v: any) => localStorage.setItem(k, JSON.stringify(v))

summary:
Stringifies and stores a value in localStorage. This function converts any JavaScript value to a JSON string and saves it to the browser's localStorage under the specified key.

details:
This function is a simple wrapper around localStorage.setItem() that handles the JSON serialization step. It takes a key string and any value, converts the value to a JSON string using JSON.stringify(), and then stores it in the browser's localStorage using the provided key. This makes it easy to store complex data structures in localStorage, which normally only accepts string values.

import/access examples:
import { setJson } from '@welshman/lib';
import { setJson } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1294:1299
id: a384c9d35e389d7609dfbdf6807285c9cb69d11836a034a9b2b114e0a5a06e20
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1294

declaration:
type FetchOpts = {
  method?: string
  headers?: Record<string, string | boolean>
  body?: string | FormData
}

summary:
A type definition for options used in fetch requests. It includes optional properties for HTTP method, headers, and request body.

details:
This type alias defines the structure for options passed to fetch-related functions. It contains:
1. `method`: Optional string for HTTP method (GET, POST, etc.)
2. `headers`: Optional record of string keys to string or boolean values
3. `body`: Optional request body that can be either a string or FormData object

This type is used internally by utility functions like `fetchJson` and `postJson` to provide a simplified interface for making HTTP requests.

=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1307:1323
id: 7b3badd79be0b52d7520786d403d71f1507d791bec53b40512a26be3efd82a76
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1307

declaration:
fetchJson = async (url: string, opts: FetchOpts = {}) => {
  // Make sure the url is valid, this will throw if not
  url = String(new URL(url))

  if (!opts.headers) {
    opts.headers = {}
  }

  if (!opts.headers["Accept"]) {
    opts.headers["Accept"] = "application/json"
  }

  const res = await fetch(url, opts as RequestInit)
  const json = await res.json()

  return json
}

summary:
Fetches JSON data from a URL with customizable options. This function validates the URL, sets default headers for JSON acceptance, makes the fetch request, and parses the JSON response.

Parameters:
- url: String URL to fetch data from
- opts: Optional fetch configuration object with method, headers, and body properties

Returns: Promise that resolves to the parsed JSON response

details:
Implementation details:
1. Validates the URL by creating a URL object and converting it back to string (will throw if invalid)
2. Ensures the headers object exists in the options
3. Sets the 'Accept' header to 'application/json' if not already specified
4. Makes the fetch request using the native fetch API with the provided URL and options
5. Parses the response using the .json() method
6. Returns the parsed JSON data

The function handles the basic setup needed for JSON API requests while allowing customization through the options parameter.

related: FetchOpts

import/access examples:
import { fetchJson } from '@welshman/lib';
import { fetchJson } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1332:1348
id: 1b7f6156942e0e6f398a90423d0efe9b67da574aad08a0976d9e9728f268a296
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1332

declaration:
postJson = async <T>(url: string, data: T, opts: FetchOpts = {}) => {
  if (!opts.method) {
    opts.method = "POST"
  }

  if (!opts.headers) {
    opts.headers = {}
  }

  if (!opts.headers["Content-Type"]) {
    opts.headers["Content-Type"] = "application/json"
  }

  opts.body = JSON.stringify(data)

  return fetchJson(url, opts)
}

summary:
Posts JSON data to a URL with appropriate headers. This function simplifies sending JSON data via HTTP POST requests by automatically setting the correct content type headers and serializing the data.

@param url - URL to post to
@param data - Data to send (will be JSON-serialized)
@param opts - Additional fetch options (optional)
@returns Promise of parsed JSON response

details:
The implementation:
1. Sets the HTTP method to "POST" if not specified
2. Initializes headers object if not provided
3. Sets "Content-Type" header to "application/json" if not already set
4. Serializes the data object to JSON string and assigns it to request body
5. Delegates the actual request to the fetchJson utility function

This function handles all the common setup needed for JSON POST requests while allowing customization through the opts parameter.

related: FetchOpts

import/access examples:
import { postJson } from '@welshman/lib';
import { postJson } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1356:1362
id: 74c67e33ed36cd2e59e8ffd9cbc361105395a7c096b76f53d930f37bab18a103
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1356

declaration:
uploadFile = (url: string, file: File) => {
  const body = new FormData()

  body.append("file", file)

  return fetchJson(url, {method: "POST", body})
}

summary:
Uploads a file to a specified URL using a POST request with FormData. The function creates a FormData object, appends the file to it, and sends it to the server using the fetchJson utility function. It returns a Promise that resolves to the parsed JSON response from the server.

details:
The implementation is straightforward:
1. Creates a new FormData object to hold the file data
2. Appends the file to the FormData with the field name "file"
3. Calls the fetchJson utility function with:
   - The provided URL
   - A configuration object specifying:
     - POST method
     - The FormData as the request body
4. Returns the Promise from fetchJson which will resolve to the parsed JSON response

This function relies on the fetchJson utility defined elsewhere in the file, which handles the actual HTTP request and JSON parsing.

import/access examples:
import { uploadFile } from '@welshman/lib';
import { uploadFile } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1372:1385
id: 651fd54c798e110bfb3bee9197ee39312e323b7cda1911f7c9d132db4ea2230f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1372

declaration:
on = <EventMap extends Record<string | symbol, any[]>, E extends keyof EventMap>(
  target: {
    on(event: E, listener: (...args: EventMap[E]) => any): any
    off(event: E, listener: (...args: EventMap[E]) => any): any
  },
  eventName: E,
  callback: (...args: EventMap[E]) => void,
): (() => void) => {
  target.on(eventName, callback)

  return () => {
    target.off(eventName, callback)
  }
}

summary:
A generic type-safe event listener function that works with event emitters. It attaches an event listener to a target object and returns a cleanup function that removes the listener when called.

Parameters:
- `target`: An object with 'on' and 'off' methods for event handling
- `eventName`: The name of the event to listen for
- `callback`: The function to execute when the event occurs

Returns: A function that, when called, removes the event listener

details:
The implementation is straightforward but powerful in its type safety:

1. It uses TypeScript generics to ensure type safety between event names and their corresponding callback argument types:
   - `EventMap` defines the mapping between event names and their argument arrays
   - `E` represents a specific event name from the EventMap

2. The function:
   - Registers the callback with the target's 'on' method
   - Returns a cleanup function that calls the target's 'off' method with the same parameters

3. This pattern implements the common "subscription" pattern where attaching a listener returns a function to detach it, making it easy to manage event listener lifecycles.

import/access examples:
import { on } from '@welshman/lib';
import { on } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1398:1408
id: 2357d648bee9b9268a22d14ca0c7f488beb6f2551bc7b3b3614e5d6983229d48
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1398

declaration:
ellipsize = (s: string, l: number, suffix = "...") => {
  if (s.length < l * 1.1) {
    return s
  }

  while (s.length > l && s.includes(" ")) {
    s = s.split(" ").slice(0, -1).join(" ")
  }

  return s + suffix
}

summary:
Truncates a string to a specified maximum length, breaking at word boundaries to avoid cutting words in half. If the string is truncated, a suffix (default '...') is appended to indicate the truncation.

Parameters:
- s: String to truncate
- l: Maximum length
- suffix: String to append if truncated (defaults to '...')

Returns: The truncated string with suffix appended if truncation occurred.

details:
The implementation works by:
1. First checking if the string is already short enough (less than 110% of target length) - if so, returns it unchanged
2. If truncation is needed, it repeatedly removes the last word (by splitting on spaces, removing the last element, and rejoining) until the string is shorter than the target length
3. Finally, it appends the suffix to indicate truncation

The function is careful to preserve word boundaries, ensuring that words aren't cut in the middle. It only performs truncation if the string contains spaces.

import/access examples:
import { ellipsize } from '@welshman/lib';
import { ellipsize } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1411:1421
id: 2af0daf4b10f44704630c7bbfa6eb196f6d4b85ea6709f1884368319c705fc31
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1411

declaration:
displayList = <T>(xs: T[], conj = "and", n = 6) => {
  if (xs.length > n + 2) {
    return `${xs.slice(0, n).join(", ")}, ${conj} ${xs.length - n} others`
  }

  if (xs.length < 3) {
    return xs.join(` ${conj} `)
  }

  return `${xs.slice(0, -1).join(", ")}, ${conj} ${xs.slice(-1).join("")}`
}

summary:
Formats a list of items into a human-readable string with proper grammar, using oxford commas and a conjunction. The function handles different list lengths with special formatting:
- For short lists (< 3 items): joins with the conjunction (e.g., "a and b")
- For medium lists: uses oxford comma format (e.g., "a, b, and c")
- For long lists (> n+2 items): truncates and adds summary (e.g., "a, b, c, d, e, f, and 4 others")

@param xs - Array of items to format into a list
@param conj - Conjunction to use (defaults to "and")
@param n - Maximum number of items to show before truncating (defaults to 6)
@returns Formatted string representation of the list

details:
The implementation handles three distinct cases:

1. Long lists (length > n+2):
   - Takes the first n items using slice(0, n)
   - Joins them with commas
   - Appends the conjunction and count of remaining items

2. Short lists (length < 3):
   - Simply joins the items with the conjunction surrounded by spaces

3. Medium lists (all other cases):
   - Takes all but the last item using slice(0, -1)
   - Joins them with commas
   - Appends the conjunction and the last item
   - Uses the oxford comma format (comma before conjunction)

The function uses template literals for string construction and array methods like slice() and join() for manipulating the list elements.

import/access examples:
import { displayList } from '@welshman/lib';
import { displayList } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1424:1425
id: 0866230ba67a9ac22c6a6dfc1df3124640aa4d88cbfe703c79b2da8a2c649388
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1424

declaration:
hash = (s: string) =>
  Math.abs(s.split("").reduce((a, b) => ((a << 5) - a + b.charCodeAt(0)) | 0, 0)).toString()

summary:
Generates a hash string from an input string. This function creates a numeric hash value from the characters in the string and returns it as a string. The hash is calculated using a common algorithm (djb2) that shifts and adds character codes, then takes the absolute value of the result.

details:
The implementation uses a simple but effective string hashing algorithm:

1. It splits the input string into individual characters
2. Reduces the array of characters using a bitwise operation: ((a << 5) - a + charCode) | 0
   - This is equivalent to a * 31 + charCode, a common hash multiplier
   - The | 0 forces the result to be a 32-bit integer
3. Takes the absolute value of the final number (Math.abs) to ensure a positive result
4. Converts the numeric hash to a string

This is a variation of the djb2 hashing algorithm, which is simple but provides reasonable distribution for string inputs. It's not cryptographically secure but works well for basic hashing needs.

import/access examples:
import { hash } from '@welshman/lib';
import { hash } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1432:1435
id: a17241b8d20d1a2a2bb7d0c30b129293bf5d4e3c3c91da91ba7a1300cf327633
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1432

declaration:
nth =
  (i: number) =>
  <T>(xs: T[], ...args: unknown[]) =>
    xs[i]

summary:
Returns a function that gets the nth element of an array. This is a curried utility function that takes an index parameter and returns a function that, when called with an array, returns the element at the specified index.

details:
This is a higher-order function implementation using currying. It takes an index parameter first, then returns a new function that accepts an array and additional arguments (which are ignored). The returned function simply accesses the array at the specified index position using bracket notation (xs[i]) and returns that element. The function is generic, with type parameter T representing the type of elements in the array.

import/access examples:
import { nth } from '@welshman/lib';
import { nth } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1438:1441
id: 89ecf50ebb861a5aeee655495aa24d948a464a6ce4d778bace372782d5d7fa70
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1438

declaration:
nthEq =
  (i: number, v: any) =>
  (xs: any[], ...args: unknown[]) =>
    xs[i] === v

summary:
Returns a function that checks if the nth element of an array equals a specific value. This is a curried function that takes an index and a value, then returns a predicate function that can be applied to arrays.

details:
This is a higher-order function that implements a curried approach to array element comparison. It works in two steps:
1. First call takes an index `i` and a value `v` to compare against
2. Returns a new function that accepts an array `xs` and optional additional arguments
3. The returned function checks if the element at position `i` in the array strictly equals (`===`) the value `v`

The function is part of a collection of curried utilities for working with collections, making it useful for functional programming patterns like filtering arrays based on specific element values.

import/access examples:
import { nthEq } from '@welshman/lib';
import { nthEq } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1444:1447
id: 47dbc1574f3bead52d3ef7971fb1f71692b3c726d04d5f642e8f4b5b57ea4ee4
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1444

declaration:
nthNe =
  (i: number, v: any) =>
  (xs: any[], ...args: unknown[]) =>
    xs[i] !== v

summary:
Returns a higher-order function that checks if the nth element of an array does not equal a specific value. The function takes an index and a value to compare against, and returns a predicate function that accepts an array and returns a boolean.

details:
This is a curried function that creates a predicate for array element inequality checking. It works in two steps:
1. First call takes an index `i` and comparison value `v`
2. Returns a function that takes an array `xs` and optional additional arguments
3. The returned function checks if the element at position `i` in the array is not equal to value `v` using strict inequality (!==)

The function uses the rest parameter pattern (`...args: unknown[]`) to allow for additional arguments that are ignored in the implementation.

import/access examples:
import { nthNe } from '@welshman/lib';
import { nthNe } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1450:1466
id: 4a3c2cdbe0df45f863242ab11b52c042a3580cbc0602ee36e5a803f5a108181a
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1450

declaration:
spec =
  (values: Obj | Array<any>) =>
  (x: Obj | Array<any>, ...args: unknown[]) => {
    if (Array.isArray(values)) {
      for (let i = 0; i < values.length; i++) {
        if ((x as Array<any>)[i] !== values[i]) {
          return false
        }
      }
    } else {
      for (const [k, v] of Object.entries(values)) {
        if ((x as Obj)[k] !== v) return false
      }
    }

    return true
  }

summary:
Returns a function that checks if key/value pairs of an object or elements of an array match all pairs in a specification object or array. The function takes a specification (values) as input and returns a predicate function that tests whether a given object or array matches that specification.

details:
The implementation handles two cases:

1. When the specification is an array:
   - It iterates through each index of the array
   - Compares each element at the corresponding index in the target
   - Returns false if any element doesn't match exactly (using ===)

2. When the specification is an object:
   - It iterates through each key-value pair in the specification
   - Checks if the target object has matching values for those keys
   - Returns false if any value doesn't match exactly

The function returns true only if all specified values match. This creates a partial equality checker that only verifies the properties or elements explicitly included in the specification.

related: Obj

import/access examples:
import { spec } from '@welshman/lib';
import { spec } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1469:1472
id: bed5c23854182ac1632d278239509275d711eda96eb1ad3bbe4b28cdea8b15b0
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1469

declaration:
eq =
  <T>(v: T) =>
  (x: T, ...args: unknown[]) =>
    x === v

summary:
Returns a higher-order function that checks if a value is equal to a specified value. This is a curried equality check function that takes a value and returns a predicate function that tests for equality with that value.

details:
This function implements a simple curried equality check using JavaScript's strict equality operator (===). It's a utility for functional programming patterns where you need to create predicates on the fly. The implementation is straightforward:

1. It takes a generic value `v` of type `T`
2. Returns a function that takes another value `x` of the same type and additional arguments (which are ignored)
3. The returned function simply compares `x` and `v` using strict equality (===)
4. The function is designed to be used in filter operations or other higher-order function contexts

import/access examples:
import { eq } from '@welshman/lib';
import { eq } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1475:1478
id: c89397efaafd4176c8915123cb4babdb11fad2fa300094e9ac5df1ba10bcc812
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1475

declaration:
ne =
  <T>(v: T) =>
  (x: T, ...args: unknown[]) =>
    x !== v

summary:
Returns a higher-order function that checks if a value is not equal to a specified value. The function takes a value `v` as input and returns a new function that accepts a value `x` and additional arguments, then returns the result of the inequality comparison `x !== v`.

details:
This is a simple curried function that implements the inequality check. It's part of a collection of functional programming utilities in the Tools module. The implementation is straightforward:
1. It accepts a generic type parameter T to ensure type safety
2. Takes a value v of type T
3. Returns a function that takes another value x of type T and optional additional arguments
4. The returned function performs a strict inequality check (x !== v) and returns the boolean result

The function ignores any additional arguments passed to the inner function, making it compatible with higher-order functions that might pass extra parameters.

import/access examples:
import { ne } from '@welshman/lib';
import { ne } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1481:1484
id: d5db106d3c0a182200ee96639776eec70492f52ae64134027432ca86fb1a6710
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1481

declaration:
prop =
  <T>(k: string) =>
  (x: Record<string, unknown>) =>
    x[k] as T

summary:
Returns a function that gets a property value from an object. This is a curried function that takes a property key and returns a function that, when given an object, extracts the value at that key with the specified type.

details:
This is a simple curried function implementation that creates a property accessor. It uses a generic type parameter T to allow type-safe property access. The implementation is straightforward:
1. It takes a string key parameter
2. Returns a function that accepts an object with string keys
3. The returned function extracts the value at the specified key and casts it to type T

This function is part of a functional programming utilities collection, designed for use in property access patterns common in functional programming.

import/access examples:
import { prop } from '@welshman/lib';
import { prop } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1487:1490
id: fe3e0f30f90a91f98fb46648a35b6ce05a602816835b2ce618fe77d64ecde964
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1487

declaration:
assoc =
  <K extends string, T, U>(k: K, v: T) =>
  (o: U) =>
    ({...o, [k as K]: v}) as U & Record<K, T>

summary:
Returns a function that adds or updates a property on an object. This is a curried function that takes a key and value, then returns a function that accepts an object and returns a new object with the specified property added or updated.

details:
This function implements a common functional programming pattern for immutable object updates. It uses a curried approach where:

1. First call takes a key and value to be added/updated
2. Second call takes the target object
3. Returns a new object that spreads the original properties and adds/updates the specified key-value pair
4. Uses TypeScript's type system to properly type the return value as the original object type extended with the new property
5. The implementation uses the spread operator to create a new object rather than mutating the original

import/access examples:
import { assoc } from '@welshman/lib';
import { assoc } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1493:1496
id: f804a6e60d86179074330f5226bd3d79635d540c2eb6cf9c0dd53fa2ac23bb4e
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1493

declaration:
dissoc =
  <K extends string, T extends Obj>(k: K) =>
  (o: T) =>
    omit([k], o)

summary:
Returns a function that removes a property from an object. This is a curried function that takes a key name and returns a new function that, when called with an object, returns a new object with the specified property removed.

details:
This function is implemented as a curried function using arrow functions. It first takes a key parameter of type K (which must be a string), then returns another function that takes an object parameter of type T (which must extend the Obj type). The returned function uses the `omit` utility function to create a new object without the specified property. The implementation is simple and leverages the existing `omit` function to do the actual property removal work.

related: __function,omit

import/access examples:
import { dissoc } from '@welshman/lib';
import { dissoc } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1499:1502
id: 50594ae8effbea3b535a885664a9edbbc82d5eaf2355f41fd6f8d23a0289a310
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1499

declaration:
member =
  <T>(xs: Iterable<T>) =>
  (x: T) =>
    Array.from(xs).includes(x)

summary:
Returns a higher-order function that checks whether a value is present in a given iterable sequence. The function takes an iterable collection and returns a predicate function that tests if a value is a member of that collection.

details:
This is a curried function that works in two steps:
1. First call accepts an iterable collection and returns a new function
2. The returned function accepts a value and checks if it exists in the original collection

The implementation converts the iterable to an array using Array.from() and then uses the standard includes() method to check for membership. This allows it to work with any iterable type (arrays, sets, etc.) but may have performance implications for large collections since it creates a new array on each call.

import/access examples:
import { member } from '@welshman/lib';
import { member } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1514:1519
id: 2249d8946ee0a9eda39414868e3ca344e5c05e1546a4b7d419f5ebe1cca42326
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1514

declaration:
addToKey = <T>(m: Record<string, Set<T>>, k: string, v: T) => {
  const s = m[k] || new Set<T>()

  s.add(v)
  m[k] = s
}

summary:
Adds a value to a Set stored at a specific key in an object. If the key doesn't exist yet, it creates a new Set first. This function is useful for maintaining collections of unique values organized by keys.

details:
The implementation follows these steps:
1. Retrieves the Set at the specified key, or creates a new empty Set if none exists
2. Adds the provided value to the Set
3. Assigns the Set back to the object at the specified key

This is a mutating operation that modifies the input object directly rather than returning a new object.

import/access examples:
import { addToKey } from '@welshman/lib';
import { addToKey } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1527:1532
id: 410b147bb3750b5f99fd01f626eab17ec1566909b49898ac13d11aba83b22c43
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1527

declaration:
pushToKey = <T>(m: Record<string, T[]>, k: string, v: T) => {
  const a = m[k] || []

  a.push(v)
  m[k] = a
}

summary:
Pushes a value to an array at a specific key in an object. If the key doesn't exist or its value is falsy, it initializes a new empty array at that key before pushing the value. This function modifies the input object directly.

details:
The implementation is straightforward:
1. It retrieves the array at the specified key, or creates a new empty array if none exists
2. Pushes the new value to this array
3. Assigns the updated array back to the key in the object

This is a utility function for working with objects that store collections (arrays) at different keys, allowing for easy appending of values without having to check if the array already exists.

import/access examples:
import { pushToKey } from '@welshman/lib';
import { pushToKey } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1544:1549
id: 564b0eb42c17fab625dfc33da87a41437335657a070688146395aa7bf40ec736
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1544

declaration:
addToMapKey = <K, T>(m: Map<K, Set<T>>, k: K, v: T) => {
  const s = m.get(k) || new Set<T>()

  s.add(v)
  m.set(k, s)
}

summary:
Adds a value to a Set stored at a specific key in a Map. If the key doesn't exist in the Map, a new Set is created first. This function is useful for maintaining collections of unique values organized by keys in a Map.

details:
The implementation follows these steps:
1. Retrieves the Set associated with the key from the Map, or creates a new empty Set if none exists
2. Adds the provided value to the Set
3. Updates the Map with the modified Set at the specified key

This is a utility function for working with nested data structures, specifically when you need to maintain unique values (using Sets) grouped by keys in a Map.

import/access examples:
import { addToMapKey } from '@welshman/lib';
import { addToMapKey } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1557:1562
id: 195f7f8c219274e5858d3146d667d032c4bd774f406cfb80b18ed065b052426a
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1557

declaration:
pushToMapKey = <K, T>(m: Map<K, T[]>, k: K, v: T) => {
  const a = m.get(k) || []

  a.push(v)
  m.set(k, a)
}

summary:
Pushes a value to an array stored at a specific key in a Map. If the key doesn't exist yet, it creates a new array with the value and sets it at that key. This function modifies the Map in place.

details:
The implementation follows these steps:
1. Retrieves the array at the specified key using `m.get(k)` or creates an empty array if none exists
2. Pushes the new value to this array using `a.push(v)`
3. Updates the Map with the modified array using `m.set(k, a)`

This is a utility function for working with Maps that store arrays as values, making it easier to append items without having to handle the empty case separately.

import/access examples:
import { pushToMapKey } from '@welshman/lib';
import { pushToMapKey } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1574:1575
id: e470d2e61fee18660cd723751aede868e767ec1db049f46b75cd259044f8f54a
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1574

declaration:
hexToBech32 = (prefix: string, hex: string) =>
  bech32.encode(prefix, bech32.toWords(utf8.decode(hex)), false)

summary:
Converts a hexadecimal string to bech32 format with the specified prefix. Bech32 is a human-readable encoding format commonly used in blockchain addresses.

@param prefix - Bech32 prefix to use in the encoded string
@param hex - Hexadecimal string to convert
@returns Bech32 encoded string

details:
The implementation uses the @scure/base library's bech32 and utf8 modules to perform the conversion. The function works by:
1. Decoding the hex string to binary data using utf8.decode
2. Converting the binary data to bech32 words using bech32.toWords
3. Encoding the words with the specified prefix using bech32.encode with the checksum option set to false

related: bech32

import/access examples:
import { hexToBech32 } from '@welshman/lib';
import { hexToBech32 } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1582:1583
id: 7ba43e3ffec45e1acc74dda8b2615b07054b26fb47406a30dc690f389dbd2579
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1582

declaration:
bech32ToHex = (b32: string) =>
  utf8.encode(bech32.fromWords(bech32.decode(b32 as any, false).words))

summary:
Converts a bech32 encoded string to hexadecimal format. This function takes a bech32 string as input and returns the corresponding hex encoded string.

details:
The implementation works in several steps:
1. Uses `bech32.decode()` to decode the bech32 string, passing `false` as the second parameter (likely to indicate no limit on the string length)
2. Extracts the `words` property from the decoded result
3. Converts the words to bytes using `bech32.fromWords()`
4. Encodes the resulting bytes as a hex string using `utf8.encode()`

Note that it casts the input string to `any` when calling `decode()`, possibly to bypass type checking constraints.

related: utf8

import/access examples:
import { bech32ToHex } from '@welshman/lib';
import { bech32ToHex } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1594:1602
id: 10518f7791fc0616df4ca5a7b35bbee0e19ce1c7634c8e297a7c2bdb2c0144ac
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1594

declaration:
bytesToHex = (buffer: ArrayBuffer | Uint8Array) => {
  if (buffer instanceof ArrayBuffer) {
    buffer = new Uint8Array(buffer)
  }

  return Array.from(buffer)
    .map(b => b.toString(16).padStart(2, "0"))
    .join("")
}

summary:
Converts an ArrayBuffer or Uint8Array to a hexadecimal string representation. The function takes a binary buffer as input and returns a string where each byte is represented as a two-character hexadecimal value.

details:
The implementation works in these steps:
1. First checks if the input is an ArrayBuffer and converts it to a Uint8Array if needed
2. Uses Array.from() to convert the Uint8Array to a regular array
3. Maps each byte to its hexadecimal string representation using toString(16)
4. Ensures each byte is represented by exactly two characters using padStart(2, "0")
5. Joins all the hex values together into a single string without separators

import/access examples:
import { bytesToHex } from '@welshman/lib';
import { bytesToHex } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1609:1610
id: b5cd1bdd6babe6f75015c9bbde9459b6bb4eb7701e100c9177d26263bd883b8d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1609

declaration:
hexToBytes = (hex: string) =>
  new Uint8Array(hex.match(/.{2}/g)!.map(hex => parseInt(hex, 16)))

summary:
Converts a hexadecimal string to a Uint8Array (array buffer). This function takes a hex string as input and returns a typed array containing the binary representation of that data.

details:
The implementation works by:
1. Taking a hex string input
2. Using regex pattern `/.{2}/g` to split the string into pairs of characters (each pair represents one byte)
3. Mapping each hex pair to its decimal integer value using `parseInt(hex, 16)`
4. Creating a new Uint8Array from the resulting array of integers

Note that the function uses the non-null assertion operator (!) after the regex match, assuming the input is always a valid hex string with an even number of characters.

import/access examples:
import { hexToBytes } from '@welshman/lib';
import { hexToBytes } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1616:1616
id: 332281f9dcb4d94af4578788fe35b1afcc3e614d64e84b266340600ca6faf79f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1616

declaration:
textEncoder = new TextEncoder()

summary:
A constant that provides a TextEncoder instance for encoding strings into UTF-8 binary data. This encoder can be used to convert JavaScript strings into Uint8Array objects containing UTF-8 encoded bytes.

details:
This is a simple initialization of the standard TextEncoder class from the Web API. The TextEncoder is used for converting JavaScript strings to their binary representation in UTF-8 encoding, which is useful for cryptographic operations, network transmissions, and other binary data processing. It's exported as a singleton instance to avoid creating multiple encoder objects throughout the application.

import/access examples:
import { textEncoder } from '@welshman/lib';
import { textEncoder } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1618:1618
id: ab55a537d62528a101a8c0664a33cec48691ae153440a9571180c45e3cfdf2f0
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1618

declaration:
textDecoder = new TextDecoder()

summary:
A constant that provides a TextDecoder instance for converting binary data to text. The TextDecoder API is used to decode binary data into strings using a specified text encoding.

details:
This creates a new instance of the TextDecoder class with default parameters (UTF-8 encoding). The TextDecoder is part of the Web APIs and provides functionality to decode binary data (like ArrayBuffer or Uint8Array) into JavaScript strings. It's commonly used alongside TextEncoder when working with binary data that represents text.

import/access examples:
import { textDecoder } from '@welshman/lib';
import { textDecoder } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/Tools.ts
lines: 1625:1629
id: f899b22a2f8602c44daa7270bcada408a2a40e20bb5904d6618ccf912992cbd8
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts#L1625

declaration:
sha256 = async (data: ArrayBuffer | Uint8Array): Promise<string> => {
  const hashBuffer = await crypto.subtle.digest("SHA-256", data)
  const hashArray = Array.from(new Uint8Array(hashBuffer))
  return hashArray.map(b => b.toString(16).padStart(2, "0")).join("")
}

summary:
Computes SHA-256 hash of binary data and returns it as a hex-encoded string. This function accepts either an ArrayBuffer or Uint8Array as input and returns a Promise that resolves to the hash string.

details:
The implementation uses the Web Crypto API's subtle.digest method to perform the SHA-256 hashing. The function works in these steps:
1. Takes binary data (ArrayBuffer or Uint8Array) as input
2. Uses crypto.subtle.digest with the SHA-256 algorithm to hash the data
3. Converts the resulting hash buffer to a Uint8Array and then to an array of numbers
4. Maps each byte to its hexadecimal representation (padded to 2 characters)
5. Joins the hex values into a single string and returns it

This is an asynchronous function that returns a Promise, as the Web Crypto API's digest method is asynchronous.

import/access examples:
import { sha256 } from '@welshman/lib';
import { sha256 } from '@welshman/lib/Tools';


=========================
workspace: packages/lib
file: packages/lib/src/TaskQueue.ts
lines: 3:6
id: 608d0110cb53dab8037773034d6d266ca45e7447b06a79eeb372beebc8107cdf
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/TaskQueue.ts#L3

declaration:
export type TaskQueueOptions<Item> = {
  batchSize: number
  processItem: (item: Item) => unknown
}

summary:
TaskQueueOptions is a generic type that defines the configuration for a TaskQueue. It requires two properties: `batchSize` which determines how many items to process in a single batch, and `processItem` which is a function that handles the processing of each individual item in the queue.

details:
This type alias defines the structure for options passed to the TaskQueue class constructor. It uses a generic type parameter `Item` which allows the TaskQueue to work with any type of items. The type consists of two required properties:
1. `batchSize`: A number that controls how many items will be processed in a single batch during queue processing
2. `processItem`: A function that takes an item of type `Item` and returns an unknown value, which allows for flexible processing implementations

import/access examples:
import type { TaskQueueOptions } from '@welshman/lib';
import type { TaskQueueOptions } from '@welshman/lib/TaskQueue';


=========================
workspace: packages/lib
file: packages/lib/src/TaskQueue.ts
lines: 8:73
id: 876c42560375dadd8d45c4bbe287ca9ff2bb11e786005ec8ae8456b43f2f1a27
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/TaskQueue.ts#L8

declaration:
export class TaskQueue<Item>{
  _subs: ((item: Item) => void)[];
  items: Item[];
  isPaused: boolean;
  isProcessing: boolean;
  constructor(readonly options: TaskQueueOptions<Item>);
  push(item: Item);
  remove(item: Item);
  subscribe(subscriber: (item: Item) => void);
  async process();
  stop();
  start();
  clear();
}

summary:
A generic queue for processing tasks asynchronously in batches. The `TaskQueue<Item>` class allows adding items to a queue, processing them according to a specified batch size, and notifying subscribers about processed items. It provides methods to push items, remove specific items, subscribe to item processing, control queue processing (start/stop), and clear the queue.

details:
Implementation details:

1. The class maintains internal state through several properties:
   - `_subs`: Array of subscriber callbacks
   - `items`: Array of queued items waiting to be processed
   - `isPaused`: Flag to control processing state
   - `isProcessing`: Flag to prevent concurrent processing

2. The core processing logic is in the `process()` method which:
   - Uses guards to prevent concurrent processing or processing when paused
   - Yields the thread before processing to improve responsiveness
   - Processes items in batches defined by `options.batchSize`
   - For each item, notifies all subscribers and then processes the item
   - Handles errors for individual items without stopping the queue
   - Recursively calls itself if more items remain after processing

3. The queue implements a simple pub/sub pattern through the `subscribe()` method, which returns an unsubscribe function for cleanup.

related: TaskQueueOptions

code:
export class TaskQueue<Item> {
  _subs: ((item: Item) => void)[] = []
  items: Item[] = []
  isPaused = false
  isProcessing = false

  constructor(readonly options: TaskQueueOptions<Item>) {}

  push(item: Item) {
    this.items.push(item)
    this.process()
  }

  remove(item: Item) {
    this.items = remove(item, this.items)
  }

  subscribe(subscriber: (item: Item) => void) {
    this._subs.push(subscriber)

    return () => {
      this._subs = remove(subscriber, this._subs)
    }
  }

  async process() {
    if (this.isProcessing || this.isPaused || this.items.length === 0) {
      return
    }

    this.isProcessing = true

    await yieldThread()

    for (const item of this.items.splice(0, this.options.batchSize)) {
      try {
        for (const subscriber of this._subs) {
          subscriber(item)
        }

        await this.options.processItem(item)
      } catch (e) {
        console.error(e)
      }
    }

    this.isProcessing = false

    if (this.items.length > 0) {
      this.process()
    }
  }

  stop() {
    this.isPaused = true
  }

  start() {
    this.isPaused = false
    this.process()
  }

  clear() {
    this.items = []
  }
}

import/access examples:
import { TaskQueue } from '@welshman/lib';
import { TaskQueue } from '@welshman/lib/TaskQueue';


=========================
workspace: packages/lib
file: packages/lib/src/normalize-url/index.ts
lines: 4:284
id: b813290a22436435dbd5edbbd256a927b8fb83a9b77a59606c3b81478b190800
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/normalize-url/index.ts#L4

declaration:
export type Options = {
  /**
	@default 'http'
	*/
  readonly defaultProtocol?: "https" | "http"

  /**
	Prepends `defaultProtocol` to the URL if it's protocol-relative.

	@default true

	@example
	```
	normalizeUrl('//sindresorhus.com');
	//=> 'http://sindresorhus.com'

	normalizeUrl('//sindresorhus.com', {normalizeProtocol: false});
	//=> '//sindresorhus.com'
	```
	*/
  readonly normalizeProtocol?: boolean

  /**
	Normalizes HTTPS URLs to HTTP.

	@default false

	@example
	```
	normalizeUrl('https://sindresorhus.com');
	//=> 'https://sindresorhus.com'

	normalizeUrl('https://sindresorhus.com', {forceHttp: true});
	//=> 'http://sindresorhus.com'
	```
	*/
  readonly forceHttp?: boolean

  /**
	Normalizes HTTP URLs to HTTPS.

	This option cannot be used with the `forceHttp` option at the same time.

	@default false

	@example
	```
	normalizeUrl('http://sindresorhus.com');
	//=> 'http://sindresorhus.com'

	normalizeUrl('http://sindresorhus.com', {forceHttps: true});
	//=> 'https://sindresorhus.com'
	```
	*/
  readonly forceHttps?: boolean

  /**
	Strip the [authentication](https://en.wikipedia.org/wiki/Basic_access_authentication) part of a URL.

	@default true

	@example
	```
	normalizeUrl('user:password@sindresorhus.com');
	//=> 'https://sindresorhus.com'

	normalizeUrl('user:password@sindresorhus.com', {stripAuthentication: false});
	//=> 'https://user:password@sindresorhus.com'
	```
	*/
  readonly stripAuthentication?: boolean

  /**
	Removes hash from the URL.

	@default false

	@example
	```
	normalizeUrl('sindresorhus.com/about.html#contact');
	//=> 'http://sindresorhus.com/about.html#contact'

	normalizeUrl('sindresorhus.com/about.html#contact', {stripHash: true});
	//=> 'http://sindresorhus.com/about.html'
	```
	*/
  readonly stripHash?: boolean

  /**
	Remove the protocol from the URL: `http://sindresorhus.com` → `sindresorhus.com`.

	It will only remove `https://` and `http://` protocols.

	@default false

	@example
	```
	normalizeUrl('https://sindresorhus.com');
	//=> 'https://sindresorhus.com'

	normalizeUrl('sindresorhus.com', {stripProtocol: true});
	//=> 'sindresorhus.com'
	```
	*/
  readonly stripProtocol?: boolean

  /**
	Strip the [text fragment](https://web.dev/text-fragments/) part of the URL

	__Note:__ The text fragment will always be removed if the `stripHash` option is set to `true`, as the hash contains the text fragment.

	@default true

	@example
	```
	normalizeUrl('http://sindresorhus.com/about.html#:~:text=hello');
	//=> 'http://sindresorhus.com/about.html#'

	normalizeUrl('http://sindresorhus.com/about.html#section:~:text=hello');
	//=> 'http://sindresorhus.com/about.html#section'

	normalizeUrl('http://sindresorhus.com/about.html#:~:text=hello', {stripTextFragment: false});
	//=> 'http://sindresorhus.com/about.html#:~:text=hello'

	normalizeUrl('http://sindresorhus.com/about.html#section:~:text=hello', {stripTextFragment: false});
	//=> 'http://sindresorhus.com/about.html#section:~:text=hello'
	```
	*/
  readonly stripTextFragment?: boolean

  /**
	Removes `www.` from the URL.

	@default true

	@example
	```
	normalizeUrl('http://www.sindresorhus.com');
	//=> 'http://sindresorhus.com'

	normalizeUrl('http://www.sindresorhus.com', {stripWWW: false});
	//=> 'http://www.sindresorhus.com'
	```
	*/
  readonly stripWWW?: boolean

  /**
	Removes query parameters that matches any of the provided strings or regexes.

	@default [/^utm_\w+/i]

	@example
	```
	normalizeUrl('www.sindresorhus.com?foo=bar&ref=test_ref', {
		removeQueryParameters: ['ref']
	});
	//=> 'http://sindresorhus.com/?foo=bar'
	```

	If a boolean is provided, `true` will remove all the query parameters.

	```
	normalizeUrl('www.sindresorhus.com?foo=bar', {
		removeQueryParameters: true
	});
	//=> 'http://sindresorhus.com'
	```

	`false` will not remove any query parameter.

	```
	normalizeUrl('www.sindresorhus.com?foo=bar&utm_medium=test&ref=test_ref', {
		removeQueryParameters: false
	});
	//=> 'http://www.sindresorhus.com/?foo=bar&ref=test_ref&utm_medium=test'
	```
	*/
  readonly removeQueryParameters?: ReadonlyArray<RegExp | string> | boolean

  /**
	Keeps only query parameters that matches any of the provided strings or regexes.

	__Note__: It overrides the `removeQueryParameters` option.

	@default undefined

	@example
	```
	normalizeUrl('https://sindresorhus.com?foo=bar&ref=unicorn', {
		keepQueryParameters: ['ref']
	});
	//=> 'https://sindresorhus.com/?ref=unicorn'
	```
	*/
  readonly keepQueryParameters?: ReadonlyArray<RegExp | string>

  /**
	Removes trailing slash.

	__Note__: Trailing slash is always removed if the URL doesn't have a pathname unless the `removeSingleSlash` option is set to `false`.

	@default true

	@example
	```
	normalizeUrl('http://sindresorhus.com/redirect/');
	//=> 'http://sindresorhus.com/redirect'

	normalizeUrl('http://sindresorhus.com/redirect/', {removeTrailingSlash: false});
	//=> 'http://sindresorhus.com/redirect/'

	normalizeUrl('http://sindresorhus.com/', {removeTrailingSlash: false});
	//=> 'http://sindresorhus.com'
	```
	*/
  readonly removeTrailingSlash?: boolean

  /**
	Remove a sole `/` pathname in the output. This option is independent of `removeTrailingSlash`.

	@default true

	@example
	```
	normalizeUrl('https://sindresorhus.com/');
	//=> 'https://sindresorhus.com'

	normalizeUrl('https://sindresorhus.com/', {removeSingleSlash: false});
	//=> 'https://sindresorhus.com/'
	```
	*/
  readonly removeSingleSlash?: boolean

  /**
	Removes the default directory index file from path that matches any of the provided strings or regexes.
	When `true`, the regex `/^index\.[a-z]+$/` is used.

	@default false

	@example
	```
	normalizeUrl('www.sindresorhus.com/foo/default.php', {
		removeDirectoryIndex: [/^default\.[a-z]+$/]
	});
	//=> 'http://sindresorhus.com/foo'
	```
	*/
  readonly removeDirectoryIndex?: boolean | ReadonlyArray<RegExp | string>

  /**
	Removes an explicit port number from the URL.

	Port 443 is always removed from HTTPS URLs and 80 is always removed from HTTP URLs regardless of this option.

	@default false

	@example
	```
	normalizeUrl('sindresorhus.com:123', {
		removeExplicitPort: true
	});
	//=> 'http://sindresorhus.com'
	```
	*/
  readonly removeExplicitPort?: boolean

  /**
	Sorts the query parameters alphabetically by key.

	@default true

	@example
	```
	normalizeUrl('www.sindresorhus.com?b=two&a=one&c=three', {
		sortQueryParameters: false
	});
	//=> 'http://sindresorhus.com/?b=two&a=one&c=three'
	```
	*/
  readonly sortQueryParameters?: boolean
}

summary:
The `Options` type defines the configuration options for URL normalization. It includes various settings to control how URLs are processed, such as protocol handling, authentication stripping, query parameter management, and path normalization. Each option has a default value and controls a specific aspect of URL normalization behavior.

details:
This type declaration is a comprehensive configuration interface for URL normalization with the following key options:

1. Protocol options:
   - `defaultProtocol`: Sets the default protocol (http/https)
   - `normalizeProtocol`: Controls prepending default protocol to protocol-relative URLs
   - `forceHttp`/`forceHttps`: Forces conversion to HTTP or HTTPS
   - `stripProtocol`: Removes protocol from URLs

2. URL component options:
   - `stripAuthentication`: Removes username/password from URLs
   - `stripHash`: Removes hash fragments
   - `stripTextFragment`: Removes text fragments (e.g., #:~:text=...)
   - `stripWWW`: Removes www. prefix

3. Query parameter options:
   - `removeQueryParameters`: Removes specified query parameters
   - `keepQueryParameters`: Keeps only specified query parameters
   - `sortQueryParameters`: Sorts query parameters alphabetically

4. Path normalization options:
   - `removeTrailingSlash`: Removes trailing slashes
   - `removeSingleSlash`: Removes sole / pathname
   - `removeDirectoryIndex`: Removes index files
   - `removeExplicitPort`: Removes explicit port numbers

Each option includes detailed documentation with examples showing before/after normalization.

import/access examples:
import type { Options } from '@welshman/lib/normalize-url';


=========================
workspace: packages/lib
file: packages/lib/src/normalize-url/index.ts
lines: 287:287
id: 76666ea9a39e7a384f81fee0c8f940882c7f7820b2294934bd783546d69ffe66
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/normalize-url/index.ts#L287

declaration:
DATA_URL_DEFAULT_MIME_TYPE = "text/plain"

summary:
A constant that defines the default MIME type for data URLs as "text/plain". This is used when normalizing data URLs that don't specify a MIME type.

details:
This constant is used in the normalizeDataURL function to provide a default MIME type when processing data URLs. When normalizing a data URL, if no MIME type is specified or if the specified type matches this default value, the MIME type part may be omitted in the normalized output for brevity.

=========================
workspace: packages/lib
file: packages/lib/src/normalize-url/index.ts
lines: 288:288
id: adff7a3903215d155f9ecef47cf9700f8df25902e2326c33282fc2a6231a1896
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/normalize-url/index.ts#L288

declaration:
DATA_URL_DEFAULT_CHARSET = "us-ascii"

summary:
A constant string representing the default character set for data URLs, set to "us-ascii".

details:
This constant is used in the normalizeDataURL function to handle data URL normalization. When processing data URLs, if the charset attribute matches this default value, it will be omitted from the normalized output to keep the URL as concise as possible.

=========================
workspace: packages/lib
file: packages/lib/src/normalize-url/index.ts
lines: 290:291
id: 6c83ba2d9931835d9e37e92c6c8f304e5f31f1f531820909fbedda1c3ab04f8b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/normalize-url/index.ts#L290

declaration:
testParameter = (name: string, filters: any[]) =>
  filters.some(filter => (filter instanceof RegExp ? filter.test(name) : filter === name))

summary:
A utility function that tests if a parameter name matches any of the provided filters. It accepts a parameter name (string) and an array of filters (which can be RegExp objects or strings). Returns true if any filter matches the parameter name.

details:
This function uses the `some()` method on the filters array to check if at least one filter matches the parameter name. For each filter, it checks:
1. If the filter is a RegExp instance, it uses the RegExp.test() method to check if the name matches the pattern
2. If the filter is not a RegExp, it performs a strict equality comparison (===) between the filter and the name

The function is used internally by the normalizeUrl function to test if query parameters or directory indexes match certain patterns for removal or retention.

=========================
workspace: packages/lib
file: packages/lib/src/normalize-url/index.ts
lines: 293:293
id: 35ac964b0de358ac27435a2525aa1f58182cf8d8f3562d540e11d67f579e3f08
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/normalize-url/index.ts#L293

declaration:
supportedProtocols = new Set(["https:", "http:", "file:"])

summary:
A Set containing the supported URL protocols: 'https:', 'http:', and 'file:'. This constant is used to determine if a URL has a custom protocol by checking if its protocol is not in this set.

details:
This constant creates an immutable Set data structure containing the three standard protocols that the normalize-url function fully supports. It's used in the hasCustomProtocol helper function to determine whether a URL uses a standard protocol (which should be normalized) or a custom protocol (which should be passed through without normalization).

=========================
workspace: packages/lib
file: packages/lib/src/normalize-url/index.ts
lines: 295:302
id: 6b41d72c8f7fd8a4d12a4f54e51f0838c4973e69ea32714f61c46577e1904af6
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/normalize-url/index.ts#L295

declaration:
hasCustomProtocol = (urlString: string) => {
  try {
    const {protocol} = new URL(urlString)
    return protocol.endsWith(":") && !supportedProtocols.has(protocol)
  } catch {
    return false
  }
}

summary:
A function that checks if a URL string has a custom protocol that is not in the list of supported protocols (https, http, file). It returns a boolean value indicating whether the URL has a custom protocol.

details:
The function works by attempting to create a URL object from the input string and then checking if the protocol ends with ':' and is not in the predefined set of supported protocols. It handles potential errors by catching exceptions that might occur during URL parsing (e.g., for invalid URLs) and returns false in those cases.

The implementation uses:
1. The URL constructor to parse the URL string
2. The protocol property of the URL object to extract the protocol
3. The endsWith() method to check if the protocol ends with ':'
4. The supportedProtocols Set to check if the protocol is supported
5. Try/catch to handle invalid URLs gracefully

=========================
workspace: packages/lib
file: packages/lib/src/normalize-url/index.ts
lines: 304:351
id: 148c2836921b7428d48aa62fb6df142b68011d9eba1ed0129107faa6d01bbc1d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/normalize-url/index.ts#L304

declaration:
normalizeDataURL = (urlString: string, {stripHash}: {stripHash: boolean}) => {
  const match = /^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(urlString)

  if (!match) {
    throw new Error(`Invalid URL: ${urlString}`)
  }

  let {type, data, hash} = match.groups as any
  const mediaType = type.split(";")
  hash = stripHash ? "" : hash

  let isBase64 = false
  if (mediaType[mediaType.length - 1] === "base64") {
    mediaType.pop()
    isBase64 = true
  }

  // Lowercase MIME type
  const mimeType = mediaType.shift()?.toLowerCase() ?? ""
  const attributes = mediaType
    .map((attribute: string) => {
      let [key, value = ""] = attribute.split("=").map((s: string) => s.trim())

      // Lowercase `charset`
      if (key === "charset") {
        value = value.toLowerCase()

        if (value === DATA_URL_DEFAULT_CHARSET) {
          return ""
        }
      }

      return `${key}${value ? `=${value}` : ""}`
    })
    .filter(Boolean)

  const normalizedMediaType = [...attributes]

  if (isBase64) {
    normalizedMediaType.push("base64")
  }

  if (normalizedMediaType.length > 0 || (mimeType && mimeType !== DATA_URL_DEFAULT_MIME_TYPE)) {
    normalizedMediaType.unshift(mimeType)
  }

  return `data:${normalizedMediaType.join(";")},${isBase64 ? data.trim() : data}${hash ? `#${hash}` : ""}`
}

summary:
A function that normalizes data URLs by processing and standardizing their components. It takes a data URL string and an options object with a stripHash property. The function parses the data URL, normalizes its media type, handles base64 encoding, and returns a properly formatted data URL string.

details:
The implementation:
1. Uses regex to extract the components of a data URL (type, data, and hash)
2. Throws an error if the URL format is invalid
3. Processes the media type by splitting it into components
4. Handles the hash part based on the stripHash option
5. Detects and handles base64 encoding
6. Normalizes the MIME type by lowercasing it
7. Processes media type attributes, with special handling for charset
8. Reconstructs the normalized media type with proper formatting
9. Assembles and returns the normalized data URL with all components

=========================
workspace: packages/lib
file: packages/lib/src/normalize-url/index.ts
lines: 353:593
id: 3cb9ab796181970c6a4938647fee54166c7a3b937843a8f7cbf2c39086ad6ec4
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/normalize-url/index.ts#L353

declaration:
export default function normalizeUrl(urlString: string, opts?: Options): string

summary:
Normalizes a URL by applying various transformations to standardize its format. The function accepts a URL string and an optional options object to customize the normalization process. It handles various URL types including http, https, file, and data URLs. The function can modify protocols, remove authentication, strip hashes, normalize paths, remove query parameters, and perform many other URL transformations based on the provided options.

details:
The implementation works by:

1. Merging default options with user-provided options
2. Handling special cases:
   - Data URLs are processed by the `normalizeDataURL` helper function
   - URLs with custom protocols are passed through unchanged
3. Performing a series of transformations on the URL:
   - Prepending default protocol if needed
   - Converting between http/https based on options
   - Removing authentication credentials if requested
   - Handling hash fragments and text fragments
   - Normalizing pathname by removing duplicate slashes
   - Decoding URI components
   - Removing directory index files
   - Removing www subdomain
   - Filtering query parameters based on options
   - Sorting query parameters
   - Handling trailing slashes
   - Removing explicit port numbers

The function uses the built-in URL API for parsing and manipulating URLs, with special handling for relative URLs and protocol-relative URLs. It includes careful handling of edge cases and maintains compatibility with older JavaScript engines by avoiding features like negative lookbehind.

related: Options

code:
export default function normalizeUrl(urlString: string, opts?: Options): string {
  const options = {
    defaultProtocol: "http",
    normalizeProtocol: true,
    forceHttp: false,
    forceHttps: false,
    stripAuthentication: true,
    stripHash: false,
    stripTextFragment: true,
    stripWWW: true,
    removeQueryParameters: [/^utm_\w+/i],
    removeTrailingSlash: true,
    removeSingleSlash: true,
    removeDirectoryIndex: false,
    removeExplicitPort: false,
    sortQueryParameters: true,
    ...opts,
  }

  // Legacy: Append `:` to the protocol if missing.
  if (typeof options.defaultProtocol === "string" && !options.defaultProtocol.endsWith(":")) {
    options.defaultProtocol = `${options.defaultProtocol}:`
  }

  urlString = urlString.trim()

  // Data URL
  if (/^data:/i.test(urlString)) {
    return normalizeDataURL(urlString, options)
  }

  if (hasCustomProtocol(urlString)) {
    return urlString
  }

  const hasRelativeProtocol = urlString.startsWith("//")
  const isRelativeUrl = !hasRelativeProtocol && /^\.*\//.test(urlString)

  // Prepend protocol
  if (!isRelativeUrl) {
    urlString = urlString.replace(/^(?!(?:\w+:)?\/\/)|^\/\//, options.defaultProtocol)
  }

  const urlObject = new URL(urlString)

  if (options.forceHttp && options.forceHttps) {
    throw new Error("The `forceHttp` and `forceHttps` options cannot be used together")
  }

  if (options.forceHttp && urlObject.protocol === "https:") {
    urlObject.protocol = "http:"
  }

  if (options.forceHttps && urlObject.protocol === "http:") {
    urlObject.protocol = "https:"
  }

  // Remove auth
  if (options.stripAuthentication) {
    urlObject.username = ""
    urlObject.password = ""
  }

  // Remove hash
  if (options.stripHash) {
    urlObject.hash = ""
  } else if (options.stripTextFragment) {
    urlObject.hash = urlObject.hash.replace(/#?:~:text.*?$/i, "")
  }

  // Remove duplicate slashes if not preceded by a protocol
  // NOTE: This could be implemented using a single negative lookbehind
  // regex, but we avoid that to maintain compatibility with older js engines
  // which do not have support for that feature.
  if (urlObject.pathname) {
    // TODO: Replace everything below with `urlObject.pathname = urlObject.pathname.replace(/(?<!\b[a-z][a-z\d+\-.]{1,50}:)\/{2,}/g, '/');` when Safari supports negative lookbehind.

    // Split the string by occurrences of this protocol regex, and perform
    // duplicate-slash replacement on the strings between those occurrences
    // (if any).
    const protocolRegex = /\b[a-z][a-z\d+\-.]{1,50}:\/\//g

    let lastIndex = 0
    let result = ""
    for (;;) {
      const match = protocolRegex.exec(urlObject.pathname)
      if (!match) {
        break
      }

      const protocol = match[0]
      const protocolAtIndex = match.index
      const intermediate = urlObject.pathname.slice(lastIndex, protocolAtIndex)

      result += intermediate.replace(/\/{2,}/g, "/")
      result += protocol
      lastIndex = protocolAtIndex + protocol.length
    }

    const remnant = urlObject.pathname.slice(lastIndex, urlObject.pathname.length)
    result += remnant.replace(/\/{2,}/g, "/")

    urlObject.pathname = result
  }

  // Decode URI octets
  if (urlObject.pathname) {
    try {
      urlObject.pathname = decodeURI(urlObject.pathname)
    } catch {}
  }

  // Remove directory index
  if (options.removeDirectoryIndex === true) {
    options.removeDirectoryIndex = [/^index\.[a-z]+$/]
  }

  if (Array.isArray(options.removeDirectoryIndex) && options.removeDirectoryIndex.length > 0) {
    let pathComponents = urlObject.pathname.split("/")
    const lastComponent = pathComponents[pathComponents.length - 1]

    if (testParameter(lastComponent, options.removeDirectoryIndex)) {
      pathComponents = pathComponents.slice(0, -1)
      urlObject.pathname = pathComponents.slice(1).join("/") + "/"
    }
  }

  if (urlObject.hostname) {
    // Remove trailing dot
    urlObject.hostname = urlObject.hostname.replace(/\.$/, "")

    // Remove `www.`
    if (
      options.stripWWW &&
      /^www\.(?!www\.)[a-z\-\d]{1,63}\.[a-z.\-\d]{2,63}$/.test(urlObject.hostname)
    ) {
      // Each label should be max 63 at length (min: 1).
      // Source: https://en.wikipedia.org/wiki/Hostname#Restrictions_on_valid_host_names
      // Each TLD should be up to 63 characters long (min: 2).
      // It is technically possible to have a single character TLD, but none currently exist.
      urlObject.hostname = urlObject.hostname.replace(/^www\./, "")
    }
  }

  // Remove query unwanted parameters
  if (Array.isArray(options.removeQueryParameters)) {
    // @ts-ignore
    for (const key of [...urlObject.searchParams.keys()]) {
      if (testParameter(key, options.removeQueryParameters)) {
        urlObject.searchParams.delete(key)
      }
    }
  }

  if (!Array.isArray(options.keepQueryParameters) && options.removeQueryParameters === true) {
    urlObject.search = ""
  }

  // Keep wanted query parameters
  if (Array.isArray(options.keepQueryParameters) && options.keepQueryParameters.length > 0) {
    // @ts-ignore
    for (const key of [...urlObject.searchParams.keys()]) {
      if (!testParameter(key, options.keepQueryParameters)) {
        urlObject.searchParams.delete(key)
      }
    }
  }

  // Sort query parameters
  if (options.sortQueryParameters) {
    urlObject.searchParams.sort()

    // Calling `.sort()` encodes the search parameters, so we need to decode them again.
    try {
      urlObject.search = decodeURIComponent(urlObject.search)
    } catch {}
  }

  if (options.removeTrailingSlash) {
    urlObject.pathname = urlObject.pathname.replace(/\/$/, "")
  }

  // Remove an explicit port number, excluding a default port number, if applicable
  if (options.removeExplicitPort && urlObject.port) {
    urlObject.port = ""
  }

  const oldUrlString = urlString

  // Take advantage of many of the Node `url` normalizations
  urlString = urlObject.toString()

  if (
    !options.removeSingleSlash &&
    urlObject.pathname === "/" &&
    !oldUrlString.endsWith("/") &&
    urlObject.hash === ""
  ) {
    urlString = urlString.replace(/\/$/, "")
  }

  // Remove ending `/` unless removeSingleSlash is false
  if (
    (options.removeTrailingSlash || urlObject.pathname === "/") &&
    urlObject.hash === "" &&
    options.removeSingleSlash
  ) {
    urlString = urlString.replace(/\/$/, "")
  }

  // Restore relative protocol, if applicable
  if (hasRelativeProtocol && !options.normalizeProtocol) {
    urlString = urlString.replace(/^http:\/\//, "//")
  }

  // Remove http/https
  if (options.stripProtocol) {
    urlString = urlString.replace(/^(?:https?:)?\/\//, "")
  }

  return urlString
}

import/access examples:
import default from '@welshman/lib/normalize-url';
import { normalizeUrl } from '@welshman/lib';


=========================
type: file
workspace: packages/lib
path: packages/lib/__tests__/Deferred.test.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/__tests__/Deferred.test.ts
summary: This test file validates the functionality of the Deferred module, which provides two main utilities: `makePromise` and `defer`. These utilities help with creating and managing promises with explicit resolve and reject capabilities. The tests verify that both functions properly handle resolution, rejection, async operations, and promise chaining while maintaining type safety.

details: The test suite is organized into two main sections:

1. `makePromise` tests:
   - Tests creation of promises that resolve with success data
   - Tests creation of promises that reject with error data
   - Verifies handling of async operations using setTimeout
   - Confirms proper error propagation in promise chains

2. `defer` tests:
   - Tests creating deferred promises that can be resolved/rejected externally
   - Verifies both async (setTimeout) and immediate resolution/rejection
   - Tests promise chaining with transformations (.then/.catch)
   - Confirms error propagation through promise chains
   - Validates type safety with default error types

The tests use TypeScript interfaces (SuccessResponse and ErrorResponse) to validate the type safety of the deferred promises, ensuring the utilities maintain proper typing throughout promise operations.

=========================
type: dir
workspace: packages/lib
path: packages/lib/__tests__/
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/__tests__/
summary: The __tests__ directory contains test files for various utility modules in the project. It includes tests for Deferred (promise utilities with explicit resolve/reject capabilities), Emitter, LRUCache, and general Tools. The tests validate core functionality, edge cases, and type safety of these utility modules, suggesting this is a collection of tests for fundamental helper classes and functions used throughout the project.

=========================
type: file
workspace: packages/lib
path: packages/lib/src/Deferred.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Deferred.ts
summary: This file provides utilities for working with promises that have strongly typed errors. It exports three main components: `CustomPromise<T, E>` type that extends Promise with typed error information, `makePromise<T, E>()` function to create such promises, and `defer<T, E>()` function that creates a Deferred promise with exposed resolve/reject methods.

details: The implementation is straightforward:
1. `CustomPromise<T, E>` adds a phantom type property `__errorType` to Promise to track error types at compile time
2. `makePromise()` creates a standard Promise but casts it to the CustomPromise type
3. `defer()` creates a promise while capturing the resolve/reject functions from the executor, then exposes these functions by attaching them to the promise object using Object.assign()
4. The implementation uses type assertions to maintain type safety while working with the underlying Promise API

=========================
type: file
workspace: packages/lib
path: packages/lib/src/Emitter.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Emitter.ts
summary: The file exports the `Emitter` class, which extends Node.js's `EventEmitter` with enhanced functionality. The key feature is that it automatically emits all events to wildcard ('*') listeners in addition to specific event type listeners, allowing for global event monitoring.

details: The implementation is straightforward:
1. The `Emitter` class extends the standard Node.js `EventEmitter`
2. It overrides the `emit` method to:
   - First emit the event to specific listeners using the parent implementation
   - Then emit the same event to wildcard ('*') listeners, passing the event type as the first argument
   - Return true only if both emissions had listeners (logical AND of both results)
3. The wildcard emission allows code to listen to all events by subscribing to the '*' event type

=========================
type: file
workspace: packages/lib
path: packages/lib/src/LRUCache.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/LRUCache.ts
summary: The file exports an LRU (Least Recently Used) cache implementation with three main exports: 1) `LRUCache` class for generic key-value caching with size limits, 2) `cached` function that creates memoized functions with LRU caching behavior, and 3) `simpleCache` function that provides a simplified interface for function memoization with default settings.

details: The implementation consists of:

1. `LRUCache<T, U>` class that uses a Map for storage and an array to track key access order. It maintains its size by removing least recently used items when the cache exceeds its maximum size. The class provides methods for checking existence (`has`), retrieving (`get`), storing (`set`), and retrieving-then-removing (`pop`) cache entries.

2. `cached` function that creates a memoized function with configurable key generation, value computation, and cache size. It returns a function with attached properties including the cache instance and methods for key/value generation.

3. `simpleCache` function that wraps `cached` with sensible defaults (max size of 100,000 and key generation by joining arguments with colons).

The LRU implementation has a potential optimization issue where it only trims the keys array when it grows to twice the maximum size, which could lead to memory inefficiency for large caches.

=========================
type: file
workspace: packages/lib
path: packages/lib/src/TaskQueue.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/TaskQueue.ts
summary: The TaskQueue class provides a mechanism for processing items in batches. It allows pushing items to a queue, processing them according to a specified batch size, subscribing to item processing events, and controlling the queue's execution with pause/resume functionality. The queue processes items asynchronously and handles errors gracefully.

details: Implementation details:
1. The TaskQueue maintains an internal array of items and a list of subscribers.
2. The queue has state flags (isPaused, isProcessing) to control its execution flow.
3. When items are pushed, the process() method is automatically triggered if not already running.
4. The process() method:
   - Checks if processing should occur based on state flags and queue content
   - Processes items in batches defined by options.batchSize
   - Notifies all subscribers for each item before processing
   - Uses yieldThread() to prevent blocking the main thread
   - Handles errors for individual items without stopping the queue
   - Recursively calls itself if more items remain after processing
5. The queue provides control methods (stop, start, clear) to manage execution state.
6. The remove() method uses an external utility function to filter out specific items.

=========================
type: file
workspace: packages/lib
path: packages/lib/src/Tools.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/Tools.ts
summary: The Tools.ts file provides a comprehensive utility library with functions for working with nil values, types, functional programming, numbers, timestamps, sequences, objects, combinators, randomness, async operations, URLs, JSON, localStorage, fetch, event emitters, strings, collections, sets, maps, and various encoding formats. It exports numerous helper functions that simplify common programming tasks, handle edge cases, and provide functional programming patterns for TypeScript applications.

details: This utility library is organized into distinct sections, each focusing on a specific category of helper functions:

1. Nil handling - Functions like `isNil`, `isNotNil` for safely working with null/undefined values

2. Type utilities - Type helpers like `Override` and `MakeOptional` for type manipulation

3. Functional programming - Basic utilities like `noop`, `identity`, `always`, `not`, and a comprehensive `equals` function for deep equality comparison

4. Number operations - Functions for arithmetic (`add`, `sub`, `mul`, `div`), comparisons (`lt`, `gt`), and array operations (`max`, `min`, `sum`, `avg`)

5. Time utilities - Constants for time periods (MINUTE, HOUR, DAY), timestamp functions, and date formatting

6. Sequence operations - Array manipulation functions like `first`, `last`, `drop`, `take`, `concat`, `union`, `intersection`, `difference`, etc.

7. Object manipulation - Functions like `pick`, `omit`, `mapKeys`, `mapVals`, `mergeLeft`, `deepMergeRight`

8. Functional combinators - Higher-order functions like `complement`, `tryCatch`, `once`, `memoize`

9. Async utilities - Functions like `sleep`, `poll`, `throttle`, `batch`, `batcher`, `race`

10. Encoding utilities - Functions for working with bech32, hex, and binary data

The implementation uses modern JavaScript/TypeScript features and follows functional programming principles with pure functions, immutability, and composability. Many functions include TypeScript generics for type safety.

=========================
type: file
workspace: packages/lib
path: packages/lib/src/normalize-url/index.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/normalize-url/index.ts
summary: This module exports a function `normalizeUrl` that normalizes URLs according to various options. It handles different URL formats including data URLs, custom protocols, and relative URLs. The function accepts a URL string and an optional configuration object with properties like `defaultProtocol`, `forceHttp`, `stripAuthentication`, `removeQueryParameters`, and many others that control how the URL is normalized.

details: The implementation includes:

1. A comprehensive Options type definition with detailed documentation for each option
2. Helper functions for handling special cases:
   - `testParameter` to check if a parameter matches filters
   - `hasCustomProtocol` to detect non-standard protocols
   - `normalizeDataURL` for normalizing data URLs
3. The main `normalizeUrl` function that:
   - Applies default options
   - Handles different URL types (data URLs, custom protocols, relative URLs)
   - Uses the URL API for parsing and manipulation
   - Performs various normalization steps based on options:
     - Protocol normalization
     - Authentication removal
     - Hash and text fragment handling
     - Duplicate slash removal
     - Directory index removal
     - Query parameter filtering and sorting
     - Trailing slash handling
     - Port number normalization
   - Special handling for edge cases and compatibility

=========================
type: dir
workspace: packages/lib
path: packages/lib/src/normalize-url/
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/normalize-url/
summary: The normalize-url module provides URL standardization functionality through its main export `normalizeUrl`. This function handles various URL protocols (http, https, file, data) and offers extensive customization options for modifying URL components such as protocol, authentication, hash, query parameters, and trailing slashes. The module is designed to standardize URLs while preserving their functionality, with special handling for data URLs and custom protocols.

=========================
type: dir
workspace: packages/lib
path: packages/lib/src/
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/src/
summary: The `src` directory contains a collection of utility modules that provide foundational functionality for TypeScript applications. It exports several key utilities: `Deferred` for creating promises with typed errors, `Emitter` for enhanced event handling, `LRUCache` for caching with LRU eviction, `TaskQueue` for batch processing of items, and an extensive `Tools` module with numerous helper functions for common programming tasks. The directory also includes a `normalize-url` module for URL standardization. Together, these utilities form a comprehensive toolkit for handling asynchronous operations, events, caching, task management, and various data transformations in a type-safe manner.

=========================
type: dir
workspace: packages/lib
path: packages/lib/
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/lib/
summary: This directory contains a collection of TypeScript utility modules that provide foundational functionality for applications. The main exports include `Deferred` for enhanced promise handling with explicit resolve/reject capabilities, `Emitter` for event management, `LRUCache` for caching with least-recently-used eviction policy, `TaskQueue` for batch processing, and a comprehensive `Tools` module with various helper functions. It also includes a `normalize-url` utility. These utilities are thoroughly tested with corresponding test files in the `__tests__` directory, ensuring reliability and type safety. The package serves as a toolkit for handling common programming tasks including asynchronous operations, events, caching, and data transformations in a type-safe manner.

=========================
type: file
workspace: packages/net
file: packages/net/package.json
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/package.json
include: always
{
  "name": "@welshman/net",
  "version": "0.4.6",
  "author": "hodlbod",
  "license": "MIT",
  "description": "Utilities for connecting with nostr relays.",
  "publishConfig": {
    "access": "public"
  },
  "type": "module",
  "main": "dist/net/src/index.js",
  "types": "dist/net/src/index.d.ts",
  "files": [
    "dist"
  ],
  "scripts": {
    "build": "pnpm run clean && pnpm run compile --force",
    "clean": "rimraf ./dist",
    "compile": "tsc -b tsconfig.build.json",
    "prepublishOnly": "pnpm run build"
  },
  "dependencies": {
    "@welshman/lib": "workspace:*",
    "@welshman/relay": "workspace:*",
    "@welshman/util": "workspace:*",
    "events": "^3.3.0",
    "isomorphic-ws": "^5.0.0"
  },
  "devDependencies": {
    "rimraf": "~6.0.0",
    "typescript": "~5.8.0"
  }
}


=========================
type: file
workspace: packages/net
file: packages/net/tsconfig.json
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/tsconfig.json
include: always
{
  "extends": "../../tsconfig.json"
}


=========================
workspace: packages/net
file: packages/net/src/tracker.ts
lines: 3:85
id: fdb7d0a89fc8a120b64ca8a6a07d7f4190b1d3265bdedf577444dd9b7ff1ac11
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/tracker.ts#L3

declaration:
export class Tracker extends Emitter{
  relaysById: Map<string, Set<string>>;
  idsByRelay: Map<string, Set<string>>;
  constructor();
  getIds: (relay: string) => Set<string>;
  getRelays: (eventId: string) => Set<string>;
  hasRelay: (eventId: string, relay: string) => boolean | undefined;
  addRelay: (eventId: string, relay: string) => void;
  removeRelay: (eventId: string, relay: string) => void;
  track: (eventId: string, relay: string) => boolean;
  copy: (eventId1: string, eventId2: string) => void;
  load: (relaysById: Map<string, Set<string>>) => void;
  clear: () => void;
}

summary:
The `Tracker` class extends `Emitter` and provides functionality to track relationships between event IDs and relays. It maintains bidirectional mappings between event IDs and relays, allowing efficient lookup in either direction. The class emits events when relationships are added, removed, loaded, or cleared. Methods include getting relays for an event ID, getting event IDs for a relay, checking if a relationship exists, adding/removing relationships, tracking events, copying relationships between events, loading data, and clearing all data.

details:
Implementation details:

1. The class maintains two primary data structures:
   - `relaysById`: A Map that stores sets of relay strings keyed by event IDs
   - `idsByRelay`: A Map that stores sets of event IDs keyed by relay strings

2. These dual maps provide efficient bidirectional lookup between events and relays.

3. The constructor increases the maximum number of event listeners to 100.

4. Most methods emit events when they modify the data structures:
   - "add" when a relationship is added
   - "remove" when a relationship is removed
   - "load" when data is loaded
   - "clear" when data is cleared

5. The `track` method combines checking if an event has been seen before with adding a new relay relationship.

6. The `copy` method transfers all relay relationships from one event ID to another.

7. The `load` method uses the `addToMapKey` utility function from an external library to rebuild both maps from input data.

code:
export class Tracker extends Emitter {
  relaysById = new Map<string, Set<string>>()
  idsByRelay = new Map<string, Set<string>>()

  constructor() {
    super()

    this.setMaxListeners(100)
  }

  getIds = (relay: string) => this.idsByRelay.get(relay) || new Set<string>()

  getRelays = (eventId: string) => this.relaysById.get(eventId) || new Set<string>()

  hasRelay = (eventId: string, relay: string) => this.relaysById.get(eventId)?.has(relay)

  addRelay = (eventId: string, relay: string) => {
    let relays = this.relaysById.get(eventId)
    let ids = this.idsByRelay.get(relay)

    if (relays?.has(relay) && ids?.has(eventId)) return

    if (!relays) {
      relays = new Set()
    }

    if (!ids) {
      ids = new Set()
    }

    relays.add(relay)
    ids.add(eventId)

    this.relaysById.set(eventId, relays)
    this.idsByRelay.set(relay, ids)

    this.emit("add", eventId, relay)
  }

  removeRelay = (eventId: string, relay: string) => {
    const didDeleteRelay = this.relaysById.get(eventId)?.delete(relay)
    const didDeleteId = this.idsByRelay.get(relay)?.delete(eventId)

    if (!didDeleteRelay && !didDeleteId) return

    this.emit("remove", eventId, relay)
  }

  track = (eventId: string, relay: string) => {
    const seen = this.relaysById.has(eventId)

    this.addRelay(eventId, relay)

    return seen
  }

  copy = (eventId1: string, eventId2: string) => {
    for (const relay of this.getRelays(eventId1)) {
      this.addRelay(eventId2, relay)
    }
  }

  load = (relaysById: Tracker["relaysById"]) => {
    this.relaysById.clear()
    this.idsByRelay.clear()

    for (const [id, relays] of relaysById.entries()) {
      for (const relay of relays) {
        addToMapKey(this.relaysById, id, relay)
        addToMapKey(this.idsByRelay, relay, id)
      }
    }

    this.emit("load")
  }

  clear = () => {
    this.relaysById.clear()
    this.idsByRelay.clear()

    this.emit("clear")
  }
}

import/access examples:
import { Tracker } from '@welshman/net';
import { Tracker } from '@welshman/net/tracker';


=========================
workspace: packages/net
file: packages/net/src/message.ts
lines: 5:13
id: fe24427ee8d53946c368c285a886d8f1f5de800829fb3765ddb02fe60f11d3bb
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/message.ts#L5

declaration:
export enum RelayMessageType {
  Auth = "AUTH",
  Closed = "CLOSED",
  Eose = "EOSE",
  Event = "EVENT",
  NegErr = "NEG-ERR",
  NegMsg = "NEG-MSG",
  Ok = "OK",
}

summary:
The `RelayMessageType` enum defines the message types that can be sent from a relay to a client in a communication protocol. It includes message types for authentication (`Auth`), connection closure (`Closed`), end of stored events (`Eose`), event delivery (`Event`), negotiation errors (`NegErr`), negotiation messages (`NegMsg`), and operation acknowledgment (`Ok`).

details:
This enum is part of a typed messaging system for relay-client communication, likely in a pub/sub or event-based architecture. Each enum value is a string literal that matches the protocol's message type identifiers. The enum is used as discriminators in union types to create type-safe message handling throughout the application. It works together with corresponding payload types and type guard functions defined elsewhere in the file.

import/access examples:
import { RelayMessageType } from '@welshman/net';
import { RelayMessageType } from '@welshman/net/message';


=========================
workspace: packages/net
file: packages/net/src/message.ts
lines: 15:15
id: 44ea9412336b4275035d64120d5033dde124c7e71a716803a6250b200d73ccb2
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/message.ts#L15

declaration:
export type RelayMessage = any[]

summary:
A type alias representing messages sent from a relay to a client. It's defined as an array of any type (`any[]`), serving as a base type for various specific relay message formats like `RelayAuth`, `RelayEvent`, etc. This type is used as a common denominator for all relay-to-client communication patterns.

details:
This type is part of a messaging system between relays and clients, where messages are represented as arrays. The first element of the array typically contains a message type (from `RelayMessageType` enum), and subsequent elements contain payload data specific to that message type. The `RelayMessage` type serves as a generic container that can be type-narrowed to specific message types using type guard functions like `isRelayAuth`, `isRelayEvent`, etc.

import/access examples:
import type { RelayMessage } from '@welshman/net';
import type { RelayMessage } from '@welshman/net/message';


=========================
workspace: packages/net
file: packages/net/src/message.ts
lines: 17:17
id: 58b4aaf66d9f86fccc6186932a41539af711dc8dfc14b8e007219883757f53cb
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/message.ts#L17

declaration:
export type RelayAuthPayload = [string]

summary:
RelayAuthPayload is a type alias representing the payload structure for authentication messages sent from a relay to a client. It is defined as a tuple containing a single string element, which typically represents the authentication challenge or token.

details:
This type is part of the relay-to-client message protocol implementation. It's used in conjunction with the RelayMessageType.Auth enum value to form complete RelayAuth messages. The payload's single string parameter likely contains authentication-related information such as a challenge string that the client would need to respond to in order to authenticate with the relay.

import/access examples:
import type { RelayAuthPayload } from '@welshman/net';
import type { RelayAuthPayload } from '@welshman/net/message';


=========================
workspace: packages/net
file: packages/net/src/message.ts
lines: 19:19
id: 75e993d42c0fa6d92a3c1c671c14d3c59410eca4564ea40e9242f06f0ad94e8b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/message.ts#L19

declaration:
export type RelayClosedPayload = [string, string]

summary:
A type alias representing the payload structure for a 'CLOSED' message sent from a relay to a client. It consists of a tuple with two string elements, likely representing a subscription ID and a reason for closure.

details:
This type is part of the relay-to-client message protocol. The payload is structured as a fixed-length tuple of two strings: [string, string]. The first string likely represents the subscription identifier that was closed, while the second string provides the reason or explanation for why the connection was closed.

import/access examples:
import type { RelayClosedPayload } from '@welshman/net';
import type { RelayClosedPayload } from '@welshman/net/message';


=========================
workspace: packages/net
file: packages/net/src/message.ts
lines: 21:21
id: 2d1325f862dc2b289160a395ade73d45efd80e7c83d084f2fc08f72f8d49bb93
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/message.ts#L21

declaration:
export type RelayEosePayload = [string]

summary:
RelayEosePayload is a type alias representing the payload structure for an End of Stored Events (EOSE) message sent from a relay to a client. It is defined as a tuple containing a single string element, which typically represents a subscription ID.

details:
This type is part of the relay-to-client message protocol. The single string in the tuple is used to identify which subscription the EOSE message relates to, allowing clients to know when a relay has finished sending all stored events matching a particular subscription request.

import/access examples:
import type { RelayEosePayload } from '@welshman/net';
import type { RelayEosePayload } from '@welshman/net/message';


=========================
workspace: packages/net
file: packages/net/src/message.ts
lines: 23:23
id: 0bb46bcd1bbde57dbd777873bd51ecc71a6f555dfae8714585e6f27f0d33243a
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/message.ts#L23

declaration:
export type RelayEventPayload = [string, SignedEvent]

summary:
RelayEventPayload is a type alias that defines the payload structure for relay event messages. It is a tuple containing a string (subscription ID) followed by a SignedEvent object. This type is used in the relay-to-client communication protocol to deliver events that match a client's subscription.

details:
This type is part of a larger message protocol system that defines the communication format between relays and clients. The first element in the tuple is typically a subscription identifier string that allows clients to match received events with their corresponding subscriptions. The second element is a SignedEvent object which contains the actual event data. This type is used as a component of the RelayEvent type which combines the message type enum with this payload.

import/access examples:
import type { RelayEventPayload } from '@welshman/net';
import type { RelayEventPayload } from '@welshman/net/message';


=========================
workspace: packages/net
file: packages/net/src/message.ts
lines: 25:25
id: edad75a7e232e00df49595fc1829f9df573e2523b110bb7100352a87847cac3a
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/message.ts#L25

declaration:
export type RelayNegErrPayload = [string, string]

summary:
A type alias representing the payload structure for a relay negotiation error message. It's defined as a tuple containing two string elements, typically representing an error identifier and an error message.

details:
This type is part of a message protocol system for relay-client communication. The `RelayNegErrPayload` specifically defines the structure for error messages during negotiation processes. It's used in conjunction with the `RelayMessageType.NegErr` enum value to form complete `RelayNegErr` messages.

import/access examples:
import type { RelayNegErrPayload } from '@welshman/net';
import type { RelayNegErrPayload } from '@welshman/net/message';


=========================
workspace: packages/net
file: packages/net/src/message.ts
lines: 27:27
id: 316112d6a250b2d974474d76587dbcee43b740e964d0be4381b604f9dec9f075
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/message.ts#L27

declaration:
export type RelayNegMsgPayload = [string, string]

summary:
RelayNegMsgPayload is a type alias that represents the payload structure for a relay negotiation message. It is defined as a tuple containing two string elements, typically used for communication between a relay server and client in a negotiation context.

details:
This type is part of the relay message system in the application. It's structured as a tuple type [string, string], where the strings likely represent a message identifier and the actual negotiation message content. It's used in conjunction with the RelayMessageType.NegMsg enum value to form complete RelayNegMsg messages ([RelayMessageType.NegMsg, ...RelayNegMsgPayload]). This type is exported from both the message module and the main index, indicating it's part of the public API.

import/access examples:
import type { RelayNegMsgPayload } from '@welshman/net';
import type { RelayNegMsgPayload } from '@welshman/net/message';


=========================
workspace: packages/net
file: packages/net/src/message.ts
lines: 29:29
id: b3997ee5d6b987ac6c6378ecdf2ae14ff063debef18662cf7736910810eb942d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/message.ts#L29

declaration:
export type RelayOkPayload = [string, boolean, string]

summary:
RelayOkPayload is a type alias that defines the payload structure for a relay OK message. It is represented as a tuple containing three elements: a string (subscription ID), a boolean (success indicator), and a string (message or reason).

details:
This type is part of the relay-to-client message protocol. The RelayOkPayload is used in conjunction with the RelayMessageType.Ok enum value to form a complete RelayOk message. The payload contains:
1. A string that typically represents the subscription ID that the OK response is related to
2. A boolean indicating success or failure of the operation
3. A string providing additional information or reason for the response

import/access examples:
import type { RelayOkPayload } from '@welshman/net';
import type { RelayOkPayload } from '@welshman/net/message';


=========================
workspace: packages/net
file: packages/net/src/message.ts
lines: 31:31
id: a346ce14425860a516de43270742a6dd021895947f13a538a602979f60c238cf
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/message.ts#L31

declaration:
export type RelayAuth = [RelayMessageType.Auth, ...RelayAuthPayload]

summary:
A type representing an authentication message sent from a relay to a client. It consists of a tuple where the first element is the RelayMessageType.Auth enum value, followed by the RelayAuthPayload which contains a string.

details:
This type is part of the relay-to-client message protocol. It structures authentication messages in a specific format where:
1. The first element identifies the message type as Auth
2. The remaining elements (spread from RelayAuthPayload) contain a single string parameter, likely an authentication token or challenge

related: Auth,RelayAuthPayload

import/access examples:
import type { RelayAuth } from '@welshman/net';
import type { RelayAuth } from '@welshman/net/message';


=========================
workspace: packages/net
file: packages/net/src/message.ts
lines: 33:33
id: 7ce85590c8b462a8a516c5c88414c9acaf3c7754e68bfcccafebb161c28d658c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/message.ts#L33

declaration:
export type RelayClosed = [RelayMessageType.Closed, ...RelayClosedPayload]

summary:
A type representing a CLOSED message sent from a relay to a client. It's structured as a tuple where the first element is the RelayMessageType.Closed enum value, followed by the payload which consists of two string parameters.

details:
This type is part of the relay-to-client message protocol. The RelayClosed type is a tuple with the following structure:
[RelayMessageType.Closed, string, string]

The first element identifies this as a CLOSED message type, while the remaining elements represent the payload (RelayClosedPayload) which contains two string parameters, likely representing a subscription ID and a reason for closing.

related: Closed,RelayClosedPayload

import/access examples:
import type { RelayClosed } from '@welshman/net';
import type { RelayClosed } from '@welshman/net/message';


=========================
workspace: packages/net
file: packages/net/src/message.ts
lines: 35:35
id: 1a2bc2a48d7dec18d11309333682f6a2d097a361cd555e54b137c982a6cb53d8
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/message.ts#L35

declaration:
export type RelayEose = [RelayMessageType.Eose, ...RelayEosePayload]

summary:
A type alias representing an End of Stored Events (EOSE) message sent from a relay to a client. It's structured as a tuple where the first element is the RelayMessageType.Eose enum value, followed by the RelayEosePayload which contains a subscription ID string.

details:
This type is part of a protocol implementation for relay-client communication. The RelayEose type combines the message type identifier (RelayMessageType.Eose) with the payload structure (RelayEosePayload). The payload contains a single string which represents the subscription ID that the EOSE message is related to. This message signals to the client that all stored events matching a particular subscription have been sent.

related: Eose,RelayEosePayload

import/access examples:
import type { RelayEose } from '@welshman/net';
import type { RelayEose } from '@welshman/net/message';


=========================
workspace: packages/net
file: packages/net/src/message.ts
lines: 37:37
id: daa6f78c20c3c343ebf315db6fbc1e754ab53d0d3995dcc615dbfc679a0e2fea
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/message.ts#L37

declaration:
export type RelayEvent = [RelayMessageType.Event, ...RelayEventPayload]

summary:
A type representing an EVENT message sent from a relay to a client. It follows the structure of [RelayMessageType.Event, subscriptionId, signedEvent], where subscriptionId is a string identifier for the subscription and signedEvent is a signed event object from the @welshman/util package.

details:
This type is part of the relay-to-client message protocol implementation. It's structured as a tuple with a specific format:

1. The first element is always RelayMessageType.Event ("EVENT" string literal)
2. The remaining elements follow the RelayEventPayload structure, which consists of:
   - A subscription ID string
   - A SignedEvent object

This type is used to type-check messages received from relays and ensure they conform to the expected EVENT message format.

related: Event,RelayEventPayload

import/access examples:
import type { RelayEvent } from '@welshman/net';
import type { RelayEvent } from '@welshman/net/message';


=========================
workspace: packages/net
file: packages/net/src/message.ts
lines: 39:39
id: 19d4ed6a3e7d7a827fa67df725443cf46a1dff34307527d4493b27e61a18fb47
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/message.ts#L39

declaration:
export type RelayNegErr = [RelayMessageType.NegErr, ...RelayNegErrPayload]

summary:
A type representing a negative error message from a relay to a client. It's structured as a tuple where the first element is the message type identifier (`RelayMessageType.NegErr`) followed by the payload elements defined in `RelayNegErrPayload`, which consists of two string parameters.

details:
This type is part of a messaging protocol between relays and clients. The `RelayNegErr` type is constructed as a tuple with a specific structure:

1. The first element is always `RelayMessageType.NegErr` which identifies the message type
2. The remaining elements are from `RelayNegErrPayload` which contains two strings (likely an identifier and an error message)

This type is used in conjunction with the type guard function `isRelayNegErr()` to safely determine if a message is of this specific type.

related: NegErr,RelayNegErrPayload

import/access examples:
import type { RelayNegErr } from '@welshman/net';
import type { RelayNegErr } from '@welshman/net/message';


=========================
workspace: packages/net
file: packages/net/src/message.ts
lines: 41:41
id: bc984d4c5b6cb4f50359f7b8e1916c5c319daddce41519ff68cfcbaf4b85b66e
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/message.ts#L41

declaration:
export type RelayNegMsg = [RelayMessageType.NegMsg, ...RelayNegMsgPayload]

summary:
A type representing a negotiation message from a relay to a client. It follows the format [RelayMessageType.NegMsg, ...RelayNegMsgPayload], where RelayMessageType.NegMsg is the message type identifier and RelayNegMsgPayload contains a string subscription ID and a string message.

details:
This type is part of a protocol implementation for relay-client communication. It structures a negotiation message sent from a relay to a client as a tuple with a specific format. The first element is always the message type identifier (RelayMessageType.NegMsg), followed by the payload elements defined in RelayNegMsgPayload, which consists of two strings: likely a subscription identifier and the actual message content. This type helps ensure type safety when handling relay negotiation messages in the application.

related: NegMsg,RelayNegMsgPayload

import/access examples:
import type { RelayNegMsg } from '@welshman/net';
import type { RelayNegMsg } from '@welshman/net/message';


=========================
workspace: packages/net
file: packages/net/src/message.ts
lines: 43:43
id: 30128a1faff6f2288635a2fef2267ace9580511e857948b3a9932366399a79b0
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/message.ts#L43

declaration:
export type RelayOk = [RelayMessageType.Ok, ...RelayOkPayload]

summary:
A type representing an 'OK' message sent from a relay to a client. It follows the format [RelayMessageType.Ok, ...RelayOkPayload] where RelayOkPayload is a tuple containing a string, a boolean, and a string. This message type is typically used to acknowledge receipt of a client message and indicate whether it was successfully processed.

details:
This type is part of the relay-to-client message protocol. The RelayOk type is structured as a tuple where:
1. The first element is the message type identifier (RelayMessageType.Ok)
2. The remaining elements come from RelayOkPayload which contains:
   - A string (likely a subscription ID or event ID)
   - A boolean (success/failure indicator)
   - A string (likely an error message or additional information)

The type is used in conjunction with the isRelayOk type guard function (line 57) to safely identify and process OK messages from relays.

related: Ok,RelayOkPayload

import/access examples:
import type { RelayOk } from '@welshman/net';
import type { RelayOk } from '@welshman/net/message';


=========================
workspace: packages/net
file: packages/net/src/message.ts
lines: 45:45
id: c8f1d40fc36591b5e56e648942e683b6cb628f97fe6f1bef6b652e7da1f35482
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/message.ts#L45

declaration:
isRelayAuth = (m: RelayMessage): m is RelayAuth => m[0] === RelayMessageType.Auth

summary:
A type guard function that checks if a given relay message is of type 'AUTH'. It takes a RelayMessage parameter and returns a boolean indicating whether the message is a RelayAuth message type.

details:
This function implements a TypeScript type guard pattern that narrows the type of the input parameter 'm' from the general RelayMessage type to the more specific RelayAuth type when the condition is true. It works by checking if the first element of the array (m[0]) equals RelayMessageType.Auth. The function uses the 'is' type predicate syntax to inform TypeScript's type system about this type narrowing.

related: RelayMessageType,Auth,RelayMessage

import/access examples:
import { isRelayAuth } from '@welshman/net';
import { isRelayAuth } from '@welshman/net/message';


=========================
workspace: packages/net
file: packages/net/src/message.ts
lines: 47:47
id: 97f6baa78d5efd0072b09ec16807c80ba6f175eb554a4d43f21c2a36b293f971
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/message.ts#L47

declaration:
isRelayClosed = (m: RelayMessage): m is RelayClosed => m[0] === RelayMessageType.Closed

summary:
A type guard function that checks if a given relay message is of type 'CLOSED'. It takes a RelayMessage parameter and returns a boolean indicating whether the message is a RelayClosed message type.

details:
The implementation is a simple arrow function that checks if the first element of the message array (m[0]) equals the RelayMessageType.Closed enum value. This is a TypeScript type predicate function (using the 'is' keyword) which helps with type narrowing - when this function returns true, TypeScript will know that the message is specifically of the RelayClosed type.

related: RelayMessageType,Closed,RelayMessage

import/access examples:
import { isRelayClosed } from '@welshman/net';
import { isRelayClosed } from '@welshman/net/message';


=========================
workspace: packages/net
file: packages/net/src/message.ts
lines: 49:49
id: 90cb5f1fc88952f55ee622215f6f2975ce8c188a7d6c969570a2f527967c10fa
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/message.ts#L49

declaration:
isRelayEose = (m: RelayMessage): m is RelayEose => m[0] === RelayMessageType.Eose

summary:
A type guard function that checks if a given relay message is of type 'EOSE' (End of Stored Events). It takes a RelayMessage parameter and returns a boolean indicating whether the message is a RelayEose type.

details:
This function implements a simple type guard pattern in TypeScript. It checks if the first element of the array message (m[0]) equals the RelayMessageType.Eose enum value. If true, TypeScript will narrow the type of the message to RelayEose in the scope where this function is used with a conditional check. The implementation is straightforward with no side effects or complex logic.

related: RelayMessageType,Eose,RelayMessage

import/access examples:
import { isRelayEose } from '@welshman/net';
import { isRelayEose } from '@welshman/net/message';


=========================
workspace: packages/net
file: packages/net/src/message.ts
lines: 51:51
id: d1f8c0ffeebb30dd6139467e43d55ff9a5ede045006d2c2c964236ef038493bf
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/message.ts#L51

declaration:
isRelayEvent = (m: RelayMessage): m is RelayEvent => m[0] === RelayMessageType.Event

summary:
A type guard function that checks if a given relay message is of type 'EVENT'. It takes a RelayMessage parameter and returns a boolean indicating whether the message is a RelayEvent type. This function helps with type narrowing in TypeScript.

details:
The implementation is straightforward - it checks if the first element of the array message (m[0]) equals the RelayMessageType.Event enum value. This is a simple type predicate function that allows TypeScript to narrow the type of a variable from the more general RelayMessage type to the more specific RelayEvent type when used in conditional statements.

related: RelayMessageType,Event,RelayMessage

import/access examples:
import { isRelayEvent } from '@welshman/net';
import { isRelayEvent } from '@welshman/net/message';


=========================
workspace: packages/net
file: packages/net/src/message.ts
lines: 53:53
id: c9a2f20f4784b9667f21d503920531b8e01b06e300ab53f149d6567e62d0611d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/message.ts#L53

declaration:
isRelayNegErr = (m: RelayMessage): m is RelayNegErr => m[0] === RelayMessageType.NegErr

summary:
A type guard function that checks if a given relay message is of type 'NEG-ERR'. It takes a RelayMessage parameter and returns a boolean indicating whether the message is a RelayNegErr type.

details:
This function implements a TypeScript type guard pattern that narrows the type of the input parameter 'm' from the general RelayMessage type to the more specific RelayNegErr type when the function returns true.

The implementation is straightforward - it checks if the first element of the array (m[0]) equals RelayMessageType.NegErr. If true, TypeScript will treat the message as a RelayNegErr in the scope where this function is used with a conditional check.

related: RelayMessageType,NegErr,RelayMessage

import/access examples:
import { isRelayNegErr } from '@welshman/net';
import { isRelayNegErr } from '@welshman/net/message';


=========================
workspace: packages/net
file: packages/net/src/message.ts
lines: 55:55
id: 6ef8506e184f277a3ef9ec239ee811efc73dd7a2e1c2fa23ae768c22f90adae5
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/message.ts#L55

declaration:
isRelayNegMsg = (m: RelayMessage): m is RelayNegMsg => m[0] === RelayMessageType.NegMsg

summary:
A type guard function that checks if a given relay message is of type 'NEG-MSG'. It takes a RelayMessage parameter and returns a boolean indicating whether the message is a RelayNegMsg type.

details:
This function implements a simple type guard pattern in TypeScript. It examines the first element of the array message (m[0]) and checks if it equals RelayMessageType.NegMsg (which is the string "NEG-MSG"). The function uses TypeScript's type predicate syntax (m is RelayNegMsg) to narrow the type of the parameter within conditional blocks when the function returns true.

related: RelayMessageType,NegMsg,RelayMessage

import/access examples:
import { isRelayNegMsg } from '@welshman/net';
import { isRelayNegMsg } from '@welshman/net/message';


=========================
workspace: packages/net
file: packages/net/src/message.ts
lines: 57:57
id: 05c67d9dd635969a7e703d3f78625a7c108d4f69b95cefba1fcfed4aa3827c59
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/message.ts#L57

declaration:
isRelayOk = (m: RelayMessage): m is RelayOk => m[0] === RelayMessageType.Ok

summary:
A type guard function that checks if a given relay message is of type 'OK'. It takes a RelayMessage parameter and returns a boolean indicating whether the message is a RelayOk type.

details:
The implementation is a simple arrow function that checks if the first element of the message array (m[0]) equals the RelayMessageType.Ok enum value. This is a TypeScript type predicate function (m is RelayOk) that helps with type narrowing when used in conditional statements.

related: RelayMessageType,Ok,RelayMessage

import/access examples:
import { isRelayOk } from '@welshman/net';
import { isRelayOk } from '@welshman/net/message';


=========================
workspace: packages/net
file: packages/net/src/message.ts
lines: 61:68
id: f2d0205c03dd1f0a1deb64b7b731cb3a6edde2cb471827db8db97378518e1788
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/message.ts#L61

declaration:
export enum ClientMessageType {
  Auth = "AUTH",
  Close = "CLOSE",
  Event = "EVENT",
  NegClose = "NEG-CLOSE",
  NegOpen = "NEG-OPEN",
  Req = "REQ",
}

summary:
An enumeration that defines the types of messages a client can send to a relay in a Nostr protocol implementation. The enum includes values for authentication (AUTH), closing a subscription (CLOSE), sending an event (EVENT), negotiation closing (NEG-CLOSE), negotiation opening (NEG-OPEN), and requesting data (REQ).

details:
This enum is part of a type system for handling client-to-relay communication in what appears to be a Nostr protocol implementation. It works together with corresponding payload types and type guards defined elsewhere in the file. Each enum value represents a specific message type that follows the Nostr protocol specification, where messages are typically formatted as arrays with the message type as the first element followed by payload data.

import/access examples:
import { ClientMessageType } from '@welshman/net';
import { ClientMessageType } from '@welshman/net/message';


=========================
workspace: packages/net
file: packages/net/src/message.ts
lines: 70:70
id: 08ad2018ad10f16f1a9dfd61e554375fa78e7e522e525f239b52d16a081cd3d5
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/message.ts#L70

declaration:
export type ClientMessage = any[]

summary:
ClientMessage is a type alias representing messages sent from a client to a relay in a communication protocol. It's defined as an array of any type (any[]), serving as a base type for various specific client message formats like authentication, event publishing, and subscription requests.

details:
This type is part of a messaging protocol implementation that appears to follow the Nostr protocol or a similar relay-based communication system. It serves as the parent type for more specific client message types (ClientAuth, ClientClose, ClientEvent, etc.) which are defined later in the file. The implementation uses type guards (isClientAuth, isClientClose, etc.) to safely determine the specific message type at runtime by checking the first element of the array against values in the ClientMessageType enum.

import/access examples:
import type { ClientMessage } from '@welshman/net';
import type { ClientMessage } from '@welshman/net/message';


=========================
workspace: packages/net
file: packages/net/src/message.ts
lines: 72:72
id: aa26917710266cb1a2cef876edf35fa0ab0fdac32c0b104864a5b1a120b9c28f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/message.ts#L72

declaration:
export type ClientAuthPayload = [string]

summary:
ClientAuthPayload is a type alias representing the payload structure for client authentication messages sent from a client to a relay. It is defined as a tuple containing a single string element, which typically represents the authentication token or challenge response.

details:
This type is part of the client-to-relay messaging system in the protocol. It's used in conjunction with ClientAuth type to form complete authentication messages. The single string parameter in the tuple likely contains authentication credentials or a response to an authentication challenge from the relay. This type is exported and can be imported from both the message module and the main index.

import/access examples:
import type { ClientAuthPayload } from '@welshman/net';
import type { ClientAuthPayload } from '@welshman/net/message';


=========================
workspace: packages/net
file: packages/net/src/message.ts
lines: 74:74
id: 422b98adc07abd63d371cdfef2c7b841d50644b48f7a28a1c9b53b5c3819cec4
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/message.ts#L74

declaration:
export type ClientClosePayload = [string]

summary:
A type alias representing the payload for a client close message in a relay communication protocol. It is defined as a tuple containing a single string element, which typically represents a subscription identifier that the client wants to close.

details:
This type is part of the client-to-relay messaging system. It's used to structure the payload portion of a CLOSE message that a client sends to a relay when it wants to terminate a specific subscription. The string parameter is usually a subscription ID that was previously used in a REQ message.

import/access examples:
import type { ClientClosePayload } from '@welshman/net';
import type { ClientClosePayload } from '@welshman/net/message';


=========================
workspace: packages/net
file: packages/net/src/message.ts
lines: 76:76
id: 3c07833e950a56c50b40a378ce982cb252a2213738dce9d4396641ccc7364d2f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/message.ts#L76

declaration:
export type ClientEventPayload = [SignedEvent]

summary:
ClientEventPayload is a type alias that represents the payload structure for client event messages sent from a client to a relay. It is defined as a tuple containing a single SignedEvent element, which represents a signed event to be published to the relay.

details:
This type is part of a message protocol implementation for client-relay communication. It specifically defines the payload format for EVENT messages that clients send to relays. The payload consists of just the SignedEvent object, which would contain the event data along with cryptographic signatures. This type is used in conjunction with ClientMessageType.Event to form the complete ClientEvent message structure ([ClientMessageType.Event, ...ClientEventPayload]).

import/access examples:
import type { ClientEventPayload } from '@welshman/net';
import type { ClientEventPayload } from '@welshman/net/message';


=========================
workspace: packages/net
file: packages/net/src/message.ts
lines: 78:78
id: 6e92e864218b7e015fe0e976f490d78f7f0dbc3b9e6edea0da7d087a649ce8f9
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/message.ts#L78

declaration:
export type ClientNegClosePayload = [string]

summary:
A type alias representing the payload for a client-to-relay negotiation close message. It consists of a tuple with a single string element, which typically represents the subscription ID that is being closed.

details:
This type is part of the client-to-relay message protocol implementation. It defines the structure for the payload of a NEG-CLOSE message that a client sends to a relay when it wants to close a negotiated connection. The single string parameter in the tuple is used to identify which specific subscription should be closed.

import/access examples:
import type { ClientNegClosePayload } from '@welshman/net';
import type { ClientNegClosePayload } from '@welshman/net/message';


=========================
workspace: packages/net
file: packages/net/src/message.ts
lines: 80:80
id: 013715e8881059f58dbde442a41cdadbe295ff27c9684cddaf7b0aa239dcd701
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/message.ts#L80

declaration:
export type ClientNegOpenPayload = [string, Filter, string]

summary:
A type alias representing the payload structure for a client's negotiation open message. It is defined as a tuple with three elements: a string identifier, a Filter object, and another string parameter.

details:
This type alias defines the structure for the payload of a NEG-OPEN message sent from a client to a relay in what appears to be a Nostr protocol implementation. The payload consists of:
1. A string that likely serves as a subscription identifier
2. A Filter object (imported from @welshman/util) that defines what events the client wants to receive
3. A string that might represent additional negotiation parameters or metadata

This type is used as part of the ClientNegOpen message type defined later in the file.

import/access examples:
import type { ClientNegOpenPayload } from '@welshman/net';
import type { ClientNegOpenPayload } from '@welshman/net/message';


=========================
workspace: packages/net
file: packages/net/src/message.ts
lines: 82:82
id: aa6405a4a8d4c564f46dc6d86f5909da0b919cb4f161ee2d42a513895731217d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/message.ts#L82

declaration:
export type ClientReqPayload = [string, Filter]

summary:
ClientReqPayload is a type alias that represents the payload structure for client request messages sent to a relay. It is defined as a tuple containing a subscription identifier string and a Filter object, which specifies the criteria for the data being requested.

details:
This type is part of the client-to-relay messaging system in the application. The payload consists of two elements:
1. A string that serves as a subscription identifier
2. A Filter object (imported from @welshman/util) that defines the filtering criteria for the request

This type is used in the ClientReq type (line 94) which combines the request message type (REQ) with this payload to form a complete client request message.

import/access examples:
import type { ClientReqPayload } from '@welshman/net';
import type { ClientReqPayload } from '@welshman/net/message';


=========================
workspace: packages/net
file: packages/net/src/message.ts
lines: 84:84
id: 14ed2680c79261fe6d7c2ed91bb8b1e084b481ee08cd9537fd81d02bfe48317b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/message.ts#L84

declaration:
export type ClientAuth = [ClientMessageType.Auth, ...ClientAuthPayload]

summary:
A type representing an authentication message sent from a client to a relay in a Nostr protocol implementation. It follows the format of [ClientMessageType.Auth, ...ClientAuthPayload] where ClientAuthPayload is a tuple containing a single string parameter.

details:
This type is part of a message typing system for client-relay communication in what appears to be a Nostr protocol implementation. The ClientAuth type is structured as a tuple where:
1. The first element is always ClientMessageType.Auth (string literal "AUTH")
2. The remaining elements are spread from ClientAuthPayload, which is defined as [string] - a tuple with a single string parameter

The type is used with the isClientAuth type guard function to safely determine if a message is an authentication message from client to relay.

related: Auth,ClientAuthPayload

import/access examples:
import type { ClientAuth } from '@welshman/net';
import type { ClientAuth } from '@welshman/net/message';


=========================
workspace: packages/net
file: packages/net/src/message.ts
lines: 86:86
id: 7d975b199a659975b5c6dd885b7e6eaa1b4cfed78174b7786f0b186e078de545
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/message.ts#L86

declaration:
export type ClientClose = [ClientMessageType.Close, ...ClientClosePayload]

summary:
A type representing a client-to-relay CLOSE message in the protocol. It's structured as a tuple where the first element is the ClientMessageType.Close enum value, followed by the ClientClosePayload which contains a subscription ID string.

details:
This type is part of the client-to-relay messaging protocol implementation. It defines the structure of a CLOSE message that a client sends to a relay when it wants to terminate a subscription. The message consists of:
1. The message type identifier (ClientMessageType.Close)
2. A string parameter representing the subscription ID that should be closed

The type leverages TypeScript's tuple and spread operator syntax to ensure proper message structure.

related: Close,ClientClosePayload

import/access examples:
import type { ClientClose } from '@welshman/net';
import type { ClientClose } from '@welshman/net/message';


=========================
workspace: packages/net
file: packages/net/src/message.ts
lines: 88:88
id: b8ac6a1e75eaed240ab0bbee3ecd26ef399ec78f42fa4d520f8daaa535ca5ca3
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/message.ts#L88

declaration:
export type ClientEvent = [ClientMessageType.Event, ...ClientEventPayload]

summary:
A type representing a client-to-relay EVENT message in the protocol. It's structured as a tuple where the first element is the ClientMessageType.Event enum value, followed by the ClientEventPayload which contains a SignedEvent.

details:
This type is part of the client-to-relay messaging protocol implementation. It follows a specific format where:
1. The first element is the message type identifier (ClientMessageType.Event)
2. The rest of the elements are spread from ClientEventPayload, which is defined as [SignedEvent]

This means a complete ClientEvent message would look like: ['EVENT', signedEventObject]

related: Event,ClientEventPayload

import/access examples:
import type { ClientEvent } from '@welshman/net';
import type { ClientEvent } from '@welshman/net/message';


=========================
workspace: packages/net
file: packages/net/src/message.ts
lines: 90:90
id: 45717e06cbff8e94cc7e51f61070a84c9b8fd8d8cab2d7006d48c4db6c6fc5ac
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/message.ts#L90

declaration:
export type ClientNegClose = [ClientMessageType.NegClose, ...ClientNegClosePayload]

summary:
A type representing a client-to-relay message for closing a negotiation channel. It follows the format [ClientMessageType.NegClose, string], where the string parameter is the negotiation channel identifier.

details:
This type is part of the client-to-relay messaging protocol. It structures messages for closing a negotiation channel with a specific format:

1. The first element is the message type constant `ClientMessageType.NegClose`
2. The second element is a string representing the negotiation channel identifier

The type leverages TypeScript's tuple type with spread operator to ensure the correct structure of the message.

related: NegClose,ClientNegClosePayload

import/access examples:
import type { ClientNegClose } from '@welshman/net';
import type { ClientNegClose } from '@welshman/net/message';


=========================
workspace: packages/net
file: packages/net/src/message.ts
lines: 92:92
id: 552c7ed640f46780d51b6df3e5e284921aa206759ca736a6d325df8adcd630f8
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/message.ts#L92

declaration:
export type ClientNegOpen = [ClientMessageType.NegOpen, ...ClientNegOpenPayload]

summary:
A type alias representing a client-to-relay negotiation open message in the protocol. It follows the format [ClientMessageType.NegOpen, string, Filter, string], where the first element is the message type identifier, followed by the payload consisting of a string identifier, a Filter object, and another string parameter.

details:
This type is part of the client-to-relay messaging protocol implementation. It combines the message type enum value (NegOpen) with the payload type (ClientNegOpenPayload). The structure uses TypeScript's tuple type with spread operator to ensure the correct format of the message array. It's used in conjunction with the isClientNegOpen type guard function to safely identify and process these messages in the application.

related: NegOpen,ClientNegOpenPayload

import/access examples:
import type { ClientNegOpen } from '@welshman/net';
import type { ClientNegOpen } from '@welshman/net/message';


=========================
workspace: packages/net
file: packages/net/src/message.ts
lines: 94:94
id: 00cccbd4a6e91acb6b46da9c3caaf3d3d387424d571d190bfe0bce09e746847f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/message.ts#L94

declaration:
export type ClientReq = [ClientMessageType.Req, ...ClientReqPayload]

summary:
A type alias representing a client request message sent to a relay in a specific format. It follows the structure of [ClientMessageType.Req, ...ClientReqPayload], where ClientReqPayload is a tuple containing a string identifier and a Filter object. This type is used for requesting specific data from a relay server.

details:
This type is part of a messaging protocol implementation between clients and relays. The ClientReq type is structured as a tuple where:
1. The first element is always ClientMessageType.Req (which is the string "REQ")
2. The remaining elements follow the ClientReqPayload format, which consists of:
   - A string identifier (subscription ID)
   - A Filter object (imported from @welshman/util) that specifies what data is being requested

This type works together with the isClientReq type guard function that checks if a message conforms to this format.

related: Req,ClientReqPayload

import/access examples:
import type { ClientReq } from '@welshman/net';
import type { ClientReq } from '@welshman/net/message';


=========================
workspace: packages/net
file: packages/net/src/message.ts
lines: 96:96
id: ef055f03255d5750acff188cd4d22f180b97dc92dfc223caaba128078befe513
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/message.ts#L96

declaration:
isClientAuth = (m: ClientMessage): m is ClientAuth => m[0] === ClientMessageType.Auth

summary:
A type guard function that checks if a given client message is an authentication message. It returns true if the message is of type ClientAuth, which is determined by checking if the first element of the message array is ClientMessageType.Auth.

details:
This function implements a simple type guard pattern in TypeScript. It takes a ClientMessage parameter (which is defined as any[]) and checks if the first element (m[0]) matches the ClientMessageType.Auth enum value. If it does, TypeScript will narrow the type of the message to ClientAuth in the scope where this function returns true. The implementation is a straightforward one-line arrow function using a strict equality check.

related: ClientMessageType,Auth,ClientMessage

import/access examples:
import { isClientAuth } from '@welshman/net';
import { isClientAuth } from '@welshman/net/message';


=========================
workspace: packages/net
file: packages/net/src/message.ts
lines: 98:99
id: dfd783054cf7792e1baec8d77f2c40feb376615363e6f84e207d478115544f6f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/message.ts#L98

declaration:
isClientClose = (m: ClientMessage): m is ClientClose =>
  m[0] === ClientMessageType.Close

summary:
A type guard function that checks if a given client message is of type 'CLOSE'. It takes a ClientMessage parameter and returns a boolean indicating whether the message is a ClientClose message type.

details:
This function implements a TypeScript type guard pattern that narrows the type of the input parameter 'm' from the general ClientMessage type to the more specific ClientClose type when the condition is true. It works by checking if the first element of the message array (m[0]) equals the ClientMessageType.Close enum value. When this function returns true, TypeScript will treat the message as having the ClientClose type in the narrowed scope.

related: ClientMessageType,Close,ClientMessage

import/access examples:
import { isClientClose } from '@welshman/net';
import { isClientClose } from '@welshman/net/message';


=========================
workspace: packages/net
file: packages/net/src/message.ts
lines: 101:102
id: 0ae22feb42cb8d6cdc5b9ab0c5fb4e79f4d35d2a438861d6c76b26123252617c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/message.ts#L101

declaration:
isClientEvent = (m: ClientMessage): m is ClientEvent =>
  m[0] === ClientMessageType.Event

summary:
A type guard function that checks if a given client message is of type 'EVENT'. It takes a ClientMessage parameter and returns a boolean indicating whether the message is a ClientEvent type.

details:
This function implements a TypeScript type guard pattern that narrows the type of the input parameter 'm' from the generic ClientMessage type to the more specific ClientEvent type when the condition is true. It works by checking if the first element of the message array (m[0]) equals the ClientMessageType.Event enum value. This is a simple implementation that relies on the array structure of client messages where the first element always indicates the message type.

related: ClientMessageType,Event,ClientMessage

import/access examples:
import { isClientEvent } from '@welshman/net';
import { isClientEvent } from '@welshman/net/message';


=========================
workspace: packages/net
file: packages/net/src/message.ts
lines: 104:105
id: 12f769c8a0594b9634a552dbcf10995ac1a6cb32d586eb3eba768b9e264c08aa
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/message.ts#L104

declaration:
isClientNegClose = (m: ClientMessage): m is ClientNegClose =>
  m[0] === ClientMessageType.NegClose

summary:
A type guard function that checks if a given client message is of type 'NEG-CLOSE'. It takes a ClientMessage parameter and returns a boolean indicating whether the message is a ClientNegClose message type.

details:
The implementation is straightforward - it checks if the first element of the message array (m[0]) equals the ClientMessageType.NegClose enum value. This is a simple type predicate function that helps with TypeScript type narrowing, allowing the compiler to know that if this function returns true, the message can be safely treated as a ClientNegClose type.

related: ClientMessageType,NegClose,ClientMessage

import/access examples:
import { isClientNegClose } from '@welshman/net';
import { isClientNegClose } from '@welshman/net/message';


=========================
workspace: packages/net
file: packages/net/src/message.ts
lines: 107:108
id: 86065dd3cf7653a6d1793a1ed107de236e82ea6f1fea5dc1be6d9bda93e89bec
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/message.ts#L107

declaration:
isClientNegOpen = (m: ClientMessage): m is ClientNegOpen =>
  m[0] === ClientMessageType.NegOpen

summary:
A type guard function that checks if a given client message is of type ClientNegOpen. It returns true if the message's first element matches the ClientMessageType.NegOpen enum value.

details:
This function implements a simple type guard pattern for TypeScript. It takes a ClientMessage parameter and checks if the first element (m[0]) equals ClientMessageType.NegOpen. If true, TypeScript will narrow the type of the message to ClientNegOpen in the scope where this function is used with a conditional check. The implementation is a one-line arrow function using a strict equality comparison.

related: ClientMessageType,NegOpen,ClientMessage

import/access examples:
import { isClientNegOpen } from '@welshman/net';
import { isClientNegOpen } from '@welshman/net/message';


=========================
workspace: packages/net
file: packages/net/src/message.ts
lines: 110:110
id: daaa3ea1270756bca81f798803590827ea0fd9b21fe0c498734a6b8337e392d8
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/message.ts#L110

declaration:
isClientReq = (m: ClientMessage): m is ClientReq => m[0] === ClientMessageType.Req

summary:
A type guard function that checks if a given client message is of type 'REQ'. It takes a ClientMessage parameter and returns a boolean indicating whether the message is a ClientReq type, which is used for subscription requests from client to relay.

details:
This function implements a simple type guard that examines the first element of the provided message array to determine if it matches the ClientMessageType.Req enum value. If it does, TypeScript will narrow the type of the message to ClientReq in the scope where this function returns true. The implementation is a straightforward comparison between the message's first element (m[0]) and the Req value from ClientMessageType enum.

related: ClientMessageType,Req,ClientMessage

import/access examples:
import { isClientReq } from '@welshman/net';
import { isClientReq } from '@welshman/net/message';


=========================
workspace: packages/net
file: packages/net/src/util.ts
lines: 1:1
id: 5d9f413c9491c9e53ca4ec2356e379e74970143d6770094586b914b0e79accef
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/util.ts#L1

declaration:
export type Unsubscriber = () => void

summary:
A type alias representing a function that can be called to unsubscribe from an event or subscription. The function takes no parameters and returns nothing (void).

import/access examples:
import type { Unsubscriber } from '@welshman/net/util';


=========================
workspace: packages/net
file: packages/net/src/auth.ts
lines: 9:17
id: 9737e9275d5a4fdefca1bb85f99a2d2414554172d46c30c5e31f33c439e92420
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/auth.ts#L9

declaration:
export enum AuthStatus {
  None = "auth:status:none",
  Requested = "auth:status:requested",
  PendingSignature = "auth:status:pending_signature",
  DeniedSignature = "auth:status:denied_signature",
  PendingResponse = "auth:status:pending_response",
  Forbidden = "auth:status:forbidden",
  Ok = "auth:status:ok",
}

summary:
An enumeration representing the various authentication states in a relay connection. It defines the following states: None (initial state), Requested (relay has requested authentication), PendingSignature (waiting for user to sign), DeniedSignature (user denied signing), PendingResponse (waiting for relay response), Forbidden (authentication rejected), and Ok (authentication successful).

details:
This enum is used to track the authentication flow state within the AuthState class. Each state is represented by a string value with a 'auth:status:' prefix followed by a descriptive name. The states follow a logical progression through the authentication process, from initial state to final authenticated or rejected states. These status values help coordinate the authentication flow and are emitted as events to notify subscribers about state changes.

import/access examples:
import { AuthStatus } from '@welshman/net';
import { AuthStatus } from '@welshman/net/auth';


=========================
workspace: packages/net
file: packages/net/src/auth.ts
lines: 19:22
id: 5268e0a864b6eed6873c93817a402e179941c07394d2dfb7e84fab015a68a65e
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/auth.ts#L19

declaration:
export type AuthResult = {
  ok: boolean
  reason?: string
}

summary:
AuthResult is a type that represents the outcome of an authentication process. It contains a boolean 'ok' field indicating whether authentication was successful, and an optional 'reason' string field that can provide additional information about why authentication failed when 'ok' is false.

details:
This is a simple type definition that serves as a data structure for authentication results. It doesn't contain implementation logic itself but is used to standardize the format of authentication responses throughout the application.

import/access examples:
import type { AuthResult } from '@welshman/net';
import type { AuthResult } from '@welshman/net/auth';


=========================
workspace: packages/net
file: packages/net/src/auth.ts
lines: 24:26
id: 12049fbcbc6d7be2dc6a1c869300e4078dcd8842c14c50372ae7138f2b7d2d27
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/auth.ts#L24

declaration:
export enum AuthStateEvent {
  Status = "auth:event:status",
}

summary:
The `AuthStateEvent` enum defines the event types that can be emitted by the `AuthState` class. Currently, it contains a single event type: `Status`, which is emitted when the authentication status changes.

details:
This enum is part of the event system used in the authentication state management. It works with the `AuthStateEvents` type (defined right after it) to provide type-safe event handling. The `Status` event (with value "auth:event:status") is emitted whenever the authentication status changes, allowing subscribers to react to authentication state transitions.

import/access examples:
import { AuthStateEvent } from '@welshman/net';
import { AuthStateEvent } from '@welshman/net/auth';


=========================
workspace: packages/net
file: packages/net/src/auth.ts
lines: 28:30
id: ddb7653891b6a7d313004ce1824b8921f8d45d09a7ced953795bb45ceda0ae7e
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/auth.ts#L28

declaration:
export type AuthStateEvents = {
  [AuthStateEvent.Status]: (status: AuthStatus) => void
}

summary:
A type definition that maps authentication state events to their handler functions. Currently, it only includes a mapping for the `Status` event, which is triggered when the authentication status changes. The handler function for this event receives the new `AuthStatus` as its parameter.

details:
This type is used to define the event structure for the `AuthState` class's event emitter functionality. It creates a typed interface for the events that can be emitted by the `AuthState` class, ensuring type safety when subscribing to these events. The implementation uses an index signature with the `AuthStateEvent` enum as keys and function signatures as values.

related: AuthStatus

import/access examples:
import type { AuthStateEvents } from '@welshman/net';
import type { AuthStateEvents } from '@welshman/net/auth';


=========================
workspace: packages/net
file: packages/net/src/auth.ts
lines: 32:32
id: 990efd11d6455a0523a2695f93a1ee91689211476e789403caf5bf44e1480dc0
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/auth.ts#L32

declaration:
type Sign = (event: StampedEvent) => Promise<SignedEvent>

summary:
A type alias representing a function that signs a stamped event. The function takes a `StampedEvent` as input and returns a Promise that resolves to a `SignedEvent`.

=========================
workspace: packages/net
file: packages/net/src/auth.ts
lines: 34:150
id: a91241e86f755825226e2d1ebd37154268acbb00dedcfad6ee7389fb86c14a73
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/auth.ts#L34

declaration:
export class AuthState extends EventEmitter{
  challenge: string | undefined;
  request: string | undefined;
  details: string | undefined;
  status: AuthStatus;
  _unsubscribers: Unsubscriber[];
  constructor(readonly socket: Socket);
  setStatus(status: AuthStatus);
  async doAuth(sign: Sign);
  async attemptAuth(sign: Sign);
  async retryAuth(sign: Sign);
  cleanup();
}

summary:
AuthState is a class that manages the authentication state for a WebSocket connection. It extends EventEmitter to provide event-based status updates. The class handles the NIP-42 authentication flow, tracking the current authentication status, managing challenges from relays, and coordinating the signing and submission of authentication events. It provides methods to initiate authentication (attemptAuth), retry authentication (retryAuth), and clean up resources (cleanup).

details:
The implementation maintains the authentication state machine through several key components:

1. Internal state tracking via properties:
   - challenge: stores the current auth challenge from the relay
   - request: stores the ID of the sent auth event
   - details: stores additional information from the relay response
   - status: tracks the current AuthStatus enum value

2. Socket event listeners (set up in constructor):
   - Listens for incoming relay AUTH messages to capture challenges
   - Monitors outgoing AUTH messages to update status
   - Watches socket status to reset auth state when connection closes

3. Authentication flow methods:
   - doAuth: Creates and sends the authentication event using the provided signing function
   - attemptAuth: Orchestrates the full auth flow with timeouts
   - retryAuth: Resets state and attempts authentication again

The implementation uses polling with timeouts to wait for state transitions and handles error cases like missing challenges or attempting authentication in invalid states. The class properly cleans up event listeners through the _unsubscribers array.

related: AuthStatus,None,Requested,PendingSignature,DeniedSignature,PendingResponse,Forbidden,Ok,Unsubscriber,Socket

code:
export class AuthState extends EventEmitter {
  challenge: string | undefined
  request: string | undefined
  details: string | undefined
  status = AuthStatus.None
  _unsubscribers: Unsubscriber[] = []

  constructor(readonly socket: Socket) {
    super()

    this._unsubscribers.push(
      on(socket, SocketEvent.Receive, (message: RelayMessage) => {
        if (isRelayOk(message)) {
          const [_, id, ok, details] = message

          if (id === this.request) {
            this.details = details

            if (ok) {
              this.setStatus(AuthStatus.Ok)
            } else {
              this.setStatus(AuthStatus.Forbidden)
            }
          }
        }

        if (isRelayAuth(message)) {
          const [_, challenge] = message

          // Sometimes relays send the same challenge multiple times, no need to
          // respond to it twice
          if (challenge !== this.challenge) {
            this.challenge = challenge
            this.request = undefined
            this.details = undefined
            this.setStatus(AuthStatus.Requested)
          }
        }
      }),
      on(socket, SocketEvent.Sending, (message: RelayMessage) => {
        if (isClientAuth(message)) {
          this.setStatus(AuthStatus.PendingResponse)
        }
      }),
      on(socket, SocketEvent.Status, (status: SocketStatus) => {
        if (status === SocketStatus.Closed || status === SocketStatus.Error) {
          this.challenge = undefined
          this.request = undefined
          this.details = undefined
          this.setStatus(AuthStatus.None)
        }
      }),
    )
  }

  setStatus(status: AuthStatus) {
    this.status = status
    this.emit(AuthStateEvent.Status, status)
  }

  async doAuth(sign: Sign) {
    if (!this.challenge) {
      throw new Error("Attempted to authenticate with no challenge")
    }

    if (this.status !== AuthStatus.Requested) {
      throw new Error(`Attempted to authenticate when auth is already ${this.status}`)
    }

    this.setStatus(AuthStatus.PendingSignature)

    const template = makeRelayAuth(this.socket.url, this.challenge)
    const event = await tryCatch(() => sign(template))

    if (event) {
      this.request = event.id
      this.socket.send(["AUTH", event])
    } else {
      this.setStatus(AuthStatus.DeniedSignature)
    }
  }

  async attemptAuth(sign: Sign) {
    this.socket.attemptToOpen()

    if (![AuthStatus.Forbidden, AuthStatus.Ok].includes(this.status)) {
      await poll({
        signal: AbortSignal.timeout(800),
        condition: () => this.status === AuthStatus.Requested,
      })

      if (this.status === AuthStatus.Requested) {
        await this.doAuth(sign)
      }

      await poll({
        signal: AbortSignal.timeout(800),
        condition: () => this.status !== AuthStatus.PendingResponse,
      })
    }
  }

  async retryAuth(sign: Sign) {
    if (this.challenge) {
      this.request = undefined
      this.details = undefined
      this.setStatus(AuthStatus.Requested)
    }

    await this.attemptAuth(sign)
  }

  cleanup() {
    this.removeAllListeners()
    this._unsubscribers.forEach(call)
  }
}

import/access examples:
import { AuthState } from '@welshman/net';
import { AuthState } from '@welshman/net/auth';


=========================
workspace: packages/net
file: packages/net/src/socket.ts
lines: 7:13
id: ccad373f857d41b5001efea090f8f8143d3ec4d910be796777defa22478b7489
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/socket.ts#L7

declaration:
export enum SocketStatus {
  Open = "socket:status:open",
  Opening = "socket:status:opening",
  Closing = "socket:status:closing",
  Closed = "socket:status:closed",
  Error = "socket:status:error",
}

summary:
An enumeration that represents the various states of a WebSocket connection. It defines five possible states: Open, Opening, Closing, Closed, and Error. These states are used to track and communicate the current status of a socket connection throughout the application.

details:
This enum uses string values with a consistent naming pattern ('socket:status:X') that likely helps with event handling and debugging. The enum is exported and used within the Socket class to maintain the current connection state and emit status change events. It appears to be part of a larger WebSocket management system that handles connection lifecycle events.

import/access examples:
import { SocketStatus } from '@welshman/net';
import { SocketStatus } from '@welshman/net/socket';


=========================
workspace: packages/net
file: packages/net/src/socket.ts
lines: 15:22
id: 345be9e44fde767f9261f2024faff9152709138e08963c3817d73f19a8979e40
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/socket.ts#L15

declaration:
export enum SocketEvent {
  Error = "socket:event:error",
  Status = "socket:event:status",
  Send = "socket:event:send",
  Sending = "socket:event:sending",
  Receive = "socket:event:receive",
  Receiving = "socket:event:receiving",
}

summary:
An enumeration that defines various socket event types for a WebSocket-based communication system. These events represent different states and actions in the socket lifecycle, including error handling, status changes, and message transmission. The enum includes: Error, Status, Send, Sending, Receive, and Receiving events, each with a unique string identifier prefixed with 'socket:event:'.

details:
This enum is part of a WebSocket communication framework and works in conjunction with the Socket class and SocketEvents type. Each enum value serves as an event name in the EventEmitter pattern implemented by the Socket class. The naming convention follows 'socket:event:' prefix followed by the specific event type. These events are used to track and respond to different stages of socket communication:

1. Error - emitted when socket errors occur
2. Status - emitted when socket status changes
3. Send - emitted after a message is sent
4. Sending - emitted before a message is sent
5. Receive - emitted after a message is received and processed
6. Receiving - emitted when a message is initially received before processing

The enum is exported and used throughout the application to maintain consistent event naming.

import/access examples:
import { SocketEvent } from '@welshman/net';
import { SocketEvent } from '@welshman/net/socket';


=========================
workspace: packages/net
file: packages/net/src/socket.ts
lines: 24:31
id: 70b09c852ed28d33dcc16ed66115721bfe725f566f9ee4eaa41fabc748b8dab7
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/socket.ts#L24

declaration:
export type SocketEvents = {
  [SocketEvent.Error]: (error: string, url: string) => void
  [SocketEvent.Status]: (status: SocketStatus, url: string) => void
  [SocketEvent.Send]: (message: ClientMessage, url: string) => void
  [SocketEvent.Sending]: (message: ClientMessage, url: string) => void
  [SocketEvent.Receive]: (message: RelayMessage, url: string) => void
  [SocketEvent.Receiving]: (message: RelayMessage, url: string) => void
}

summary:
A TypeScript type definition that maps socket events to their corresponding event handler function signatures. It defines the structure of event handlers for various socket events such as errors, status changes, message sending, and message receiving. Each event handler receives specific parameters relevant to the event type.

details:
This type alias uses an index signature pattern to map each value from the SocketEvent enum to its corresponding event handler function type. The handlers receive different parameters based on the event type:

1. Error events receive an error message and URL
2. Status events receive a SocketStatus enum value and URL
3. Send/Sending events receive a ClientMessage object and URL
4. Receive/Receiving events receive a RelayMessage object and URL

This type is likely used with EventEmitter's typed event handling to provide type safety when registering event listeners on the Socket class.

related: SocketStatus,ClientMessage,RelayMessage

import/access examples:
import type { SocketEvents } from '@welshman/net';
import type { SocketEvents } from '@welshman/net/socket';


=========================
workspace: packages/net
file: packages/net/src/socket.ts
lines: 33:142
id: 948295fa70fd8313433958d13e91da7eac0c01d7b9d0195fc613632fb37bf01b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/socket.ts#L33

declaration:
export class Socket extends EventEmitter{
  auth: AuthState;
  status: SocketStatus;
  _ws?: WebSocket;
  _sendQueue: TaskQueue<ClientMessage>;
  _recvQueue: TaskQueue<RelayMessage>;
  constructor(readonly url: string);
  open: () => void;
  attemptToOpen: () => void;
  close: () => void;
  cleanup: () => void;
  send: (message: ClientMessage) => void;
}

summary:
A WebSocket client implementation that extends EventEmitter to manage socket connections. It handles connection lifecycle (open, close), message sending and receiving with queuing, and authentication state. The class emits various events for socket status changes and message handling, allowing consumers to react to socket operations.

details:
The Socket class implements a WebSocket client with these key features:

1. Connection management:
   - Maintains socket status (open, opening, closing, closed, error)
   - Provides methods to open, close, and clean up connections
   - Handles WebSocket events (onopen, onclose, onerror, onmessage)

2. Message handling:
   - Uses two TaskQueue instances for sending and receiving messages
   - The send queue batches outgoing messages (50 at a time) and serializes them to JSON
   - The receive queue processes incoming messages and emits events
   - Validates that received messages are arrays (RelayMessage format)

3. Authentication:
   - Maintains an AuthState instance for handling authentication

4. Event system:
   - Extends EventEmitter to provide event-based communication
   - Defines typed events for error handling, status changes, and message operations
   - Sets a high maximum listener count (1000) to support many subscribers

The implementation uses a combination of queues and event emission to create an asynchronous, non-blocking WebSocket client.

related: AuthState,SocketStatus,Open,Opening,Closing,Closed,Error,ClientMessage,RelayMessage

code:
export class Socket extends EventEmitter {
  auth: AuthState
  status = SocketStatus.Closed

  _ws?: WebSocket
  _sendQueue: TaskQueue<ClientMessage>
  _recvQueue: TaskQueue<RelayMessage>

  constructor(readonly url: string) {
    super()

    this.auth = new AuthState(this)

    this._sendQueue = new TaskQueue<ClientMessage>({
      batchSize: 50,
      processItem: (message: ClientMessage) => {
        this._ws?.send(JSON.stringify(message))
        this.emit(SocketEvent.Send, message, this.url)
      },
    })

    this._recvQueue = new TaskQueue<RelayMessage>({
      batchSize: 50,
      processItem: (message: RelayMessage) => {
        this.emit(SocketEvent.Receive, message, this.url)
      },
    })

    this.on(SocketEvent.Status, (status: SocketStatus) => {
      this.status = status
    })

    this._sendQueue.stop()
    this.setMaxListeners(1000)
  }

  open = () => {
    if (this._ws) {
      throw new Error("Attempted to open a websocket that has not been closed")
    }

    try {
      this._ws = new WebSocket(this.url)
      this.emit(SocketEvent.Status, SocketStatus.Opening, this.url)

      this._ws.onopen = () => {
        this.emit(SocketEvent.Status, SocketStatus.Open, this.url)
        this._sendQueue.start()
      }

      this._ws.onerror = () => {
        this._ws = undefined
        this._sendQueue.stop()
        this.emit(SocketEvent.Status, SocketStatus.Error, this.url)
      }

      this._ws.onclose = () => {
        this._ws = undefined
        this._sendQueue.stop()

        if (this.status !== SocketStatus.Error) {
          this.emit(SocketEvent.Status, SocketStatus.Closed, this.url)
        }
      }

      this._ws.onmessage = (event: any) => {
        const data = event.data as string

        try {
          const message = JSON.parse(data)

          if (Array.isArray(message)) {
            this._recvQueue.push(message as RelayMessage)
            this.emit(SocketEvent.Receiving, message, this.url)
          } else {
            this.emit(SocketEvent.Error, "Invalid message received", this.url)
          }
        } catch (e) {
          this.emit(SocketEvent.Error, "Invalid message received", this.url)
        }
      }
    } catch (e) {
      this.emit(SocketEvent.Status, SocketStatus.Error, this.url)
    }
  }

  attemptToOpen = () => {
    if (!this._ws) {
      this.open()
    }
  }

  close = () => {
    this._ws?.close()
    this._ws = undefined
  }

  cleanup = () => {
    this.close()
    this.auth.cleanup()
    this._recvQueue.clear()
    this._sendQueue.clear()
    this.removeAllListeners()
  }

  send = (message: ClientMessage) => {
    this._sendQueue.push(message)
    this.emit(SocketEvent.Sending, message, this.url)
  }
}

import/access examples:
import { Socket } from '@welshman/net';
import { Socket } from '@welshman/net/socket';


=========================
workspace: packages/net
file: packages/net/src/policy.ts
lines: 19:24
id: 882bdf36bc5d1c07a5fdc88fcd2283d844def1a5cc13318e7064be541d713f62
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/policy.ts#L19

declaration:
export type SocketPolicy = (socket: Socket) => Unsubscriber

summary:
A type definition representing a socket policy function. A socket policy takes a Socket object as input and returns an Unsubscriber function that can be called to clean up any resources or event listeners created by the policy. Socket policies are used to define behaviors for socket connections.

details:
This is a simple type alias that defines the function signature for socket policies in the system. It doesn't contain implementation details itself, but establishes the contract that all socket policies must follow:

1. Accept a Socket object as their only parameter
2. Return an Unsubscriber function (which is likely a function that performs cleanup when called)

The type serves as a foundation for the various socket policy implementations in the file (socketPolicyAuthBuffer, socketPolicyConnectOnSend, socketPolicyCloseInactive, etc.).

related: Socket,Unsubscriber

import/access examples:
import type { SocketPolicy } from '@welshman/net';
import type { SocketPolicy } from '@welshman/net/policy';


=========================
workspace: packages/net
file: packages/net/src/policy.ts
lines: 33:88
id: d9e05be8c0579f34840baa4b09290d472101353eb38418517df25f2e0abd4d10
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/policy.ts#L33

declaration:
socketPolicyAuthBuffer = (socket: Socket) => {
  const {None, Ok, DeniedSignature, Forbidden} = AuthStatus
  const terminalStatuses = [Ok, DeniedSignature, Forbidden]

  let buffer: ClientMessage[] = []

  const unsubscribers = [
    on(socket, SocketEvent.Sending, (message: ClientMessage) => {
      // Always allow sending auth
      if (isClientAuth(message)) return

      // Always allow sending join requests
      if (isClientEvent(message) && message[1].kind === AUTH_JOIN) return

      // If the auth flow is complete, no need to buffer anymore
      if (terminalStatuses.includes(socket.auth.status)) return

      // If the client is closing a req, remove both from our buffer
      // Otherwise, if auth isn't done, hang on to recent messages in case we need to replay them
      if (isClientClose(message) || isClientNegClose(message)) {
        buffer = buffer.filter(nthNe(1, message[1]))
      } else {
        buffer = buffer.slice(-50).concat([message])
      }
    }),
    on(socket, SocketEvent.Receiving, (message: RelayMessage) => {
      // If the client is closing a request during auth, don't tell the caller, we'll retry it
      if (isRelayClosed(message) && message[2]?.startsWith("auth-required:")) {
        socket._recvQueue.remove(message)
      }

      // If we get an eose but we're in the middle of authenticating, wait
      if (isRelayEose(message) && ![None, Ok].includes(socket.auth.status)) {
        socket._recvQueue.remove(message)
      }

      // If the client is rejecting an event during auth, don't tell the caller, we'll retry it
      if (isRelayOk(message) && !message[2] && message[3]?.startsWith("auth-required:")) {
        socket._recvQueue.remove(message)
      }
    }),
    on(socket.auth, AuthStateEvent.Status, (status: AuthStatus) => {
      // Send buffered messages when we get successful auth. In any case, clear them out
      // if the auth flow is complete
      if (status === Ok) {
        for (const message of buffer.splice(0)) {
          socket.send(message)
        }
      } else if (terminalStatuses.includes(socket.auth.status)) {
        buffer = []
      }
    }),
  ]

  return () => unsubscribers.forEach(call)
}

summary:
A socket policy function that manages authentication-related message handling. It buffers outgoing messages when authentication is in progress, allows certain messages to pass through regardless of auth status (auth messages and join requests), and handles auth-required rejections by intercepting them and replaying buffered messages once authentication succeeds. Returns a cleanup function that removes all event listeners.

details:
Implementation details:
1. Creates a buffer array to store messages that need to be held during authentication
2. Sets up three event listeners:
   - SocketEvent.Sending: Intercepts outgoing messages and either lets them pass through (auth messages, join requests) or buffers them if auth is in progress
   - SocketEvent.Receiving: Intercepts incoming messages that indicate auth-required rejections, removing them from the receive queue to handle internally
   - AuthStateEvent.Status: Monitors auth status changes to replay buffered messages when auth succeeds or clear the buffer when auth fails
3. Maintains a list of terminal auth statuses (Ok, DeniedSignature, Forbidden) to determine when the auth flow is complete
4. Uses message type checking functions (isClientAuth, isClientEvent, etc.) to determine how to handle different message types
5. Returns a cleanup function that calls all unsubscriber functions to remove event listeners

related: Socket

import/access examples:
import { socketPolicyAuthBuffer } from '@welshman/net';
import { socketPolicyAuthBuffer } from '@welshman/net/policy';


=========================
workspace: packages/net
file: packages/net/src/policy.ts
lines: 95:116
id: a823b5e82ae1c29d11fafa4eb4203f22c6176cc8c86f1285a3fc4667e5ff1e67
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/policy.ts#L95

declaration:
socketPolicyConnectOnSend = (socket: Socket) => {
  let lastError = 0

  const unsubscribers = [
    on(socket, SocketEvent.Status, (newStatus: SocketStatus) => {
      // Keep track of the most recent error
      if (newStatus === SocketStatus.Error) {
        lastError = now()
      }
    }),
    on(socket, SocketEvent.Sending, (message: ClientMessage) => {
      const isClosed = [SocketStatus.Closed, SocketStatus.Error].includes(socket.status)

      // When a new message is sent, make sure the socket is open (unless there was a recent error)
      if (isClosed && lastError < ago(5)) {
        socket.open()
      }
    }),
  ]

  return () => unsubscribers.forEach(call)
}

summary:
A socket policy function that automatically connects a closed socket when a message is sent, unless there was a recent error. It takes a Socket object as input and returns a cleanup function that removes all event listeners when called.

details:
Implementation details:
1. Tracks the timestamp of the most recent error using `lastError` variable.
2. Sets up two event listeners:
   - Listens for socket status changes to record when errors occur using the `now()` function.
   - Listens for outgoing messages to check if the socket needs to be reopened.
3. When a message is being sent and the socket is closed (either in Closed or Error state), it will automatically open the socket, but only if there hasn't been an error in the last 5 seconds (using the `ago()` function to compare timestamps).
4. Returns a cleanup function that calls all unsubscriber functions to remove the event listeners.

related: Socket

import/access examples:
import { socketPolicyConnectOnSend } from '@welshman/net';
import { socketPolicyConnectOnSend } from '@welshman/net/policy';


=========================
workspace: packages/net
file: packages/net/src/policy.ts
lines: 123:183
id: bafe4beb9d479fb2f1cb9108080f52345f4f617d0469a8c41d5dd6bf8d990c30
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/policy.ts#L123

declaration:
socketPolicyCloseInactive = (socket: Socket) => {
  const pending = new Map<string, ClientMessage>()

  let lastOpen = now()
  let lastActivity = now()

  const unsubscribers = [
    on(socket, SocketEvent.Status, (newStatus: SocketStatus) => {
      const isClosed = [SocketStatus.Closed, SocketStatus.Error].includes(socket.status)

      // Keep track of the most recent open
      if (newStatus === SocketStatus.Open) {
        lastOpen = now()
      }

      // If the socket closed and we have no error, reopen it but don't flap
      if (isClosed && pending.size) {
        sleep(Math.max(0, ms(5 - (now() - lastOpen)))).then(() => {
          socket.attemptToOpen()

          for (const message of pending.values()) {
            socket.send(message)
          }
        })
      }
    }),
    on(socket, SocketEvent.Send, (message: ClientMessage) => {
      lastActivity = now()

      if (isClientEvent(message)) {
        pending.set(message[1].id, message)
      }

      if (isClientReq(message)) {
        pending.set(message[1], message)
      }

      if (isClientClose(message)) {
        pending.delete(message[1])
      }
    }),
    on(socket, SocketEvent.Receive, (message: RelayMessage) => {
      lastActivity = now()

      if (isRelayClosed(message) || isRelayOk(message)) {
        pending.delete(message[1])
      }
    }),
  ]

  const interval = setInterval(() => {
    if (socket.status === SocketStatus.Open && lastActivity < ago(30) && pending.size === 0) {
      socket.close()
    }
  }, 3000)

  return () => {
    unsubscribers.forEach(call)
    clearInterval(interval)
  }
}

summary:
A socket policy function that manages socket connections based on activity. It automatically closes sockets that have been inactive for 30 seconds with no pending messages, and reopens closed sockets when there are pending messages to be sent. The function takes a Socket object as input and returns a cleanup function that removes all event listeners and clears the activity check interval.

details:
The implementation works by tracking three main pieces of state:

1. A map of pending messages that haven't received responses
2. Timestamp of the last socket open event
3. Timestamp of the last activity (send/receive)

The function sets up event listeners for:
- Socket status changes: When the socket opens, it updates the lastOpen timestamp. When closed with pending messages, it attempts to reopen after a delay (with rate limiting to prevent flapping)
- Message sending: Updates activity timestamp and tracks pending events/requests in the map
- Message receiving: Updates activity timestamp and removes messages from the pending map when they're acknowledged

It also creates an interval that runs every 3 seconds to check if the socket has been inactive for 30+ seconds with no pending messages, closing it if so.

The cleanup function removes all event listeners and clears the interval to prevent memory leaks.

related: Socket

import/access examples:
import { socketPolicyCloseInactive } from '@welshman/net';
import { socketPolicyCloseInactive } from '@welshman/net/policy';


=========================
workspace: packages/net
file: packages/net/src/policy.ts
lines: 185:188
id: d45be925c38808f692cfb9c893b842e92d8fc05672d8254b12b14f8a3d6b1bee
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/policy.ts#L185

declaration:
export type SocketPolicyAuthOptions = {
  sign: (event: StampedEvent) => Promise<SignedEvent>
  shouldAuth?: (socket: Socket) => boolean
}

summary:
A type definition for options used in the authentication policy for sockets. It contains required and optional properties to configure how socket authentication should work. The type includes a required `sign` function that takes a `StampedEvent` and returns a Promise of `SignedEvent`, and an optional `shouldAuth` function that determines whether authentication should proceed for a given socket.

details:
This type alias defines the configuration interface for the `makeSocketPolicyAuth` factory function. It has two properties:

1. `sign`: A required function that handles the actual signing of events, which is essential for the authentication process. It takes an unsigned but timestamped event and returns a promise that resolves to a fully signed event.

2. `shouldAuth`: An optional predicate function that determines whether authentication should proceed for a given socket. If not provided, the default behavior (implemented in `makeSocketPolicyAuth`) is to always return true via the `always` utility function.

related: Socket

import/access examples:
import type { SocketPolicyAuthOptions } from '@welshman/net';
import type { SocketPolicyAuthOptions } from '@welshman/net/policy';


=========================
workspace: packages/net
file: packages/net/src/policy.ts
lines: 195:209
id: 0a5207b095705892830f59ea26a67a675473cb32a873acb9bd4dd1d3b1b1ab64
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/policy.ts#L195

declaration:
makeSocketPolicyAuth = (options: SocketPolicyAuthOptions) => (socket: Socket) => {
  const shouldAuth = options.shouldAuth || always(true)

  const unsubscribers = [
    on(socket.auth, AuthStateEvent.Status, (status: AuthStatus) => {
      if (status === AuthStatus.Requested && shouldAuth(socket)) {
        socket.auth.doAuth(options.sign)
      }
    }),
  ]

  return () => {
    unsubscribers.forEach(call)
  }
}

summary:
A factory function that creates a socket policy for handling authentication. It takes authentication options including a sign function for signing events and an optional shouldAuth function to determine if authentication should proceed. The returned policy monitors the socket's authentication status and triggers the authentication process when requested, if the shouldAuth condition is met.

details:
The implementation:
1. Creates a socket policy function that takes a Socket object
2. Sets up a default shouldAuth function that always returns true if none is provided
3. Sets up an event listener for the AuthStateEvent.Status event on the socket's auth object
4. When the auth status becomes 'Requested' and shouldAuth returns true, it calls the socket's auth.doAuth method with the provided sign function
5. Returns a cleanup function that removes all event listeners when called

The policy is designed to work with the socket's authentication system, responding to authentication requests by signing events when appropriate.

related: SocketPolicyAuthOptions

import/access examples:
import { makeSocketPolicyAuth } from '@welshman/net';
import { makeSocketPolicyAuth } from '@welshman/net/policy';


=========================
workspace: packages/net
file: packages/net/src/policy.ts
lines: 211:215
id: e9b6f23bd2755deb1d74ce940da9b5dfd10d4371fc3c99238f879992ada623e4
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/policy.ts#L211

declaration:
defaultSocketPolicies = [
  socketPolicyAuthBuffer,
  socketPolicyConnectOnSend,
  socketPolicyCloseInactive,
]

summary:
An array of default socket policies that are applied to sockets by default. It includes three policies: `socketPolicyAuthBuffer` for handling authentication buffering, `socketPolicyConnectOnSend` for auto-connecting closed sockets when messages are sent, and `socketPolicyCloseInactive` for managing inactive socket connections.

details:
This constant exports an array containing the three main socket policies that provide standard behavior for sockets in the system:

1. `socketPolicyAuthBuffer` - Handles buffering messages during authentication
2. `socketPolicyConnectOnSend` - Automatically connects sockets when messages are sent
3. `socketPolicyCloseInactive` - Manages socket lifecycle based on activity

These policies together provide a complete set of default behaviors for socket management, handling authentication, connection management, and resource optimization through automatic closing of inactive connections.

related: socketPolicyAuthBuffer,socketPolicyConnectOnSend,socketPolicyCloseInactive

import/access examples:
import { defaultSocketPolicies } from '@welshman/net';
import { defaultSocketPolicies } from '@welshman/net/policy';


=========================
workspace: packages/net
file: packages/net/src/pool.ts
lines: 6:14
id: 2fc4d0ab62344cd312b15b38b7e6d6fece69c3a50c0ad6cdf6ab8ea5da8bda26
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/pool.ts#L6

declaration:
makeSocket = (url: string, policies = defaultSocketPolicies) => {
  const socket = new Socket(url)

  for (const applyPolicy of policies) {
    applyPolicy(socket)
  }

  return socket
}

summary:
Creates and configures a new Socket instance with the given URL and optional policies. The function applies each policy from the provided array to the socket before returning it. If no policies are provided, it uses the defaultSocketPolicies.

details:
The implementation:
1. Creates a new Socket instance with the provided URL
2. Iterates through each policy function in the policies array
3. Applies each policy function to the socket instance
4. Returns the configured socket

The function serves as a factory method that handles both socket creation and policy application in one step.

related: Socket

import/access examples:
import { makeSocket } from '@welshman/net';
import { makeSocket } from '@welshman/net/pool';


=========================
workspace: packages/net
file: packages/net/src/pool.ts
lines: 16:16
id: 3bcec90c203ce7520fb51dde8650bb8efddf0733980f292574d9e1d5c49ba4bf
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/pool.ts#L16

declaration:
export type PoolSubscription = (socket: Socket) => void

summary:
A type alias representing a callback function that is invoked when a new socket is created in a Pool. The callback receives a Socket instance as its parameter and returns void.

related: Socket

import/access examples:
import type { PoolSubscription } from '@welshman/net';
import type { PoolSubscription } from '@welshman/net/pool';


=========================
workspace: packages/net
file: packages/net/src/pool.ts
lines: 18:20
id: 53c53639020039d3ca0bbe0486cd071df7d35e69043b5f43fc7f5d3b7c7a4053
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/pool.ts#L18

declaration:
export type PoolOptions = {
  makeSocket?: (url: string) => Socket
}

summary:
A type definition that specifies configuration options for a Pool instance. It contains an optional `makeSocket` property which is a function that takes a URL string and returns a Socket instance, allowing customization of how sockets are created within the pool.

details:
This type alias is used to configure the behavior of the Pool class. The only option currently supported is `makeSocket`, which if provided, overrides the default socket creation mechanism in the Pool. This allows for custom socket initialization logic or for injecting mock sockets during testing.

related: Socket

import/access examples:
import type { PoolOptions } from '@welshman/net';
import type { PoolOptions } from '@welshman/net/pool';


=========================
workspace: packages/net
file: packages/net/src/pool.ts
lines: 22:22
id: ee42189313174815a5a4455d9b5fb066220f1db24a757e8bded36426254c83d3
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/pool.ts#L22

declaration:
poolSingleton: Pool

summary:
A global singleton instance of the Pool class. This variable holds a reference to the shared Pool instance that can be accessed throughout the application. It's initialized lazily when first accessed through Pool.get().

details:
This is a simple exported variable declaration that serves as a reference to the singleton instance of the Pool class. It's initially undefined and gets assigned a value when Pool.get() is called for the first time. The singleton pattern ensures that only one Pool instance exists in the application, providing a centralized way to manage Socket connections.

related: Pool

import/access examples:
import { poolSingleton } from '@welshman/net';
import { poolSingleton } from '@welshman/net/pool';


=========================
workspace: packages/net
file: packages/net/src/pool.ts
lines: 24:92
id: 2491f8a15195c384eb7632e71934d21183aab89c5e27500d84123db8fa7facec
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/pool.ts#L24

declaration:
export class Pool{
  _data: Map<string, Socket>;
  _subs: PoolSubscription[];
  static get();
  constructor(readonly options: PoolOptions = {});
  has(url: string);
  makeSocket(url: string);
  get(_url: string): Socket;
  subscribe(cb: PoolSubscription);
  remove(url: string);
  clear();
}

summary:
The `Pool` class manages a collection of Socket instances, providing a centralized way to create, retrieve, and manage WebSocket connections. It implements a singleton pattern with the `get()` static method and offers methods to check for existing sockets, create new ones, subscribe to socket creation events, remove sockets, and clear all connections. The class helps in reusing socket connections across the application, avoiding duplicate connections to the same URL.

details:
Implementation details:
1. Uses a Map (`_data`) to store Socket instances with normalized URLs as keys
2. Maintains a list of subscription callbacks (`_subs`) that are called when new sockets are created
3. Implements a singleton pattern through the static `get()` method and `poolSingleton` variable
4. Allows customization of socket creation through the `options.makeSocket` parameter
5. Normalizes URLs using the `normalizeRelayUrl` utility function to ensure consistent keys
6. The `get()` method either returns an existing socket or creates a new one if needed
7. When creating new sockets, it notifies all subscribers
8. The `remove()` method properly cleans up sockets before removing them from the pool
9. The `clear()` method iterates through all sockets and removes them

related: Socket,PoolSubscription,PoolOptions

code:
export class Pool {
  _data = new Map<string, Socket>()
  _subs: PoolSubscription[] = []

  static get() {
    if (!poolSingleton) {
      poolSingleton = new Pool()
    }

    return poolSingleton
  }

  constructor(readonly options: PoolOptions = {}) {}

  has(url: string) {
    return this._data.has(normalizeRelayUrl(url))
  }

  makeSocket(url: string) {
    if (this.options.makeSocket) {
      return this.options.makeSocket(url)
    }

    return makeSocket(url)
  }

  get(_url: string): Socket {
    const url = normalizeRelayUrl(_url)
    const socket = this._data.get(url)

    if (socket) {
      return socket
    }

    const newSocket = this.makeSocket(url)

    this._data.set(url, newSocket)

    for (const cb of this._subs) {
      cb(newSocket)
    }

    return newSocket
  }

  subscribe(cb: PoolSubscription) {
    this._subs.push(cb)

    return () => {
      this._subs = remove(cb, this._subs)
    }
  }

  remove(url: string) {
    const socket = this._data.get(url)

    if (socket) {
      socket.cleanup()

      this._data.delete(url)
    }
  }

  clear() {
    for (const url of this._data.keys()) {
      this.remove(url)
    }
  }
}

import/access examples:
import { Pool } from '@welshman/net';
import { Pool } from '@welshman/net/pool';


=========================
workspace: packages/net
file: packages/net/src/context.ts
lines: 6:12
id: 014a3005d4ef7b2ba8b653c1496d3048ce97ee8f0514fd737143eb533d43afd7
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/context.ts#L6

declaration:
export type NetContext = {
  pool: Pool
  repository: Repository
  isEventValid: (event: TrustedEvent, url: string) => boolean
  isEventDeleted: (event: TrustedEvent, url: string) => boolean
  getAdapter?: (url: string, context: NetContext) => AbstractAdapter
}

summary:
NetContext is a type definition that represents the network context for operations in the application. It includes a pool, repository, event validation and deletion checking functions, and an optional adapter getter function. This type is essential for managing network-related operations and validations.

details:
The NetContext type is a simple type alias that defines the structure for network context objects. It contains:
1. A Pool instance for managing connection pools
2. A Repository instance for data storage operations
3. Two validation functions for events (isEventValid and isEventDeleted)
4. An optional getAdapter function that can retrieve an appropriate adapter for a given URL

The implementation also exports a default netContext object that initializes with default values, where the validation functions use the verifyEvent utility and the repository's isDeleted method.

related: Pool,AbstractAdapter

import/access examples:
import type { NetContext } from '@welshman/net';
import type { NetContext } from '@welshman/net/context';


=========================
workspace: packages/net
file: packages/net/src/context.ts
lines: 14:19
id: d0b1c1cb150281391298e4c7e80c4b851e09bccc2318adc826dcaf413d58c358
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/context.ts#L14

declaration:
netContext: NetContext = {
  pool: Pool.get(),
  repository: Repository.get(),
  isEventValid: (event, url) => verifyEvent(event),
  isEventDeleted: (event, url) => netContext.repository.isDeleted(event),
}

summary:
A global context object that provides essential services for network operations. It includes a connection pool, repository access, and methods for event validation and deletion checking. Optionally allows for adapter retrieval based on URLs.

details:
The `netContext` implementation initializes with:
1. A singleton Pool instance via `Pool.get()`
2. A singleton Repository instance via `Repository.get()`
3. An event validation function that delegates to the `verifyEvent` utility
4. An event deletion check function that uses the repository's `isDeleted` method

The implementation creates a circular reference where `isEventDeleted` references the `netContext` object itself.

related: NetContext

import/access examples:
import { netContext } from '@welshman/net';
import { netContext } from '@welshman/net/context';


=========================
workspace: packages/net
file: packages/net/src/adapter.ts
lines: 10:12
id: 67d08c3e759b89572cef85b30df6a0c02f921fdf9245040388812889bc732e6f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/adapter.ts#L10

declaration:
export enum AdapterEvent {
  Receive = "adapter:event:receive",
}

summary:
An enumeration that defines event types emitted by adapters in the relay communication system. Currently contains a single event 'Receive' which is triggered when an adapter receives a message from a relay.

details:
This enum is used throughout the adapter system to provide type-safe event handling. The 'Receive' event (with value 'adapter:event:receive') is the only defined event and is used when messages are received from relays. This enum works in conjunction with the AdapterEvents type to provide type checking for event handlers.

import/access examples:
import { AdapterEvent } from '@welshman/net';
import { AdapterEvent } from '@welshman/net/adapter';


=========================
workspace: packages/net
file: packages/net/src/adapter.ts
lines: 14:16
id: 0dc5593787dbdffbcad515ebafdbdfb8392f47bca1214c0302f8d2d7201ddf4b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/adapter.ts#L14

declaration:
export type AdapterEvents = {
  [AdapterEvent.Receive]: (message: RelayMessage, url: string) => void
}

summary:
AdapterEvents is a type definition that maps the AdapterEvent.Receive event to its handler function signature. It specifies that when an adapter receives a message, the event handler should accept a RelayMessage object and a string URL as parameters.

details:
This type alias is used for type-checking event handlers in the adapter system. It ensures that when code listens for the AdapterEvent.Receive event, the callback function has the correct parameter types (RelayMessage and string). This is part of the event system infrastructure that enables type-safe event handling throughout the application.

related: RelayMessage

import/access examples:
import type { AdapterEvents } from '@welshman/net';
import type { AdapterEvents } from '@welshman/net/adapter';


=========================
workspace: packages/net
file: packages/net/src/adapter.ts
lines: 18:29
id: 5ef16e77cddd1b8f1e0019e2bc5081b27b4a93c188c809369e9e516a3068b124
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/adapter.ts#L18

declaration:
export abstract class AbstractAdapter extends EventEmitter{
  _unsubscribers: Unsubscriber[];
  abstract urls: string[];
  abstract sockets: Socket[];
  abstract send(message: ClientMessage): void;
  cleanup();
}

summary:
AbstractAdapter is an abstract base class that extends EventEmitter to provide a common interface for relay adapters. It defines the core functionality for managing connections to relays, handling messages, and cleaning up resources. The class requires implementations to provide access to relay URLs, socket instances, and message sending capabilities.

details:
The AbstractAdapter implementation:

1. Extends EventEmitter to provide event handling capabilities
2. Maintains an array of unsubscriber functions in `_unsubscribers` to track cleanup handlers
3. Defines abstract properties and methods that must be implemented by subclasses:
   - `urls`: A string array of relay URLs the adapter connects to
   - `sockets`: An array of Socket instances managed by the adapter
   - `send()`: Method to transmit ClientMessage objects to relays
4. Provides a `cleanup()` method that:
   - Removes all event listeners
   - Calls and clears all unsubscriber functions stored in the `_unsubscribers` array

This class serves as the foundation for concrete adapter implementations like SocketAdapter, LocalAdapter, and MockAdapter defined later in the file.

related: Unsubscriber,Socket,ClientMessage

code:
export abstract class AbstractAdapter extends EventEmitter {
  _unsubscribers: Unsubscriber[] = []

  abstract urls: string[]
  abstract sockets: Socket[]
  abstract send(message: ClientMessage): void

  cleanup() {
    this.removeAllListeners()
    this._unsubscribers.splice(0).forEach(call)
  }
}

import/access examples:
import { AbstractAdapter } from '@welshman/net';
import { AbstractAdapter } from '@welshman/net/adapter';


=========================
workspace: packages/net
file: packages/net/src/adapter.ts
lines: 31:53
id: 1260bd8ba86c55af91de7c61577140a9d50e38742a91a93b4b0563036070ec14
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/adapter.ts#L31

declaration:
export class SocketAdapter extends AbstractAdapter{
  constructor(readonly socket: Socket);
  get sockets();
  get urls();
  send(message: ClientMessage);
}

summary:
SocketAdapter is a class that extends AbstractAdapter to provide a bridge between a Socket instance and the adapter system. It handles communication with a relay server through a socket connection. The class emits events when messages are received from the socket and allows sending messages to the socket.

details:
The SocketAdapter implementation:

1. Takes a Socket instance in its constructor and sets up an event listener for the SocketEvent.Receive event
2. When the socket receives a message, it forwards it by emitting an AdapterEvent.Receive event
3. Implements the abstract properties and methods from AbstractAdapter:
   - sockets: Returns an array containing the single socket instance
   - urls: Returns an array containing the URL of the socket
   - send: Delegates message sending to the underlying socket

The implementation is straightforward, acting primarily as a wrapper around the Socket instance that conforms to the AbstractAdapter interface.

related: AbstractAdapter,Socket

code:
export class SocketAdapter extends AbstractAdapter {
  constructor(readonly socket: Socket) {
    super()

    this._unsubscribers.push(
      on(socket, SocketEvent.Receive, (message: RelayMessage, url: string) => {
        this.emit(AdapterEvent.Receive, message, url)
      }),
    )
  }

  get sockets() {
    return [this.socket]
  }

  get urls() {
    return [this.socket.url]
  }

  send(message: ClientMessage) {
    this.socket.send(message)
  }
}

import/access examples:
import { SocketAdapter } from '@welshman/net';
import { SocketAdapter } from '@welshman/net/adapter';


=========================
workspace: packages/net
file: packages/net/src/adapter.ts
lines: 55:79
id: 744950aa9426d89b4580201f2ca58bb7e11373f87aaeccf33b8ff66bb1f24531
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/adapter.ts#L55

declaration:
export class LocalAdapter extends AbstractAdapter{
  constructor(readonly relay: LocalRelay);
  get sockets();
  get urls();
  send(message: ClientMessage);
}

summary:
The `LocalAdapter` class extends `AbstractAdapter` and provides an implementation for connecting to a local relay. It emits received messages from the local relay and allows sending messages to it. The adapter implements the required abstract properties and methods from `AbstractAdapter` including `urls`, `sockets`, and `send`.

details:
Implementation details:
1. The class takes a `LocalRelay` instance in its constructor and sets up an event listener on it.
2. When any event ('*') is emitted from the relay, it captures the message and re-emits it as an `AdapterEvent.Receive` event with the `LOCAL_RELAY_URL` as the source.
3. The `sockets` getter returns an empty array since local adapters don't use actual network sockets.
4. The `urls` getter returns an array containing only the `LOCAL_RELAY_URL` constant.
5. The `send` method destructures the incoming `ClientMessage` into a type and rest parameters, then forwards them to the relay's send method.
6. It leverages the event emitter pattern inherited from `AbstractAdapter` (which extends EventEmitter) for communication.

related: AbstractAdapter

code:
export class LocalAdapter extends AbstractAdapter {
  constructor(readonly relay: LocalRelay) {
    super()

    this._unsubscribers.push(
      on(relay, "*", (...message: RelayMessage) => {
        this.emit(AdapterEvent.Receive, message, LOCAL_RELAY_URL)
      }),
    )
  }

  get sockets() {
    return []
  }

  get urls() {
    return [LOCAL_RELAY_URL]
  }

  send(message: ClientMessage) {
    const [type, ...rest] = message

    this.relay.send(type, ...rest)
  }
}

import/access examples:
import { LocalAdapter } from '@welshman/net';
import { LocalAdapter } from '@welshman/net/adapter';


=========================
workspace: packages/net
file: packages/net/src/adapter.ts
lines: 81:100
id: deaaddf1e85e5753f4c4555deed5bc315802427fb7386052d6a06a64ea6d385a
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/adapter.ts#L81

declaration:
export class MockAdapter extends AbstractAdapter{
  constructor(
      readonly url: string,
      readonly send: (message: ClientMessage) => void,
    );
  get sockets();
  get urls();
  receive: (message: RelayMessage) => void;
}

summary:
MockAdapter is a class that extends AbstractAdapter for testing purposes. It simulates a relay connection with a specified URL and custom send behavior. It provides methods to manually trigger message reception through the `receive` method, making it useful for unit testing relay communication.

details:
The MockAdapter implementation is fairly simple:

1. It takes a URL string and a send function in its constructor, allowing tests to provide custom behavior for outgoing messages.
2. It implements the required abstract properties from AbstractAdapter:
   - `sockets` returns an empty array since this is a mock that doesn't use real sockets
   - `urls` returns an array containing only the provided URL
3. It provides a `receive` method that allows tests to manually trigger the reception of messages, which will emit the AdapterEvent.Receive event with the message and URL.

This adapter is designed for testing scenarios where you want to simulate relay communication without actual network connections.

related: AbstractAdapter,ClientMessage

code:
export class MockAdapter extends AbstractAdapter {
  constructor(
    readonly url: string,
    readonly send: (message: ClientMessage) => void,
  ) {
    super()
  }

  get sockets() {
    return []
  }

  get urls() {
    return [this.url]
  }

  receive = (message: RelayMessage) => {
    this.emit(AdapterEvent.Receive, message, this.url)
  }
}

import/access examples:
import { MockAdapter } from '@welshman/net';
import { MockAdapter } from '@welshman/net/adapter';


=========================
workspace: packages/net
file: packages/net/src/adapter.ts
lines: 102:102
id: c1ac371efac461c93e34638d29dad060d50554d6a55e69bfd0b460b005c8a62c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/adapter.ts#L102

declaration:
export type AdapterContext = Partial<NetContext>

summary:
AdapterContext is a type alias that represents a partial configuration for network adapters. It extends the NetContext interface, allowing users to provide optional configuration parameters when creating adapters.

details:
This type alias is defined as a Partial<NetContext>, meaning it accepts any subset of properties from the NetContext interface. It's used primarily in the getAdapter function to allow customization of adapter creation without requiring all NetContext properties to be specified. The implementation is straightforward - it's just a type definition that makes the NetContext properties optional.

related: NetContext

import/access examples:
import type { AdapterContext } from '@welshman/net';
import type { AdapterContext } from '@welshman/net/adapter';


=========================
workspace: packages/net
file: packages/net/src/adapter.ts
lines: 104:124
id: b5420c7a5a3ad8d909bbf90e32ce4ccbffe85b4eec9b7db1805377ccd5a223c6
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/adapter.ts#L104

declaration:
getAdapter = (url: string, adapterContext: AdapterContext = {}) => {
  const context = mergeRight(netContext, adapterContext as any)

  if (context.getAdapter) {
    const adapter = context.getAdapter(url, context)

    if (adapter) {
      return adapter
    }
  }

  if (url === LOCAL_RELAY_URL) {
    return new LocalAdapter(new LocalRelay(context.repository))
  }

  if (isRelayUrl(url)) {
    return new SocketAdapter(context.pool.get(url))
  }

  throw new Error(`Invalid relay url ${url}`)
}

summary:
A function that creates and returns an appropriate adapter instance based on the provided URL. It accepts a URL string and an optional adapter context object. The function returns an instance of AbstractAdapter (either LocalAdapter, SocketAdapter, or a custom adapter provided by the context). Throws an error if the URL is invalid.

details:
The implementation follows these steps:
1. Merges the provided adapterContext with the default netContext
2. Checks if the context provides a custom getAdapter function and uses it if available
3. If no custom adapter is provided, it selects an adapter based on URL type:
   - For LOCAL_RELAY_URL, creates a LocalAdapter with a new LocalRelay
   - For valid relay URLs (checked with isRelayUrl), creates a SocketAdapter using a socket from the context's pool
   - For any other URL, throws an error indicating invalid relay URL

The function prioritizes custom adapters from the context before falling back to built-in adapter types.

related: AdapterContext

import/access examples:
import { getAdapter } from '@welshman/net';
import { getAdapter } from '@welshman/net/adapter';


=========================
workspace: packages/net
file: packages/net/src/negentropy.ts
lines: 5:5
id: aa119953404abaff1ca25dcc7e0f447dc49e187d694b12638601a4e252461294
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/negentropy.ts#L5

declaration:
PROTOCOL_VERSION = 0x61

summary:
A constant that defines the protocol version for the Negentropy synchronization protocol. It is set to 0x61, which represents Version 1 of the protocol.

details:
This constant is used throughout the Negentropy implementation to identify and validate the protocol version during communication between peers. When messages are exchanged, this version byte is included at the beginning of the message to ensure compatibility. The code includes validation to reject messages with unsupported protocol versions (lines 300-308).

=========================
workspace: packages/net
file: packages/net/src/negentropy.ts
lines: 6:6
id: 7560e8ad8226a5f7553526942c1d2ac05527e6e06f2c397bf41285dc38ee2d3b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/negentropy.ts#L6

declaration:
ID_SIZE = 32

summary:
A constant that defines the size of IDs used in the Negentropy protocol, set to 32 bytes.

details:
This constant is used throughout the Negentropy implementation to ensure consistent ID size handling. It's referenced in various parts of the code including the Accumulator class (for buffer initialization), item validation in NegentropyStorageVector, and when processing IDs during reconciliation.

=========================
workspace: packages/net
file: packages/net/src/negentropy.ts
lines: 7:7
id: d7d9af14d0126a9b6f5a3a923ec56710da9c151ff4bc399653f1cc6b9071badc
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/negentropy.ts#L7

declaration:
FINGERPRINT_SIZE = 16

summary:
A constant that defines the size of fingerprints used in the Negentropy protocol. It is set to 16 bytes (128 bits).

details:
This constant is used throughout the Negentropy protocol implementation to determine the size of fingerprint values that are generated from data sets. Fingerprints are used in the reconciliation process to efficiently compare data collections between peers. The 16-byte size represents a balance between collision resistance and transmission efficiency.

=========================
workspace: packages/net
file: packages/net/src/negentropy.ts
lines: 9:13
id: ff570b91ebc021fced22da7428c18378b25b89b87493313f2ee0495cb22b0553
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/negentropy.ts#L9

declaration:
Mode = {
  Skip: 0,
  Fingerprint: 1,
  IdList: 2,
}

summary:
Mode is an enumeration object that defines the operational modes for the Negentropy protocol. It contains three constants: Skip (0), Fingerprint (1), and IdList (2). These values are used to determine the behavior during the reconciliation process in the Negentropy synchronization algorithm.

details:
This is a simple constant object that serves as an enum-like structure in JavaScript/TypeScript. It defines three possible modes that control how the Negentropy protocol processes data during reconciliation:

1. Skip (0): Used to indicate sections that can be skipped during reconciliation
2. Fingerprint (1): Used when comparing fingerprints of data ranges
3. IdList (2): Used when exchanging explicit lists of IDs

These mode values are used extensively in the reconciliation algorithm to determine what action to take for each data range being processed.

=========================
workspace: packages/net
file: packages/net/src/negentropy.ts
lines: 15:57
id: 799fd65d4806e24bb075e926386289f3218c1ccf831afde2294d9d9e909e8035
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/negentropy.ts#L15

declaration:
class WrappedBuffer{
  constructor(buffer);
  unwrap();
  get capacity();
  extend(buf);
  shift();
  shiftN(n = 1);
}

summary:
WrappedBuffer is a utility class that wraps a Uint8Array buffer with additional functionality. It provides methods to manipulate the underlying buffer, including extending it with new data, shifting elements from the beginning, and unwrapping to get the raw buffer. The class automatically handles buffer capacity management, resizing when necessary.

details:
The implementation maintains an internal Uint8Array (`_raw`) and tracks the logical length separately from the buffer capacity. Key implementation details:

1. Constructor initializes either with a provided buffer or creates a new one with default capacity of 512 bytes
2. `unwrap()` returns a view (subarray) of the internal buffer up to the current length
3. `extend()` adds data to the buffer, automatically doubling capacity when needed
4. `shift()` removes and returns the first byte from the buffer
5. `shiftN()` removes and returns the first N bytes as a subarray
6. The class handles capacity management by creating a new, larger buffer and copying data when necessary
7. The implementation distinguishes between logical length (the amount of data) and capacity (the total allocated space)

code:
class WrappedBuffer {
  constructor(buffer) {
    this._raw = new Uint8Array(buffer || 512)
    this.length = buffer ? buffer.length : 0
  }

  unwrap() {
    return this._raw.subarray(0, this.length)
  }

  get capacity() {
    return this._raw.byteLength
  }

  extend(buf) {
    if (buf._raw) buf = buf.unwrap()
    if (typeof buf.length !== "number") throw Error("bad length")
    const targetSize = buf.length + this.length
    if (this.capacity < targetSize) {
      const oldRaw = this._raw
      const newCapacity = Math.max(this.capacity * 2, targetSize)
      this._raw = new Uint8Array(newCapacity)
      this._raw.set(oldRaw)
    }

    this._raw.set(buf, this.length)
    this.length += buf.length
  }

  shift() {
    const first = this._raw[0]
    this._raw = this._raw.subarray(1)
    this.length--
    return first
  }

  shiftN(n = 1) {
    const firstSubarray = this._raw.subarray(0, n)
    this._raw = this._raw.subarray(n)
    this.length -= n
    return firstSubarray
  }
}

=========================
workspace: packages/net
file: packages/net/src/negentropy.ts
lines: 59:70
id: 80d12b7d05031ad70bb651ac7e09a44afc276b8c2ddd43b5bf0e6fb6638fcab9
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/negentropy.ts#L59

declaration:
function decodeVarInt(buf)

summary:
Decodes a variable-length integer from a buffer. The function reads bytes from the buffer until it encounters a byte with the most significant bit unset, combining the 7 least significant bits of each byte to form the result.

details:
This function implements a variable-length integer decoding algorithm where:
1. Each byte contributes 7 bits to the result
2. The most significant bit (MSB) of each byte indicates if more bytes follow (1) or if this is the last byte (0)
3. The function shifts the accumulated result left by 7 bits for each new byte and combines it with the 7 least significant bits of the current byte
4. It throws an error if the buffer ends prematurely before finding a byte with MSB=0
5. The function modifies the input buffer by removing the bytes it processes

code:
function decodeVarInt(buf) {
  let res = 0

  while (1) {
    if (buf.length === 0) throw Error("parse ends prematurely")
    const byte = buf.shift()
    res = (res << 7) | (byte & 127)
    if ((byte & 128) === 0) break
  }

  return res
}

=========================
workspace: packages/net
file: packages/net/src/negentropy.ts
lines: 72:87
id: 0811fc9bc08e7df604d79024bbde0f250b1e04c09189a83a1377e1c6af7aa57f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/negentropy.ts#L72

declaration:
function encodeVarInt(n)

summary:
Encodes a number into a variable-length integer format, returning a WrappedBuffer. This function uses a 7-bit encoding scheme where each byte uses 7 bits for the value and 1 bit as a continuation flag.

details:
The implementation works as follows:
1. If the input number is 0, it returns a WrappedBuffer containing a single zero byte
2. For non-zero numbers, it breaks the number into 7-bit chunks, pushing each chunk into an array
3. The chunks are stored in reverse order, then reversed to get the correct byte order
4. It sets the high bit (bit 7) on all bytes except the last one to indicate continuation
5. Finally, it wraps the resulting array in a WrappedBuffer and returns it

This encoding is space-efficient for small numbers while still supporting arbitrarily large values.

related: WrappedBuffer

code:
function encodeVarInt(n) {
  if (n === 0) return new WrappedBuffer([0])

  const o = []

  while (n !== 0) {
    o.push(n & 127)
    n >>>= 7
  }

  o.reverse()

  for (let i = 0; i < o.length - 1; i++) o[i] |= 128

  return new WrappedBuffer(o)
}

=========================
workspace: packages/net
file: packages/net/src/negentropy.ts
lines: 89:91
id: b8b83372be831147b48aecd2d75cdd275ed34febac1522ab5f033d0ebb0998f3
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/negentropy.ts#L89

declaration:
function getByte(buf)

summary:
The `getByte` function extracts a single byte from a buffer. It takes a buffer as input and returns the first byte from that buffer.

details:
This is a simple utility function that calls the `getBytes` function with a length of 1 and returns the first element of the resulting array. It's a convenience wrapper that makes the code more readable when only a single byte needs to be extracted from a buffer.

code:
function getByte(buf) {
  return getBytes(buf, 1)[0]
}

=========================
workspace: packages/net
file: packages/net/src/negentropy.ts
lines: 93:96
id: 40afc443fc42b789f1a56dde3eb98b3a814ba98036634cb03a812afb3f22c9ab
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/negentropy.ts#L93

declaration:
function getBytes(buf, n)

summary:
A utility function that extracts a specified number of bytes from a buffer. It takes a buffer object and a number of bytes to extract, then returns the extracted bytes. Throws an error if the buffer doesn't contain enough bytes.

details:
The implementation is straightforward:
1. First checks if the buffer has at least n bytes available using a length comparison
2. If not enough bytes are available, throws an error with message "parse ends prematurely"
3. Uses the buffer's shiftN method to extract and remove n bytes from the beginning of the buffer
4. Returns the extracted bytes as a subarray

code:
function getBytes(buf, n) {
  if (buf.length < n) throw Error("parse ends prematurely")
  return buf.shiftN(n)
}

=========================
workspace: packages/net
file: packages/net/src/negentropy.ts
lines: 98:161
id: 616819eed3d5fd9e8c04ad07a50a40ac3eaf102107fd1ce8ef8e9f90c474a780
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/negentropy.ts#L98

declaration:
class Accumulator{
  constructor();
  setToZero();
  add(otherBuf);
  negate();
  async getFingerprint(n);
}

summary:
The `Accumulator` class is used for cryptographic accumulation operations in the Negentropy protocol. It provides methods to manipulate a buffer of fixed size (ID_SIZE), including setting it to zero, adding another buffer to it, negating its value, and generating a fingerprint based on the current state and a provided number.

details:
The implementation details include:

1. The class maintains an internal buffer of ID_SIZE (32 bytes) that can be manipulated with various operations.
2. It detects the environment (Node.js vs browser) to use the appropriate SHA-256 implementation.
3. The `add` method performs addition with carry between two buffers by treating them as arrays of 32-bit integers.
4. The `negate` method performs two's complement negation by inverting all bits and adding 1.
5. The `getFingerprint` method creates a cryptographic fingerprint by:
   - Combining the current buffer with an encoded variable integer
   - Hashing the result with SHA-256
   - Returning the first FINGERPRINT_SIZE (16) bytes of the hash

The class is a core component of the Negentropy protocol's fingerprinting mechanism used for efficient set reconciliation.

code:
class Accumulator {
  constructor() {
    this.setToZero()

    if (typeof window === "undefined") {
      // node.js
      this.sha256 = async slice =>
        new Uint8Array(crypto.createHash("sha256").update(slice).digest())
    } else {
      // browser
      this.sha256 = async slice => new Uint8Array(await crypto.subtle.digest("SHA-256", slice))
    }
  }

  setToZero() {
    this.buf = new Uint8Array(ID_SIZE)
  }

  add(otherBuf) {
    let currCarry = 0,
      nextCarry = 0
    const p = new DataView(this.buf.buffer)
    const po = new DataView(otherBuf.buffer)

    for (let i = 0; i < 8; i++) {
      const offset = i * 4
      const orig = p.getUint32(offset, true)
      const otherV = po.getUint32(offset, true)

      let next = orig

      next += currCarry
      next += otherV
      if (next > 0xffffffff) nextCarry = 1

      p.setUint32(offset, next & 0xffffffff, true)
      currCarry = nextCarry
      nextCarry = 0
    }
  }

  negate() {
    const p = new DataView(this.buf.buffer)

    for (let i = 0; i < 8; i++) {
      const offset = i * 4
      p.setUint32(offset, ~p.getUint32(offset, true))
    }

    const one = new Uint8Array(ID_SIZE)
    one[0] = 1
    this.add(one)
  }

  async getFingerprint(n) {
    const input = new WrappedBuffer()
    input.extend(this.buf)
    input.extend(encodeVarInt(n))

    const hash = await this.sha256(input.unwrap())

    return hash.subarray(0, FINGERPRINT_SIZE)
  }
}

=========================
workspace: packages/net
file: packages/net/src/negentropy.ts
lines: 163:257
id: f2b2ff98b0f95867fb0242267c3571c14cce0c1046803acd11ee9bb8fd7466d1
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/negentropy.ts#L163

declaration:
class NegentropyStorageVector{
  constructor();
  insert(timestamp, id);
  seal();
  unseal();
  size();
  getItem(i);
  iterate(begin, end, cb);
  findLowerBound(begin, end, bound);
  async fingerprint(begin, end);
  _checkSealed();
  _checkBounds(begin, end);
  _binarySearch(arr, first, last, cmp);
}

summary:
NegentropyStorageVector is a class that manages a collection of timestamped items with IDs for the Negentropy protocol. It provides methods to insert items, seal the collection (which sorts and validates it), and perform operations like fingerprinting ranges of items. The class supports binary search for efficient lookups and iteration over ranges of items.

details:
The implementation details include:

1. Storage is handled via an internal `items` array containing objects with `timestamp` and `id` properties.
2. The class has a `sealed` state that must be toggled before certain operations can be performed.
3. When sealed, items are sorted using the `itemCompare` function which compares timestamps first, then IDs if timestamps are equal.
4. The class implements binary search via the `_binarySearch` method for efficient range lookups.
5. The `fingerprint` method uses an `Accumulator` to generate a cryptographic fingerprint of a range of items.
6. Range operations are protected by bounds checking to prevent invalid access.
7. The class enforces uniqueness of items when sealing by checking for duplicates.
8. The implementation supports both iteration and direct access to items via index.

code:
class NegentropyStorageVector {
  constructor() {
    this.items = []
    this.sealed = false
  }

  insert(timestamp, id) {
    if (this.sealed) throw Error("already sealed")
    id = loadInputBuffer(id)
    if (id.byteLength !== ID_SIZE) throw Error("bad id size for added item")
    this.items.push({timestamp, id})
  }

  seal() {
    if (this.sealed) throw Error("already sealed")
    this.sealed = true

    this.items.sort(itemCompare)

    for (let i = 1; i < this.items.length; i++) {
      if (itemCompare(this.items[i - 1], this.items[i]) === 0)
        throw Error("duplicate item inserted")
    }
  }

  unseal() {
    this.sealed = false
  }

  size() {
    this._checkSealed()
    return this.items.length
  }

  getItem(i) {
    this._checkSealed()
    if (i >= this.items.length) throw Error("out of range")
    return this.items[i]
  }

  iterate(begin, end, cb) {
    this._checkSealed()
    this._checkBounds(begin, end)

    for (let i = begin; i < end; ++i) {
      if (!cb(this.items[i], i)) break
    }
  }

  findLowerBound(begin, end, bound) {
    this._checkSealed()
    this._checkBounds(begin, end)

    return this._binarySearch(this.items, begin, end, a => itemCompare(a, bound) < 0)
  }

  async fingerprint(begin, end) {
    const out = new Accumulator()
    out.setToZero()

    this.iterate(begin, end, (item, i) => {
      out.add(item.id)
      return true
    })

    return await out.getFingerprint(end - begin)
  }

  _checkSealed() {
    if (!this.sealed) throw Error("not sealed")
  }

  _checkBounds(begin, end) {
    if (begin > end || end > this.items.length) throw Error("bad range")
  }

  _binarySearch(arr, first, last, cmp) {
    let count = last - first

    while (count > 0) {
      let it = first
      const step = Math.floor(count / 2)
      it += step

      if (cmp(arr[it])) {
        first = ++it
        count -= step + 1
      } else {
        count = step
      }
    }

    return first
  }
}

import/access examples:
import { NegentropyStorageVector } from '@welshman/net';
import { NegentropyStorageVector } from '@welshman/net/negentropy';


=========================
workspace: packages/net
file: packages/net/src/negentropy.ts
lines: 259:547
id: d9d3fd0fd51989a59b1dc11060563c42efa1b075802c2b84ee5e9cfa0002b855
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/negentropy.ts#L259

declaration:
class Negentropy{
  constructor(storage, frameSizeLimit = 0);
  _bound(timestamp, id);
  async initiate();
  setInitiator();
  async reconcile(query);
  async splitRange(lower, upper, upperBound, o);
  _renderOutput(o);
  exceededFrameSizeLimit(n);
  decodeTimestampIn(encoded);
  decodeBound(encoded);
  encodeTimestampOut(timestamp);
  encodeBound(key);
  getMinimalBound(prev, curr);
}

summary:
The `Negentropy` class implements a protocol for efficient set reconciliation between two parties. It allows two systems to determine and synchronize differences in their data sets with minimal data transfer. The class takes a storage object and an optional frame size limit. It provides methods for initiating reconciliation (`initiate`), continuing reconciliation (`reconcile`), and various helper methods for encoding/decoding protocol messages.

details:
The implementation uses a divide-and-conquer approach to efficiently identify differences between two sets:

1. It works by exchanging fingerprints (hashes) of ranges of items, splitting ranges recursively when fingerprints don't match.
2. The protocol has three modes: Skip, Fingerprint, and IdList, which control how ranges are processed.
3. Key components include:
   - Delta encoding for timestamps to reduce message size
   - Binary search for efficient range splitting
   - Fingerprinting using SHA-256 hashing
   - Frame size limiting to prevent oversized messages
   - Support for both initiator and responder roles

The reconciliation process works by:
1. Initiator sends an initial message with fingerprints
2. Responder compares fingerprints and responds with either more fingerprints or actual IDs
3. When differences are found, the protocol exchanges the actual IDs
4. The process continues until all differences are identified

The class handles both hex string and Uint8Array representations of data.

code:
class Negentropy {
  constructor(storage, frameSizeLimit = 0) {
    if (frameSizeLimit !== 0 && frameSizeLimit < 4096) throw Error("frameSizeLimit too small")

    this.storage = storage
    this.frameSizeLimit = frameSizeLimit

    this.lastTimestampIn = 0
    this.lastTimestampOut = 0
  }

  _bound(timestamp, id) {
    return {timestamp, id: id ? id : new Uint8Array(0)}
  }

  async initiate() {
    if (this.isInitiator) throw Error("already initiated")
    this.isInitiator = true

    const output = new WrappedBuffer()
    output.extend([PROTOCOL_VERSION])

    await this.splitRange(0, this.storage.size(), this._bound(Number.MAX_VALUE), output)

    return this._renderOutput(output)
  }

  setInitiator() {
    this.isInitiator = true
  }

  async reconcile(query) {
    const haveIds = [],
      needIds = []
    query = new WrappedBuffer(loadInputBuffer(query))

    this.lastTimestampIn = this.lastTimestampOut = 0 // reset for each message

    const fullOutput = new WrappedBuffer()
    fullOutput.extend([PROTOCOL_VERSION])

    const protocolVersion = getByte(query)
    if (protocolVersion < 0x60 || protocolVersion > 0x6f)
      throw Error("invalid negentropy protocol version byte")
    if (protocolVersion !== PROTOCOL_VERSION) {
      if (this.isInitiator)
        throw Error(
          "unsupported negentropy protocol version requested: " + (protocolVersion - 0x60),
        )
      else return [this._renderOutput(fullOutput), haveIds, needIds]
    }

    const storageSize = this.storage.size()
    let prevBound = this._bound(0)
    let prevIndex = 0
    let skip = false

    while (query.length !== 0) {
      let o = new WrappedBuffer()

      const doSkip = () => {
        if (skip) {
          skip = false
          o.extend(this.encodeBound(prevBound))
          o.extend(encodeVarInt(Mode.Skip))
        }
      }

      const currBound = this.decodeBound(query)
      const mode = decodeVarInt(query)

      const lower = prevIndex
      let upper = this.storage.findLowerBound(prevIndex, storageSize, currBound)

      if (mode === Mode.Skip) {
        skip = true
      } else if (mode === Mode.Fingerprint) {
        const theirFingerprint = getBytes(query, FINGERPRINT_SIZE)
        const ourFingerprint = await this.storage.fingerprint(lower, upper)

        if (compareUint8Array(theirFingerprint, ourFingerprint) !== 0) {
          doSkip()
          await this.splitRange(lower, upper, currBound, o)
        } else {
          skip = true
        }
      } else if (mode === Mode.IdList) {
        const numIds = decodeVarInt(query)

        const theirElems = {} // stringified Uint8Array -> original Uint8Array (or hex)
        for (let i = 0; i < numIds; i++) {
          const e = getBytes(query, ID_SIZE)
          if (this.isInitiator) theirElems[e] = e
        }

        if (this.isInitiator) {
          skip = true

          this.storage.iterate(lower, upper, item => {
            const k = item.id

            if (!theirElems[k]) {
              // ID exists on our side, but not their side
              if (this.isInitiator) haveIds.push(this.wantUint8ArrayOutput ? k : uint8ArrayToHex(k))
            } else {
              // ID exists on both sides
              delete theirElems[k]
            }

            return true
          })

          for (const v of Object.values(theirElems)) {
            // ID exists on their side, but not our side
            needIds.push(this.wantUint8ArrayOutput ? v : uint8ArrayToHex(v))
          }
        } else {
          doSkip()

          const responseIds = new WrappedBuffer()
          let numResponseIds = 0
          let endBound = currBound

          this.storage.iterate(lower, upper, (item, index) => {
            if (this.exceededFrameSizeLimit(fullOutput.length + responseIds.length)) {
              endBound = item
              upper = index // shrink upper so that remaining range gets correct fingerprint
              return false
            }

            responseIds.extend(item.id)
            numResponseIds++
            return true
          })

          o.extend(this.encodeBound(endBound))
          o.extend(encodeVarInt(Mode.IdList))
          o.extend(encodeVarInt(numResponseIds))
          o.extend(responseIds)

          fullOutput.extend(o)
          o = new WrappedBuffer()
        }
      } else {
        throw Error("unexpected mode")
      }

      if (this.exceededFrameSizeLimit(fullOutput.length + o.length)) {
        // frameSizeLimit exceeded: Stop range processing and return a fingerprint for the remaining range
        const remainingFingerprint = await this.storage.fingerprint(upper, storageSize)

        fullOutput.extend(this.encodeBound(this._bound(Number.MAX_VALUE)))
        fullOutput.extend(encodeVarInt(Mode.Fingerprint))
        fullOutput.extend(remainingFingerprint)
        break
      } else {
        fullOutput.extend(o)
      }

      prevIndex = upper
      prevBound = currBound
    }

    return [
      fullOutput.length === 1 && this.isInitiator ? null : this._renderOutput(fullOutput),
      haveIds,
      needIds,
    ]
  }

  async splitRange(lower, upper, upperBound, o) {
    const numElems = upper - lower
    const buckets = 16

    if (numElems < buckets * 2) {
      o.extend(this.encodeBound(upperBound))
      o.extend(encodeVarInt(Mode.IdList))

      o.extend(encodeVarInt(numElems))
      this.storage.iterate(lower, upper, item => {
        o.extend(item.id)
        return true
      })
    } else {
      const itemsPerBucket = Math.floor(numElems / buckets)
      const bucketsWithExtra = numElems % buckets
      let curr = lower

      for (let i = 0; i < buckets; i++) {
        const bucketSize = itemsPerBucket + (i < bucketsWithExtra ? 1 : 0)
        const ourFingerprint = await this.storage.fingerprint(curr, curr + bucketSize)
        curr += bucketSize

        let nextBound

        if (curr === upper) {
          nextBound = upperBound
        } else {
          let prevItem, currItem

          this.storage.iterate(curr - 1, curr + 1, (item, index) => {
            if (index === curr - 1) prevItem = item
            else currItem = item
            return true
          })

          nextBound = this.getMinimalBound(prevItem, currItem)
        }

        o.extend(this.encodeBound(nextBound))
        o.extend(encodeVarInt(Mode.Fingerprint))
        o.extend(ourFingerprint)
      }
    }
  }

  _renderOutput(o) {
    o = o.unwrap()
    if (!this.wantUint8ArrayOutput) o = uint8ArrayToHex(o)
    return o
  }

  exceededFrameSizeLimit(n) {
    return this.frameSizeLimit && n > this.frameSizeLimit - 200
  }

  // Decoding

  decodeTimestampIn(encoded) {
    let timestamp = decodeVarInt(encoded)
    timestamp = timestamp === 0 ? Number.MAX_VALUE : timestamp - 1
    if (this.lastTimestampIn === Number.MAX_VALUE || timestamp === Number.MAX_VALUE) {
      this.lastTimestampIn = Number.MAX_VALUE
      return Number.MAX_VALUE
    }
    timestamp += this.lastTimestampIn
    this.lastTimestampIn = timestamp
    return timestamp
  }

  decodeBound(encoded) {
    const timestamp = this.decodeTimestampIn(encoded)
    const len = decodeVarInt(encoded)
    if (len > ID_SIZE) throw Error("bound key too long")
    const id = getBytes(encoded, len)
    return {timestamp, id}
  }

  // Encoding

  encodeTimestampOut(timestamp) {
    if (timestamp === Number.MAX_VALUE) {
      this.lastTimestampOut = Number.MAX_VALUE
      return encodeVarInt(0)
    }

    const temp = timestamp
    timestamp -= this.lastTimestampOut
    this.lastTimestampOut = temp
    return encodeVarInt(timestamp + 1)
  }

  encodeBound(key) {
    const output = new WrappedBuffer()

    output.extend(this.encodeTimestampOut(key.timestamp))
    output.extend(encodeVarInt(key.id.length))
    output.extend(key.id)

    return output
  }

  getMinimalBound(prev, curr) {
    if (curr.timestamp !== prev.timestamp) {
      return this._bound(curr.timestamp)
    } else {
      let sharedPrefixBytes = 0
      const currKey = curr.id
      const prevKey = prev.id

      for (let i = 0; i < ID_SIZE; i++) {
        if (currKey[i] !== prevKey[i]) break
        sharedPrefixBytes++
      }

      return this._bound(curr.timestamp, curr.id.subarray(0, sharedPrefixBytes + 1))
    }
  }
}

import/access examples:
import { Negentropy } from '@welshman/net';
import { Negentropy } from '@welshman/net/negentropy';


=========================
workspace: packages/net
file: packages/net/src/negentropy.ts
lines: 549:553
id: 692dc37e0c32f9d96f61aa31e512ff43e4318b6f35784c4ed9b6c4723aa06d2a
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/negentropy.ts#L549

declaration:
function loadInputBuffer(inp)

summary:
The `loadInputBuffer` function converts various input formats into a Uint8Array buffer. It accepts input as a string (hex format) or a buffer-like object and ensures the output is a proper Uint8Array.

details:
This utility function handles three cases:
1. If the input is a string, it converts it from hex format to Uint8Array using the hexToUint8Array function
2. If the input is not a Uint8Array (checking prototype), it creates a new Uint8Array from the input (handling Node.js Buffer objects)
3. Otherwise, it returns the input as is

The function is used throughout the Negentropy protocol implementation to ensure consistent buffer handling regardless of input format.

code:
function loadInputBuffer(inp) {
  if (typeof inp === "string") inp = hexToUint8Array(inp)
  else if (__proto__ !== Uint8Array.prototype) inp = new Uint8Array(inp) // node Buffer?
  return inp
}

=========================
workspace: packages/net
file: packages/net/src/negentropy.ts
lines: 555:561
id: 15058a7ec10ecdc45bde1a511a7c32fcb839bc981b3e15c3c00ebdf6bb271233
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/negentropy.ts#L555

declaration:
function hexToUint8Array(h)

summary:
Converts a hexadecimal string to a Uint8Array. The function accepts a hex string (with or without '0x' prefix) and returns a Uint8Array containing the corresponding byte values.

details:
The implementation works by:
1. Removing the '0x' prefix if present
2. Checking that the hex string has an even length (since each byte requires 2 hex characters)
3. Creating a new Uint8Array with the appropriate length (half the length of the hex string)
4. Iterating through the string, converting each pair of hex characters to a byte value using parseInt with base 16
5. Storing each byte value in the array

code:
function hexToUint8Array(h) {
  if (h.startsWith("0x")) h = h.substr(2)
  if (h.length % 2 === 1) throw Error("odd length of hex string")
  const arr = new Uint8Array(h.length / 2)
  for (let i = 0; i < arr.length; i++) arr[i] = parseInt(h.substr(i * 2, 2), 16)
  return arr
}

=========================
workspace: packages/net
file: packages/net/src/negentropy.ts
lines: 563:563
id: 85fdd1731fab490d0e8d98804dc7d3138428adca3c4d5a6dc59493fba7efaa00
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/negentropy.ts#L563

declaration:
uint8ArrayToHexLookupTable = new Array(256)

summary:
A lookup table used for efficient conversion of Uint8Array values to hexadecimal strings. It's initialized as an array of 256 elements, where each element contains the two-character hex representation of its index.

details:
This variable is a pre-computed lookup table that stores the hexadecimal representation of all possible byte values (0-255). The table is initialized with an array of 256 elements, and then populated in the immediately following code block (lines 564-586) with two-character hex strings. Each index in the array corresponds to a byte value, and the value at that index is the hex representation of that byte.

This approach optimizes the uint8ArrayToHex function (lines 588-594) by eliminating the need to calculate hex values on the fly, instead allowing direct lookups from this table. This is a common performance optimization technique when converting binary data to hex strings.

=========================
workspace: packages/net
file: packages/net/src/negentropy.ts
lines: 588:594
id: 3b632d8f4c03e6782907291da4e2d4466482e7604826265f84d8b7c8c41dea8f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/negentropy.ts#L588

declaration:
function uint8ArrayToHex(arr)

summary:
Converts a Uint8Array to a hexadecimal string representation. Takes a Uint8Array as input and returns a string where each byte is represented as two hexadecimal characters.

details:
The implementation uses a pre-computed lookup table (`uint8ArrayToHexLookupTable`) for efficient conversion. For each byte in the input array, it retrieves the corresponding two-character hex representation from the lookup table and concatenates them to form the final hex string. This approach is more efficient than calculating the hex representation for each byte on-the-fly.

code:
function uint8ArrayToHex(arr) {
  let out = ""
  for (let i = 0, edx = arr.length; i < edx; i++) {
    out += uint8ArrayToHexLookupTable[arr[i]]
  }
  return out
}

=========================
workspace: packages/net
file: packages/net/src/negentropy.ts
lines: 596:606
id: 95b246060cc68145a2631b64c1e3d032e6c15e187b95398fd7a2d6bc21d4bb33
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/negentropy.ts#L596

declaration:
function compareUint8Array(a, b)

summary:
Compares two Uint8Array objects lexicographically. Returns -1 if a < b, 1 if a > b, and 0 if they are equal. The comparison is done byte by byte, and if all bytes are equal, the shorter array is considered smaller.

details:
The implementation iterates through both arrays simultaneously, comparing each byte. If a byte in array 'a' is less than the corresponding byte in array 'b', it returns -1. If a byte in 'a' is greater than in 'b', it returns 1. If all bytes that exist in both arrays are equal, it then compares the lengths of the arrays - returning 1 if 'a' is longer, -1 if 'b' is longer, and 0 if they have the same length (meaning the arrays are identical).

code:
function compareUint8Array(a, b) {
  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] < b[i]) return -1
    if (a[i] > b[i]) return 1
  }

  if (a.byteLength > b.byteLength) return 1
  if (a.byteLength < b.byteLength) return -1

  return 0
}

=========================
workspace: packages/net
file: packages/net/src/negentropy.ts
lines: 608:614
id: 79822be942515aa3105d90073811400095078e7c247fa9bf6cfff82e8f9fbd76
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/negentropy.ts#L608

declaration:
function itemCompare(a, b)

summary:
The `itemCompare` function compares two items based on their timestamps and IDs. It returns a negative number if `a` comes before `b`, a positive number if `a` comes after `b`, and zero if they are equal. Items are first compared by timestamp, and if timestamps are equal, they are compared by ID using `compareUint8Array`.

details:
This function implements a comparison algorithm for sorting items in the Negentropy protocol:

1. First checks if timestamps are equal
2. If timestamps match, it delegates to `compareUint8Array` to compare the binary IDs lexicographically
3. If timestamps differ, it returns their numeric difference (a.timestamp - b.timestamp)

The function is used internally by the `NegentropyStorageVector` class for sorting and detecting duplicates.

code:
function itemCompare(a, b) {
  if (a.timestamp === b.timestamp) {
    return compareUint8Array(a.id, b.id)
  }

  return a.timestamp - b.timestamp
}

=========================
workspace: packages/net
file: packages/net/src/request.ts
lines: 28:40
id: 67950b10b786d9f8ee067f7ba47197e3034d022aca28abd998a1438e297eca45
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/request.ts#L28

declaration:
deduplicateEvents = (events: TrustedEvent[]) => {
  const eventsByAddress = new Map<string, TrustedEvent>()

  for (const event of events) {
    const address = getAddress(event)

    if (lte(eventsByAddress.get(address)?.created_at, event.created_at)) {
      eventsByAddress.set(address, event)
    }
  }

  return Array.from(eventsByAddress.values())
}

summary:
deduplicateEvents(events: TrustedEvent[]): TrustedEvent[]

Deduplicates an array of events by their Nostr address, keeping only the most recent event for each address. It accepts a list of trusted events and returns a new array where duplicate addresses have been collapsed to the event with the highest `created_at` timestamp. No side‑effects are performed; the original array is not mutated.

details:
Implementation steps:
1. Creates a `Map<string, TrustedEvent>` called `eventsByAddress` to store the latest event for each address.
2. Iterates over the input `events` array.
3. For each event, obtains its address via `getAddress(event)`.
4. Uses `lte(eventsByAddress.get(address)?.created_at, event.created_at)` to compare timestamps; if the current event is newer (or the map has no entry), it replaces the stored event.
5. After processing all events, converts the map’s values to an array with `Array.from(eventsByAddress.values())` and returns it.

Key utilities used:
- `getAddress` from `@welshman/util` to compute a unique address string for an event.
- `lte` from `@welshman/lib` for safe numeric comparison handling undefined values.

The function is internal (non‑exported) and serves as a helper for higher‑level request functions that need to ensure a clean, deduplicated result set before resolving promises.

=========================
workspace: packages/net
file: packages/net/src/request.ts
lines: 42:57
id: 38b1066a7c91ec986b4e3a8e87948b7599dab07a8c0c9b12ef092ebe12f04661
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/request.ts#L42

declaration:
export type BaseRequestOptions = {
  signal?: AbortSignal
  tracker?: Tracker
  context?: AdapterContext
  autoClose?: boolean
  isEventValid?: (event: TrustedEvent, url: string) => boolean
  isEventDeleted?: (event: TrustedEvent, url: string) => boolean
  onEvent?: (event: TrustedEvent, url: string) => void
  onDeleted?: (event: unknown, url: string) => void
  onInvalid?: (event: unknown, url: string) => void
  onFiltered?: (event: TrustedEvent, url: string) => void
  onDuplicate?: (event: TrustedEvent, url: string) => void
  onDisconnect?: (url: string) => void
  onEose?: (url: string) => void
  onClose?: () => void
}

summary:
BaseRequestOptions is a TypeScript type that defines the common configuration options for making requests to relays in a Nostr network. It includes options for controlling request lifecycle, validation, and event handling. Key properties include:
- `signal`: AbortSignal for cancellation
- `tracker`: For tracking seen events
- `context`: AdapterContext for relay connections
- `autoClose`: Whether to automatically close the request
- Various event handlers (onEvent, onDeleted, onInvalid, etc.)
- Connection lifecycle handlers (onDisconnect, onEose, onClose)

details:
This type serves as the foundation for more specific request option types in the module. It defines a comprehensive set of optional callbacks and configuration parameters that control how requests behave, how events are validated, and how various scenarios are handled during the request lifecycle. The type is used as a base for `RequestOneOptions` and is included in the composition of `RequestOptions` and `LoadOptions`, showing its central role in the request system architecture.

related: Tracker,AdapterContext

import/access examples:
import type { BaseRequestOptions } from '@welshman/net';
import type { BaseRequestOptions } from '@welshman/net/request';


=========================
workspace: packages/net
file: packages/net/src/request.ts
lines: 59:62
id: 9e0604405708798c2d9bf141a06031636d93173d7537a1f36e671ab280c01c2a
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/request.ts#L59

declaration:
export type RequestOneOptions = BaseRequestOptions & {
  relay: string
  filters: Filter[]
}

summary:
A type alias that extends BaseRequestOptions with specific properties for making a request to a single relay. It includes:
- `relay`: A string representing the relay URL to connect to.
- `filters`: An array of Filter objects that define what events to request from the relay.

details:
This type combines the base request options (which include callback handlers, validation functions, and control parameters) with relay-specific configuration needed when making a request to a single Nostr relay. It's used as the parameter type for the `requestOne` function, providing all the necessary information to establish a connection, send filters, and process incoming events from a specific relay.

related: BaseRequestOptions

import/access examples:
import type { RequestOneOptions } from '@welshman/net';
import type { RequestOneOptions } from '@welshman/net/request';


=========================
workspace: packages/net
file: packages/net/src/request.ts
lines: 64:162
id: 20a0bf1eeefa8042064a55ad8e14f16949fb0fc8028a64a25ac704686dd0b3c6
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/request.ts#L64

declaration:
requestOne = (options: RequestOneOptions) => {
  const ids = new Set<string>()
  const eose = new Set<string>()
  const events: TrustedEvent[] = []
  const deferred = defer<TrustedEvent[]>()
  const tracker = options.tracker || new Tracker()
  const adapter = getAdapter(options.relay, options.context)
  const isEventValid = options.isEventValid || netContext.isEventValid
  const isEventDeleted = options.isEventDeleted || netContext.isEventDeleted

  let closed = false

  const close = () => {
    if (closed) return

    closed = true

    for (const id of ids) {
      adapter.send(["CLOSE", id])
    }

    options.onClose?.()
    adapter.cleanup()
    unsubscribers.map(call)
    deferred.resolve(deduplicateEvents(events))
  }

  const unsubscribers = [
    on(adapter, AdapterEvent.Receive, (message: RelayMessage, url: string) => {
      if (isRelayEvent(message)) {
        const [_, id, event] = message

        if (ids.has(id)) {
          if (tracker.track(event.id, url)) {
            options.onDuplicate?.(event, url)
          } else if (isEventDeleted(event, url)) {
            options.onDeleted?.(event, url)
          } else if (!isEventValid(event, url)) {
            options.onInvalid?.(event, url)
          } else if (!matchFilters(options.filters, event)) {
            options.onFiltered?.(event, url)
          } else {
            options.onEvent?.(event, url)
            events.push(event)
          }
        }
      }

      if (isRelayEose(message)) {
        const [_, id] = message

        if (ids.has(id)) {
          eose.add(id)

          if (eose.size === ids.size) {
            options.onEose?.(url)

            if (options.autoClose) {
              close()
            }
          }
        }
      }
    }),
  ]

  // Listen to disconnects from any sockets
  for (const socket of adapter.sockets) {
    unsubscribers.push(
      on(socket, SocketEvent.Status, (status: SocketStatus) => {
        if (![SocketStatus.Open, SocketStatus.Opening].includes(status)) {
          options.onDisconnect?.(socket.url)

          if (options.autoClose) {
            close()
          }
        }
      }),
    )
  }

  // Handle abort signal
  options.signal?.addEventListener("abort", close)

  // If we're auto-closing, make sure it happens even if the relay doesn't send an eose
  // and the caller doesn't provide a signal, in order to avoid memory leaks
  if (options.autoClose && !options.signal) {
    setTimeout(close, 30_000)
  }

  for (const filter of options.filters) {
    const id = `REQ-${randomId().slice(0, 8)}`

    ids.add(id)
    adapter.send([ClientMessageType.Req, id, filter])
  }

  return deferred
}

summary:
A function that sends a request to a single relay with specified filters and returns a promise that resolves with deduplicated events. It handles event validation, filtering, and tracking duplicates. The function accepts options including relay URL, filters, abort signal, event handlers, and auto-close behavior. It returns a deferred promise that resolves with the collected events when the request completes.

details:
Implementation details:
1. Sets up tracking for request IDs, EOSE (End of Stored Events) signals, and collected events
2. Creates a deferred promise to return to the caller
3. Gets or creates a tracker for deduplicating events across relays
4. Gets an adapter for the specified relay
5. Implements a close function that:
   - Sends CLOSE messages to the relay
   - Cleans up resources
   - Resolves the promise with deduplicated events
6. Sets up event listeners for:
   - Relay messages (events and EOSE signals)
   - Socket status changes
   - Abort signals
7. Implements auto-closing with a 30-second timeout if enabled
8. For each filter, generates a unique request ID and sends a REQ message to the relay
9. Handles various event conditions (duplicates, deleted, invalid, filtered)
10. Uses a complex event flow to properly track when all requests are complete

related: RequestOneOptions

import/access examples:
import { requestOne } from '@welshman/net';
import { requestOne } from '@welshman/net/request';


=========================
workspace: packages/net
file: packages/net/src/request.ts
lines: 164:168
id: 56a983d85a358d4017295edab8f6e31e05b6775f4f9804e293817a6a268074e5
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/request.ts#L164

declaration:
export type RequestOptions = BaseRequestOptions & {
  relays: string[]
  filters: Filter[]
  threshold?: number
}

summary:
A type definition that extends BaseRequestOptions for making requests to multiple relays. It includes properties for specifying relays, filters, and an optional threshold for determining when to consider the request complete.

details:
This type alias combines the BaseRequestOptions with additional properties specific to multi-relay requests:
1. `relays`: An array of relay URLs to connect to
2. `filters`: An array of Filter objects to apply to events
3. `threshold`: An optional number (between 0 and 1) that determines what portion of relays need to respond before considering the request complete

related: BaseRequestOptions

import/access examples:
import type { RequestOptions } from '@welshman/net';
import type { RequestOptions } from '@welshman/net/request';


=========================
workspace: packages/net
file: packages/net/src/request.ts
lines: 170:202
id: 62d0471c16c8984cd7056c4eab0f5498ed78d15bda5649abe19506bd13b635b4
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/request.ts#L170

declaration:
request = async (options: RequestOptions) => {
  const closed = new Set<string>()
  const ctrl = new AbortController()
  const relays = new Set(options.relays)
  const tracker = options.tracker || new Tracker()
  const signal = options.signal ? AbortSignal.any([options.signal, ctrl.signal]) : ctrl.signal
  const threshold = options.threshold || 1

  if (relays.size !== options.relays.length) {
    console.warn("Non-unique relays passed to request")
  }

  return flatten(
    await Promise.all(
      Array.from(relays).map(relay =>
        requestOne({
          ...options,
          tracker,
          signal,
          relay,
          onClose: () => {
            closed.add(relay)

            if (closed.size >= relays.size * threshold) {
              options.onClose?.()
              ctrl.abort()
            }
          },
        }),
      ),
    ),
  )
}

summary:
The `request` function sends a request to multiple relays with specified filters and returns a promise that resolves to an array of trusted events. It handles deduplication of events across relays and supports configurable thresholds for determining when to close the request.

Parameters:
- `options`: RequestOptions object containing:
  - `relays`: Array of relay URLs to query
  - `filters`: Array of filters to apply
  - `threshold`: Optional fraction (0-1) of relays that need to respond before resolving (defaults to 1)
  - Various callback options for events, disconnections, etc.
  - `signal`: Optional AbortSignal to cancel the request
  - `tracker`: Optional Tracker instance for deduplication

Returns: Promise<TrustedEvent[]> - A flattened array of deduplicated events from all relays.

details:
The implementation works by:

1. Setting up state tracking with Sets for closed relays and creating an AbortController
2. Creating a combined abort signal if the user provided one
3. Deduplicating the relay list with a Set
4. Mapping each relay to a call to `requestOne` with the same options plus:
   - Shared tracker instance for cross-relay deduplication
   - Custom onClose handler that tracks closed relays and aborts when threshold is reached
5. Using Promise.all to wait for all relay requests to complete
6. Flattening the resulting array of arrays into a single array of events

The threshold mechanism allows the request to complete early when enough relays have responded, which is useful for optimizing performance in unreliable networks.

related: RequestOptions

import/access examples:
import { request } from '@welshman/net';
import { request } from '@welshman/net/request';


=========================
workspace: packages/net
file: packages/net/src/request.ts
lines: 204:211
id: 91e5a668c6c14301a07a25c4263ca384114dbfcd570aa464f8e4312a82c7f41a
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/request.ts#L204

declaration:
export type LoaderOptions = {
  delay: number
  timeout?: number
  threshold?: number
  context?: AdapterContext
  isEventValid?: (event: TrustedEvent, url: string) => boolean
  isEventDeleted?: (event: TrustedEvent, url: string) => boolean
}

summary:
LoaderOptions is a type alias that defines configuration options for creating a loader function. It includes settings for request timing, validation, and event handling. Properties include:
- delay: The time to wait before batching requests (in milliseconds)
- timeout: Optional maximum time to wait for responses (in milliseconds)
- threshold: Optional value between 0-1 determining the proportion of relays needed to respond before resolving
- context: Optional adapter context for relay connections
- isEventValid: Optional function to validate events
- isEventDeleted: Optional function to check if events are deleted

details:
This type is used as the parameter type for the `makeLoader` function, which creates a batched request handler for Nostr events. The configuration options control how the loader will batch and process requests, handle timeouts, and validate events. The threshold property is particularly important as it determines how many relays need to respond before considering a request complete, which helps balance between speed and completeness of results.

related: AdapterContext

import/access examples:
import type { LoaderOptions } from '@welshman/net';
import type { LoaderOptions } from '@welshman/net/request';


=========================
workspace: packages/net
file: packages/net/src/request.ts
lines: 213:221
id: e71750db448d23b30f92b65f865587b79dce551c3ea0cfe8492779586b4f1fdc
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/request.ts#L213

declaration:
export type LoadOptions = {
  relays: string[]
  filters: Filter[]
  signal?: AbortSignal
  onEvent?: (event: TrustedEvent, url: string) => void
  onDisconnect?: (url: string) => void
  onEose?: (url: string) => void
  onClose?: () => void
}

summary:
LoadOptions is a type definition that specifies the configuration for loading events from Nostr relays. It includes the following properties:
- relays: An array of relay URLs to connect to
- filters: An array of Filter objects to query events
- signal: Optional AbortSignal to cancel the request
- onEvent: Optional callback function triggered when an event is received
- onDisconnect: Optional callback function triggered when a relay disconnects
- onEose: Optional callback function triggered when a relay sends an End of Stored Events signal
- onClose: Optional callback function triggered when the request is closed

details:
This type is used as the parameter type for the `Loader` function type and is consumed by the `load` function. It defines the interface for making requests to Nostr relays, specifying which relays to connect to and what filters to apply. The callbacks provide hooks for handling various events during the request lifecycle, allowing consumers to react to events as they arrive rather than waiting for the entire request to complete.

import/access examples:
import type { LoadOptions } from '@welshman/net';
import type { LoadOptions } from '@welshman/net/request';


=========================
workspace: packages/net
file: packages/net/src/request.ts
lines: 223:223
id: eee1da35b0b47f999b1772776103d29a4d8516b0287ee7d81db38fcf931a3780
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/request.ts#L223

declaration:
export type Loader = (options: LoadOptions) => Promise<TrustedEvent[]>

summary:
A **Loader** is a function type that accepts a single argument `options` of type `LoadOptions` (which specifies the relays to query, filters to apply, optional abort signal, and optional callbacks such as `onEvent`, `onDisconnect`, `onEose`, and `onClose`). It returns a `Promise` that resolves to an array of `TrustedEvent` objects representing the events collected from the requested relays.

related: LoadOptions

import/access examples:
import type { Loader } from '@welshman/net';
import type { Loader } from '@welshman/net/request';


=========================
workspace: packages/net
file: packages/net/src/request.ts
lines: 232:327
id: f262160e39c278cc3edd928278e797439bad0f5c06d8ba21b9c6197c2cb885b4
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/request.ts#L232

declaration:
makeLoader = (options: LoaderOptions) =>
  batcher(options.delay, (allRequests: LoadOptions[]) => {
    const resultsByRequest = new Map<LoadOptions, Deferred<TrustedEvent[]>>()
    const eventsByRequest = new Map<LoadOptions, TrustedEvent[]>()
    const requestsByRelay = new Map<string, LoadOptions[]>()
    const controllersByRelay = new Map<string, AbortController>()
    const signalsByRelay = new Map<string, AbortSignal>()
    const closedRequestsByRelay = new Map<string, Set<LoadOptions>>()
    const closedRelaysByRequest = new Map<LoadOptions, Set<string>>()
    const relays = uniq(allRequests.flatMap(r => r.relays))
    const threshold = options.threshold || 1
    const tracker = new Tracker()

    const close = (relay: string, request: LoadOptions) => {
      addToMapKey(closedRequestsByRelay, relay, request)
      addToMapKey(closedRelaysByRequest, request, relay)

      const closedRelays = closedRelaysByRequest.get(request)?.size || 0
      if (closedRelays >= uniq(request.relays).length * threshold) {
        const events = deduplicateEvents(eventsByRequest.get(request) || [])

        request.onClose?.()
        resultsByRequest.get(request)?.resolve(events)
      }

      if (closedRequestsByRelay.get(relay)?.size === requestsByRelay.get(relay)?.length) {
        controllersByRelay.get(relay)?.abort()
      }
    }

    for (const request of allRequests) {
      for (const relay of uniq(request.relays)) {
        pushToMapKey(requestsByRelay, relay, request)
        resultsByRequest.set(request, defer())

        // Propagate abort when all requests have been closed for a given relay
        request.signal?.addEventListener("abort", () => close(relay, request))
      }
    }

    // Create an abort controller for each relay
    for (const relay of relays) {
      const controller = new AbortController()
      const signals = [controller.signal]

      if (options.timeout) {
        signals.push(AbortSignal.timeout(options.timeout))
      }

      controllersByRelay.set(relay, controller)
      signalsByRelay.set(relay, AbortSignal.any(signals))
    }

    Array.from(requestsByRelay).forEach(([relay, requests]) => {
      // Union all filters for a given request and send them together
      const filters = unionFilters(requests.flatMap(r => r.filters))

      // Propagate events to caller, but only for requests that have not been aborted
      const getOpenRequests = () =>
        requests.filter(request => !closedRequestsByRelay.get(relay)?.has(request))

      requestOne({
        relay,
        filters,
        tracker,
        autoClose: true,
        signal: signalsByRelay.get(relay),
        context: options.context,
        isEventValid: options.isEventValid,
        isEventDeleted: options.isEventDeleted,
        onEvent: (event: TrustedEvent, url: string) => {
          for (const request of getOpenRequests()) {
            if (matchFilters(request.filters, event)) {
              pushToMapKey(eventsByRequest, request, event)
              request.onEvent?.(event, url)

              // Calculate cardinality for unioned filters so that we can return early
              if (request.filters.length === 1) {
                const cardinality = getFilterResultCardinality(request.filters[0])

                if (eventsByRequest.get(request)?.length === cardinality) {
                  close(relay, request)
                }
              }
            }
          }
        },
        onDisconnect: (url: string) =>
          getOpenRequests().forEach(request => request.onDisconnect?.(url)),
        onEose: (url: string) => getOpenRequests().forEach(request => request.onEose?.(url)),
        onClose: () => requests.forEach(request => close(relay, request)),
      })
    })

    return allRequests.map(r => resultsByRequest.get(r) || [])
  }) as Loader

summary:
Creates a function that efficiently loads events from multiple relays based on specified filters. The returned loader function batches requests, optimizes network traffic by unioning filters, and can return early if filter cardinality is known. It accepts LoadOptions including relays, filters, and various callbacks, and returns a Promise resolving to an array of TrustedEvent objects. The loader supports configurable delay, timeout, threshold for considering requests complete, and custom event validation.

details:
The implementation uses a batching mechanism to group multiple load requests that occur within a specified delay window. For each batch:

1. It maintains several tracking maps to manage the state of requests, events, and relay connections
2. It creates a unified request for each relay by combining filters from all requests targeting that relay
3. It sets up abort controllers with configurable timeouts for each relay
4. When events arrive, they're matched against each request's filters and distributed to appropriate requesters
5. It implements early completion logic based on filter cardinality (when a request has received all expected events)
6. It handles relay disconnections and EOSE (End of Stored Events) signals
7. The close function manages the completion logic, resolving promises when enough relays have responded
8. The threshold parameter (defaulting to 1) determines what fraction of relays must respond before considering a request complete

The implementation efficiently handles multiple concurrent requests to the same relays by batching them together, reducing network overhead.

related: batcher,LoaderOptions,Loader

import/access examples:
import { makeLoader } from '@welshman/net';
import { makeLoader } from '@welshman/net/request';


=========================
workspace: packages/net
file: packages/net/src/request.ts
lines: 329:329
id: 2a10f61f3f526114eadebb3354c1a815bc6b1337f50672b9d5c71e548ca9de84
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/request.ts#L329

declaration:
load = makeLoader({delay: 200, timeout: 3000, threshold: 0.5})

summary:
A pre-configured loader function for fetching events from Nostr relays. It's created with specific default settings: a 200ms delay for batching requests, a 3000ms timeout for relay responses, and a threshold of 0.5 (meaning it considers the request complete when at least half of the relays have responded). This function simplifies the process of loading events from multiple relays with batching optimization.

details:
This is a simple variable declaration that creates a pre-configured instance of a loader function by calling `makeLoader()` with specific parameters:

1. delay: 200ms - determines how long to wait before batching requests together
2. timeout: 3000ms - maximum time to wait for relay responses before aborting
3. threshold: 0.5 - considers the request complete when 50% of relays have responded

The implementation details are handled by the `makeLoader` function, which creates a batched request handler for Nostr events.

related: __function,makeLoader,Loader

import/access examples:
import { load } from '@welshman/net';
import { load } from '@welshman/net/request';


=========================
workspace: packages/net
file: packages/net/src/publish.ts
lines: 5:12
id: 8eb771fd88f9e9ac654da95a92d9925fc9a32ec8f8487771e2a7edf4ece27a40
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/publish.ts#L5

declaration:
export enum PublishStatus {
  Sending = "publish:status:sending",
  Pending = "publish:status:pending",
  Success = "publish:status:success",
  Failure = "publish:status:failure",
  Timeout = "publish:status:timeout",
  Aborted = "publish:status:aborted",
}

summary:
An enumeration representing the various states of a publish operation to a relay. It includes states like Sending, Pending, Success, Failure, Timeout, and Aborted, each with a unique string identifier.

details:
This enum is used throughout the publish module to track and communicate the status of event publishing operations. The string values follow a consistent pattern of 'publish:status:X' where X is the lowercase name of the status. These status values are used in the return values of publish operations and in the status tracking objects.

import/access examples:
import { PublishStatus } from '@welshman/net';
import { PublishStatus } from '@welshman/net/publish';


=========================
workspace: packages/net
file: packages/net/src/publish.ts
lines: 14:17
id: 0af5f37165f39f008e123872d8ebe95a0213fe6131e8ab5d59ffe53434db162e
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/publish.ts#L14

declaration:
export type PublishResult = {
  status: PublishStatus
  detail: string
}

summary:
PublishResult is a type that represents the outcome of a publish operation. It contains two properties: 'status' which is a PublishStatus enum value indicating the state of the publish operation (sending, pending, success, failure, timeout, or aborted), and 'detail' which is a string providing additional information about the result.

details:
This is a simple type definition that serves as a data structure for returning publish operation results. It doesn't contain implementation logic itself but is used by the publish-related functions to communicate the outcome of publishing events to relays.

related: PublishStatus

import/access examples:
import type { PublishResult } from '@welshman/net';
import type { PublishResult } from '@welshman/net/publish';


=========================
workspace: packages/net
file: packages/net/src/publish.ts
lines: 19:31
id: 132935352e4d4072e1d6b18da97abea4998d96ff43e4b8039ed1af945e9eb5c1
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/publish.ts#L19

declaration:
export type PublishOneOptions = {
  event: SignedEvent
  relay: string
  signal?: AbortSignal
  timeout?: number
  context?: AdapterContext
  onSuccess?: (detail: string) => void
  onFailure?: (detail: string) => void
  onPending?: () => void
  onTimeout?: () => void
  onAborted?: () => void
  onComplete?: () => void
}

summary:
PublishOneOptions is a type that defines the configuration for publishing a single event to a relay in a Nostr network. It includes the event to publish, the relay URL, optional abort signal, timeout, context, and various callback functions for different publishing states (success, failure, pending, timeout, aborted, and completion).

details:
This type is part of the publishing mechanism in the library and contains:

1. Required fields:
   - `event`: A SignedEvent to be published
   - `relay`: A string URL of the relay to publish to

2. Optional configuration:
   - `signal`: AbortSignal for cancellation
   - `timeout`: Number of milliseconds before timing out
   - `context`: AdapterContext for relay connection

3. Optional callbacks for different states:
   - `onSuccess`: Called when publish succeeds
   - `onFailure`: Called when publish fails
   - `onPending`: Called when publish is pending
   - `onTimeout`: Called when publish times out
   - `onAborted`: Called when publish is aborted
   - `onComplete`: Called when publish completes (regardless of outcome)

This type is used by the `publishOne` function to handle publishing a single event to a single relay.

related: AdapterContext

import/access examples:
import type { PublishOneOptions } from '@welshman/net';
import type { PublishOneOptions } from '@welshman/net/publish';


=========================
workspace: packages/net
file: packages/net/src/publish.ts
lines: 33:84
id: 5525395a5023ff7c09359968e8da781bdec6eae08f5d363769c9b887515e7376
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/publish.ts#L33

declaration:
publishOne = (options: PublishOneOptions) =>
  new Promise(resolve => {
    const adapter = getAdapter(options.relay, options.context)

    let status = PublishStatus.Pending

    options.onPending?.()

    const cleanup = () => {
      options.onComplete?.()
      adapter.cleanup()
      resolve(status)
    }

    adapter.on(AdapterEvent.Receive, (message: RelayMessage, url: string) => {
      if (isRelayOk(message)) {
        const [_, id, ok, detail] = message

        if (id !== options.event.id) return

        if (ok) {
          status = PublishStatus.Success
          options.onSuccess?.(detail)
        } else {
          status = PublishStatus.Failure
          options.onFailure?.(detail)
        }

        cleanup()
      }
    })

    options.signal?.addEventListener("abort", () => {
      if (status === PublishStatus.Pending) {
        status = PublishStatus.Aborted
        options.onAborted?.()
      }

      cleanup()
    })

    setTimeout(() => {
      if (status === PublishStatus.Pending) {
        status = PublishStatus.Timeout
        options.onTimeout?.()
      }

      cleanup()
    }, options.timeout || 10_000)

    adapter.send([ClientMessageType.Event, options.event])
  })

summary:
Publishes a signed event to a single relay and returns a promise that resolves with the publish status. Takes a PublishOneOptions object containing the event to publish, relay URL, optional abort signal, timeout, context, and various callback functions for different publish statuses (success, failure, pending, timeout, aborted, complete).

details:
Implementation details:
1. Creates an adapter for the specified relay using getAdapter
2. Sets initial status to Pending and calls the onPending callback
3. Defines a cleanup function that calls onComplete, cleans up the adapter, and resolves the promise with the final status
4. Sets up event listeners:
   - Listens for relay responses and checks if they're OK responses
   - Verifies the event ID matches and updates status accordingly (Success/Failure)
   - Handles abort signals by setting status to Aborted if still pending
   - Sets a timeout (default 10 seconds) that sets status to Timeout if still pending
5. Sends the event to the relay using the adapter
6. Returns a promise that resolves with the final publish status

related: PublishOneOptions

import/access examples:
import { publishOne } from '@welshman/net';
import { publishOne } from '@welshman/net/publish';


=========================
workspace: packages/net
file: packages/net/src/publish.ts
lines: 86:86
id: 9d8eaffa805dbb09e62763b4737118bb8b917d34a3a92ddf4e5895f7e5957c0b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/publish.ts#L86

declaration:
export type PublishStatusByRelay = Record<string, PublishStatus>

summary:
A type alias that represents a record mapping relay URLs (strings) to their corresponding publish statuses. It's used to track the status of event publications across multiple relays.

details:
This is a simple type alias that creates a dictionary type where keys are relay URLs (strings) and values are PublishStatus enum values. It's primarily used as the return type of the `publish` function to report the final status of each relay after attempting to publish an event.

related: PublishStatus

import/access examples:
import type { PublishStatusByRelay } from '@welshman/net';
import type { PublishStatusByRelay } from '@welshman/net/publish';


=========================
workspace: packages/net
file: packages/net/src/publish.ts
lines: 88:100
id: 1a75aa258520572f14de9347c213484c9dc695cbfba452ef63999231d089784d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/publish.ts#L88

declaration:
export type PublishOptions = {
  event: SignedEvent
  relays: string[]
  signal?: AbortSignal
  timeout?: number
  context?: AdapterContext
  onSuccess?: (detail: string, relay: string) => void
  onFailure?: (detail: string, relay: string) => void
  onPending?: (relay: string) => void
  onTimeout?: (relay: string) => void
  onAborted?: (relay: string) => void
  onComplete?: () => void
}

summary:
PublishOptions is a type that defines the configuration for publishing a signed event to multiple relays. It includes properties for the event to publish, target relays, optional abort signal, timeout, context, and various callback functions that are triggered during different stages of the publishing process.

details:
This type defines the structure for options passed to the `publish` function. It contains:

1. `event`: The SignedEvent to be published
2. `relays`: An array of relay URLs to publish to
3. `signal`: Optional AbortSignal for cancellation
4. `timeout`: Optional timeout in milliseconds
5. `context`: Optional adapter context
6. Callback functions for different publishing states:
   - `onSuccess`: Called when publishing succeeds on a relay
   - `onFailure`: Called when publishing fails on a relay
   - `onPending`: Called when publishing is pending on a relay
   - `onTimeout`: Called when publishing times out on a relay
   - `onAborted`: Called when publishing is aborted on a relay
   - `onComplete`: Called when publishing is complete on all relays

related: AdapterContext

import/access examples:
import type { PublishOptions } from '@welshman/net';
import type { PublishOptions } from '@welshman/net/publish';


=========================
workspace: packages/net
file: packages/net/src/publish.ts
lines: 102:152
id: 1a4963b43750fdcb8fe5a87f0a75708f68b179367d997bebb0f3d69e3865d4ff
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/publish.ts#L102

declaration:
publish = async (options: PublishOptions) => {
  const {event, timeout, signal, context} = options
  const status: PublishStatusByRelay = {}
  const completed = new Set<string>()
  const relays = new Set(options.relays)

  if (relays.size !== options.relays.length) {
    console.warn("Non-unique relays passed to publish")
  }

  await Promise.all(
    options.relays.map(relay =>
      publishOne({
        event,
        relay,
        signal,
        timeout,
        context,
        onSuccess: (detail: string) => {
          status[relay] = PublishStatus.Success
          options.onSuccess?.(detail, relay)
        },
        onFailure: (detail: string) => {
          status[relay] = PublishStatus.Failure
          options.onFailure?.(detail, relay)
        },
        onPending: () => {
          status[relay] = PublishStatus.Pending
          options.onPending?.(relay)
        },
        onTimeout: () => {
          status[relay] = PublishStatus.Timeout
          options.onTimeout?.(relay)
        },
        onAborted: () => {
          status[relay] = PublishStatus.Aborted
          options.onAborted?.(relay)
        },
        onComplete: () => {
          completed.add(relay)

          if (completed.size === relays.size) {
            options.onComplete?.()
          }
        },
      }),
    ),
  )

  return status
}

summary:
Publishes a signed event to multiple relays concurrently and returns the status of each publish operation. It accepts options including the event to publish, an array of relay URLs, optional abort signal, timeout, context, and various callback functions for different publish statuses (success, failure, pending, timeout, aborted, and completion). The function returns a record mapping relay URLs to their final publish status.

details:
Implementation details:

1. The function first extracts necessary parameters from the options object and initializes tracking variables:
   - A status object to track publish status for each relay
   - A completed Set to track which relays have finished processing
   - A Set of relays to detect and warn about duplicates

2. It checks for duplicate relays in the input array and logs a warning if found

3. The core implementation uses Promise.all to concurrently publish to all relays by:
   - Mapping each relay to a publishOne call with appropriate parameters
   - Setting up callback handlers that:
     - Update the status object with the appropriate PublishStatus
     - Call the corresponding user-provided callbacks with relevant details
     - Track completion status and trigger the onComplete callback when all relays are done

4. Finally, it returns the status object containing the final publish status for each relay

related: PublishOptions,PublishStatusByRelay

import/access examples:
import { publish } from '@welshman/net';
import { publish } from '@welshman/net/publish';


=========================
workspace: packages/net
file: packages/net/src/diff.ts
lines: 16:20
id: 013080450711273498c53c9a3e164fd47b4a4acdfcdadfa7cac8dcaad6337830
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/diff.ts#L16

declaration:
export enum DifferenceEvent {
  Message = "difference:event:message",
  Error = "difference:event:error",
  Close = "difference:event:close",
}

summary:
DifferenceEvent is an enumeration that defines event types emitted by the Difference class during the negentropy synchronization process. It includes three event types: Message (when difference data is received), Error (when an error occurs), and Close (when the connection is closed).

details:
This enum is part of the event system for the Difference class, which implements the negentropy protocol for efficient set reconciliation between clients and relays. The enum values are string constants with namespaced identifiers (prefixed with 'difference:event:') to avoid potential naming collisions. These events are used in conjunction with the EventEmitter pattern to notify subscribers about the state of the synchronization process.

import/access examples:
import { DifferenceEvent } from '@welshman/net';
import { DifferenceEvent } from '@welshman/net/diff';


=========================
workspace: packages/net
file: packages/net/src/diff.ts
lines: 22:26
id: b26c8365f6745ffd7adc08b74d46b58ab216dca8431be91a0f35ddb286f7b260
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/diff.ts#L22

declaration:
export type DifferenceEvents = {
  [DifferenceEvent.Message]: (payload: {have: string[]; need: string[]}, url: string) => void
  [DifferenceEvent.Error]: (error: string, url: string) => void
  [DifferenceEvent.Close]: () => void
}

summary:
DifferenceEvents is a TypeScript type that defines the event handlers for the Difference class. It maps each event type from the DifferenceEvent enum to its corresponding event handler function signature. The type includes handlers for three events: Message (receiving have/need lists), Error (handling error messages), and Close (when the difference process ends).

details:
This type definition uses TypeScript's mapped type syntax to create a dictionary where:
1. Keys are from the DifferenceEvent enum
2. Values are the corresponding event handler function types

Specifically, it defines:
- Message event handler: Receives payload with 'have' and 'need' string arrays and the relay URL
- Error event handler: Receives an error string and the relay URL
- Close event handler: Takes no parameters

This type is used with EventEmitter to provide type safety when registering event handlers for the Difference class.

import/access examples:
import type { DifferenceEvents } from '@welshman/net';
import type { DifferenceEvents } from '@welshman/net/diff';


=========================
workspace: packages/net
file: packages/net/src/diff.ts
lines: 28:33
id: 333f7713bffa9fef0ba4f02ac6942467b98c09bb5717e549109228b4bede9e8e
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/diff.ts#L28

declaration:
export type DifferenceOptions = {
  relay: string
  filter: Filter
  events: SignedEvent[]
  context?: AdapterContext
}

summary:
DifferenceOptions is a type that defines the configuration parameters for the Difference class, which handles event synchronization between clients and relays using the Negentropy protocol. It includes the following properties: relay (string) - the URL of the relay to connect to, filter (Filter) - criteria for filtering events, events (SignedEvent[]) - array of events to synchronize, and an optional context (AdapterContext) for adapter configuration.

details:
This type serves as the configuration interface for the Difference class constructor. It contains the essential parameters needed to establish a Negentropy-based synchronization session:

1. relay: Specifies the target relay server URL
2. filter: Defines criteria for filtering which events to synchronize
3. events: Provides the local collection of signed events to compare with the relay
4. context (optional): Provides additional configuration for the adapter that will handle the connection

These options are used internally to initialize the Negentropy protocol, which efficiently determines which events the client has that the relay needs and vice versa.

related: AdapterContext

import/access examples:
import type { DifferenceOptions } from '@welshman/net';
import type { DifferenceOptions } from '@welshman/net/diff';


=========================
workspace: packages/net
file: packages/net/src/diff.ts
lines: 35:112
id: 2401d0e77cb7c323aa9f65e4c18a8c992e87957d812213dd473f2fd8cc505aa7
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/diff.ts#L35

declaration:
export class Difference extends EventEmitter{
  have: Set<string>;
  need: Set<string>;
  _id: string;
  _unsubscriber: () => void;
  _adapter: AbstractAdapter;
  _closed: boolean;
  constructor(readonly options: DifferenceOptions);
  close();
}

summary:
The `Difference` class extends EventEmitter to facilitate the comparison of events between a client and a relay using the Negentropy protocol. It establishes a connection to a relay, reconciles event differences, and emits events when differences are found. The class tracks events the client has (`have`) and events the client needs (`need`). It requires options including a relay URL, filter criteria, and a list of events to compare. The class provides methods to close the connection and clean up resources.

details:
Implementation details:
1. The class initializes with a unique ID (`_id`), sets up a relay adapter, and creates a Negentropy instance with a storage vector.
2. It populates the storage vector with the provided events (by timestamp and ID) and seals it.
3. It sets up event listeners for relay messages, specifically handling Negentropy messages and errors.
4. When Negentropy messages are received, it:
   - Reconciles differences using the Negentropy protocol
   - Updates internal `have` and `need` sets
   - Emits a Message event with the differences
   - Sends follow-up messages if needed
5. It initiates the Negentropy protocol by sending an opening message to the relay.
6. The `close()` method sends a closing message to the relay, emits a Close event, removes listeners, and cleans up resources.
7. The implementation uses an adapter pattern to abstract relay communication details.

related: AbstractAdapter,DifferenceOptions

code:
export class Difference extends EventEmitter {
  have = new Set<string>()
  need = new Set<string>()

  _id = `NEG-${randomId().slice(0, 8)}`
  _unsubscriber: () => void
  _adapter: AbstractAdapter
  _closed = false

  constructor(readonly options: DifferenceOptions) {
    super()

    // Set up our adapter
    this._adapter = getAdapter(this.options.relay, this.options.context)

    // Set up negentropy
    const storage = new NegentropyStorageVector()
    const neg = new Negentropy(storage, 50_000)

    for (const event of this.options.events) {
      storage.insert(event.created_at, event.id)
    }

    storage.seal()

    // Add listeners
    this._unsubscriber = on(
      this._adapter,
      AdapterEvent.Receive,
      async (message: RelayMessage, url: string) => {
        if (isRelayNegMsg(message)) {
          const [_, negid, msg] = message

          if (negid === this._id) {
            const [newMsg, have, need] = await neg.reconcile(msg)

            for (const id of have) {
              this.have.add(id)
            }

            for (const id of need) {
              this.need.add(id)
            }

            this.emit(DifferenceEvent.Message, {have, need}, url)

            if (newMsg) {
              this._adapter.send([RelayMessageType.NegMsg, this._id, newMsg])
            }
          }
        }

        if (isRelayNegErr(message)) {
          const [_, negid, msg] = message

          if (negid === this._id) {
            this.emit(DifferenceEvent.Error, msg, url)
          }
        }
      },
    )

    neg.initiate().then((msg: string) => {
      this._adapter.send([ClientMessageType.NegOpen, this._id, this.options.filter, msg])
    })
  }

  close() {
    if (this._closed) return

    this._adapter.send([ClientMessageType.NegClose, this._id])
    this.emit(DifferenceEvent.Close)
    this.removeAllListeners()
    this._adapter.cleanup()
    this._unsubscriber()
    this._closed = true
  }
}

import/access examples:
import { Difference } from '@welshman/net';
import { Difference } from '@welshman/net/diff';


=========================
workspace: packages/net
file: packages/net/src/diff.ts
lines: 116:121
id: 040d6f2edb289abd661b57fec8f74e03a87ac7cbc51db2fae82033ba3088ff1d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/diff.ts#L116

declaration:
export type DiffOptions = {
  relays: string[]
  filters: Filter[]
  events: SignedEvent[]
  context?: AdapterContext
}

summary:
DiffOptions is a type alias that defines the configuration options for the diff function. It specifies the parameters needed to compare event sets across multiple relays using the Negentropy protocol. The type includes the following properties: relays (an array of relay URLs), filters (an array of Filter objects to specify which events to compare), events (an array of SignedEvent objects representing the local event set), and an optional context for adapter configuration.

details:
This type serves as the parameter interface for the diff function which performs Negentropy-based set reconciliation across multiple relays and filters. The structure is designed to support batch operations where the same comparison needs to be performed against multiple relays with potentially different filters. The context property is passed to the underlying adapter system to configure connection behavior.

related: AdapterContext

import/access examples:
import type { DiffOptions } from '@welshman/net';
import type { DiffOptions } from '@welshman/net/diff';


=========================
workspace: packages/net
file: packages/net/src/diff.ts
lines: 123:127
id: 40ea732eb6e3f6c9c3a090c0e00369a7ae7e697ced7e210f35c8b1d136c0f77b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/diff.ts#L123

declaration:
export type DiffItem = {
  relay: string
  have: Set<string>
  need: Set<string>
}

summary:
DiffItem is a type alias that represents the result of a difference operation between a relay and a set of events. It contains three properties: 'relay' (the relay URL string), 'have' (a Set of event IDs that the relay has), and 'need' (a Set of event IDs that the relay needs).

details:
This type is used in the diff function to track which events are present or missing on specific relays. It serves as an intermediate data structure during the reconciliation process, storing the results of the negentropy protocol execution. The 'have' and 'need' Sets contain string IDs representing events that either exist on the relay or need to be sent to the relay, respectively.

import/access examples:
import type { DiffItem } from '@welshman/net';
import type { DiffItem } from '@welshman/net/diff';


=========================
workspace: packages/net
file: packages/net/src/diff.ts
lines: 129:175
id: 511db0abf3f2747703dc1a226c705f0bb58b3e9ad4072fdf7fb87c510df172d2
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/diff.ts#L129

declaration:
diff = async ({relays, filters, ...options}: DiffOptions) => {
  const diffs = flatten(
    await Promise.all(
      relays.flatMap(async relay => {
        return await Promise.all(
          filters.map(
            async filter =>
              new Promise<DiffItem>((resolve, reject) => {
                const diff = new Difference({relay, filter, ...options})

                diff.on(DifferenceEvent.Close, () => {
                  resolve({relay, have: diff.have, need: diff.need})
                })

                diff.on(DifferenceEvent.Error, (url, message) => {
                  reject(message)
                  diff.close()
                })

                sleep(30_000).then(() => {
                  reject("timeout")
                  diff.close()
                })
              }),
          ),
        )
      }),
    ),
  )

  return Array.from(groupBy(diff => diff.relay, diffs).entries()).map(([relay, diffs]) => {
    const have = new Set<string>()
    const need = new Set<string>()

    for (const diff of diffs) {
      for (const id of diff.have) {
        have.add(id)
      }

      for (const id of diff.need) {
        need.add(id)
      }
    }

    return {relay, have: Array.from(have), need: Array.from(need)}
  })
}

summary:
The `diff` function performs a difference operation across multiple relays and filters to determine which events a relay has and which it needs. It takes a `DiffOptions` object containing arrays of relays, filters, events, and an optional context. It returns an array of objects, each containing a relay URL and arrays of event IDs that the relay has and needs.

details:
Implementation details:
1. The function creates a Difference instance for each combination of relay and filter.
2. It flattens the results of all these operations using Promise.all and the flatten utility.
3. For each Difference instance:
   - It sets up event listeners for Close and Error events
   - It includes a 30-second timeout that will reject the promise if exceeded
4. After collecting all results, it groups them by relay using the groupBy utility
5. For each relay group, it aggregates all the 'have' and 'need' sets into single sets
6. Finally, it converts these sets to arrays and returns an array of objects with relay URLs and their respective have/need arrays
7. The implementation handles concurrent operations efficiently by using Promise.all for parallel execution

related: DiffOptions

import/access examples:
import { diff } from '@welshman/net';
import { diff } from '@welshman/net/diff';


=========================
workspace: packages/net
file: packages/net/src/diff.ts
lines: 179:179
id: 0a788e3a7da31e52d59ad5ea5a934986afe9b6b158cea718bd0f26c419bc3259
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/diff.ts#L179

declaration:
export type PullOptions = DiffOptions

summary:
PullOptions is a type alias that represents the configuration options for the pull function. It extends DiffOptions, which includes properties for specifying relays, filters, events, and an optional adapter context. This type is used to configure the process of identifying and fetching missing events from relays.

details:
This type alias is a simple extension of the DiffOptions type without adding any additional properties. It's used specifically for the pull function which performs a diff operation across multiple relays and filters, then fetches any missing events. The type serves as a semantic indicator that these options are specifically for the pull operation, even though the structure is identical to DiffOptions.

related: DiffOptions

import/access examples:
import type { PullOptions } from '@welshman/net';
import type { PullOptions } from '@welshman/net/diff';


=========================
workspace: packages/net
file: packages/net/src/diff.ts
lines: 181:221
id: c67740cac045f0ecd4f08add6bd97e9693125954dcf0d942702513a7a743df02
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/diff.ts#L181

declaration:
pull = async ({context, ...options}: PullOptions) => {
  const countById = new Map<string, number>()
  const idsByRelay = new Map<string, string[]>()

  for (const {relay, need} of await diff({context, ...options})) {
    for (const id of need) {
      const count = countById.get(id) || 0

      // Reduce, but don't completely eliminate duplicates, just in case a relay
      // won't give us what we ask for.
      if (count < 2) {
        pushToMapKey(idsByRelay, relay, id)
        countById.set(id, inc(count))
      }
    }
  }

  const result: SignedEvent[] = []

  await Promise.all(
    Array.from(idsByRelay.entries()).map(([relay, allIds]) => {
      return Promise.all(
        chunk(500, allIds).map(
          ids =>
            new Promise<void>(resolve =>
              requestOne({
                relay,
                context,
                filters: [{ids}],
                autoClose: true,
                onClose: resolve,
                onEvent: event => result.push(event as SignedEvent),
              }),
            ),
        ),
      )
    }),
  )

  return result
}

summary:
The `pull` function retrieves missing events from relays based on a difference comparison. It takes a `PullOptions` object (which extends `DiffOptions`) containing relay URLs, filters, events, and an optional adapter context. The function returns a Promise that resolves to an array of retrieved `SignedEvent` objects.

details:
Implementation details:
1. First calls the `diff` function to determine which events are needed from which relays
2. Creates tracking maps: `countById` to limit duplicates and `idsByRelay` to organize which IDs to request from each relay
3. Processes the diff results, limiting each event ID to be requested from at most 2 relays to reduce duplicates while maintaining redundancy
4. Makes parallel requests to relays, chunking IDs into groups of 500 for efficient fetching
5. Uses `requestOne` for each chunk to fetch events from relays
6. Collects all retrieved events into a single result array
7. Returns the combined array of fetched `SignedEvent` objects

related: PullOptions

import/access examples:
import { pull } from '@welshman/net';
import { pull } from '@welshman/net/diff';


=========================
workspace: packages/net
file: packages/net/src/diff.ts
lines: 225:225
id: 824d6d9a50f91c27fe5ffbf57c9c377df4cc7c056c92a4d0606d3c484c153396
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/diff.ts#L225

declaration:
export type PushOptions = DiffOptions

summary:
PushOptions is a type alias that represents the configuration options for the push function. It extends DiffOptions, which includes properties for specifying relays, filters, events, and an optional context for the operation.

details:
This type alias is simply reusing the DiffOptions type for the push function parameters. The push function uses these options to determine which events need to be published to which relays. It doesn't add any additional properties beyond what DiffOptions already provides, indicating that the push operation uses the same configuration structure as the diff operation.

related: DiffOptions

import/access examples:
import type { PushOptions } from '@welshman/net';
import type { PushOptions } from '@welshman/net/diff';


=========================
workspace: packages/net
file: packages/net/src/diff.ts
lines: 227:245
id: 051986ee1652a73c47a202e756822844c2aa601844188bb9e04ef1675ae1d859
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/diff.ts#L227

declaration:
push = async ({context, events, ...options}: PushOptions) => {
  const relaysById = new Map<string, string[]>()

  for (const {relay, have} of await diff({context, events, ...options})) {
    for (const id of have) {
      pushToMapKey(relaysById, id, relay)
    }
  }

  await Promise.all(
    events.map(async event => {
      const relays = relaysById.get(event.id)

      if (relays) {
        await publish({event, relays, context})
      }
    }),
  )
}

summary:
The `push` function synchronizes events across multiple relays by publishing events that are missing from specific relays. It takes a `PushOptions` object containing relays, filters, events, and an optional context. The function identifies which relays already have which events, then publishes each event to relays that don't have it yet.

details:
Implementation details:
1. First calls the `diff` function to determine which events each relay already has (in their 'have' sets)
2. Creates a mapping from event IDs to arrays of relay URLs that already have those events using `pushToMapKey`
3. For each event in the input:
   - Checks if there are relays that have this event (meaning other relays need it)
   - If so, publishes the event to the appropriate relays using the `publish` function
4. Uses Promise.all to handle all publishing operations concurrently
5. The function leverages the negentropy protocol (implemented in the Difference class) to efficiently determine event differences between relays

related: PushOptions

import/access examples:
import { push } from '@welshman/net';
import { push } from '@welshman/net/diff';


=========================
workspace: packages/net
file: packages/net/__tests__/policy.test.ts
lines: 13:20
id: 6f949badf9fb575cd6813e9bd250126aab12b243b2c74961acff11de1654b5db
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/__tests__/policy.test.ts#L13

declaration:
mockWs = vi.hoisted(() => ({
  close: vi.fn(),
  send: vi.fn(),
  onopen: vi.fn(),
  onclose: null,
  onerror: null,
  onmessage: null,
}))

summary:
A mocked WebSocket object created using Vitest's hoisted function. It provides mock implementations for WebSocket methods and properties used in tests. The mock includes functions for close, send, and onopen (all created with vi.fn()), as well as null values for onclose, onerror, and onmessage event handlers.

details:
This variable is created using vi.hoisted() to ensure the mock is defined at the top level of the module, making it available throughout the test file. The mock implementation mimics the WebSocket interface with just enough functionality for testing purposes. It's used in conjunction with the vi.mock() call for 'isomorphic-ws' to replace the actual WebSocket implementation during tests. The mock functions (close, send, onopen) can be spied on or have their implementations modified during tests to verify behavior or simulate specific scenarios.

related: vi

=========================
type: file
workspace: packages/net
path: packages/net/__tests__/policy.test.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/__tests__/policy.test.ts
summary: This file contains tests for three socket policy functions: socketPolicyAuthBuffer, socketPolicyConnectOnSend, and socketPolicyCloseInactive. These policies manage authentication buffering, automatic connection on message sending, and closing inactive connections respectively. The tests verify the behavior of these policies under various conditions using the Vitest testing framework.

details: The implementation details include:

1. Test setup with mocked WebSocket using Vitest's mocking capabilities
2. Tests for socketPolicyAuthBuffer verify:
   - Message buffering when not authenticated
   - Sending buffered messages after authentication
   - Proper handling of CLOSE messages
   - Retrying events and REQs once when auth-required
   - Not retrying AUTH_JOIN events
   - Clearing pending messages on successful responses

3. Tests for socketPolicyConnectOnSend verify:
   - Opening socket when sending messages while closed
   - Not opening already open sockets
   - Error backoff behavior

4. Tests for socketPolicyCloseInactive verify:
   - Closing sockets after inactivity timeout
   - Resetting timers on activity
   - Reopening sockets with pending messages
   - Handling message completion and CLOSE commands

The tests use fake timers to control time-based behaviors and extensively use event emission to simulate socket states and messages.

=========================
type: dir
workspace: packages/net
path: packages/net/__tests__/
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/__tests__/
summary: The __tests__ directory contains test files for a WebSocket-based communication library. The tests cover various aspects of the library including socket policies (authentication buffering, auto-connection, inactivity management), request handling, authentication mechanisms, connection pooling, and message publishing. The directory focuses on verifying the correct behavior of the library's core components through unit tests using the Vitest testing framework.

=========================
type: file
workspace: packages/net
path: packages/net/src/adapter.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/adapter.ts
summary: This file defines adapter classes for handling relay communication. It exports `AbstractAdapter` as a base class, along with concrete implementations: `SocketAdapter` for WebSocket connections, `LocalAdapter` for local relay communication, and `MockAdapter` for testing. The `getAdapter` function creates appropriate adapters based on URL types. Adapters emit events when messages are received and provide methods to send messages to relays.

details: The implementation revolves around the EventEmitter pattern, with adapters extending EventEmitter to handle relay communication events.

1. `AbstractAdapter` defines the core interface with abstract properties for URLs and sockets, and an abstract `send` method.
2. `SocketAdapter` wraps a Socket instance, forwarding received messages as adapter events.
3. `LocalAdapter` connects to a LocalRelay instance for in-memory communication.
4. `MockAdapter` provides a testing implementation with a custom send function and a `receive` method to simulate incoming messages.
5. The `getAdapter` factory function determines which adapter type to create based on the URL and context:
   - Uses custom adapter from context if provided
   - Creates LocalAdapter for LOCAL_RELAY_URL
   - Creates SocketAdapter for valid relay URLs
   - Throws an error for invalid URLs

The implementation uses helper functions from external libraries for event handling and object merging.

=========================
type: file
workspace: packages/net
path: packages/net/src/auth.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/auth.ts
summary: The auth.ts file exports components for handling authentication with a relay server. It defines AuthStatus enum for tracking authentication states, AuthResult type for authentication outcomes, and AuthStateEvent enum for event types. The main export is the AuthState class, which extends EventEmitter to manage the authentication process, including handling challenges, signing events, and tracking authentication status.

details: The implementation revolves around the AuthState class which manages WebSocket authentication flow:

1. It tracks the current authentication status through the status property.
2. It subscribes to socket events (receive, sending, status) to react to relay messages.
3. When a relay sends an AUTH challenge, it updates the state and prepares for authentication.
4. The doAuth method handles signing the authentication challenge using the provided sign function.
5. The attemptAuth method orchestrates the authentication flow with timeouts.
6. The retryAuth method allows retrying authentication when needed.
7. The class uses event emitters to notify subscribers of status changes.
8. It properly handles cleanup by removing event listeners when no longer needed.

The implementation uses polling with timeouts to wait for state changes during the authentication process.

=========================
type: file
workspace: packages/net
path: packages/net/src/context.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/context.ts
summary: The context.ts file exports a NetContext type and a netContext object that provides access to core network functionality. It includes a pool, repository, and methods for event validation and deletion checking. It also allows for optional adapter retrieval based on URL.

details: The implementation creates a singleton-like netContext object that:
1. Uses Pool.get() to access a shared pool instance
2. Uses Repository.get() to access a shared repository instance
3. Implements isEventValid by delegating to the verifyEvent utility function
4. Implements isEventDeleted by checking the repository's isDeleted method
5. Defines an optional getAdapter function type that would return an AbstractAdapter for a given URL

=========================
type: file
workspace: packages/net
path: packages/net/src/diff.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/diff.ts
summary: The diff.ts file exports tools for synchronizing events between Nostr relays using the Negentropy protocol. It provides the Difference class for comparing event sets between a client and a relay, and three utility functions: diff() for comparing events across multiple relays and filters, pull() for fetching missing events from relays, and push() for publishing events to relays that don't have them.

details: Implementation details:

1. The Difference class extends EventEmitter and implements the Negentropy protocol for efficient set reconciliation between a client and a relay. It:
   - Uses an adapter system to abstract relay communication
   - Maintains 'have' and 'need' sets to track event IDs
   - Handles Negentropy protocol messages and errors
   - Emits events for message reception, errors, and closing

2. The diff() function orchestrates multiple Difference instances across multiple relays and filters, aggregating results by relay.

3. The pull() function:
   - Uses diff() to identify missing events
   - Deduplicates requests to avoid excessive fetching
   - Chunks large requests into smaller batches (500 IDs)
   - Uses requestOne() to fetch events from relays

4. The push() function:
   - Uses diff() to identify which relays are missing which events
   - Maps events to relays that need them
   - Uses publish() to send events to appropriate relays

=========================
type: file
workspace: packages/net
path: packages/net/src/message.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/message.ts
summary: This file defines the message types and type guards for communication between relay servers and clients. It exports enums for message types (RelayMessageType and ClientMessageType), type definitions for various message payloads, and type guard functions to check message types. The file clearly separates relay-to-client messages from client-to-relay messages, providing a complete typing system for this communication protocol.

details: The implementation is organized into two main sections:

1. Relay-to-client messages (lines 3-57):
   - Defines RelayMessageType enum with values like Auth, Closed, Eose, Event, etc.
   - Defines payload types for each message type (RelayAuthPayload, RelayClosedPayload, etc.)
   - Creates complete message types by combining the message type and payload (RelayAuth, RelayClosed, etc.)
   - Provides type guard functions (isRelayAuth, isRelayClosed, etc.) to check message types

2. Client-to-relay messages (lines 59-110):
   - Similar structure with ClientMessageType enum
   - Defines corresponding payload and message types
   - Provides type guard functions for client messages

All message types are represented as arrays, with the first element being the message type identifier.

=========================
type: file
workspace: packages/net
path: packages/net/src/negentropy.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/negentropy.ts
summary: The negentropy.ts file exports two main classes: Negentropy and NegentropyStorageVector. This module implements the Negentropy protocol, which is a data synchronization algorithm that efficiently identifies differences between two sets of data. NegentropyStorageVector provides storage for items with timestamps and IDs, while the Negentropy class handles the reconciliation process between two data sets, allowing clients to determine which items they have that others need and vice versa.

details: The implementation consists of several key components:

1. WrappedBuffer - A utility class for managing byte arrays with dynamic resizing.
2. Accumulator - Handles mathematical operations on byte arrays and fingerprint generation using SHA-256.
3. NegentropyStorageVector - Manages a sorted collection of timestamped items with unique IDs.
4. Negentropy - The main class implementing the protocol with methods for initiating and reconciling data sets.

The protocol works by exchanging fingerprints of data ranges and recursively splitting ranges that don't match. It uses variable-length integer encoding, binary search for efficient range operations, and supports both browser and Node.js environments for cryptographic operations. The implementation includes optimizations for handling large datasets through frame size limits and efficient binary comparisons.

=========================
type: file
workspace: packages/net
path: packages/net/src/policy.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/policy.ts
summary: This file defines socket policies for managing WebSocket connections in a Nostr client. It exports several policy functions: `socketPolicyAuthBuffer` for handling authentication-related message buffering, `socketPolicyConnectOnSend` for auto-connecting closed sockets when messages are sent, `socketPolicyCloseInactive` for managing inactive connections, and `makeSocketPolicyAuth` for creating authentication policies. The `SocketPolicy` type defines the contract for these policies, and `defaultSocketPolicies` provides a standard set of policies to apply.

details: The implementation revolves around event-based socket management with these key components:

1. `socketPolicyAuthBuffer` - Buffers messages during authentication, preventing them from being sent until auth is complete. It handles special cases like AUTH_JOIN events and replays buffered messages after successful authentication.

2. `socketPolicyConnectOnSend` - Tracks socket errors and automatically reopens closed sockets when new messages are sent, unless there was a recent error (within 5 seconds).

3. `socketPolicyCloseInactive` - Manages socket lifecycle by:
   - Tracking pending messages in a Map
   - Closing sockets after 30 seconds of inactivity when no pending messages exist
   - Reopening sockets and resending pending messages if the socket closes unexpectedly
   - Preventing connection flapping with a cooldown period

4. `makeSocketPolicyAuth` - Factory function that creates a policy to handle authentication requests based on provided signing function and optional condition.

All policies use the event system (via the `on` function) to react to socket state changes and implement cleanup functions to properly unsubscribe when no longer needed.

=========================
type: file
workspace: packages/net
path: packages/net/src/pool.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/pool.ts
summary: This file exports a Socket pool management system. The main exports are `makeSocket` function for creating configured Socket instances, `Pool` class for managing a collection of Sockets by URL, and related types. The Pool class provides a singleton pattern through `Pool.get()`, methods to create, retrieve, and manage sockets, and a subscription mechanism to notify when new sockets are created.

details: The implementation revolves around the `Pool` class which maintains a Map of normalized URLs to Socket instances. Key features include:
1. Singleton pattern implementation via static `get()` method and module-level `poolSingleton` variable
2. Socket creation with policy application through the `makeSocket` function
3. URL normalization using `normalizeRelayUrl` from an external utility
4. Subscription system allowing callbacks when new sockets are created
5. Memory management through `remove` and `clear` methods that properly clean up sockets
6. Customization through `PoolOptions` that allows overriding the socket creation process

=========================
type: file
workspace: packages/net
path: packages/net/src/publish.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/publish.ts
summary: This file provides functionality for publishing signed events to Nostr relays. It exports two main functions: `publishOne` for sending an event to a single relay, and `publish` for sending to multiple relays simultaneously. It also defines types and enums for tracking publish status, options, and results. The API supports callbacks for various states (success, failure, pending, timeout, aborted) and allows for timeout and abort signal configuration.

details: Implementation details:

1. The file uses an adapter pattern to abstract relay communication, importing `getAdapter` from "./adapter.js".
2. `publishOne` returns a Promise that resolves with the final status of the publish operation.
3. The implementation sets up event listeners on the adapter to handle relay responses.
4. It includes timeout handling (defaulting to 10 seconds) and abort signal support.
5. The `publish` function orchestrates multiple `publishOne` calls in parallel using Promise.all.
6. Status tracking is maintained in a Record object mapping relay URLs to their respective PublishStatus.
7. The implementation handles completion tracking to ensure the onComplete callback is only fired once all relay operations are finished.
8. There's a warning check for duplicate relay URLs in the input array.

=========================
type: file
workspace: packages/net
path: packages/net/src/request.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/request.ts
summary: This file provides utilities for making requests to Nostr relays. It exports functions like `requestOne`, `request`, `makeLoader`, and `load` for fetching events from relays. The module handles relay connections, event filtering, deduplication, and batching of requests. It also provides options for validating events, handling disconnections, and controlling request lifecycle through abort signals.

details: The implementation revolves around several key components:

1. `requestOne` - Core function that handles a single relay request, managing subscriptions, event validation, and connection lifecycle.

2. `request` - Builds on `requestOne` to handle requests to multiple relays, with threshold-based completion.

3. `makeLoader` - Creates a batching function that groups requests to the same relays, optimizing network usage by unioning filters and distributing events to appropriate requesters.

4. The code uses a tracker system to deduplicate events across relays, and implements early returns when filter cardinality is known.

5. Request lifecycle management is handled through AbortSignals, with automatic cleanup to prevent memory leaks.

6. Events go through multiple validation steps (valid, deleted, matching filters) before being accepted.

7. The implementation uses Maps extensively to track relationships between relays, requests, and events.

=========================
type: file
workspace: packages/net
path: packages/net/src/socket.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/socket.ts
summary: The socket.ts file exports a Socket class that manages WebSocket connections, along with supporting enums and types. It provides functionality for opening/closing connections, sending/receiving messages, and emitting events for various socket states. The Socket class extends EventEmitter and includes methods for connection management, message handling, and cleanup operations.

details: Implementation details:

1. The Socket class extends EventEmitter and manages a WebSocket connection to a specified URL.
2. It uses two TaskQueue instances from @welshman/lib to handle sending and receiving messages in batches.
3. The class maintains an internal state through the status property (SocketStatus enum) and emits events when status changes.
4. Message handling includes:
   - Sending messages through a queue that processes them in batches of 50
   - Receiving and parsing messages from the WebSocket
   - Validating that received messages are arrays (RelayMessage type)
5. The class integrates with an AuthState instance for authentication management.
6. Error handling is implemented throughout, with appropriate status updates and event emissions.
7. The implementation includes methods for opening connections (open, attemptToOpen), closing (close), and complete cleanup (cleanup) that removes all listeners and clears queues.

=========================
type: dir
workspace: packages/net
path: packages/net/src/
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/
summary: The src directory implements a comprehensive Nostr client library for interacting with relays. It provides core functionality for WebSocket management, authentication, event publishing/requesting, and set reconciliation using the Negentropy protocol. Key exports include the Socket class for connection management, Pool for socket registry, AuthState for relay authentication, publish/request functions for event transmission, and Difference class for efficient event synchronization. The library uses an adapter pattern for relay communication, supports various socket policies, and provides utilities for tracking event-relay relationships.

=========================
type: file
workspace: packages/net
path: packages/net/src/tracker.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/tracker.ts
summary: The Tracker class extends Emitter to track relationships between event IDs and relays. It provides methods to add, remove, check, and retrieve relays associated with events and vice versa. The class emits events when relationships change, including 'add', 'remove', 'load', and 'clear' events.

details: The implementation maintains two bidirectional maps: relaysById (mapping event IDs to sets of relays) and idsByRelay (mapping relays to sets of event IDs). Key methods include:
1. getIds/getRelays - retrieve associated items
2. hasRelay - check if a relationship exists
3. addRelay - create a new relationship and emit 'add' event
4. removeRelay - delete a relationship and emit 'remove' event
5. track - add a relationship and return whether the event was previously seen
6. copy - duplicate all relay associations from one event to another
7. load - replace all tracked relationships with new data
8. clear - remove all tracked relationships

The class increases the maximum event listeners to 100 in its constructor.

=========================
type: file
workspace: packages/net
path: packages/net/src/util.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/src/util.ts
summary: The file exports a single type `Unsubscriber`, which represents a function that can be called to unsubscribe from something. It's a simple type definition for a function that takes no arguments and returns nothing (void).

=========================
type: dir
workspace: packages/net
path: packages/net/
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/net/
summary: This directory contains a comprehensive Nostr client library for WebSocket-based relay communication. The library provides core functionality for managing WebSocket connections, authentication with relays, event publishing and requesting, connection pooling, and efficient set reconciliation using the Negentropy protocol. Key exports include the Socket class for connection management, Pool for socket registry, AuthState for relay authentication, publish/request functions for event transmission, and utilities for tracking event-relay relationships. The library implements an adapter pattern for relay communication and supports various socket policies for connection management.

=========================
type: file
workspace: packages/relay
file: packages/relay/package.json
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/relay/package.json
include: always
{
  "name": "@welshman/relay",
  "version": "0.4.6",
  "author": "hodlbod",
  "license": "MIT",
  "description": "An in-memory nostr relay implementation.",
  "publishConfig": {
    "access": "public"
  },
  "type": "module",
  "main": "dist/relay/src/index.js",
  "types": "dist/relay/src/index.d.ts",
  "files": [
    "dist"
  ],
  "scripts": {
    "build": "pnpm run clean && pnpm run compile --force",
    "clean": "rimraf ./dist",
    "compile": "tsc -b tsconfig.build.json",
    "prepublishOnly": "pnpm run build"
  },
  "dependencies": {
    "@welshman/lib": "workspace:*",
    "@welshman/util": "workspace:*"
  },
  "devDependencies": {
    "rimraf": "~6.0.0",
    "typescript": "~5.8.0"
  }
}


=========================
type: file
workspace: packages/relay
file: packages/relay/tsconfig.json
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/relay/tsconfig.json
include: always
{
  "extends": "../../tsconfig.json"
}


=========================
workspace: packages/relay
file: packages/relay/src/repository.ts
lines: 26:26
id: 49043068b166b3b8d8bab049387d301b8d82d9bff15f9140f46760a03c5869be
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/relay/src/repository.ts#L26

declaration:
LOCAL_RELAY_URL = "local://welshman.relay/"

summary:
A constant string representing the URL for a local relay in the Welshman system. The value is set to "local://welshman.relay/".

details:
This is a simple constant variable that defines a URL string used to identify a local relay within the application. It likely serves as a reference point for local communication or testing purposes within the Welshman system.

import/access examples:
import { LOCAL_RELAY_URL } from '@welshman/relay';
import { LOCAL_RELAY_URL } from '@welshman/relay/repository';


=========================
workspace: packages/relay
file: packages/relay/src/repository.ts
lines: 28:28
id: 657e5c7fd338f7a27611afe5f6ef487b163828e465ad7c35cfc5289bdbdf83dd
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/relay/src/repository.ts#L28

declaration:
getDay = (ts: number) => Math.floor(ts / DAY)

summary:
A function that converts a timestamp (in milliseconds) to a day number by dividing the timestamp by the number of milliseconds in a day and flooring the result.

details:
This is a simple utility function that takes a timestamp parameter and returns an integer representing the day number. It divides the timestamp by the DAY constant (presumably the number of milliseconds in a day) and uses Math.floor to round down to the nearest integer. This function is used within the Repository class to index events by day.

=========================
workspace: packages/relay
file: packages/relay/src/repository.ts
lines: 30:30
id: bd49e3077292f9d30b99775df883f98d72779ea379dcd606c26f29b41c4ac040
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/relay/src/repository.ts#L30

declaration:
repositorySingleton: Repository<TrustedEvent>

summary:
A global variable that holds a singleton instance of the Repository class for TrustedEvent objects. This variable provides a centralized access point to the repository throughout the application.

details:
This is a singleton pattern implementation where `repositorySingleton` is declared as a mutable variable (using `let`) that will hold the single instance of the Repository class. It's initialized as undefined and later populated by the `Repository.get()` static method. The variable is exported to make it accessible from other modules.

related: Repository

import/access examples:
import { repositorySingleton } from '@welshman/relay';
import { repositorySingleton } from '@welshman/relay/repository';


=========================
workspace: packages/relay
file: packages/relay/src/repository.ts
lines: 32:35
id: 919689e8cfd622e4ebcaea9164c6cc74af7bcb46268c8efe4588c5bdde6ebc30
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/relay/src/repository.ts#L32

declaration:
export type RepositoryUpdate = {
  added: TrustedEvent[]
  removed: Set<string>
}

summary:
A type definition that represents an update to the repository. It contains two properties: `added` which is an array of TrustedEvent objects that have been added to the repository, and `removed` which is a Set of string IDs representing events that have been removed from the repository.

details:
This type is used to communicate changes in the repository state, particularly when emitting update events. The `added` array contains the full event objects that were newly added, while the `removed` Set contains only the IDs of events that were deleted, expired, or replaced. This structure allows subscribers to efficiently process repository changes without needing to re-query the entire repository.

import/access examples:
import type { RepositoryUpdate } from '@welshman/relay';
import type { RepositoryUpdate } from '@welshman/relay/repository';


=========================
workspace: packages/relay
file: packages/relay/src/repository.ts
lines: 37:409
id: a66fe00d2bd0d5edeabf5d70eebcf67bb252807c648643e539441b5ba90c3fc4
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/relay/src/repository.ts#L37

declaration:
export class Repository<E extends HashedEvent = TrustedEvent> extends Emitter{
  eventsById: Map<string, E>;
  eventsByWrap: Map<string, E>;
  eventsByAddress: Map<string, E>;
  eventsByTag: Map<string, E[]>;
  eventsByDay: Map<number, E[]>;
  eventsByAuthor: Map<string, E[]>;
  eventsByKind: Map<number, E[]>;
  deletes: Map<string, number>;
  expired: Map<string, number>;
  static get();
  constructor();
  dump: () => E[];
  load: (events: E[], chunkSize?: number) => void;
  getEvent: (idOrAddress: string) => E | undefined;
  hasEvent: (event: E) => boolean | undefined;
  removeEvent: (idOrAddress: string) => void;
  query: (filters: Filter[], { includeDeleted, includeExpired, shouldSort }?: { includeDeleted?: boolean | undefined; includeExpired?: boolean | undefined; shouldSort?: boolean | undefined; }) => E[];
  publish: (event: E, { shouldNotify }?: { shouldNotify?: boolean | undefined; }) => boolean;
  isDeletedByAddress: (event: E) => boolean;
  isDeletedById: (event: E) => boolean;
  isDeleted: (event: E) => boolean;
  isExpired: (event: E) => boolean;
  _sortEvents: (shouldSort: boolean, events: E[]) => E[];
  _updateIndex: <K>(m: Map<K, E[]>, k: K, add?: E | undefined, remove?: E | undefined) => void;
  _getEvents: (ids: Iterable<string>) => E[];
  _applyIdsFilter: (filter: Filter) => { filter: Filter; ids: Set<string>; } | undefined;
  _applyAuthorsFilter: (filter: Filter) => { filter: Filter; ids: Set<string>; } | undefined;
  _applyTagsFilter: (filter: Filter) => { filter: Filter; ids: Set<string>; } | undefined;
  _applyKindsFilter: (filter: Filter) => { filter: Filter; ids: Set<string>; } | undefined;
  _applyDaysFilter: (filter: Filter) => { filter: Filter; ids: Set<string>; } | undefined;
  _applyAnyFilter: (filter: Filter) => { filter: Filter; ids: Set<string>; } | undefined;
}

summary:
Repository is a class that manages a collection of events (HashedEvent or TrustedEvent objects). It provides functionality for storing, retrieving, querying, and managing events with various indexing mechanisms. The class extends Emitter to provide event notification capabilities. It maintains multiple indexes for efficient querying by ID, address, tag, day, author, and kind. The Repository also tracks deleted and expired events.

details:
The Repository implementation uses a sophisticated indexing system with several Map collections to enable efficient querying:

1. It maintains primary indexes (eventsById, eventsByWrap, eventsByAddress) and secondary indexes (eventsByTag, eventsByDay, eventsByAuthor, eventsByKind) to optimize different query patterns.

2. The class implements a singleton pattern through the static `get()` method, ensuring a single repository instance is used throughout the application.

3. Event management is handled through several key methods:
   - `publish()`: Adds events to the repository, handling replacements and deletions
   - `query()`: Retrieves events based on filters, with optimizations to use the most efficient index
   - `dump()/load()`: Exports/imports the entire repository state

4. The implementation includes specialized filter application methods (_applyIdsFilter, _applyAuthorsFilter, etc.) that optimize queries by leveraging the appropriate indexes.

5. The class tracks event deletions and expirations through dedicated maps (deletes, expired) and provides methods to check event status (isDeleted, isExpired).

6. Events are emitted when the repository state changes, allowing subscribers to react to updates.

code:
export class Repository<E extends HashedEvent = TrustedEvent> extends Emitter {
  eventsById = new Map<string, E>()
  eventsByWrap = new Map<string, E>()
  eventsByAddress = new Map<string, E>()
  eventsByTag = new Map<string, E[]>()
  eventsByDay = new Map<number, E[]>()
  eventsByAuthor = new Map<string, E[]>()
  eventsByKind = new Map<number, E[]>()
  deletes = new Map<string, number>()
  expired = new Map<string, number>()

  static get() {
    if (!repositorySingleton) {
      repositorySingleton = new Repository()
    }

    return repositorySingleton
  }

  constructor() {
    super()

    this.setMaxListeners(1000)
  }

  // Dump/load/clear

  dump = () => {
    return Array.from(this.eventsById.values())
  }

  load = (events: E[], chunkSize = 1000) => {
    const stale = new Set(this.eventsById.keys())

    this.eventsById.clear()
    this.eventsByWrap.clear()
    this.eventsByAddress.clear()
    this.eventsByTag.clear()
    this.eventsByDay.clear()
    this.eventsByAuthor.clear()
    this.eventsByKind.clear()
    this.deletes.clear()
    this.expired.clear()

    const added = []

    for (const eventsChunk of chunk(chunkSize, events)) {
      for (const event of eventsChunk) {
        if (this.publish(event, {shouldNotify: false})) {
          // Don't send duplicate events to subscribers
          if (!stale.has(event.id)) {
            added.push(event)
          }
        }
      }
    }

    const removed = new Set<string>()

    // Anything we had before clearing the repository has been removed
    for (const id of stale) {
      if (!this.eventsById.has(id)) {
        removed.add(id)
      }
    }

    // Anything removed via delete or replace has been removed
    for (const id of this.deletes.keys()) {
      removed.add(id)
    }

    // Anything expired has been removed
    for (const id of this.expired.keys()) {
      removed.add(id)
    }

    this.emit("update", {added, removed})
  }

  // API

  getEvent = (idOrAddress: string) => {
    return idOrAddress.includes(":")
      ? this.eventsByAddress.get(idOrAddress)
      : this.eventsById.get(idOrAddress)
  }

  hasEvent = (event: E) => {
    const duplicate = this.eventsById.get(event.id) || this.eventsByAddress.get(getAddress(event))

    return duplicate && duplicate.created_at >= event.created_at
  }

  removeEvent = (idOrAddress: string) => {
    const event = this.getEvent(idOrAddress)

    if (event) {
      this.eventsById.delete(event.id)

      if (isUnwrappedEvent(event)) {
        this.eventsByWrap.delete(event.wrap.id)
      }

      this.eventsByAddress.delete(getAddress(event))

      for (const [k, v] of event.tags) {
        if (k.length === 1) {
          this._updateIndex(this.eventsByTag, `${k}:${v}`, undefined, event)
        }
      }

      this._updateIndex(this.eventsByDay, getDay(event.created_at), undefined, event)
      this._updateIndex(this.eventsByAuthor, event.pubkey, undefined, event)
      this._updateIndex(this.eventsByKind, event.kind, undefined, event)

      this.emit("update", {added: [], removed: [event.id]})
    }
  }

  query = (
    filters: Filter[],
    {includeDeleted = false, includeExpired = false, shouldSort = true} = {},
  ) => {
    const result: E[][] = []
    for (const originalFilter of filters) {
      if (originalFilter.limit !== undefined && !shouldSort) {
        throw new Error("Unable to skip sorting if limit is defined")
      }

      // Attempt to fulfill the query using one of our indexes. Fall back to all events.
      const applied = this._applyAnyFilter(originalFilter)
      const filter = applied?.filter || originalFilter
      const events = applied ? this._getEvents(applied!.ids) : this.dump()
      const sorted = this._sortEvents(shouldSort && Boolean(filter.limit), events)

      const chunk: E[] = []
      for (const event of sorted) {
        if (filter.limit && chunk.length >= filter.limit) {
          break
        }

        if (!includeDeleted && this.isDeleted(event)) {
          continue
        }

        if (!includeExpired && this.isExpired(event)) {
          continue
        }

        if (matchFilter(filter, event)) {
          chunk.push(event)
        }
      }

      result.push(chunk)
    }

    // Only re-sort if we had multiple filters, or if our single filter wasn't sorted
    const shouldSortAll = shouldSort && (filters.length > 1 || !filters[0]?.limit)

    return this._sortEvents(shouldSortAll, uniq(flatten(result)))
  }

  publish = (event: E, {shouldNotify = true} = {}): boolean => {
    if (!event?.id) {
      console.warn("Attempted to publish invalid event to repository", event)

      return false
    }

    // If we've already seen this event we're done
    if (this.eventsById.get(event.id)) {
      return false
    }

    const removed = new Set<string>()
    const address = getAddress(event)
    const duplicate = this.eventsByAddress.get(address)

    if (duplicate) {
      // If our event is younger than the duplicate, we're done
      if (event.created_at < duplicate.created_at) {
        return false
      }

      // If our event is newer than what it's replacing, delete the old version
      this.deletes.set(duplicate.id, event.created_at)

      // Notify listeners that it's been removed
      removed.add(duplicate.id)
    }

    // Add our new event by id
    this.eventsById.set(event.id, event)

    // Add our new event by address
    if (isReplaceable(event)) {
      this.eventsByAddress.set(address, event)
    }

    // Save wrapper index
    if (isUnwrappedEvent(event)) {
      this.eventsByWrap.set(event.wrap.id, event)
    }

    // Update our timestamp and author indexes
    this._updateIndex(this.eventsByDay, getDay(event.created_at), event, duplicate)
    this._updateIndex(this.eventsByAuthor, event.pubkey, event, duplicate)
    this._updateIndex(this.eventsByKind, event.kind, event, duplicate)

    // Update our tag indexes
    for (const tag of event.tags) {
      if (tag[0]?.length === 1) {
        this._updateIndex(this.eventsByTag, tag.slice(0, 2).join(":"), event, duplicate)

        // If this is a delete event, the tag value is an id or address. Track when it was
        // deleted so that replaceables can be restored.
        if (event.kind === DELETE && ["a", "e"].includes(tag[0]) && tag[1]) {
          this.deletes.set(tag[1], Math.max(event.created_at, this.deletes.get(tag[1]) || 0))

          const deletedEvent = this.getEvent(tag[1])

          if (deletedEvent && this.isDeleted(deletedEvent)) {
            removed.add(deletedEvent.id)
          }
        }
      }

      // Keep track of whether this event is expired
      if (tag[0] === "expiration") {
        const expiration = parseInt(tag[1] || "")

        if (!isNaN(expiration)) {
          this.expired.set(event.id, expiration)
        }
      }
    }

    if (shouldNotify) {
      this.emit("update", {added: [event], removed})
    }

    return true
  }

  isDeletedByAddress = (event: E) => (this.deletes.get(getAddress(event)) || 0) > event.created_at

  isDeletedById = (event: E) => (this.deletes.get(event.id) || 0) > event.created_at

  isDeleted = (event: E) => this.isDeletedByAddress(event) || this.isDeletedById(event)

  isExpired = (event: E) => {
    const ts = this.expired.get(event.id)

    return Boolean(ts && ts < now())
  }

  // Utilities

  _sortEvents = (shouldSort: boolean, events: E[]) =>
    shouldSort ? sortBy(e => -e.created_at, events) : events

  _updateIndex = <K>(m: Map<K, E[]>, k: K, add?: E, remove?: E) => {
    let a = m.get(k) || []

    if (remove) {
      a = a.filter((x: E) => x !== remove)
    }

    if (add) {
      a.push(add)
    }

    m.set(k, a)
  }

  _getEvents = (ids: Iterable<string>) => {
    const events: E[] = []

    for (const id of ids) {
      const event = this.eventsById.get(id)

      if (event) {
        events.push(event)
      }
    }

    return events
  }

  _applyIdsFilter = (filter: Filter) => {
    if (!filter.ids) return undefined

    return {
      filter: omit(["ids"], filter),
      ids: new Set(filter.ids),
    }
  }

  _applyAuthorsFilter = (filter: Filter) => {
    if (!filter.authors) return undefined

    const events = filter.authors.flatMap(pubkey => this.eventsByAuthor.get(pubkey) || [])

    return {
      filter: omit(["authors"], filter),
      ids: new Set(pluck<string>("id", events)),
    }
  }

  _applyTagsFilter = (filter: Filter) => {
    for (const [k, values] of Object.entries(filter)) {
      if (!k.startsWith("#") || k.length !== 2) {
        continue
      }

      const ids = new Set<string>()

      for (const v of values as string[]) {
        for (const event of this.eventsByTag.get(`${k[1]}:${v}`) || []) {
          ids.add(event.id)
        }
      }

      return {filter: omit([k], filter), ids}
    }

    return undefined
  }

  _applyKindsFilter = (filter: Filter) => {
    if (!filter.kinds) return undefined

    const events = filter.kinds.flatMap(kind => this.eventsByKind.get(kind) || [])

    return {
      filter: omit(["kinds"], filter),
      ids: new Set(pluck<string>("id", events)),
    }
  }

  _applyDaysFilter = (filter: Filter) => {
    if (!filter.since && !filter.until) return undefined

    const sinceDay = getDay(filter.since || EPOCH)
    const untilDay = getDay(filter.until || now())
    const days = Array.from(range(sinceDay, inc(untilDay)))
    const events = days.flatMap((day: number) => this.eventsByDay.get(day) || [])
    const ids = new Set(pluck<string>("id", events))

    return {filter, ids}
  }

  _applyAnyFilter = (filter: Filter) => {
    const matchers = [
      this._applyIdsFilter,
      this._applyAuthorsFilter,
      this._applyTagsFilter,
      this._applyKindsFilter,
      this._applyDaysFilter,
    ]

    for (const matcher of matchers) {
      const result = matcher(filter)

      if (result) {
        return result
      }
    }

    return undefined
  }
}

import/access examples:
import { Repository } from '@welshman/relay';
import { Repository } from '@welshman/relay/repository';


=========================
workspace: packages/relay
file: packages/relay/src/relay.ts
lines: 5:56
id: 86eb996c1714fb00bc76e29acf0c5cf1141911ba7726a5b12bc72273f43c46b5
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/relay/src/relay.ts#L5

declaration:
export class LocalRelay<E extends HashedEvent = TrustedEvent> extends Emitter{
  subs: Map<string, Filter[]>;
  constructor(readonly repository: Repository<E>);
  send(type: string, ...message: any[]);
  handleEVENT([event]: [E]);
  handleCLOSE([subId]: [string]);
  handleREQ([subId, ...filters]: [string, ...Filter[]]);
}

summary:
LocalRelay is a class that simulates a relay server for handling events locally. It extends the Emitter class and provides methods for handling event-related messages. The class is generic, accepting a type parameter E that extends HashedEvent (defaulting to TrustedEvent). It manages subscriptions, publishes events to a repository, and notifies subscribers when matching events occur.

details:
The implementation consists of three main components:

1. Subscription management: The class maintains a Map of subscription IDs to Filter arrays in the `subs` property.

2. Message handling: The `send` method routes messages based on their type to appropriate handlers:
   - `handleEVENT`: Publishes an event to the repository and notifies subscribers after a small delay
   - `handleCLOSE`: Removes a subscription
   - `handleREQ`: Registers a new subscription with filters and sends matching events from the repository

3. Event propagation: When events are received or requested, the class uses the `matchFilters` utility to determine which subscribers should receive notifications, then emits appropriate events using the inherited Emitter functionality.

The implementation includes small artificial delays (via `sleep(1)`) to simulate asynchronous behavior of real relays.

related: Repository

code:
export class LocalRelay<E extends HashedEvent = TrustedEvent> extends Emitter {
  subs = new Map<string, Filter[]>()

  constructor(readonly repository: Repository<E>) {
    super()
  }

  send(type: string, ...message: any[]) {
    switch (type) {
      case "EVENT":
        return this.handleEVENT(message as [E])
      case "CLOSE":
        return this.handleCLOSE(message as [string])
      case "REQ":
        return this.handleREQ(message as [string, ...Filter[]])
    }
  }

  handleEVENT([event]: [E]) {
    this.repository.publish(event)

    // Callers generally expect async relays
    void sleep(1).then(() => {
      this.emit("OK", event.id, true, "")

      if (!this.repository.isDeleted(event)) {
        for (const [subId, filters] of this.subs.entries()) {
          if (matchFilters(filters, event)) {
            this.emit("EVENT", subId, event)
          }
        }
      }
    })
  }

  handleCLOSE([subId]: [string]) {
    this.subs.delete(subId)
  }

  handleREQ([subId, ...filters]: [string, ...Filter[]]) {
    this.subs.set(subId, filters)

    // Callers generally expect async relays
    void sleep(1).then(() => {
      for (const event of this.repository.query(filters)) {
        this.emit("EVENT", subId, event)
      }

      this.emit("EOSE", subId)
    })
  }
}

import/access examples:
import { LocalRelay } from '@welshman/relay';
import { LocalRelay } from '@welshman/relay/relay';


=========================
workspace: packages/relay
file: packages/relay/__tests__/repository.test.ts
lines: 6:11
id: 5939b17153c2ffdec3376fb062578f4beed0e9cdcc42000dfa5e3d7fa6704f1b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/relay/__tests__/repository.test.ts#L6

declaration:
createEvent = (kind: number, extra = {}) => ({
  ...makeEvent(kind),
  pubkey: randomId(),
  id: randomId(),
  ...extra,
})

summary:
A utility function that creates a test event object with specified kind and optional extra properties. It generates a new event with random pubkey and id values, extending the base event created by makeEvent() with any additional properties provided in the extra parameter.

details:
This helper function is used throughout the test suite to create event objects for testing the Repository class. It:
1. Takes a kind parameter (number) and an optional extra object (defaulting to empty object)
2. Uses makeEvent() to create a base event of the specified kind
3. Adds random values for pubkey and id using randomId()
4. Spreads any extra properties to override or extend the default properties
5. Returns the complete event object

=========================
type: file
workspace: packages/relay
path: packages/relay/__tests__/repository.test.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/relay/__tests__/repository.test.ts
summary: This file contains tests for the Repository class, which appears to be a storage and query system for events. The tests cover basic operations like publishing and retrieving events, handling replaceable events, delete events, expiring events, query operations, dumping and loading events, wrapped events, and event removal. The Repository seems to implement a Nostr-like protocol with support for event addressing, replacement, deletion, and expiration.

details: The test suite is organized into several describe blocks, each testing different aspects of the Repository:

1. Basic operations - tests publishing, retrieving, and checking for events, including handling invalid and duplicate events
2. Replaceable events - tests the behavior of events that can be replaced by newer versions
3. Delete events - tests how events can be marked as deleted either directly or by address
4. Expire events - tests the expiration mechanism based on expiration tags
5. Query operations - tests the query functionality with various filters (ids, authors, kinds, tags, time ranges)
6. Dump and load - tests serialization and deserialization of the repository, including chunked loading
7. Wrapped events - tests handling of events that wrap other events
8. Event removal - tests removing events and the associated update events

The Repository implementation appears to maintain several indexes for efficient querying and supports event-based notifications when the repository state changes.

=========================
type: dir
workspace: packages/relay
path: packages/relay/__tests__/
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/relay/__tests__/
summary: The __tests__ directory contains test files for core components of what appears to be a Nostr-like protocol implementation. The tests focus on the Repository class, which serves as a storage and query system for events with support for publishing, retrieving, replacing, deleting, and expiring events. The Repository implements sophisticated querying capabilities, event indexing, and serialization/deserialization functionality. The directory demonstrates the expected behavior and edge cases of the event storage and relay mechanisms in the system.

=========================
type: file
workspace: packages/relay
path: packages/relay/src/relay.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/relay/src/relay.ts
summary: The `LocalRelay` class is an in-memory implementation of a Nostr relay that handles event publishing and subscription management. It extends an `Emitter` class and works with a repository to store and query events. The class provides methods to handle event publishing (`EVENT`), subscription requests (`REQ`), and subscription closures (`CLOSE`).

details: The implementation details include:
1. The class maintains a map of subscriptions (`subs`) where each subscription ID maps to an array of filters.
2. Event handling is done through the `send` method which routes messages based on their type to specific handlers.
3. `handleEVENT` publishes events to the repository and notifies subscribers with matching filters after a small delay.
4. `handleCLOSE` removes a subscription by its ID.
5. `handleREQ` registers a new subscription with filters and immediately queries the repository for matching events, sending them to the subscriber followed by an EOSE (End Of Stored Events) signal.
6. The class uses small artificial delays (via `sleep(1)`) to simulate asynchronous behavior of real network relays.

=========================
type: file
workspace: packages/relay
path: packages/relay/src/repository.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/relay/src/repository.ts
summary: The Repository class is a central data store for managing and querying Nostr events. It provides methods for storing, retrieving, and filtering events with efficient indexing. The class maintains multiple indexes for quick access by ID, address, tag, day, author, and kind. It handles event replacement, deletion, and expiration logic. The repository can be accessed as a singleton via the static get() method, and it emits updates when events are added or removed.

details: The implementation uses multiple Map collections to index events in different ways:
1. Events are stored by ID, address, wrap ID, tag, day, author, and kind
2. Deletion and expiration information is tracked separately

Key features include:
- Event publishing with duplicate detection and replacement logic
- Querying with multiple filter types that leverage the appropriate indexes
- Support for event deletion and expiration
- Efficient batch loading and dumping of events

The query system tries to optimize lookups by applying the most efficient filter first (IDs, authors, tags, kinds, or time range). The class extends an Emitter to notify subscribers of changes to the repository.

The implementation handles special cases like replaceable events (where newer versions replace older ones) and deletion events that can mark other events as deleted. It also supports pagination through limit parameters and provides sorting capabilities.

=========================
type: dir
workspace: packages/relay
path: packages/relay/src/
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/relay/src/
summary: This directory implements core Nostr data management components. It provides a `LocalRelay` class that simulates a Nostr relay in-memory, handling event publishing and subscription management, and a `Repository` class that serves as the central data store for Nostr events with efficient indexing and querying capabilities. Together, these components enable local storage, retrieval, and subscription to Nostr events with support for event replacements, deletions, and expirations. The implementation mimics the behavior of network relays while maintaining everything in memory.

=========================
type: dir
workspace: packages/relay
path: packages/relay/
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/relay/
summary: This package implements a local Nostr protocol implementation with in-memory event storage and relay functionality. The core components include a `Repository` class that provides sophisticated event storage, indexing, and querying capabilities, and a `LocalRelay` class that simulates a Nostr relay with subscription management. The implementation supports standard Nostr operations like publishing, retrieving, replacing, deleting, and expiring events. This package is likely used for testing, development, or applications requiring local Nostr event handling without network dependencies.

=========================
type: file
workspace: packages/router
file: packages/router/package.json
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/router/package.json
include: always
{
  "name": "@welshman/router",
  "version": "0.4.6",
  "author": "hodlbod",
  "license": "MIT",
  "description": "A collection of utilities for nostr relay selection.",
  "publishConfig": {
    "access": "public"
  },
  "type": "module",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "files": [
    "dist"
  ],
  "scripts": {
    "build": "pnpm run clean && pnpm run compile --force",
    "clean": "rimraf ./dist",
    "compile": "tsc -b tsconfig.build.json",
    "prepublishOnly": "pnpm run build"
  },
  "dependencies": {
    "@welshman/lib": "workspace:*",
    "@welshman/util": "workspace:*",
    "@welshman/relay": "workspace:*"
  },
  "devDependencies": {
    "rimraf": "~6.0.0",
    "typescript": "~5.8.0"
  }
}


=========================
type: file
workspace: packages/router
file: packages/router/tsconfig.json
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/router/tsconfig.json
include: always
{
  "extends": "../../tsconfig.json"
}


=========================
workspace: packages/router
file: packages/router/src/index.ts
lines: 40:40
id: 31fa7d074f362b43b58493f1f98e2d576b4e9cb3e0c43a9bd2bfa582522ec412
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/router/src/index.ts#L40

declaration:
INDEXED_KINDS = [PROFILE, RELAYS, INBOX_RELAYS, FOLLOWS]

summary:
A constant array that defines the kinds of Nostr events that are indexed by the system. It includes PROFILE, RELAYS, INBOX_RELAYS, and FOLLOWS event kinds, which are imported from the @welshman/util package.

details:
This constant is a simple array that collects the different event kinds that the system considers as 'indexed' - meaning they are stored and retrievable from indexer relays. These specific event kinds (PROFILE, RELAYS, INBOX_RELAYS, FOLLOWS) are imported from @welshman/util and represent standard Nostr event types that contain metadata about users and their connections. This constant is later used in the getFilterSelectionsForIndexedKinds function to determine which filters should be routed to indexer relays.

related: PROFILE,RELAYS,INBOX_RELAYS,FOLLOWS

import/access examples:
import { INDEXED_KINDS } from '@welshman/router';


=========================
workspace: packages/router
file: packages/router/src/index.ts
lines: 42:45
id: 2e15cc46c508ddd3c9e091a9cf78eb82970f227c35d4ffa955518fd013b911d4
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/router/src/index.ts#L42

declaration:
export type RelaysAndFilters = {
  relays: string[]
  filters: Filter[]
}

summary:
A type definition that represents a combination of relay URLs and filters. It contains two properties: 'relays' which is an array of relay URL strings, and 'filters' which is an array of Filter objects. This type is typically used for routing Nostr events to appropriate relays based on filter criteria.

details:
This is a simple TypeScript type alias that defines a structure for pairing relay URLs with their corresponding filters. It's used throughout the codebase, particularly in the `getFilterSelections` function (lines 415-442) which returns an array of this type to represent which relays should be used for specific filters.

import/access examples:
import type { RelaysAndFilters } from '@welshman/router';


=========================
workspace: packages/router
file: packages/router/src/index.ts
lines: 47:93
id: 50b441fb02a0e0431fff6f1e0dcfeda8221254956b9fef8a27fbd6278b752581
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/router/src/index.ts#L47

declaration:
export type RouterOptions = {
  /**
   * Retrieves the user's public key.
   * @returns The user's public key as a string, or null if not available.
   */
  getUserPubkey?: () => string | undefined

  /**
   * Retrieves relays for the specified public key and mode.
   * @param pubkey - The public key to retrieve relays for.
   * @param mode - The relay mode (optional). May be "read", "write", or "inbox".
   * @returns An array of relay URLs as strings.
   */
  getPubkeyRelays?: (pubkey: string, mode?: RelayMode) => string[]

  /**
   * Retrieves default relays, for use as fallbacks when no other relays can be selected.
   * @returns An array of relay URLs as strings.
   */
  getDefaultRelays?: () => string[]

  /**
   * Retrieves relays that index profiles and relay selections.
   * @returns An array of relay URLs as strings.
   */
  getIndexerRelays?: () => string[]

  /**
   * Retrieves relays likely to support NIP-50 search.
   * @returns An array of relay URLs as strings.
   */
  getSearchRelays?: () => string[]

  /**
   * Retrieves the quality of the specified relay.
   * @param url - The URL of the relay to retrieve quality for.
   * @returns The quality of the relay as a number between 0 and 1 inclusive.
   */
  getRelayQuality?: (url: string) => number

  /**
   * Retrieves the limit setting, which is the maximum number of relays that should be
   * returned from getUrls and getSelections.
   * @returns The limit setting as a number.
   */
  getLimit?: () => number
}

summary:
RouterOptions is a type that defines configuration options for the Router class. It includes optional callback functions for retrieving various relay-related information:
- getUserPubkey: Function to get the user's public key
- getPubkeyRelays: Function to get relays for a specific public key and mode
- getDefaultRelays: Function to get fallback relays
- getIndexerRelays: Function to get relays that index profiles and relay selections
- getSearchRelays: Function to get relays supporting NIP-50 search
- getRelayQuality: Function to get the quality score of a relay
- getLimit: Function to get the maximum number of relays to return

details:
This type definition serves as a configuration interface for the Router class, allowing customization of how relay information is retrieved and managed. Each property is optional and provides a specific function for the router's operation:

1. The functions primarily deal with retrieving different sets of relays based on various criteria (user pubkey, default fallbacks, indexers, search capability)
2. The getRelayQuality function allows for quality-based relay selection, returning a score between 0 and 1
3. The getLimit function controls how many relays should be returned from selection operations

This type is central to the router's functionality as it provides the flexibility to customize relay selection behavior without modifying the router implementation itself.

import/access examples:
import type { RouterOptions } from '@welshman/router';


=========================
workspace: packages/router
file: packages/router/src/index.ts
lines: 95:98
id: feb082dfafa83b422839b0e1d2760f33f238d22f96e27797c0bd916babaa7e4e
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/router/src/index.ts#L95

declaration:
export type Selection = {
  weight: number
  relays: string[]
}

summary:
The `Selection` type represents a weighted collection of relay URLs in the Nostr routing system. It contains two properties: `weight` (a numeric value indicating the importance or priority of the selection) and `relays` (an array of relay URL strings). This type is used throughout the router system to prioritize and select appropriate relays for different operations.

details:
This is a simple type definition with two fields:
1. `weight`: A number that represents the relative importance of this selection compared to others
2. `relays`: An array of relay URL strings

The type is used in conjunction with the `makeSelection` function (defined on line 100) which creates Selection objects, filtering and normalizing the relay URLs. It's a core data structure in the router's relay selection algorithm, used extensively in the RouterScenario class and various routing methods.

import/access examples:
import type { Selection } from '@welshman/router';


=========================
workspace: packages/router
file: packages/router/src/index.ts
lines: 100:103
id: eceb6d1c6546f154d53600eab9e4373a8de6138cf17b8c67d9db76570a7f2295
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/router/src/index.ts#L100

declaration:
makeSelection = (relays: string[], weight = 1): Selection => ({
  relays: relays.filter(isRelayUrl).map(normalizeRelayUrl),
  weight,
})

summary:
Creates a Selection object from an array of relay URLs and an optional weight value. The function filters out invalid relay URLs and normalizes the valid ones. The default weight is 1 if not specified.

details:
This function creates a Selection object by:
1. Filtering the input relay array to only include valid relay URLs using the isRelayUrl function
2. Normalizing each valid relay URL with normalizeRelayUrl function
3. Setting the weight to the provided value or defaulting to 1

The returned Selection object has two properties:
- relays: Array of normalized, valid relay URLs
- weight: Numeric value representing the importance of this selection

related: Selection

import/access examples:
import { makeSelection } from '@welshman/router';


=========================
workspace: packages/router
file: packages/router/src/index.ts
lines: 107:107
id: 34f9470022728ac6846e0c4a1b26c1a4fd04f9d51cfe187f8c3f420d103a1a7f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/router/src/index.ts#L107

declaration:
export type FallbackPolicy = (count: number, limit: number) => number

summary:
FallbackPolicy is a type alias for a function that determines how many fallback relays should be added to a selection. It takes two parameters: the current count of selected relays and the maximum limit of relays, and returns the number of fallback relays to add.

details:
This type is used in the Router system to implement different fallback strategies when selecting relays. The function signature takes two numbers as input (count and limit) and returns a number representing how many fallback relays should be added.

The codebase includes several implementations of this type:
1. addNoFallbacks - adds no fallbacks (returns 0)
2. addMinimalFallbacks - adds 1 fallback only if count is 0
3. addMaximalFallbacks - fills up to the limit by returning (limit - count)

These policies are used by RouterScenario instances to determine how to supplement relay selections when the primary selection strategy doesn't yield enough relays.

import/access examples:
import type { FallbackPolicy } from '@welshman/router';


=========================
workspace: packages/router
file: packages/router/src/index.ts
lines: 109:109
id: cb79f3b22e77c1e9753af3b92cf67f5d5f155e876140e162d8702bddec968cbf
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/router/src/index.ts#L109

declaration:
addNoFallbacks = (count: number, limit: number) => 0

summary:
A fallback policy function that always returns 0, indicating no fallback relays should be added regardless of the current relay count or limit.

details:
This is a simple implementation of the FallbackPolicy type that always returns 0. When used in a RouterScenario, it ensures that no fallback relays will be added to the selection, even if the number of selected relays is below the limit. This is the most restrictive fallback policy.

import/access examples:
import { addNoFallbacks } from '@welshman/router';


=========================
workspace: packages/router
file: packages/router/src/index.ts
lines: 111:111
id: ed6af6498bbb69e3efa2d45f298d3aaf83b5b6465dd6b504c8df0fd6b00bbc5b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/router/src/index.ts#L111

declaration:
addMinimalFallbacks = (count: number, limit: number) => (count > 0 ? 0 : 1)

summary:
A fallback policy function that adds minimal fallbacks to relay selections. It returns 0 if there are already some relays selected (count > 0), or 1 if no relays are selected (count = 0). This ensures at least one relay is always available.

details:
This is a simple implementation of the FallbackPolicy type that follows a minimal approach to fallbacks. It only adds a single fallback relay when no relays have been selected at all, otherwise it adds none. This is useful when you want to ensure there's always at least one relay to connect to, but prefer to use specifically selected relays when available.

import/access examples:
import { addMinimalFallbacks } from '@welshman/router';


=========================
workspace: packages/router
file: packages/router/src/index.ts
lines: 113:113
id: 9dbc49dc44f64f9743c91128519b79dcfb3ec7c82a72b36ddf97f19c588faa7c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/router/src/index.ts#L113

declaration:
addMaximalFallbacks = (count: number, limit: number) => limit - count

summary:
A fallback policy function that adds the maximum number of fallback relays possible within the given limit. It calculates how many additional relays can be added by subtracting the current count from the limit.

details:
This function implements the FallbackPolicy type, taking the current relay count and a limit as parameters, and returns the number of fallback relays to add. It simply subtracts the current count from the limit to use all available slots for fallbacks. This is the most aggressive fallback strategy compared to addNoFallbacks and addMinimalFallbacks.

import/access examples:
import { addMaximalFallbacks } from '@welshman/router';


=========================
workspace: packages/router
file: packages/router/src/index.ts
lines: 117:125
id: 932e9918b7fe41e4a8739e17ae67dbb37d2a314a1ee3c30c9410b5e0b1c34fb7
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/router/src/index.ts#L117

declaration:
routerContext: RouterOptions = {
  getPubkeyRelays: (pubkey: string, mode?: RelayMode) => {
    return uniq(
      Repository.get()
        .query([{kinds: [RELAYS], authors: [pubkey]}])
        .flatMap(event => getRelaysFromList(readList(asDecryptedEvent(event)), mode)),
    )
  },
}

summary:
A global context object that holds configuration options for the Router class. It provides default implementations for router functionality, particularly the `getPubkeyRelays` method which retrieves relay information for a specific public key from the repository. This variable is exported and can be modified through the Router.configure method.

details:
The `routerContext` variable is initialized with a default implementation of `getPubkeyRelays` that:

1. Queries the repository for events of kind RELAYS authored by the specified pubkey
2. Processes these events by:
   - Converting them to decrypted events if needed
   - Reading the list content from the events
   - Extracting relay information based on the specified mode
3. Flattens the results and removes duplicates using the `uniq` function

This serves as the default configuration for Router instances, providing a foundation for relay discovery. The implementation leverages the Repository pattern to fetch relay information from stored events.

related: RouterOptions

import/access examples:
import { routerContext } from '@welshman/router';


=========================
workspace: packages/router
file: packages/router/src/index.ts
lines: 127:253
id: 1e355c665aa7f5fd0584bb8271c377bbb480f8724f22ae6e48974269f24a6bb0
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/router/src/index.ts#L127

declaration:
export class Router{
  readonly options: RouterOptions;
  static configure(options: RouterOptions);
  static get();
  constructor(options: RouterOptions);
  getRelaysForPubkey: (pubkey: string, mode?: RelayMode | undefined) => string[];
  getRelaysForPubkeys: (pubkeys: string[], mode?: RelayMode | undefined) => string[][];
  getRelaysForUser: (mode?: RelayMode | undefined) => string[];
  scenario: (selections: Selection[]) => RouterScenario;
  merge: (scenarios: RouterScenario[]) => RouterScenario;
  FromRelays: (relays: string[]) => RouterScenario;
  Search: () => RouterScenario;
  Index: () => RouterScenario;
  Default: () => RouterScenario;
  ForUser: () => RouterScenario;
  FromUser: () => RouterScenario;
  UserInbox: () => RouterScenario;
  ForPubkey: (pubkey: string) => RouterScenario;
  FromPubkey: (pubkey: string) => RouterScenario;
  PubkeyInbox: (pubkey: string) => RouterScenario;
  ForPubkeys: (pubkeys: string[]) => RouterScenario;
  FromPubkeys: (pubkeys: string[]) => RouterScenario;
  PubkeyInboxes: (pubkeys: string[]) => RouterScenario;
  Event: (event: TrustedEvent) => RouterScenario;
  Replies: (event: TrustedEvent) => RouterScenario;
  Quote: (event: TrustedEvent, value: string, relays?: string[]) => RouterScenario;
  EventParents: (event: TrustedEvent) => RouterScenario;
  EventRoots: (event: TrustedEvent) => RouterScenario;
  PublishEvent: (event: TrustedEvent) => RouterScenario;
}

summary:
The `Router` class is responsible for managing relay selection in a Nostr network. It provides methods to create routing scenarios based on different criteria such as user pubkeys, events, and relay lists. The class helps determine which relays should be used for different operations like publishing events, searching, or retrieving specific data.

The class offers:
- Static methods for configuration and instantiation
- Methods to retrieve relays for specific pubkeys or users
- Factory methods for creating various routing scenarios (Search, Index, ForUser, etc.)
- Specialized routing methods for handling events, replies, quotes, and publishing

details:
The Router implementation works by:

1. Maintaining configuration options through a shared context object (`routerContext`)
2. Using a composition pattern where it creates `RouterScenario` instances for different routing needs
3. Leveraging utility functions from external libraries for data manipulation

Key implementation details:
- The class uses a weight-based system to prioritize relays
- It supports different relay modes (read, write, inbox) for different operations
- It can merge multiple scenarios to create composite routing strategies
- The implementation relies on the Repository pattern to query events
- It handles special cases like event parents, roots, and quotes with specialized logic
- The class provides a fluent interface for building and combining scenarios

related: RouterOptions

code:
export class Router {
  readonly options: RouterOptions

  static configure(options: RouterOptions) {
    Object.assign(routerContext, options)
  }

  static get() {
    return new Router(routerContext)
  }

  constructor(options: RouterOptions) {
    this.options = mergeLeft(options, routerContext)
  }

  // Utilities derived from options

  getRelaysForPubkey = (pubkey: string, mode?: RelayMode) =>
    this.options.getPubkeyRelays?.(pubkey, mode) || []

  getRelaysForPubkeys = (pubkeys: string[], mode?: RelayMode) =>
    pubkeys.map(pubkey => this.getRelaysForPubkey(pubkey, mode))

  getRelaysForUser = (mode?: RelayMode) => {
    const pubkey = this.options.getUserPubkey?.()

    return pubkey ? this.getRelaysForPubkey(pubkey, mode) : []
  }

  // Utilities for creating scenarios

  scenario = (selections: Selection[]) => new RouterScenario(this, selections)

  merge = (scenarios: RouterScenario[]) =>
    this.scenario(scenarios.flatMap((scenario: RouterScenario) => scenario.selections))

  // Routing scenarios

  FromRelays = (relays: string[]) => this.scenario([makeSelection(relays)])

  Search = () => this.FromRelays(this.options.getSearchRelays?.() || [])

  Index = () => this.FromRelays(this.options.getIndexerRelays?.() || [])

  Default = () => this.FromRelays(this.options.getDefaultRelays?.() || [])

  ForUser = () => this.FromRelays(this.getRelaysForUser(RelayMode.Read))

  FromUser = () => this.FromRelays(this.getRelaysForUser(RelayMode.Write))

  UserInbox = () => this.FromRelays(this.getRelaysForUser(RelayMode.Inbox))

  ForPubkey = (pubkey: string) => this.FromRelays(this.getRelaysForPubkey(pubkey, RelayMode.Read))

  FromPubkey = (pubkey: string) => this.FromRelays(this.getRelaysForPubkey(pubkey, RelayMode.Write))

  PubkeyInbox = (pubkey: string) =>
    this.FromRelays(this.getRelaysForPubkey(pubkey, RelayMode.Inbox))

  ForPubkeys = (pubkeys: string[]) => this.merge(pubkeys.map(pubkey => this.ForPubkey(pubkey)))

  FromPubkeys = (pubkeys: string[]) => this.merge(pubkeys.map(pubkey => this.FromPubkey(pubkey)))

  PubkeyInboxes = (pubkeys: string[]) => this.merge(pubkeys.map(pubkey => this.PubkeyInbox(pubkey)))

  Event = (event: TrustedEvent) =>
    this.FromRelays(this.getRelaysForPubkey(event.pubkey, RelayMode.Write))

  Replies = (event: TrustedEvent) =>
    this.FromRelays(this.getRelaysForPubkey(event.pubkey, RelayMode.Read))

  Quote = (event: TrustedEvent, value: string, relays: string[] = []) => {
    const tag = event.tags.find(t => t[1] === value)
    const scenarios = [
      this.FromRelays(relays),
      this.ForPubkey(event.pubkey),
      this.FromPubkey(event.pubkey),
    ]

    if (tag?.[2] && isShareableRelayUrl(tag[2])) {
      scenarios.push(this.FromRelays([tag[2]]))
    }

    if (tag?.[3]?.length === 64) {
      scenarios.push(this.FromPubkeys([tag[3]]))
    }

    return this.merge(scenarios)
  }

  EventParents = (event: TrustedEvent) => {
    const {replies} = getAncestorTags(event)
    const mentions = getPubkeyTags(event.tags)
    const authors = replies.map(nth(3)).filter(p => p?.length === 64)
    const others = mentions.map(nth(1)).filter(p => p?.length === 64)
    const relays = uniq([...replies, ...mentions].map(nth(2)).filter(r => r && isRelayUrl(r)))

    return this.merge([
      this.FromPubkeys(authors).weight(10),
      this.FromPubkeys(others),
      this.FromRelays(relays),
    ])
  }

  EventRoots = (event: TrustedEvent) => {
    const {roots} = getAncestorTags(event)
    const mentions = getPubkeyTags(event.tags)
    const authors = roots.map(nth(3)).filter(p => p?.length === 64)
    const others = mentions.map(nth(1)).filter(p => p?.length === 64)
    const relays = uniq([...roots, ...mentions].map(nth(2)).filter(r => r && isRelayUrl(r)))

    return this.merge([
      this.FromPubkeys(authors).weight(10),
      this.FromPubkeys(others),
      this.FromRelays(relays),
    ])
  }

  PublishEvent = (event: TrustedEvent) => {
    const pubkeys = getPubkeyTagValues(event.tags)

    return this.merge([
      this.FromPubkey(event.pubkey),
      ...pubkeys.map(pubkey => this.ForPubkey(pubkey).weight(0.5)),
    ])
  }
}

import/access examples:
import { Router } from '@welshman/router';


=========================
workspace: packages/router
file: packages/router/src/index.ts
lines: 257:263
id: 8e16c3bc491001c3776d1648d6fc1154a114cce5c50d7aa7076ef0f7387e2ac0
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/router/src/index.ts#L257

declaration:
export type RouterScenarioOptions = {
  policy?: FallbackPolicy
  limit?: number
  allowLocal?: boolean
  allowOnion?: boolean
  allowInsecure?: boolean
}

summary:
RouterScenarioOptions is a type alias that defines configuration options for a RouterScenario. It includes the following optional properties:
- policy: A FallbackPolicy function that determines how fallback relays are added
- limit: A number specifying the maximum relays to return
- allowLocal: A boolean indicating whether local relays are permitted
- allowOnion: A boolean indicating whether Tor onion relays are permitted
- allowInsecure: A boolean indicating whether insecure (ws://) relays are permitted

details:
This type is used to configure the behavior of RouterScenario instances, providing fine-grained control over relay selection policies. It works in conjunction with the Router and RouterScenario classes to determine which relays are included in the final selection. The options affect filtering behavior in the getUrls() method of RouterScenario, where relays are filtered based on these settings before being returned to the caller.

related: FallbackPolicy

import/access examples:
import type { RouterScenarioOptions } from '@welshman/router';


=========================
workspace: packages/router
file: packages/router/src/index.ts
lines: 265:350
id: c4f5fb64ab51579a27bc17684f5a26b862815b3f85d628f0f4b511497abf8511
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/router/src/index.ts#L265

declaration:
export class RouterScenario{
  constructor(
      readonly router: Router,
      readonly selections: Selection[],
      readonly options: RouterScenarioOptions = {},
    );
  clone: (options: RouterScenarioOptions) => RouterScenario;
  filter: (f: (selection: Selection) => boolean) => RouterScenario;
  update: (f: (selection: Selection) => Selection) => RouterScenario;
  policy: (policy: FallbackPolicy) => RouterScenario;
  limit: (limit: number) => RouterScenario;
  allowLocal: (allowLocal: boolean) => RouterScenario;
  allowOnion: (allowOnion: boolean) => RouterScenario;
  allowInsecure: (allowInsecure: boolean) => RouterScenario;
  weight: (scale: number) => RouterScenario;
  getPolicy: () => (count: number, limit: number) => number;
  getLimit: () => number;
  getUrls: () => string[];
  getUrl: () => string | undefined;
}

summary:
RouterScenario is a class that represents a routing scenario for Nostr relays. It manages a collection of relay selections with their associated weights and provides methods to filter, transform, and retrieve relay URLs based on various criteria. The class offers configuration options for fallback policies, relay limits, and filtering by relay types (local, onion, insecure). It helps determine which relays should be used for different operations in a Nostr client.

details:
The RouterScenario implementation works as follows:

1. It maintains a list of Selection objects (each containing relays and their weight) and configuration options.

2. It provides chainable methods for configuration:
   - clone() - creates a copy with modified options
   - filter() - filters selections based on a predicate
   - update() - transforms selections
   - policy(), limit(), allowLocal(), allowOnion(), allowInsecure() - set specific options
   - weight() - scales the weight of all selections

3. The core functionality is in getUrls() which:
   - Aggregates relay weights across all selections
   - Filters relays based on configuration (onion/local/insecure settings)
   - Scores relays using a formula that considers quality, weight, and randomness
   - Sorts and limits relays to the configured limit
   - Adds fallback relays according to the fallback policy

4. The scoring algorithm uses a logarithmic scale with randomness to avoid over-weighting popular relays while still preferring higher quality ones.

related: Router,Selection,RouterScenarioOptions

code:
export class RouterScenario {
  constructor(
    readonly router: Router,
    readonly selections: Selection[],
    readonly options: RouterScenarioOptions = {},
  ) {}

  clone = (options: RouterScenarioOptions) =>
    new RouterScenario(this.router, this.selections, {...this.options, ...options})

  filter = (f: (selection: Selection) => boolean) =>
    new RouterScenario(
      this.router,
      this.selections.filter(selection => f(selection)),
      this.options,
    )

  update = (f: (selection: Selection) => Selection) =>
    new RouterScenario(
      this.router,
      this.selections.map(selection => f(selection)),
      this.options,
    )

  policy = (policy: FallbackPolicy) => this.clone({policy})

  limit = (limit: number) => this.clone({limit})

  allowLocal = (allowLocal: boolean) => this.clone({allowLocal})

  allowOnion = (allowOnion: boolean) => this.clone({allowOnion})

  allowInsecure = (allowInsecure: boolean) => this.clone({allowInsecure})

  weight = (scale: number) =>
    this.update(selection => ({...selection, weight: selection.weight * scale}))

  getPolicy = () => this.options.policy || addNoFallbacks

  getLimit = () => this.options.limit || this.router.options.getLimit?.() || 3

  getUrls = () => {
    const limit = this.getLimit()
    const fallbackPolicy = this.getPolicy()
    const relayWeights = new Map<string, number>()
    const {allowOnion, allowLocal, allowInsecure} = this.options

    for (const {weight, relays} of this.selections) {
      for (const relay of relays) {
        if (!isRelayUrl(relay)) continue
        if (!allowOnion && isOnionUrl(relay)) continue
        if (!allowLocal && isLocalUrl(relay)) continue
        if (!allowInsecure && relay.startsWith("ws://") && !isOnionUrl(relay)) continue

        relayWeights.set(relay, add(weight, relayWeights.get(relay)))
      }
    }

    const scoreRelay = (relay: string) => {
      const quality = this.router.options.getRelayQuality?.(relay) || 1
      const weight = relayWeights.get(relay)!

      // Log the weight, since it's a straight count which ends up over-weighting hubs.
      // Also add some random noise so that we'll occasionally pick lower quality/less
      // popular relays.
      return quality ? -(quality * inc(Math.log(weight)) * Math.random()) : 0
    }

    const relays = take(
      limit,
      sortBy(scoreRelay, Array.from(relayWeights.keys()).filter(scoreRelay)),
    )

    const fallbacksNeeded = fallbackPolicy(relays.length, limit)
    const allFallbackRelays: string[] = this.router.options.getDefaultRelays?.() || []
    const fallbackRelays = shuffle(allFallbackRelays).slice(0, fallbacksNeeded)

    for (const fallbackRelay of fallbackRelays) {
      relays.push(fallbackRelay)
    }

    return relays
  }

  getUrl = () => first(this.getUrls())
}

import/access examples:
import { RouterScenario } from '@welshman/router';


=========================
workspace: packages/router
file: packages/router/src/index.ts
lines: 354:354
id: a4c5abb5a8d6d373662c7ca67893b9e90c200c49e9091cdbf395889f9120ca9a
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/router/src/index.ts#L354

declaration:
type FilterScenario = {filter: Filter; scenario: RouterScenario}

summary:
A type alias that represents a combination of a filter and a routing scenario. It is used in the relay selection process to associate specific filters with appropriate routing scenarios.

details:
This type alias is a simple structure with two properties:
1. `filter`: A Filter object that defines criteria for selecting events
2. `scenario`: A RouterScenario instance that determines which relays to use for the filter

It's primarily used in the filter selection rules (like `getFilterSelectionsForSearch`, `getFilterSelectionsForAuthors`, etc.) to map filters to appropriate relay scenarios based on different criteria.

related: RouterScenario

=========================
workspace: packages/router
file: packages/router/src/index.ts
lines: 356:356
id: e20f3bef622af1768eb923b8a43516720ad841f20391392e1d3d59bbb755a8b1
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/router/src/index.ts#L356

declaration:
type FilterSelectionRule = (filter: Filter) => FilterScenario[]

summary:
A type alias that defines a function type for creating filter selection rules in a relay routing system. The function takes a Filter object as input and returns an array of FilterScenario objects, which pair filters with router scenarios.

details:
This type alias represents a core concept in the relay selection mechanism of the application. It defines the signature for functions that determine how to route specific filters to appropriate relays. Each implementation of this type analyzes a filter and returns scenarios that specify which relays should handle that filter. The returned FilterScenario objects contain both the (potentially modified) filter and the routing scenario that defines which relays to use.

The type is used in the defaultFilterSelectionRules array and the getFilterSelections function to create a pluggable system for routing filters to appropriate relays based on their content.

related: FilterScenario

=========================
workspace: packages/router
file: packages/router/src/index.ts
lines: 358:364
id: fe97ccde9419f70813be635e138f0c6f93cd04a11cff5cb8e421e06e914117fd
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/router/src/index.ts#L358

declaration:
getFilterSelectionsForSearch = (filter: Filter) => {
  if (!filter.search) return []

  const relays = routerContext.getSearchRelays?.() || []

  return [{filter, scenario: Router.get().FromRelays(relays).weight(10)}]
}

summary:
A function that generates filter selections for search queries. It takes a Filter object and returns an array of FilterScenario objects (containing filter and scenario properties) specifically for search operations. If the filter doesn't contain a search parameter, it returns an empty array. When a search parameter exists, it creates a scenario using search-capable relays with increased weight.

details:
The implementation works by:
1. First checking if the filter has a search property - if not, it returns an empty array immediately
2. Retrieving search-capable relays from the routerContext (or defaulting to an empty array)
3. Creating and returning a single FilterScenario object that:
   - Preserves the original filter
   - Creates a routing scenario using the Router.get().FromRelays() method with the search relays
   - Applies a weight multiplier of 10 to prioritize these relays for search operations

import/access examples:
import { getFilterSelectionsForSearch } from '@welshman/router';


=========================
workspace: packages/router
file: packages/router/src/index.ts
lines: 366:375
id: e689a6f5baf0c498b45f263ef8d21d018a91ecea3cba903fde3eed98f1e95c87
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/router/src/index.ts#L366

declaration:
getFilterSelectionsForWraps = (filter: Filter) => {
  if (!filter.kinds?.includes(WRAP) || filter.authors) return []

  return [
    {
      filter: {...filter, kinds: [WRAP]},
      scenario: Router.get().UserInbox(),
    },
  ]
}

summary:
A function that generates filter selections specifically for WRAP kind events. It takes a Filter object and returns an array of FilterScenario objects that target WRAP events through the user's inbox relays. Returns an empty array if the filter doesn't include WRAP kind or if it specifies authors.

details:
This function implements a specific rule for routing WRAP kind events:

1. It first checks if the filter is applicable for WRAP events by verifying:
   - The filter includes the WRAP kind
   - The filter doesn't specify authors (which would make it more specific than this general rule)

2. If the filter doesn't meet these criteria, it returns an empty array.

3. If applicable, it returns a single FilterScenario that:
   - Creates a modified filter that specifically targets only WRAP kind events
   - Routes these events through the user's inbox relays via Router.get().UserInbox()

This is part of the relay selection system that determines which relays should be queried for specific types of events.

import/access examples:
import { getFilterSelectionsForWraps } from '@welshman/router';


=========================
workspace: packages/router
file: packages/router/src/index.ts
lines: 377:390
id: 30f5844a1e943a28b11aa391798e0bf98b659124fe099b1125171bcb469cef5c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/router/src/index.ts#L377

declaration:
getFilterSelectionsForIndexedKinds = (filter: Filter) => {
  const kinds = intersection(INDEXED_KINDS, filter.kinds || [])

  if (kinds.length === 0) return []

  const relays = routerContext.getIndexerRelays?.() || []

  return [
    {
      filter: {...filter, kinds},
      scenario: Router.get().FromRelays(relays),
    },
  ]
}

summary:
A function that creates filter selections for indexed kinds. It takes a Filter object and returns an array of FilterScenario objects that target indexer relays for specific kinds of data (profiles, relays, inbox relays, follows). If the filter doesn't include any indexed kinds, it returns an empty array.

details:
The implementation works as follows:
1. It first extracts the intersection between INDEXED_KINDS (a predefined array of kinds that are indexed) and the kinds specified in the filter (or an empty array if none specified).
2. If there are no indexed kinds in the filter, it returns an empty array.
3. Otherwise, it retrieves indexer relays from the router context.
4. It then returns a single FilterScenario object that:
   - Contains a modified filter with only the indexed kinds
   - Uses a scenario that targets the indexer relays

This function is part of a larger relay selection system that determines which relays should be queried for different types of data in a Nostr application.

import/access examples:
import { getFilterSelectionsForIndexedKinds } from '@welshman/router';


=========================
workspace: packages/router
file: packages/router/src/index.ts
lines: 392:401
id: 9016d4882c4c4298d2a3ac1ab143f24896f67d4c5fe73d414018ec3d06847662
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/router/src/index.ts#L392

declaration:
getFilterSelectionsForAuthors = (filter: Filter) => {
  if (!filter.authors) return []

  const chunkCount = clamp([1, 30], Math.round(filter.authors.length / 30))

  return chunks(chunkCount, filter.authors).map(authors => ({
    filter: {...filter, authors},
    scenario: Router.get().FromPubkeys(authors),
  }))
}

summary:
A function that generates filter selections for authors in a Nostr relay routing system. It takes a Filter object and returns an array of FilterScenario objects. When authors are present in the filter, it divides them into chunks and creates separate filter scenarios for each chunk, using the FromPubkeys routing scenario.

details:
The implementation works as follows:
1. First checks if the filter has an authors property - if not, returns an empty array
2. Calculates how many chunks to split the authors into by dividing the total count by 30 and clamping between 1-30
3. Uses the chunks utility to split the authors array into the calculated number of chunks
4. Maps each chunk of authors to a new FilterScenario object that:
   - Contains a modified filter with just that chunk of authors
   - Uses Router.get().FromPubkeys() to create a routing scenario targeting the write relays of those authors
5. This chunking approach helps distribute author queries across multiple relays rather than sending one large query

import/access examples:
import { getFilterSelectionsForAuthors } from '@welshman/router';


=========================
workspace: packages/router
file: packages/router/src/index.ts
lines: 403:405
id: 4bb57f9301eabbaaec22499f0cc4a32bba080bdaacb5185db689868c38d006b7
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/router/src/index.ts#L403

declaration:
getFilterSelectionsForUser = (filter: Filter) => [
  {filter, scenario: Router.get().ForUser().weight(0.2)},
]

summary:
A function that creates filter selections for a user's own relays. It takes a Filter object as input and returns an array containing a single FilterScenario object. The FilterScenario includes the original filter and a scenario that targets the user's read relays with a reduced weight of 0.2.

details:
This function is part of the relay selection system and implements one of the filter selection rules. It's a simple implementation that:

1. Takes any filter and returns it unchanged
2. Pairs it with a scenario that uses the Router.get().ForUser() method to select the user's read relays
3. Applies a weight of 0.2 to this scenario, which reduces its priority compared to other selection rules
4. Returns this as a single-element array containing the filter-scenario pair

This function is used as one of the default filter selection rules in the defaultFilterSelectionRules array.

import/access examples:
import { getFilterSelectionsForUser } from '@welshman/router';


=========================
workspace: packages/router
file: packages/router/src/index.ts
lines: 407:413
id: b59bb47d6cc76178f18f73fa9d9ab0327e6228dcc6c2d7d9d2a49f345c71f589
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/router/src/index.ts#L407

declaration:
defaultFilterSelectionRules = [
  getFilterSelectionsForSearch,
  getFilterSelectionsForWraps,
  getFilterSelectionsForIndexedKinds,
  getFilterSelectionsForAuthors,
  getFilterSelectionsForUser,
]

summary:
An array of filter selection rules used as the default set of rules for determining how to route Nostr filters to appropriate relays. It includes rules for handling search queries, wraps, indexed kinds, author-specific filters, and user-related filters.

details:
This constant is an array that contains five filter selection rule functions:

1. `getFilterSelectionsForSearch` - Handles filters with search parameters by routing them to search-capable relays
2. `getFilterSelectionsForWraps` - Processes WRAP kind filters by directing them to the user's inbox
3. `getFilterSelectionsForIndexedKinds` - Routes filters for indexed kinds (profiles, relays, inbox relays, follows) to indexer relays
4. `getFilterSelectionsForAuthors` - Handles author-specific filters by chunking authors into groups and routing to appropriate relays
5. `getFilterSelectionsForUser` - Provides a fallback that routes filters to the user's read relays with reduced weight

These rules are used by the `getFilterSelections` function to determine the optimal relay routing strategy for different types of Nostr filters.

related: getFilterSelectionsForSearch,getFilterSelectionsForWraps,getFilterSelectionsForIndexedKinds,getFilterSelectionsForAuthors,getFilterSelectionsForUser

import/access examples:
import { defaultFilterSelectionRules } from '@welshman/router';


=========================
workspace: packages/router
file: packages/router/src/index.ts
lines: 415:442
id: d69fc86264cc25c6c450b10f3b25832a257ffdc414a0a623d82e25a4109e82ac
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/router/src/index.ts#L415

declaration:
getFilterSelections = (
  filters: Filter[],
  rules: FilterSelectionRule[] = defaultFilterSelectionRules,
): RelaysAndFilters[] => {
  const filtersById = new Map<string, Filter>()
  const scenariosById = new Map<string, RouterScenario[]>()

  for (const filter of filters) {
    for (const filterScenario of rules.flatMap(rule => rule(filter))) {
      const id = getFilterId(filterScenario.filter)

      filtersById.set(id, filterScenario.filter)
      pushToMapKey(scenariosById, id, filterScenario.scenario)
    }
  }

  const result = []

  for (const [id, filter] of filtersById.entries()) {
    const scenario = Router.get()
      .merge(scenariosById.get(id) || [])
      .policy(addMinimalFallbacks)

    result.push({filters: [filter], relays: scenario.getUrls()})
  }

  return result
}

summary:
A function that determines the optimal relay selections for a set of filters in a Nostr network. It takes an array of Filter objects and an optional array of FilterSelectionRule functions, and returns an array of RelaysAndFilters objects. Each RelaysAndFilters object contains a filter and the appropriate relays to query for that filter, based on the selection rules applied.

details:
The implementation works in several steps:

1. It initializes two Maps: one to store filters by their ID, and another to store scenarios by filter ID.

2. For each filter in the input array, it applies all the provided selection rules (defaulting to the predefined rules if none are specified).

3. Each rule generates FilterScenario objects that pair a filter with a RouterScenario indicating which relays should be used.

4. The function organizes these by filter ID (using getFilterId), storing the filter and accumulating scenarios for each unique filter ID.

5. Finally, it processes each unique filter:
   - Merges all scenarios for that filter
   - Applies a minimal fallback policy
   - Gets the URLs from the resulting scenario
   - Creates a RelaysAndFilters object with the filter and selected relays

The function effectively routes different types of Nostr filters to the most appropriate relays based on the filter content and the configured routing rules.

related: FilterSelectionRule,RelaysAndFilters

import/access examples:
import { getFilterSelections } from '@welshman/router';


=========================
type: file
workspace: packages/router
path: packages/router/src/index.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/router/src/index.ts
summary: This file exports a routing system for Nostr relays, centered around the `Router` class. It provides functionality to determine which relays to use for different operations based on user preferences, event context, and relay quality. Key exports include the `Router` class for creating routing scenarios, `RouterScenario` for configuring relay selection details, and utility functions like `getFilterSelections` that help determine appropriate relays for specific filters. The module also defines types like `RelaysAndFilters` and `RouterOptions` that support the routing infrastructure.

details: The implementation is built around two main classes:

1. `Router` - Creates and manages routing scenarios based on configuration options. It:
   - Uses a singleton pattern with static `configure()` and `get()` methods
   - Provides methods to create scenarios for different contexts (user relays, pubkey relays, event-specific relays)
   - Includes specialized methods for handling different Nostr use cases (replies, quotes, event publishing)

2. `RouterScenario` - Represents a specific relay selection strategy with:
   - Methods for filtering, weighting, and configuring relay selection
   - Support for fallback policies when insufficient relays are found
   - Relay scoring based on quality and weight

The implementation uses a weighted selection approach where relays are assigned weights based on their relevance to the current context. It includes several helper functions for creating selections based on filter criteria, with specialized handling for searches, wraps, indexed kinds, and author-specific queries.

The code makes extensive use of functional programming patterns from an external library (@welshman/lib) and relies on utility functions from @welshman/util for Nostr-specific operations like normalizing relay URLs and extracting information from events.

=========================
type: dir
workspace: packages/router
path: packages/router/src/
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/router/src/
summary: This directory exports a Nostr relay routing system centered around the `Router` class, which determines which relays to use for different operations based on criteria like pubkeys, event types, and user preferences. Key exports include the `Router` class for creating routing scenarios, `RouterScenario` for configuring relay selection details, and utility functions like `getFilterSelections` for determining appropriate relays for specific filters. The module implements various relay selection strategies with weighted scoring that considers relay quality, popularity, and adds randomness for diversity, along with configurable fallback policies.

=========================
type: dir
workspace: packages/router
path: packages/router/
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/router/
summary: This package provides a Nostr relay routing system built around the `Router` class, which intelligently selects appropriate relays for different operations based on criteria such as public keys, event types, and user preferences. The system implements weighted scoring for relay selection that balances relay quality, popularity, and introduces randomness for network diversity. Key exports include the `Router` class for creating routing scenarios, `RouterScenario` for detailed relay selection configuration, and utility functions like `getFilterSelections` that help determine which relays to use for specific filters. The package also supports configurable fallback policies for relay selection.

=========================
type: file
workspace: packages/signer
file: packages/signer/package.json
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/package.json
include: always
{
  "name": "@welshman/signer",
  "version": "0.4.6",
  "author": "hodlbod",
  "license": "MIT",
  "description": "A nostr signer implemenation supporting several login methods.",
  "publishConfig": {
    "access": "public"
  },
  "type": "module",
  "main": "dist/signer/src/index.js",
  "types": "dist/signer/src/index.d.ts",
  "files": [
    "dist"
  ],
  "scripts": {
    "build": "pnpm run clean && pnpm run compile --force",
    "clean": "rimraf ./dist",
    "compile": "tsc -b tsconfig.build.json",
    "prepublishOnly": "pnpm run build"
  },
  "dependencies": {
    "@noble/curves": "^1.7.0",
    "@noble/hashes": "^1.6.1",
    "@welshman/lib": "workspace:*",
    "@welshman/net": "workspace:*",
    "@welshman/util": "workspace:*",
    "nostr-tools": "^2.14.2"
  },
  "devDependencies": {
    "@capacitor/core": "^7.2.0",
    "nostr-signer-capacitor-plugin": "~0.0.4",
    "rimraf": "~6.0.0",
    "typescript": "~5.8.0"
  },
  "peerDependencies": {
    "nostr-signer-capacitor-plugin": "~0.0.4"
  }
}


=========================
type: file
workspace: packages/signer
file: packages/signer/tsconfig.json
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/tsconfig.json
include: always
{
  "extends": "../../tsconfig.json"
}


=========================
workspace: packages/signer
file: packages/signer/src/util.ts
lines: 9:9
id: 99e93724794b5a30e755c83c5f5fa6f24616a0fc6db4c3ae9b6f0a418c80136b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/util.ts#L9

declaration:
makeSecret = () => bytesToHex(generateSecretKey())

summary:
A utility function that generates a new random secret key for cryptographic operations and returns it as a hexadecimal string. This function is useful for creating private keys in Nostr-related applications.

details:
The implementation uses the `generateSecretKey()` function from the nostr-tools library to create a random secret key (which returns bytes), and then converts those bytes to a hexadecimal string using the `bytesToHex` utility from @noble/hashes. This provides a convenient way to generate secret keys in the format commonly used throughout the application.

related: bytesToHex

import/access examples:
import { makeSecret } from '@welshman/signer';
import { makeSecret } from '@welshman/signer/util';


=========================
workspace: packages/signer
file: packages/signer/src/util.ts
lines: 11:11
id: 231a7d0b80689a31c9b3e06bf74f1099d94149a733d18151ac17531988a6dc4f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/util.ts#L11

declaration:
getPubkey = (secret: string) => getPublicKey(hexToBytes(secret))

summary:
A function that derives a public key from a given secret key. It takes a hexadecimal string representing a secret key and returns the corresponding public key.

details:
This function converts the provided hex-encoded secret key to bytes using `hexToBytes` from the Noble Hashes library, then passes it to the `getPublicKey` function from Nostr Tools to generate the corresponding public key. It's a simple wrapper that handles the conversion between string and byte array formats.

related: getPublicKey

import/access examples:
import { getPubkey } from '@welshman/signer';
import { getPubkey } from '@welshman/signer/util';


=========================
workspace: packages/signer
file: packages/signer/src/util.ts
lines: 13:13
id: 64510ac226c05a1f6ba7d9a8e2c422a970c4622fb1feff6a49fe83ac66211147
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/util.ts#L13

declaration:
getHash = (event: OwnedEvent) => getEventHash(event)

summary:
A utility function that calculates and returns the hash of a Nostr event. It takes an `OwnedEvent` as input and returns the event hash as a string using the `getEventHash` function from the nostr-tools library.

details:
This function is a simple wrapper around the `getEventHash` function imported from "nostr-tools/pure". It takes an `OwnedEvent` (which is a Nostr event that has a pubkey assigned) and passes it directly to `getEventHash` to compute the event's unique identifier hash. The implementation is straightforward with no additional processing or side effects.

related: getEventHash

import/access examples:
import { getHash } from '@welshman/signer';
import { getHash } from '@welshman/signer/util';


=========================
workspace: packages/signer
file: packages/signer/src/util.ts
lines: 15:16
id: aafe11b04878e5a1361cb07a1e1ed7cfd9cbcf55d911b1eef0e9e60d8930c093
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/util.ts#L15

declaration:
getSig = (event: HashedEvent, secret: string) =>
  bytesToHex(schnorr.sign(event.id, secret))

summary:
A function that generates a Schnorr signature for a Nostr event. It takes a hashed event and a secret key as inputs and returns the signature as a hexadecimal string.

details:
The implementation uses the schnorr.sign method from the @noble/curves/secp256k1 library to create a digital signature. It signs the event's id (which is a hash) using the provided secret key. The resulting signature bytes are then converted to a hexadecimal string using bytesToHex before being returned. This function is a core component for creating signed Nostr events.

related: bytesToHex

import/access examples:
import { getSig } from '@welshman/signer';
import { getSig } from '@welshman/signer/util';


=========================
workspace: packages/signer
file: packages/signer/src/util.ts
lines: 18:18
id: 1f9cf531291d20abaa247141467d50c2ef2eb651f7c578048806ca775aca78e4
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/util.ts#L18

declaration:
stamp = (event: EventTemplate, created_at = now()) => ({...event, created_at})

summary:
The `stamp` function adds a timestamp to an event template. It takes an `EventTemplate` object and an optional `created_at` timestamp (defaulting to the current time), and returns a new object that combines the original event with the timestamp.

details:
This function implements a simple immutable update pattern by using the spread operator to create a new object that contains all properties from the original event template plus the `created_at` property. If no timestamp is provided, it uses the `now()` function (imported from `@welshman/lib`) to get the current time. This function is part of a pipeline for creating and processing Nostr events, where adding a timestamp is one step in the event creation process.

import/access examples:
import { stamp } from '@welshman/signer';
import { stamp } from '@welshman/signer/util';


=========================
workspace: packages/signer
file: packages/signer/src/util.ts
lines: 20:20
id: 9db4506b46a48fc912fc5067aa79d34aa3f515ea34905d981e293f6b31b5eb47
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/util.ts#L20

declaration:
own = (event: StampedEvent, pubkey: string) => ({...event, pubkey})

summary:
The `own` function takes a stamped event and a public key, then returns a new event object that includes all properties of the original event plus the provided public key. This function is used to associate an event with a specific owner by adding the `pubkey` property.

details:
This is a simple pure function that uses object spread syntax to create a new object. It takes a `StampedEvent` (which appears to be an event with a timestamp) and adds the `pubkey` field to it, effectively transforming it into an `OwnedEvent`. This is part of what seems to be a chain of event transformation functions in the Nostr protocol implementation.

import/access examples:
import { own } from '@welshman/signer';
import { own } from '@welshman/signer/util';


=========================
workspace: packages/signer
file: packages/signer/src/util.ts
lines: 22:22
id: a421bc333cf765c5b0b51b9b56daeadaafb1325aaa738ba1d6f1a188fbef4ba9
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/util.ts#L22

declaration:
hash = (event: OwnedEvent) => ({...event, id: getHash(event)})

summary:
A function that takes an OwnedEvent object and returns a new object with all properties of the original event plus an 'id' property containing the event hash. The hash is calculated using the getHash function.

details:
This function creates a new object by spreading the properties of the input event and adding an 'id' field. The value of this 'id' field is generated by calling the getHash function with the event as an argument. The getHash function (defined on line 13) internally uses the getEventHash function from nostr-tools/pure to calculate a unique hash for the event. This is a pure function with no side effects that follows the immutable pattern of returning a new object rather than modifying the input.

import/access examples:
import { hash } from '@welshman/signer';
import { hash } from '@welshman/signer/util';


=========================
workspace: packages/signer
file: packages/signer/src/util.ts
lines: 24:24
id: 4fc691bf97480206f7ff608471ef19d9a259894f871535f0dd001faaad88f37f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/util.ts#L24

declaration:
sign = (event: HashedEvent, secret: string) => ({...event, sig: getSig(event, secret)})

summary:
A function that signs a hashed Nostr event with a provided secret key. It takes a hashed event object and a secret key string as parameters, and returns a new event object with the signature added as the 'sig' property.

details:
This function implements Nostr event signing by:
1. Taking a hashed event (which must already have an 'id' property) and a secret key
2. Using the getSig helper function to generate a Schnorr signature for the event
3. Creating and returning a new object that spreads all properties from the original event and adds the signature as the 'sig' property
4. The actual signature generation is delegated to the getSig function which uses schnorr.sign from the @noble/curves/secp256k1 library

import/access examples:
import { sign } from '@welshman/signer';
import { sign } from '@welshman/signer/util';


=========================
workspace: packages/signer
file: packages/signer/src/util.ts
lines: 26:30
id: 386b24d838d0817cd41009498770e574f24baf4d406fb5ae49285e80260d1f01
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/util.ts#L26

declaration:
nip04 = {
  detect: (m: string) => m.includes("?iv="),
  encrypt: (pubkey: string, secret: string, m: string) => nt04.encrypt(secret, pubkey, m),
  decrypt: (pubkey: string, secret: string, m: string) => nt04.decrypt(secret, pubkey, m),
}

summary:
An object that provides utilities for NIP-04 encryption and decryption in the Nostr protocol. It includes methods to detect NIP-04 encrypted messages, encrypt messages using a public key and secret, and decrypt messages using a public key and secret.

details:
The `nip04` object contains three methods:
1. `detect`: A simple function that checks if a message contains the string '?iv=', which is a characteristic of NIP-04 encrypted messages.
2. `encrypt`: Delegates to the `encrypt` function from the imported 'nostr-tools/nip04' module to encrypt a message using a recipient's public key and the sender's secret key.
3. `decrypt`: Delegates to the `decrypt` function from the imported 'nostr-tools/nip04' module to decrypt a message using the sender's public key and the recipient's secret key.

This implementation serves as a wrapper around the core NIP-04 functionality provided by the nostr-tools library.

import/access examples:
import { nip04 } from '@welshman/signer';
import { nip04 } from '@welshman/signer/util';


=========================
workspace: packages/signer
file: packages/signer/src/util.ts
lines: 32:43
id: 388581981d6b6c63eaec206afe13cf98c0bf8e8785f80bee3b98e6feb0f2e983
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/util.ts#L32

declaration:
nip44 = {
  getSharedSecret: cached({
    maxSize: 10000,
    getKey: ([secret, pubkey]) => `${secret}:${pubkey}`,
    getValue: ([secret, pubkey]: string[]) =>
      nt44.v2.utils.getConversationKey(hexToBytes(secret), pubkey),
  }),
  encrypt: (pubkey: string, secret: string, m: string) =>
    nt44.v2.encrypt(m, nip44.getSharedSecret(secret, pubkey)!),
  decrypt: (pubkey: string, secret: string, m: string) =>
    nt44.v2.decrypt(m, nip44.getSharedSecret(secret, pubkey)!),
}

summary:
An object that provides utilities for NIP-44 encryption and decryption in the Nostr protocol. It includes methods for getting shared secrets between users, encrypting messages, and decrypting messages using the NIP-44 specification (version 2).

details:
The `nip44` object implements three main functions:

1. `getSharedSecret`: A cached function that computes and stores conversation keys between users to improve performance. It:
   - Uses a cache with a maximum size of 10,000 entries
   - Creates cache keys using a combination of secret and pubkey
   - Calls the underlying `nt44.v2.utils.getConversationKey` function with hex-decoded secret keys

2. `encrypt`: Encrypts a message using NIP-44 v2 protocol by:
   - Getting the shared secret for the given pubkey and secret
   - Using the `nt44.v2.encrypt` function with the message and shared secret

3. `decrypt`: Decrypts a message using NIP-44 v2 protocol by:
   - Getting the shared secret for the given pubkey and secret
   - Using the `nt44.v2.decrypt` function with the encrypted message and shared secret

The implementation uses caching to avoid recalculating shared secrets repeatedly, which is an optimization for performance.

import/access examples:
import { nip44 } from '@welshman/signer';
import { nip44 } from '@welshman/signer/util';


=========================
workspace: packages/signer
file: packages/signer/src/util.ts
lines: 45:45
id: 0bdab3099ee253582cd64c30437e3f588271603a97a73d54fab21a8c39633061
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/util.ts#L45

declaration:
export type Sign = (event: StampedEvent) => Promise<SignedEvent>

summary:
A TypeScript type alias that defines a function signature for signing Nostr events. The `Sign` function takes a `StampedEvent` as input and returns a Promise that resolves to a `SignedEvent`.

details:
This type alias represents the signature for event signing functions in the Nostr protocol context. It's used as part of the `ISigner` interface (defined later in the file) to standardize how different signing implementations should work. The function is expected to take an event with a timestamp and return a promise that resolves to the same event with signature information added.

import/access examples:
import type { Sign } from '@welshman/signer';
import type { Sign } from '@welshman/signer/util';


=========================
workspace: packages/signer
file: packages/signer/src/util.ts
lines: 47:47
id: 49ebe663df79d01e65b7f18eb4fc16051770e731baae4a01484ae15037317299
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/util.ts#L47

declaration:
export type Encrypt = (pubkey: string, message: string) => Promise<string>

summary:
A TypeScript type alias that defines a function signature for encrypting messages. The function takes a recipient's public key and a message as parameters, and returns a Promise that resolves to the encrypted message string.

details:
This type alias represents an encryption function in the context of Nostr protocol implementations. It's used as part of the encryption interface in the application, particularly in the `EncryptionImplementation` type and `ISigner` interface. The function signature indicates asynchronous operation through the Promise return type, suggesting encryption might involve network requests or other asynchronous operations.

import/access examples:
import type { Encrypt } from '@welshman/signer';
import type { Encrypt } from '@welshman/signer/util';


=========================
workspace: packages/signer
file: packages/signer/src/util.ts
lines: 49:49
id: a5251a9678254a105cd189d2514abd6d17cf9e8ae0632a629785980e764ad3ab
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/util.ts#L49

declaration:
export type Decrypt = (pubkey: string, message: string) => Promise<string>

summary:
A TypeScript type alias that defines a function signature for decrypting messages in a Nostr context. The function takes a public key and an encrypted message as parameters and returns a Promise that resolves to the decrypted message string.

details:
This type alias represents a function with the following signature:
- Parameters:
  1. `pubkey: string` - The public key of the message recipient/sender
  2. `message: string` - The encrypted message to be decrypted
- Returns: `Promise<string>` - A promise that resolves to the decrypted message

This type is used as part of the encryption implementation interfaces in the codebase, particularly for the `ISigner` interface which provides cryptographic operations for Nostr protocol interactions.

import/access examples:
import type { Decrypt } from '@welshman/signer';
import type { Decrypt } from '@welshman/signer/util';


=========================
workspace: packages/signer
file: packages/signer/src/util.ts
lines: 51:54
id: 79897c788cc92f675ede138003634f6a05fae114b7f647f8a2b6bce5b30186c6
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/util.ts#L51

declaration:
export type EncryptionImplementation = {
  encrypt: Encrypt
  decrypt: Decrypt
}

summary:
A type definition that represents an encryption implementation with two methods: `encrypt` and `decrypt`. This type is used to standardize encryption interfaces across different encryption protocols (like NIP-04 and NIP-44) in the Nostr ecosystem.

details:
This type alias defines the structure for encryption implementations by requiring two methods:
1. `encrypt`: A function that takes a public key and a message, and returns a Promise resolving to the encrypted message string
2. `decrypt`: A function that takes a public key and an encrypted message, and returns a Promise resolving to the decrypted message string

The type is used in the `ISigner` interface to provide consistent encryption capabilities through different protocols (NIP-04 and NIP-44). It serves as a contract that any encryption implementation must fulfill to be compatible with the signer system.

related: Encrypt,Decrypt

import/access examples:
import type { EncryptionImplementation } from '@welshman/signer';
import type { EncryptionImplementation } from '@welshman/signer/util';


=========================
workspace: packages/signer
file: packages/signer/src/util.ts
lines: 56:61
id: e0f5a47b091d9f228db0e2f48c0691a2a70433d91f6498ec22e8f0aa3680a910
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/util.ts#L56

declaration:
export interface ISigner {
  sign: Sign
  nip04: EncryptionImplementation
  nip44: EncryptionImplementation
  getPubkey: () => Promise<string>
}

summary:
ISigner is an interface that defines the contract for a Nostr signer implementation. It provides methods for signing events, encrypting and decrypting messages using both NIP-04 and NIP-44 protocols, and retrieving the public key associated with the signer.

details:
The ISigner interface consists of four key components:
1. `sign`: A method that takes a StampedEvent and returns a Promise resolving to a SignedEvent
2. `nip04`: An EncryptionImplementation object for NIP-04 encryption/decryption
3. `nip44`: An EncryptionImplementation object for NIP-44 encryption/decryption
4. `getPubkey`: A method that returns a Promise resolving to the signer's public key

This interface serves as the foundation for various signer implementations in the codebase, including the WrappedSigner class defined later in the file. It abstracts the cryptographic operations needed for Nostr protocol interactions.

related: Sign,EncryptionImplementation

import/access examples:
import type { ISigner } from '@welshman/signer';
import type { ISigner } from '@welshman/signer/util';


=========================
workspace: packages/signer
file: packages/signer/src/util.ts
lines: 63:66
id: d0a395feb700d3a4dbeab6d27d97eda0ac69e32ae329d7737b3fadf38b2f39ca
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/util.ts#L63

declaration:
decrypt = async (signer: ISigner, pubkey: string, message: string) =>
  nip04.detect(message)
    ? signer.nip04.decrypt(pubkey, message)
    : signer.nip44.decrypt(pubkey, message)

summary:
A utility function that decrypts a message using either NIP-04 or NIP-44 encryption protocol based on message format. It takes a signer interface, the public key of the message sender/recipient, and the encrypted message. The function automatically detects which encryption protocol was used and delegates to the appropriate decryption method.

details:
The implementation works by:
1. First checking if the message contains '?iv=' using the nip04.detect method, which indicates NIP-04 encryption
2. If NIP-04 is detected, it calls signer.nip04.decrypt with the provided pubkey and message
3. Otherwise, it assumes NIP-44 encryption and calls signer.nip44.decrypt with the same parameters
4. The function returns a Promise that resolves to the decrypted message string

related: __type,nip04,decrypt,nip44,ISigner

import/access examples:
import { decrypt } from '@welshman/signer';
import { decrypt } from '@welshman/signer/util';


=========================
workspace: packages/signer
file: packages/signer/src/util.ts
lines: 68:68
id: 9455e6b1509742279695c79f438b6afd66f8a0c38563dea8b4f298ed3058e6ea
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/util.ts#L68

declaration:
export type SignerMethodWrapper = <T>(method: string, thunk: () => Promise<T>) => Promise<T>

summary:
A type alias that defines a function signature for wrapping signer method calls. It takes a method name (string) and a thunk function that returns a Promise of generic type T, and returns a Promise of the same type T. This wrapper allows for intercepting and potentially modifying the behavior of signer method calls.

details:
This type alias is used to define a function that can wrap method calls on a signer implementation. The wrapper receives:
1. The name of the method being called (as a string)
2. A thunk function (a function that returns a promise)

The wrapper is expected to return the same promise type that the thunk returns. This pattern enables various cross-cutting concerns to be implemented around signer methods, such as logging, error handling, or UI interactions, without modifying the core signer implementation. It's used by the WrappedSigner class to intercept all method calls to the underlying signer.

import/access examples:
import type { SignerMethodWrapper } from '@welshman/signer';
import type { SignerMethodWrapper } from '@welshman/signer/util';


=========================
workspace: packages/signer
file: packages/signer/src/util.ts
lines: 70:99
id: 509ab59c112d81db8aaced12bd4d33a7696259608e0fbf304f2551da85d82c1a
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/util.ts#L70

declaration:
export class WrappedSigner extends Emitter implements ISigner{
  constructor(
      readonly signer: ISigner,
      readonly wrapMethod: SignerMethodWrapper,
    );
  sign(event: StampedEvent);
  getPubkey();
  nip04: { encrypt: (pubkey: string, message: string) => Promise<string>; decrypt: (pubkey: string, message: string) => Promise<string>; }
  nip44: { encrypt: (pubkey: string, message: string) => Promise<string>; decrypt: (pubkey: string, message: string) => Promise<string>; }
}

summary:
A class that wraps an ISigner implementation, providing the same interface while adding a method wrapping mechanism. It extends Emitter and implements the ISigner interface, allowing for interception and processing of all signer method calls through the provided wrapMethod function.

details:
The WrappedSigner class implements the decorator pattern to wrap an existing ISigner implementation. It:

1. Takes two constructor parameters:
   - signer: The original ISigner implementation to wrap
   - wrapMethod: A function that intercepts method calls, allowing for logging, error handling, etc.

2. Implements all ISigner methods by delegating to the wrapped signer while passing each call through the wrapMethod function:
   - sign(event): Signs a stamped event
   - getPubkey(): Gets the public key
   - nip04.encrypt/decrypt: Handles NIP-04 encryption/decryption
   - nip44.encrypt/decrypt: Handles NIP-44 encryption/decryption

3. Extends Emitter, suggesting it can emit events related to signer operations.

This pattern allows for centralized processing of all signer operations, useful for UI feedback, error handling, or analytics.

related: ISigner,SignerMethodWrapper

code:
export class WrappedSigner extends Emitter implements ISigner {
  constructor(
    readonly signer: ISigner,
    readonly wrapMethod: SignerMethodWrapper,
  ) {
    super()
  }

  sign(event: StampedEvent) {
    return this.wrapMethod("sign", () => this.signer.sign(event))
  }

  getPubkey() {
    return this.wrapMethod("getPubkey", () => this.signer.getPubkey())
  }

  nip04 = {
    encrypt: async (pubkey: string, message: string) =>
      this.wrapMethod("nip04.encrypt", () => this.signer.nip04.encrypt(pubkey, message)),
    decrypt: async (pubkey: string, message: string) =>
      this.wrapMethod("nip04.decrypt", () => this.signer.nip04.decrypt(pubkey, message)),
  }

  nip44 = {
    encrypt: async (pubkey: string, message: string) =>
      this.wrapMethod("nip44.encrypt", () => this.signer.nip44.encrypt(pubkey, message)),
    decrypt: async (pubkey: string, message: string) =>
      this.wrapMethod("nip44.decrypt", () => this.signer.nip44.decrypt(pubkey, message)),
  }
}

import/access examples:
import { WrappedSigner } from '@welshman/signer';
import { WrappedSigner } from '@welshman/signer/util';


=========================
workspace: packages/signer
file: packages/signer/src/signers/nip01.ts
lines: 4:28
id: 7d8a5dc78f0bc37438452d9bfedbc9dec3af0520647f9501f6ebe0ec9eb99f0b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/signers/nip01.ts#L4

declaration:
export class Nip01Signer implements ISigner{
  constructor(private secret: string);
  static fromSecret: (secret: string) => Nip01Signer;
  static ephemeral: () => Nip01Signer;
  getPubkey: () => Promise<string>;
  sign: (event: StampedEvent) => Promise<{ sig: string; tags: string[][]; content: string; kind: number; created_at: number; pubkey: string; id: string; }>;
  nip04: { encrypt: (pubkey: string, message: string) => Promise<string>; decrypt: (pubkey: string, message: string) => Promise<string>; }
  nip44: { encrypt: (pubkey: string, message: string) => Promise<any>; decrypt: (pubkey: string, message: string) => Promise<any>; }
}

summary:
A class implementing the ISigner interface for NIP-01 compliant Nostr signing operations. It provides functionality for key management, event signing, and message encryption/decryption using both NIP-04 and NIP-44 protocols. The signer can be created from an existing secret key or generated as an ephemeral (temporary) signer.

details:
The implementation maintains a private secret key and a derived public key stored in a private class field (#pubkey). It offers:

1. Two static factory methods: `fromSecret` to create a signer from an existing secret, and `ephemeral` to create a signer with a randomly generated secret key.

2. Core signing functionality through the `sign` method which takes a StampedEvent, creates an ownership proof with the public key, hashes it, and signs it with the secret key.

3. Two encryption/decryption interfaces:
   - nip04: Implements the older NIP-04 encryption standard
   - nip44: Implements the newer NIP-44 encryption standard

All cryptographic operations are delegated to utility functions imported from '../util.js'.

related: ISigner

code:
export class Nip01Signer implements ISigner {
  #pubkey: string

  constructor(private secret: string) {
    this.#pubkey = getPubkey(this.secret)
  }

  static fromSecret = (secret: string) => new Nip01Signer(secret)

  static ephemeral = () => new Nip01Signer(makeSecret())

  getPubkey = async () => this.#pubkey

  sign = async (event: StampedEvent) => sign(hash(own(event, this.#pubkey)), this.secret)

  nip04 = {
    encrypt: async (pubkey: string, message: string) => nip04.encrypt(pubkey, this.secret, message),
    decrypt: async (pubkey: string, message: string) => nip04.decrypt(pubkey, this.secret, message),
  }

  nip44 = {
    encrypt: async (pubkey: string, message: string) => nip44.encrypt(pubkey, this.secret, message),
    decrypt: async (pubkey: string, message: string) => nip44.decrypt(pubkey, this.secret, message),
  }
}

import/access examples:
import { Nip01Signer } from '@welshman/signer';
import { Nip01Signer } from '@welshman/signer/signers/nip01';


=========================
workspace: packages/signer
file: packages/signer/src/nip59.ts
lines: 5:5
id: 04c7c365aba512eca4908ba4ada6d51291266f5e890005913600becb8893579f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/nip59.ts#L5

declaration:
seen = new Map<string, UnwrappedEvent | Error>()

summary:
A Map that stores previously processed events by their ID, containing either the unwrapped event data or an error that occurred during unwrapping. This cache prevents redundant decryption operations for events that have already been processed.

details:
This is a global cache implemented as a Map where:
- Keys are event IDs (strings)
- Values are either successfully unwrapped events (UnwrappedEvent) or Error objects that occurred during unwrapping

The cache is used in the `unwrap` function to avoid decrypting the same event multiple times, improving performance and ensuring consistent error handling across multiple unwrap attempts of the same event.

import/access examples:
import { seen } from '@welshman/signer';
import { seen } from '@welshman/signer/nip59';


=========================
workspace: packages/signer
file: packages/signer/src/nip59.ts
lines: 7:8
id: 9ad6a08dc82d8b39be02a8483c1bf6274949a60e9e7cfdd8d579d162696127a2
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/nip59.ts#L7

declaration:
now = (drift = 0) =>
  Math.round(Date.now() / 1000 - Math.random() * Math.pow(10, drift))

summary:
A function that returns the current Unix timestamp (seconds since epoch) with an optional random drift. The drift parameter controls the magnitude of random subtraction from the current time.

details:
The implementation:
1. Gets the current time in milliseconds using Date.now()
2. Converts milliseconds to seconds by dividing by 1000
3. Subtracts a random value calculated as Math.random() * 10^drift
4. Rounds the result to the nearest integer using Math.round()

The drift parameter defaults to 0, which means no randomness is applied when not specified. Higher drift values create larger potential time variations.

import/access examples:
import { now } from '@welshman/signer';
import { now } from '@welshman/signer/nip59';


=========================
workspace: packages/signer
file: packages/signer/src/nip59.ts
lines: 10:11
id: 0bb525de0f0a91b74350d1e5a58a43e594305574e01ce5902046dd979334ec96
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/nip59.ts#L10

declaration:
getRumor = async (signer: ISigner, template: StampedEvent) =>
  hash(own(template, await signer.getPubkey()))

summary:
Asynchronously generates a rumor event by combining a template event with a signer's public key. Takes an ISigner instance and a StampedEvent template as parameters and returns a HashedEvent (a hashed version of the owned event).

details:
This function creates a 'rumor' by:
1. Awaiting the signer's public key
2. Using the 'own' utility to associate the template event with the signer's public key
3. Hashing the resulting owned event using the 'hash' utility function

The function is part of the NIP-59 implementation which deals with encrypted private events in the Nostr protocol.

related: __function,hash,ISigner

import/access examples:
import { getRumor } from '@welshman/signer';
import { getRumor } from '@welshman/signer/nip59';


=========================
workspace: packages/signer
file: packages/signer/src/nip59.ts
lines: 13:22
id: 66a02eb10f88cd3a0a45cc7eed8138944aa217282d378ee89796604f8d889490
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/nip59.ts#L13

declaration:
getSeal = async (signer: ISigner, pubkey: string, rumor: HashedEvent) =>
  signer.sign(
    hash({
      kind: SEAL,
      pubkey: await signer.getPubkey(),
      content: await signer.nip44.encrypt(pubkey, JSON.stringify(rumor)),
      created_at: now(5),
      tags: [],
    }),
  )

summary:
Creates a sealed event by signing a hashed event object. The function takes a signer, a recipient's public key, and a rumor (hashed event) as parameters. It returns a signed event that contains the encrypted rumor, which can only be decrypted by the intended recipient.

details:
This function implements part of the NIP-59 protocol for private events. It works by:
1. Creating a new event object with kind SEAL
2. Setting the pubkey to the signer's public key
3. Encrypting the rumor (serialized to JSON) using NIP-44 encryption with the recipient's pubkey
4. Setting a creation timestamp with some randomized drift (using the now() function with drift=5)
5. Adding empty tags
6. Hashing this event object
7. Signing the hashed event with the provided signer

The resulting signed event serves as a 'seal' in the NIP-59 wrapping process, which is an intermediate step between the original rumor and the final wrapped event.

related: __type,sign,ISigner

import/access examples:
import { getSeal } from '@welshman/signer';
import { getSeal } from '@welshman/signer/nip59';


=========================
workspace: packages/signer
file: packages/signer/src/nip59.ts
lines: 24:38
id: 1d5641ca381b6c7edcc70637f8699f03825cf599f7b72e3f40c9e45582404a0d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/nip59.ts#L24

declaration:
getWrap = async (
  wrapper: ISigner,
  pubkey: string,
  seal: SignedEvent,
  tags: string[][],
) =>
  wrapper.sign(
    hash({
      kind: WRAP,
      pubkey: await wrapper.getPubkey(),
      content: await wrapper.nip44.encrypt(pubkey, JSON.stringify(seal)),
      created_at: now(5),
      tags: [...tags, ["p", pubkey]],
    }),
  )

summary:
Asynchronously creates a wrapped event (NIP-59 wrap) by signing and encrypting a seal event. The function takes a wrapper signer, recipient public key, a seal event, and additional tags, then returns a signed event that encapsulates the encrypted seal.

details:
This function implements part of the NIP-59 protocol for private events:

1. Creates a new event with kind WRAP (defined as a constant imported from @welshman/util)
2. Sets the pubkey to the wrapper's public key
3. Encrypts the seal event using NIP-44 encryption to the recipient's pubkey
4. Sets creation time with some randomized drift (using the now() helper)
5. Combines provided tags with a "p" tag containing the recipient's pubkey
6. Hashes the constructed event object
7. Signs the hashed event using the wrapper's signing capability

This function is part of a chain of operations in the NIP-59 protocol where a rumor is sealed and then wrapped for private communication.

related: __type,sign,ISigner

import/access examples:
import { getWrap } from '@welshman/signer';
import { getWrap } from '@welshman/signer/nip59';


=========================
workspace: packages/signer
file: packages/signer/src/nip59.ts
lines: 40:52
id: f356ef3a1f695726a04fac208d15bef2cd3d7ad2cf03b193d5a19231012ce34f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/nip59.ts#L40

declaration:
wrap = async (
  signer: ISigner,
  wrapper: ISigner,
  pubkey: string,
  template: StampedEvent,
  tags: string[][] = [],
) => {
  const rumor = await getRumor(signer, template)
  const seal = await getSeal(signer, pubkey, rumor)
  const wrap = await getWrap(wrapper, pubkey, seal, tags)

  return Object.assign(rumor, {wrap}) as UnwrappedEvent
}

summary:
Wraps an event according to NIP-59 protocol, creating a layered encrypted structure. Takes a signer, wrapper, recipient's public key, event template, and optional tags. Returns an unwrapped event object that includes the wrapped event.

details:
This function implements the NIP-59 wrapping process in three steps:
1. Creates a 'rumor' by hashing the template event with the signer's public key
2. Creates a 'seal' by encrypting the rumor with the recipient's public key and signing it
3. Creates a 'wrap' by encrypting the seal with the recipient's public key and signing it with the wrapper

The function then returns the rumor object with the wrap attached to it. This creates a layered encryption structure where the original event is protected but can be unwrapped by the intended recipient.

related: ISigner

import/access examples:
import { wrap } from '@welshman/signer';
import { wrap } from '@welshman/signer/nip59';


=========================
workspace: packages/signer
file: packages/signer/src/nip59.ts
lines: 54:80
id: 4ba829671cc91167854d6f80eb0d75f812174cd29c3dc1c7f895a60358a1592e
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/nip59.ts#L54

declaration:
unwrap = async (signer: ISigner, wrap: SignedEvent) => {
  // Avoid decrypting the same event multiple times
  if (seen.has(wrap.id)) {
    const rumorOrError = seen.get(wrap.id)

    if (rumorOrError instanceof Error) {
      throw rumorOrError
    } else {
      return rumorOrError
    }
  }

  try {
    const seal = JSON.parse(await decrypt(signer, wrap.pubkey, wrap.content))
    const rumor = JSON.parse(await decrypt(signer, seal.pubkey, seal.content))

    if (seal.pubkey !== rumor.pubkey) throw new Error("Seal pubkey does not match rumor pubkey")

    seen.set(wrap.id, rumor)

    return Object.assign(rumor, {wrap}) as UnwrappedEvent
  } catch (error) {
    seen.set(wrap.id, error as Error)

    throw error
  }
}

summary:
Unwraps a NIP-59 wrapped event by decrypting its contents. Takes a signer interface and a wrapped signed event as parameters, and returns the unwrapped event data (rumor). The function caches previously processed events to avoid redundant decryption operations and maintains error states for failed unwrapping attempts.

details:
Implementation details:
1. First checks if the event has been seen before (using the global `seen` Map):
   - If found and is an Error, throws that error
   - If found and is an event, returns the cached result
2. If not seen before, attempts to:
   - Decrypt the outer wrap to get the seal using the provided signer
   - Decrypt the seal to get the rumor
   - Validates that the seal pubkey matches the rumor pubkey
   - Caches the successful result in the seen Map with the wrap ID as key
   - Returns the rumor with the wrap attached
3. If any errors occur during decryption or validation:
   - Caches the error in the seen Map
   - Re-throws the error
4. Uses a two-layer encryption scheme (wrap → seal → rumor) following the NIP-59 specification

related: ISigner

import/access examples:
import { unwrap } from '@welshman/signer';
import { unwrap } from '@welshman/signer/nip59';


=========================
workspace: packages/signer
file: packages/signer/src/nip59.ts
lines: 86:102
id: e348918a5149ce1933c40836f7e87800140f6057cbc948617eed21be9df9ac82
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/nip59.ts#L86

declaration:
export class Nip59{
  constructor(
      private signer: ISigner,
      private wrapper?: ISigner,
    );
  static fromSigner: (signer: ISigner) => Nip59;
  static fromSecret: (secret: string) => Nip59;
  withWrapper: (wrapper: ISigner) => Nip59;
  wrap: (pubkey: string, template: StampedEvent, tags?: string[][]) => Promise<UnwrappedEvent>;
  unwrap: (event: SignedEvent) => Promise<UnwrappedEvent | undefined>;
}

summary:
The `Nip59` class provides a utility for handling encrypted Nostr events according to NIP-59 specification. It simplifies the process of wrapping (encrypting) and unwrapping (decrypting) events, managing signers, and handling metadata privacy. The class offers factory methods for creation from existing signers or private keys, methods to set wrapper signers, and core functionality to wrap and unwrap events.

details:
Implementation details:

1. The class is designed with privacy in mind, making it harder to reuse wrapper signers which could leak metadata.
2. It maintains a private signer for the user and an optional wrapper signer.
3. Static factory methods provide convenient initialization:
   - `fromSigner()` creates an instance from an existing signer
   - `fromSecret()` creates an instance from a private key using Nip01Signer
4. The `withWrapper()` method returns a new instance with a specified wrapper signer.
5. The `wrap()` method delegates to the module-level `wrap()` function, using an ephemeral signer if no wrapper is provided.
6. The `unwrap()` method simply delegates to the module-level `unwrap()` function.
7. The implementation leverages the module's encryption/decryption functions and maintains state through the global `seen` Map to avoid redundant decryption operations.

related: ISigner

code:
export class Nip59 {
  constructor(
    private signer: ISigner,
    private wrapper?: ISigner,
  ) {}

  static fromSigner = (signer: ISigner) => new Nip59(signer)

  static fromSecret = (secret: string) => new Nip59(new Nip01Signer(secret))

  withWrapper = (wrapper: ISigner) => new Nip59(this.signer, wrapper)

  wrap = (pubkey: string, template: StampedEvent, tags: string[][] = []) =>
    wrap(this.signer, this.wrapper || Nip01Signer.ephemeral(), pubkey, template, tags)

  unwrap = (event: SignedEvent) => unwrap(this.signer, event)
}

import/access examples:
import { Nip59 } from '@welshman/signer';
import { Nip59 } from '@welshman/signer/nip59';


=========================
workspace: packages/signer
file: packages/signer/src/signers/nip07.ts
lines: 4:9
id: 7583326be38efa43d3ee3d188efecf6371d020cb413a52f097ead6ea11408cac
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/signers/nip07.ts#L4

declaration:
export type Nip07 = {
  signEvent: Sign
  nip04: EncryptionImplementation
  nip44: EncryptionImplementation
  getPublicKey: () => string | undefined
}

summary:
A TypeScript type definition representing a NIP-07 (Nostr Implementation Possibilities) browser extension interface. It defines the methods that a Nostr browser extension should implement, including event signing, encryption capabilities (NIP-04 and NIP-44), and public key retrieval.

details:
This type alias defines the expected interface for a Nostr browser extension that follows the NIP-07 specification. It includes:
1. `signEvent`: A function for signing Nostr events
2. `nip04`: An implementation of the NIP-04 encryption standard
3. `nip44`: An implementation of the NIP-44 encryption standard
4. `getPublicKey`: A function that returns the user's public key or undefined

This type is used throughout the codebase to ensure type safety when interacting with browser extensions that implement the Nostr protocol.

related: Sign,EncryptionImplementation

import/access examples:
import type { Nip07 } from '@welshman/signer';
import type { Nip07 } from '@welshman/signer/signers/nip07';


=========================
workspace: packages/signer
file: packages/signer/src/signers/nip07.ts
lines: 11:11
id: b55df5676b4f5718012c1c45176b386cff90b88d35549bfd478ca074c7199f0a
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/signers/nip07.ts#L11

declaration:
getNip07 = () => (window as {nostr?: Nip07}).nostr

summary:
A function that retrieves the Nostr extension (NIP-07 provider) from the global window object. Returns the Nostr extension object if available, or undefined if not present.

details:
This function accesses the global window object and attempts to retrieve the 'nostr' property, which should contain a NIP-07 compatible extension. It uses a type assertion to cast the window object to a specific shape with an optional 'nostr' property of type Nip07. The function doesn't perform any validation on the returned object - it simply returns whatever is found at window.nostr.

related: Nip07

import/access examples:
import { getNip07 } from '@welshman/signer';
import { getNip07 } from '@welshman/signer/signers/nip07';


=========================
workspace: packages/signer
file: packages/signer/src/signers/nip07.ts
lines: 13:55
id: 36771f37916e81635a43bd9c70eb67466a46c263854fdeec137b9bc385264d67
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/signers/nip07.ts#L13

declaration:
export class Nip07Signer implements ISigner{
  getPubkey: () => Promise<string>;
  sign: (template: StampedEvent) => Promise<SignedEvent>;
  nip04: { encrypt: (pubkey: string, message: string) => Promise<string>; decrypt: (pubkey: string, message: string) => Promise<string>; }
  nip44: { encrypt: (pubkey: string, message: string) => Promise<string>; decrypt: (pubkey: string, message: string) => Promise<string>; }
}

summary:
A class that implements the ISigner interface using a NIP-07 compatible browser extension. It provides methods for signing events, encrypting/decrypting messages using NIP-04 and NIP-44 protocols, and retrieving the user's public key from the extension.

details:
The implementation uses a promise-based locking mechanism to ensure sequential execution of operations with the browser extension. Key components:

1. Private `#lock` property: A Promise that manages sequential access to the extension.
2. Private `#then` method: Handles interaction with the extension, error recovery, and lock management.
3. Public methods:
   - `getPubkey`: Retrieves the user's public key from the extension
   - `sign`: Signs a stamped event using the extension
   - `nip04` and `nip44`: Objects containing encrypt/decrypt methods for the respective encryption protocols

The class gracefully handles errors by recovering the lock state after each operation, preventing deadlocks.

related: ISigner

code:
export class Nip07Signer implements ISigner {
  #lock = Promise.resolve()

  #then = async <T>(f: (ext: Nip07) => T | Promise<T>) => {
    const promise = this.#lock.then(() => {
      const ext = getNip07()

      if (!ext) throw new Error("Nip07 is not enabled")

      return f(ext)
    })

    // Recover from errors
    this.#lock = promise.then(
      () => undefined,
      () => undefined,
    )

    return promise
  }

  getPubkey = async () => this.#then<string>(ext => ext.getPublicKey() as string)

  sign = async (template: StampedEvent) => {
    const event = hash(own(template, await this.getPubkey()))

    return this.#then(ext => ext.signEvent(event))
  }

  nip04 = {
    encrypt: (pubkey: string, message: string) =>
      this.#then(ext => ext.nip04.encrypt(pubkey, message)),
    decrypt: (pubkey: string, message: string) =>
      this.#then(ext => ext.nip04.decrypt(pubkey, message)),
  }

  nip44 = {
    encrypt: (pubkey: string, message: string) =>
      this.#then(ext => ext.nip44.encrypt(pubkey, message)),
    decrypt: (pubkey: string, message: string) =>
      this.#then(ext => ext.nip44.decrypt(pubkey, message)),
  }
}

import/access examples:
import { Nip07Signer } from '@welshman/signer';
import { Nip07Signer } from '@welshman/signer/signers/nip07';


=========================
workspace: packages/signer
file: packages/signer/src/signers/nip46.ts
lines: 13:15
id: 0587a1aa52d278977a4e2874ac4a22a26b87fca703248849734353327d83c5d2
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/signers/nip46.ts#L13

declaration:
export type Nip46Context = {
  debug: boolean
}

summary:
The `Nip46Context` type defines the configuration context for NIP-46 (Nostr Connect) operations. It contains a single property `debug` of type boolean, which controls whether debug information is logged during NIP-46 operations.

details:
This is a simple type alias that defines the structure for configuration settings used throughout the NIP-46 implementation. When `debug` is set to true, the implementation will log detailed information about sent and received messages, which is useful for troubleshooting connection issues between clients and remote signers.

import/access examples:
import type { Nip46Context } from '@welshman/signer';
import type { Nip46Context } from '@welshman/signer/signers/nip46';


=========================
workspace: packages/signer
file: packages/signer/src/signers/nip46.ts
lines: 17:19
id: 5ac76928d2ed16a0772b6df24ebbbd4d66773eb74b3294badcc3ee2585ebd81f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/signers/nip46.ts#L17

declaration:
nip46Context = {
  debug: false,
}

summary:
A global configuration object for NIP-46 (Nostr Connect) functionality. It contains a single boolean property `debug` which defaults to `false`. When enabled, it allows for debug logging of NIP-46 communication.

details:
This is a simple configuration object that controls debug logging behavior throughout the NIP-46 implementation. When `debug` is set to `true`, various components in the NIP-46 implementation (like the sender and receiver) will log their communication details to the console. The object is exported and can be imported by other modules to modify the debug setting globally.

import/access examples:
import { nip46Context } from '@welshman/signer';
import { nip46Context } from '@welshman/signer/signers/nip46';


=========================
workspace: packages/signer
file: packages/signer/src/signers/nip46.ts
lines: 21:21
id: 7a681d401842da76727f1afc0c2822654a87e5b980ad69cdb155508bd75e97d0
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/signers/nip46.ts#L21

declaration:
export type Nip46Algorithm = "nip04" | "nip44"

summary:
Nip46Algorithm is a type alias that represents the encryption algorithm used in NIP-46 (Nostr Connect) protocol. It can be either "nip04" or "nip44", which are two different encryption methods used in the Nostr ecosystem.

details:
This type is used throughout the NIP-46 implementation to specify which encryption algorithm should be used when communicating between a client and a remote signer. NIP-04 is an older encryption method using AES-CBC, while NIP-44 is a newer, more secure encryption method. The type is used as an optional parameter in various configurations and is referenced when performing encryption/decryption operations.

import/access examples:
import type { Nip46Algorithm } from '@welshman/signer';
import type { Nip46Algorithm } from '@welshman/signer/signers/nip46';


=========================
workspace: packages/signer
file: packages/signer/src/signers/nip46.ts
lines: 23:26
id: 0e490af80a40b663ab67838c1bcefd07fa3c38885176df53631ac8eea15f4209
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/signers/nip46.ts#L23

declaration:
export enum Nip46Event {
  Send = "send",
  Receive = "receive",
}

summary:
Nip46Event is an enumeration that defines event types used in the NIP-46 (Nostr Connect) protocol implementation. It contains two event types: 'Send' for outgoing requests and 'Receive' for incoming responses.

details:
This enum is a simple type definition that provides named constants for the two main event types in the NIP-46 communication flow:

1. Send - Represents events when messages are sent to a remote signer
2. Receive - Represents events when responses are received from a remote signer

These enum values are used throughout the codebase as event types in the event emitter pattern implemented by the Nip46Sender and Nip46Receiver classes.

import/access examples:
import { Nip46Event } from '@welshman/signer';
import { Nip46Event } from '@welshman/signer/signers/nip46';


=========================
workspace: packages/signer
file: packages/signer/src/signers/nip46.ts
lines: 28:35
id: e32332e32ac1157ca49c45370cdacbc03834b4acdb907c5d7b548aca90a416d1
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/signers/nip46.ts#L28

declaration:
export type Nip46BrokerParams = {
  relays: string[]
  clientSecret: string
  connectSecret?: string
  signerPubkey?: string
  algorithm?: Nip46Algorithm
  context?: AdapterContext
}

summary:
Nip46BrokerParams is a TypeScript type that defines the configuration parameters for a NIP-46 broker, which facilitates communication between a client and a remote signer. It includes the following properties:
- relays: An array of relay URLs for communication
- clientSecret: The secret key for the client
- connectSecret: Optional secret for establishing a connection
- signerPubkey: Optional public key of the remote signer
- algorithm: Optional encryption algorithm to use (nip04 or nip44)
- context: Optional adapter context for network operations

details:
This type serves as a configuration object for the Nip46Broker class and related components. It contains all necessary parameters to establish and maintain a connection with a remote signer using the NIP-46 protocol. The relays and clientSecret are required fields, while the others are optional and can be set later during the connection process. The type is used throughout the NIP-46 implementation to maintain consistent configuration across different components.

related: Nip46Algorithm

import/access examples:
import type { Nip46BrokerParams } from '@welshman/signer';
import type { Nip46BrokerParams } from '@welshman/signer/signers/nip46';


=========================
workspace: packages/signer
file: packages/signer/src/signers/nip46.ts
lines: 37:43
id: 3d685b3aaa530392a028aaf64f5d4382698807181475d7c4afa65fd7b55fa9e3
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/signers/nip46.ts#L37

declaration:
export type Nip46Response = {
  id: string
  url: string
  event: TrustedEvent
  error?: string
  result?: string
}

summary:
Nip46Response is a TypeScript type alias that defines the structure of a response from a NIP-46 (Nostr Connect) operation. It includes fields for the request ID, relay URL, the event object, and optional error or result fields.

details:
This type represents the response structure in the NIP-46 protocol implementation. It contains:
1. `id`: A string identifier that matches the original request
2. `url`: The relay URL string where the response came from
3. `event`: A TrustedEvent object containing the Nostr event data
4. `error?`: An optional string containing error information
5. `result?`: An optional string containing the successful result

This type serves as a base interface that is further specialized into Nip46ResponseWithResult and Nip46ResponseWithError types, which enforce the presence of either the result or error field respectively.

import/access examples:
import type { Nip46Response } from '@welshman/signer';
import type { Nip46Response } from '@welshman/signer/signers/nip46';


=========================
workspace: packages/signer
file: packages/signer/src/signers/nip46.ts
lines: 45:50
id: c60bf3cf801cdf4703570aee55ed11f119ee75a8cc2be0e297f2cfe9b415ab19
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/signers/nip46.ts#L45

declaration:
export type Nip46ResponseWithResult = {
  id: string
  url: string
  event: TrustedEvent
  result: string
}

summary:
A TypeScript type alias that represents a successful response from a NIP-46 (Nostr Connect) operation. It includes the request ID, relay URL, the trusted event object, and a result string containing the successful response data.

details:
This type extends the base Nip46Response type by making the 'result' field required while omitting the 'error' field, indicating a successful operation. It's used to type-check successful responses in the NIP-46 implementation, particularly when resolving promises in the request/response flow.

import/access examples:
import type { Nip46ResponseWithResult } from '@welshman/signer';
import type { Nip46ResponseWithResult } from '@welshman/signer/signers/nip46';


=========================
workspace: packages/signer
file: packages/signer/src/signers/nip46.ts
lines: 52:57
id: 1f27ac8b35a56bdfd8b1edd53d2fba534035ac6fe1a91d527d58892a9cdd2bd4
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/signers/nip46.ts#L52

declaration:
export type Nip46ResponseWithError = {
  id: string
  url: string
  event: TrustedEvent
  error: string
}

summary:
A TypeScript type definition that represents a NIP-46 response containing an error. It extends the basic response structure with a required error field. The type includes properties for the request ID, relay URL, the original event, and an error message.

details:
This type is part of the NIP-46 protocol implementation, specifically representing error responses from a remote signer. It's a specialized version of the more general `Nip46Response` type where the `error` field is required rather than optional. This allows for type-safe handling of error cases in the protocol communication.

import/access examples:
import type { Nip46ResponseWithError } from '@welshman/signer';
import type { Nip46ResponseWithError } from '@welshman/signer/signers/nip46';


=========================
workspace: packages/signer
file: packages/signer/src/signers/nip46.ts
lines: 59:94
id: 5008fc313c31d0eaad5b0b80135c3edddbd88ed8a44c9a56ddc29c0ac14e4197
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/signers/nip46.ts#L59

declaration:
popupManager = (() => {
  let pendingUrl = ""
  let pendingSince = 0
  let currentWindow: Window

  const openPending = throttle(1000, () => {
    // If it's been a while since they asked for it, drop the request
    if (Date.now() - pendingSince > 10_000) return

    // If we have an active, open window, continue to wait
    if (currentWindow && !currentWindow.closed) {
      setTimeout(() => openPending(), 100)
    } else {
      // Attempt to open the window
      const w = window.open(pendingUrl, "", "width=600,height=800,popup=yes")

      // If open was successful, keep track of our window
      if (w) {
        currentWindow = w
      }

      // In any case, this url has been handled
      pendingUrl = ""
      pendingSince = 0
    }
  })

  return {
    open: (url: string) => {
      pendingUrl = url
      pendingSince = Date.now()

      openPending()
    },
  }
})()

summary:
A singleton manager for handling popup windows in a Nostr NIP-46 implementation. It provides a single method `open(url: string)` that opens a URL in a popup window, managing the state of pending requests and existing windows to prevent multiple popups from opening simultaneously.

details:
The implementation uses an IIFE (Immediately Invoked Function Expression) to create a closure with private state:

1. It maintains three private variables:
   - `pendingUrl`: Stores the URL waiting to be opened
   - `pendingSince`: Timestamp when the URL was requested
   - `currentWindow`: Reference to the currently open popup window

2. Uses a throttled function `openPending` that:
   - Drops requests older than 10 seconds
   - Checks if there's already an open window and waits if so
   - Opens a new popup window with specific dimensions when appropriate
   - Clears the pending state after handling

3. The returned object exposes just one method `open()` that sets the pending state and triggers the opening process.

related: __function

=========================
workspace: packages/signer
file: packages/signer/src/signers/nip46.ts
lines: 96:143
id: d926eb5ac7cb4cee0b7b344de7814229d16b4a222150ee66a4a40a000cdf3183
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/signers/nip46.ts#L96

declaration:
export class Nip46Receiver extends Emitter{
  public abortController?: AbortController;
  constructor(
      public signer: ISigner,
      public params: Nip46BrokerParams,
    );
  start: () => Promise<void>;
  stop: () => void;
}

summary:
Nip46Receiver is a class that listens for incoming events from a remote Nostr signer. It extends the Emitter class to provide event handling capabilities. The class is initialized with an ISigner instance and Nip46BrokerParams, and provides methods to start and stop listening for events. When events are received, they are decrypted and emitted for further processing.

details:
Implementation details:
1. The class maintains an AbortController instance to manage the lifecycle of the request subscription.
2. The `start` method:
   - Creates a new AbortController if not already present
   - Gets the user's public key from the provided signer
   - Sets up a request with filters for NOSTR_CONNECT events targeted at the user
   - When events are received, it decrypts them using the signer
   - Parses the JSON response and emits it as a Nip46Event.Receive event
   - Adds a delay for error responses to prevent clogging from zombie signers
3. The `stop` method aborts any ongoing requests and removes all event listeners.
4. The class leverages the request function from @welshman/net to handle the subscription to relay events.

related: ISigner,Nip46BrokerParams

code:
export class Nip46Receiver extends Emitter {
  public abortController?: AbortController

  constructor(
    public signer: ISigner,
    public params: Nip46BrokerParams,
  ) {
    super()
  }

  // start listening to the remote signer for incoming events
  // broadcast any event returned by the remote signer
  start = async () => {
    if (this.abortController) return

    this.abortController = new AbortController()

    const {relays, context} = this.params
    const userPubkey = await this.signer.getPubkey()
    const filters = [{kinds: [NOSTR_CONNECT], "#p": [userPubkey]}]

    request({
      relays,
      filters,
      context,
      signal: this.abortController.signal,
      onEvent: async (event: TrustedEvent, url: string) => {
        const json = await decrypt(this.signer, event.pubkey, event.content)
        const response = tryCatch(() => JSON.parse(json)) || {}

        // Delay errors in case there's a zombie signer out there clogging things up
        if (response.error) {
          await sleep(3000)
        }

        this.emit(Nip46Event.Receive, {...response, url, event} as Nip46Response)
      },
      onClose: () => {
        this.abortController = undefined
      },
    })
  }

  stop = () => {
    this.abortController?.abort()
    this.removeAllListeners()
  }
}

import/access examples:
import { Nip46Receiver } from '@welshman/signer';
import { Nip46Receiver } from '@welshman/signer/signers/nip46';


=========================
workspace: packages/signer
file: packages/signer/src/signers/nip46.ts
lines: 145:208
id: ebbe5607e0d83559677f5c275e4ed44b201fde22c788a88b4d9e5aa9c9bf75ef
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/signers/nip46.ts#L145

declaration:
export class Nip46Sender extends Emitter{
  public processing: boolean;
  public queue: Nip46Request[];
  constructor(
      public signer: ISigner,
      public params: Nip46BrokerParams,
    );
  public send: (request: Nip46Request) => Promise<void>;
  public process: () => Promise<void>;
  enqueue: (request: Nip46Request) => void;
  stop: () => void;
}

summary:
Nip46Sender is a class that extends Emitter and is responsible for sending requests to a remote Nostr signer using the NIP-46 protocol. It manages a queue of requests and processes them sequentially. The class requires an ISigner instance and Nip46BrokerParams to be initialized.

details:
The Nip46Sender implementation:

1. Maintains a processing state flag and a queue of Nip46Request objects
2. Provides three main methods:
   - `send()`: Sends a single request to the remote signer by:
     - Encrypting the request payload using the specified algorithm (nip44 by default)
     - Creating a Nostr event with the encrypted content
     - Publishing the event to the specified relays
     - Emitting a Send event
   - `process()`: Processes the queue of requests one by one, handling errors for each request
   - `enqueue()`: Adds a request to the queue and triggers processing
3. Includes a `stop()` method to clean up event listeners
4. Uses the signer's encryption capabilities to secure the communication with the remote signer
5. Requires a valid signerPubkey in the params to function properly

related: Nip46Request,ISigner,Nip46BrokerParams

code:
export class Nip46Sender extends Emitter {
  public processing = false
  public queue: Nip46Request[] = []

  constructor(
    public signer: ISigner,
    public params: Nip46BrokerParams,
  ) {
    super()
  }
  // send a request to the remote signer, emitting the request and the pub
  public send = async (request: Nip46Request) => {
    const {id, method, params} = request
    const {relays, signerPubkey, context, algorithm = "nip44"} = this.params

    if (!signerPubkey) {
      throw new Error("Unable to send nip46 request without a signer pubkey")
    }

    const payload = JSON.stringify({id, method, params})
    const content = await this.signer[algorithm].encrypt(signerPubkey, payload)
    const template = makeEvent(NOSTR_CONNECT, {content, tags: [["p", signerPubkey]]})
    const event = await this.signer.sign(template)

    publish({relays, event, context})

    this.emit(Nip46Event.Send, request)
  }

  // process the queue of requests
  public process = async () => {
    if (this.processing) {
      return
    }

    this.processing = true

    try {
      while (this.queue.length > 0) {
        const [request] = this.queue.splice(0, 1)

        try {
          await this.send(request)
        } catch (error: any) {
          if (nip46Context.debug) {
            console.log("nip46 error:", error, request)
          }
        }
      }
    } finally {
      this.processing = false
    }
  }

  // enqueue a request to the queue and process it
  enqueue = (request: Nip46Request) => {
    this.queue.push(request)
    this.process()
  }

  stop = () => {
    this.removeAllListeners()
  }
}

import/access examples:
import { Nip46Sender } from '@welshman/signer';
import { Nip46Sender } from '@welshman/signer/signers/nip46';


=========================
workspace: packages/signer
file: packages/signer/src/signers/nip46.ts
lines: 211:249
id: 062835be5fa0802606a7eb01b7b1a29a9ab7222994e1bf5f63319fc0a8ce32a4
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/signers/nip46.ts#L211

declaration:
export class Nip46Request{
  id: string;
  promise: Deferred<Nip46ResponseWithResult, Nip46ResponseWithError>;
  constructor(
      readonly method: string,
      readonly params: string[],
    );
  listen: (receiver: Nip46Receiver) => Promise<void>;
  send: (sender: Nip46Sender) => Promise<void>;
}

summary:
Nip46Request is a class that represents a request to a remote NIP-46 signer. It encapsulates the method name, parameters, and provides functionality to send the request and handle responses. The class generates a unique ID for each request and exposes a promise that will be resolved or rejected when the remote signer responds.

details:
Implementation details:
1. The class uses `randomId()` to generate a unique identifier for each request.
2. It creates a deferred promise using `defer<Nip46ResponseWithResult, Nip46ResponseWithError>()` that will be resolved/rejected when a response is received.
3. The `listen` method:
   - Starts the receiver if not already started
   - Sets up an event listener for the Nip46Event.Receive event
   - Handles special "auth_url" responses by opening a popup
   - Resolves/rejects the promise based on the response
   - Cleans up the event listener when done
4. The `send` method simply enqueues the request in the sender's queue for processing.
5. The class works in conjunction with Nip46Receiver and Nip46Sender classes to handle the communication flow.

related: Nip46ResponseWithResult

code:
export class Nip46Request {
  id = randomId()
  promise = defer<Nip46ResponseWithResult, Nip46ResponseWithError>()

  constructor(
    readonly method: string,
    readonly params: string[],
  ) {}

  // listen for a response from the remote signer and resolve/reject the in class promise
  listen = async (receiver: Nip46Receiver) => {
    await receiver.start()

    const onReceive = (response: Nip46Response) => {
      if (response.id !== this.id) {
        return
      }

      if (response.result === "auth_url") {
        popupManager.open(response.error!)
      } else {
        if (response.error) {
          this.promise.reject(response as Nip46ResponseWithError)
        } else {
          this.promise.resolve(response as Nip46ResponseWithResult)
        }

        receiver.off(Nip46Event.Receive, onReceive)
      }
    }

    receiver.on(Nip46Event.Receive, onReceive)
  }

  // send the request to the remote signer
  send = async (sender: Nip46Sender) => {
    sender.enqueue(this)
  }
}

import/access examples:
import { Nip46Request } from '@welshman/signer';
import { Nip46Request } from '@welshman/signer/signers/nip46';


=========================
workspace: packages/signer
file: packages/signer/src/signers/nip46.ts
lines: 251:439
id: a523341a28466c9562c36a3407d25d5f559456b7cde592f21b3b82e3ba633540
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/signers/nip46.ts#L251

declaration:
export class Nip46Broker extends Emitter{
  public signer: ISigner;
  public sender: Nip46Sender;
  public receiver: Nip46Receiver;
  constructor(public params: Nip46BrokerParams);
  static parseBunkerUrl: (url: string) => { relays: string[]; signerPubkey: string; connectSecret: string; }
  makeSigner: () => Nip01Signer;
  makeSender: () => Nip46Sender;
  makeReceiver: () => Nip46Receiver;
  cleanup: () => void;
  enqueue: (method: string, params: string[]) => Promise<Nip46Request>;
  send: (method: string, params: string[]) => Promise<string>;
  makeNostrconnectUrl: (meta?: Record<string, string>) => Promise<string>;
  waitForNostrconnect: (url: string, signal: AbortSignal) => CustomPromise<Nip46ResponseWithResult, Nip46Response | undefined>;
  getBunkerUrl: () => string;
  ping: () => Promise<string>;
  getPublicKey: () => Promise<string>;
  createAccount: (username: string, domain: string, perms?: string) => Promise<string>;
  connect: (connectSecret?: string, perms?: string) => Promise<string>;
  signEvent: (event: StampedEvent) => Promise<any>;
  nip04Encrypt: (pk: string, message: string) => Promise<string>;
  nip04Decrypt: (pk: string, message: string) => Promise<string>;
  nip44Encrypt: (pk: string, message: string) => Promise<string>;
  nip44Decrypt: (pk: string, message: string) => Promise<string>;
}

summary:
Nip46Broker is a class that facilitates communication with a remote Nostr signer using the NIP-46 protocol. It manages the connection between a client and a remote signer (bunker), handling request/response cycles, authentication, and encryption. The class provides methods for initiating connections, sending commands to the remote signer, and performing cryptographic operations like signing events and encrypting/decrypting messages.

details:
The Nip46Broker implementation consists of several key components:

1. It uses a Nip01Signer for local operations and maintains both a sender (Nip46Sender) and receiver (Nip46Receiver) to handle bidirectional communication.

2. The broker manages the lifecycle of requests through the Nip46Request class, which creates promises that resolve when responses are received.

3. Key functionality includes:
   - Connection management through makeNostrconnectUrl and waitForNostrconnect
   - Serialization of connections via getBunkerUrl
   - Standard NIP-46 methods like ping, getPublicKey, connect, signEvent, and various encryption/decryption methods

4. The implementation uses an event-based architecture where the receiver listens for incoming messages from the remote signer and emits events that the broker processes.

5. The class handles authentication flows, including opening popup windows when necessary for user authorization.

related: ISigner,Nip46Sender,Nip46Receiver,Nip46BrokerParams

code:
export class Nip46Broker extends Emitter {
  public signer: ISigner
  public sender: Nip46Sender
  public receiver: Nip46Receiver

  constructor(public params: Nip46BrokerParams) {
    super()

    this.signer = this.makeSigner()
    this.sender = this.makeSender()
    this.receiver = this.makeReceiver()
  }

  // Static utility methods

  static parseBunkerUrl = (url: string) => {
    let connectSecret = ""
    let signerPubkey = ""
    let relays: string[] = []

    try {
      const _url = new URL(url)
      const _relays = _url.searchParams.getAll("relay") || []
      const _signerPubkey = _url.hostname || _url.pathname.replace(/\//g, "")
      const _connectSecret = _url.searchParams.get("secret") || ""

      relays = _relays.map(normalizeRelayUrl)
      signerPubkey = _signerPubkey.match(/^[0-9a-f]{64}$/)?.[0] || ""
      connectSecret = _connectSecret
    } catch {
      // pass
    }

    return {relays, signerPubkey, connectSecret}
  }

  // Getters for helper objects

  makeSigner = () => new Nip01Signer(this.params.clientSecret)

  makeSender = () => {
    const sender = new Nip46Sender(this.signer, this.params)

    sender.on(Nip46Event.Send, (data: any) => {
      if (nip46Context.debug) {
        console.log("nip46 send:", data)
      }
    })

    return sender
  }

  makeReceiver = () => {
    const receiver = new Nip46Receiver(this.signer, this.params)

    receiver.on(Nip46Event.Receive, (data: any) => {
      if (nip46Context.debug) {
        console.log("nip46 receive:", data)
      }
    })

    return receiver
  }

  // Lifecycle methods

  cleanup = () => {
    this.sender.stop()
    this.receiver.stop()
  }

  // General purpose utility methods

  enqueue = async (method: string, params: string[]) => {
    const request = new Nip46Request(method, params)

    await request.listen(this.receiver)
    await request.send(this.sender)

    return request
  }

  send = async (method: string, params: string[]) => {
    const request = await this.enqueue(method, params)
    const response = await request.promise

    return response.result
  }

  // Methods for initiating a connection

  makeNostrconnectUrl = async (meta: Record<string, string> = {}) => {
    const clientPubkey = await this.signer.getPubkey()
    const secret = Math.random().toString(36).substring(7)
    const params = new URLSearchParams({...meta, secret})

    for (const relay of this.params.relays) {
      params.append("relay", relay)
    }

    return `nostrconnect://${clientPubkey}?${params.toString()}`
  }

  waitForNostrconnect = (url: string, signal: AbortSignal) => {
    const secret = new URL(url).searchParams.get("secret")

    return makePromise<Nip46ResponseWithResult, Nip46Response | undefined>((resolve, reject) => {
      const onReceive = (response: Nip46Response) => {
        if (response.result === "auth_url") return

        if (["ack", secret].includes(response.result!)) {
          this.params.signerPubkey = response.event.pubkey

          if (response.result === "ack") {
            console.warn(
              "Bunker responded to nostrconnect with 'ack', which can lead to session hijacking",
            )
          }

          resolve(response as Nip46ResponseWithResult)
        } else {
          reject(response)
        }

        cleanup()
      }

      const cleanup = () => {
        this.receiver.off(Nip46Event.Receive, onReceive)
      }

      this.receiver.on(Nip46Event.Receive, onReceive)
      this.receiver.start()

      signal.addEventListener("abort", () => {
        reject(undefined)
        cleanup()
      })
    })
  }

  // Methods for serializing a connection

  getBunkerUrl = () => {
    if (!this.params.signerPubkey) {
      throw new Error("Attempted to get a bunker url with no signerPubkey")
    }

    const params = new URLSearchParams()

    for (const relay of this.params.relays) {
      params.append("relay", relay)
    }

    if (this.params.connectSecret) {
      params.set("secret", this.params.connectSecret)
    }

    return "bunker://" + this.params.signerPubkey + "?" + params.toString()
  }

  // Normal NIP 46 methods

  ping = () => this.send("ping", [])

  getPublicKey = () => this.send("get_public_key", [])

  createAccount = (username: string, domain: string, perms = "") =>
    this.send("create_account", [username, domain, "", perms])

  connect = async (connectSecret = "", perms = "") => {
    if (!this.params.signerPubkey) {
      throw new Error("Attempted to `connect` with no signerPubkey")
    }

    return this.send("connect", [this.params.signerPubkey, connectSecret, perms])
  }

  signEvent = async (event: StampedEvent) =>
    JSON.parse(await this.send("sign_event", [JSON.stringify(event)]))

  nip04Encrypt = (pk: string, message: string) => this.send("nip04_encrypt", [pk, message])

  nip04Decrypt = (pk: string, message: string) => this.send("nip04_decrypt", [pk, message])

  nip44Encrypt = (pk: string, message: string) => this.send("nip44_encrypt", [pk, message])

  nip44Decrypt = (pk: string, message: string) => this.send("nip44_decrypt", [pk, message])
}

import/access examples:
import { Nip46Broker } from '@welshman/signer';
import { Nip46Broker } from '@welshman/signer/signers/nip46';


=========================
workspace: packages/signer
file: packages/signer/src/signers/nip46.ts
lines: 441:468
id: 4ea4213375d88d14c9c2570e27286cc05630d281e9907b29e86e1e0335084966
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/signers/nip46.ts#L441

declaration:
export class Nip46Signer implements ISigner{
  pubkey?: string;
  nip04: EncryptionImplementation;
  nip44: EncryptionImplementation;
  constructor(public broker: Nip46Broker);
  getPubkey: () => Promise<string>;
  sign: (template: StampedEvent) => Promise<any>;
}

summary:
Nip46Signer is a class that implements the ISigner interface, providing a way to interact with a remote signer through NIP-46 protocol. It wraps a Nip46Broker instance to handle encryption/decryption operations (both NIP-04 and NIP-44) and event signing. The class exposes methods to get the public key and sign events, delegating the actual implementation to the broker.

details:
The implementation is straightforward:

1. The class takes a Nip46Broker instance in its constructor and sets up encryption implementations for both NIP-04 and NIP-44 protocols by wrapping the broker's corresponding methods.

2. It caches the public key after the first retrieval to avoid unnecessary remote calls.

3. The sign method works by:
   - Taking an event template
   - Adding the public key to the event using the 'own' utility
   - Hashing the event
   - Delegating the actual signing to the broker's signEvent method

The class acts as an adapter between the ISigner interface and the Nip46Broker, allowing applications to use a remote signer through the same interface as local signers.

related: ISigner,EncryptionImplementation,Nip46Broker

code:
export class Nip46Signer implements ISigner {
  pubkey?: string
  nip04: EncryptionImplementation
  nip44: EncryptionImplementation

  constructor(public broker: Nip46Broker) {
    this.nip04 = {
      encrypt: this.broker.nip04Encrypt,
      decrypt: this.broker.nip04Decrypt,
    }

    this.nip44 = {
      encrypt: this.broker.nip44Encrypt,
      decrypt: this.broker.nip44Decrypt,
    }
  }

  getPubkey = async () => {
    if (!this.pubkey) {
      this.pubkey = await this.broker.getPublicKey()
    }

    return this.pubkey
  }

  sign = async (template: StampedEvent) =>
    this.broker.signEvent(hash(own(template, await this.getPubkey())))
}

import/access examples:
import { Nip46Signer } from '@welshman/signer';
import { Nip46Signer } from '@welshman/signer/signers/nip46';


=========================
workspace: packages/signer
file: packages/signer/src/signers/nip55.ts
lines: 6:9
id: 8f2042a040c4a776a6184c74e6f95768ebd2297f1ed8cffe383bec819a98a1fa
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/signers/nip55.ts#L6

declaration:
getNip55 = async (): Promise<AppInfo[]> => {
  const {apps} = await NostrSignerPlugin.getInstalledSignerApps()
  return apps
}

summary:
Asynchronous function that retrieves a list of installed Nostr signer applications. It returns a Promise that resolves to an array of AppInfo objects, which contain information about the installed signer apps.

details:
The implementation uses the NostrSignerPlugin from the nostr-signer-capacitor-plugin package to call the getInstalledSignerApps method. It destructures the returned object to extract the 'apps' property and returns it directly. This function serves as a simple wrapper around the plugin's functionality to get information about available NIP-55 compatible signer applications.

import/access examples:
import { getNip55 } from '@welshman/signer';
import { getNip55 } from '@welshman/signer/signers/nip55';


=========================
workspace: packages/signer
file: packages/signer/src/signers/nip55.ts
lines: 11:144
id: 1e1d6b4c5a9f5e308c4164da09f55ab9f7ab48e9edbeabc3e078e7fcb8d2a84d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/signers/nip55.ts#L11

declaration:
export class Nip55Signer implements ISigner{
  constructor(packageName: string);
  getPubkey: () => Promise<string>;
  sign: (template: StampedEvent) => Promise<SignedEvent>;
  nip04: { encrypt: (recipientPubKey: string, message: string) => Promise<string>; decrypt: (senderPubKey: string, message: string) => Promise<string>; }
  nip44: { encrypt: (recipientPubKey: string, message: string) => Promise<string>; decrypt: (senderPubKey: string, message: string) => Promise<string>; }
}

summary:
A class that implements the ISigner interface for NIP-55 compatible signer applications. It provides functionality to interact with external signer apps through the Nostr Signer Capacitor Plugin. The class handles public key retrieval, event signing, and encryption/decryption using both NIP-04 and NIP-44 protocols. It requires a package name for initialization and manages connections to the external signer app.

details:
Implementation details:

1. Uses private fields (#lock, #plugin, #packageName, etc.) to maintain state and prevent external modification.
2. Implements a locking mechanism (#lock Promise) to ensure sequential execution of operations.
3. The #initialize method sets up the connection to the external signer app.
4. The #then method provides a consistent pattern for executing operations with the signer plugin, handling initialization if needed.
5. Caches the public key (both hex and bech32 formats) after first retrieval to avoid redundant calls.
6. For signing events, it:
   - Gets the public key
   - Creates a hash of the event template
   - Delegates the actual signing to the external signer app
   - Parses and returns the signed event
7. For encryption/decryption (both NIP-04 and NIP-44), it:
   - Ensures the public key is available
   - Delegates the operation to the external signer app
   - Returns the result

related: ISigner

code:
export class Nip55Signer implements ISigner {
  #lock = Promise.resolve()
  #plugin = NostrSignerPlugin
  #packageName: string
  #packageNameSet = false
  #npub?: string
  #publicKey?: string

  constructor(packageName: string) {
    this.#packageName = packageName
    this.#initialize()
  }

  #initialize() {
    if (!this.#packageNameSet) {
      void this.#plugin.setPackageName({packageName: this.#packageName}).then(() => {
        this.#packageNameSet = true
      })
    }
  }

  #then = async <T>(f: (signer: typeof NostrSignerPlugin) => T | Promise<T>): Promise<T> => {
    const promise = this.#lock.then(async () => {
      if (!this.#packageNameSet) {
        try {
          await this.#plugin.setPackageName({packageName: this.#packageName})
          this.#packageNameSet = true
        } catch (error) {
          this.#packageNameSet = false
          throw error
        }
      }
      return f(this.#plugin)
    })

    this.#lock = promise.then(() => Promise.resolve())

    return promise
  }

  getPubkey = async (): Promise<string> => {
    return this.#then(async signer => {
      if (!this.#publicKey || !this.#npub) {
        try {
          const {npub} = await signer.getPublicKey()
          this.#npub = npub
          const {data} = decode(npub)
          this.#publicKey = data as string
        } catch (error) {
          throw new Error("Failed to get public key")
        }
      }
      return this.#publicKey
    })
  }

  sign = async (template: StampedEvent): Promise<SignedEvent> => {
    const pubkey = await this.getPubkey() // hex-encoded public key
    const npub = this.#npub! // Bech32-encoded public key
    const event = {sig: "", ...hash(own(template, pubkey))}

    return this.#then(async signer => {
      const {event: signedEventJson} = await signer.signEvent({
        eventJson: JSON.stringify(event),
        eventId: event.id,
        npub: npub,
      })
      const signedEvent = JSON.parse(signedEventJson) as SignedEvent
      return signedEvent
    })
  }

  nip04 = {
    encrypt: async (recipientPubKey: string, message: string): Promise<string> => {
      const myNpub = this.#npub
      if (!myNpub) {
        await this.getPubkey()
      }
      return this.#then(async signer => {
        const {result} = await signer.nip04Encrypt({
          pubKey: recipientPubKey,
          plainText: message,
          npub: this.#npub!,
        })
        return result
      })
    },
    decrypt: async (senderPubKey: string, message: string): Promise<string> => {
      const myNpub = this.#npub
      if (!myNpub) {
        await this.getPubkey()
      }
      return this.#then(async signer => {
        const {result} = await signer.nip04Decrypt({
          pubKey: senderPubKey,
          encryptedText: message,
          npub: this.#npub!,
        })
        return result
      })
    },
  }

  nip44 = {
    encrypt: async (recipientPubKey: string, message: string): Promise<string> => {
      const myNpub = this.#npub
      if (!myNpub) {
        await this.getPubkey()
      }
      return this.#then(async signer => {
        const {result} = await signer.nip44Encrypt({
          pubKey: recipientPubKey,
          plainText: message,
          npub: this.#npub!,
        })
        return result
      })
    },
    decrypt: async (senderPubKey: string, message: string): Promise<string> => {
      const myNpub = this.#npub
      if (!myNpub) {
        await this.getPubkey()
      }
      return this.#then(async signer => {
        const {result} = await signer.nip44Decrypt({
          pubKey: senderPubKey,
          encryptedText: message,
          npub: this.#npub!,
        })
        return result
      })
    },
  }
}

import/access examples:
import { Nip55Signer } from '@welshman/signer';
import { Nip55Signer } from '@welshman/signer/signers/nip55';


=========================
workspace: packages/signer
file: packages/signer/__tests__/common.ts
lines: 6:58
id: 9facfac2c218797c1668d0ec6ba9709fc62921a123e60d726c3b706c6f02438c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/__tests__/common.ts#L6

declaration:
testSigner = (name: string, createSigner: () => ISigner) => {
  describe(name, () => {
    let signer: ISigner

    beforeEach(() => {
      signer = createSigner()
    })

    describe("getPubkey", () => {
      it("should return valid public key", async () => {
        const pubkey = await signer.getPubkey()
        expect(pubkey).toMatch(/^[0-9a-f]{64}$/) // hex pubkey
      })
    })

    describe("sign", () => {
      it("should sign event correctly", async () => {
        const event: StampedEvent = {
          kind: 1,
          created_at: 1000,
          tags: [],
          content: "test",
        }
        const signed = await signer.sign(event)
        expect(signed.sig).toMatch(/^[0-9a-f]{128}$/) // hex signature
      })
    })

    describe("nip04", () => {
      it("should encrypt and decrypt messages", async () => {
        const message = "test message"
        const pubkey = await signer.getPubkey()

        const encrypted = await signer.nip04.encrypt(pubkey, message)
        const decrypted = await signer.nip04.decrypt(pubkey, encrypted)

        expect(decrypted).toBe(message)
      })
    })

    describe("nip44", () => {
      it("should encrypt and decrypt messages", async () => {
        const message = "test message"
        const pubkey = await signer.getPubkey()

        const encrypted = await signer.nip44.encrypt(pubkey, message)
        const decrypted = await signer.nip44.decrypt(pubkey, encrypted)

        expect(decrypted).toBe(message)
      })
    })
  })
}

summary:
A test suite factory function that creates standardized tests for any implementation of the ISigner interface. It takes a name for the test suite and a factory function that creates a signer instance. The tests verify that the signer correctly implements key functionality including: retrieving a public key, signing events, and handling both NIP-04 and NIP-44 encryption/decryption operations.

details:
The implementation creates a Vitest test suite with the following structure:

1. Sets up a fresh signer instance before each test using the provided factory function
2. Tests the `getPubkey()` method to ensure it returns a valid 64-character hex string
3. Tests the `sign()` method by signing a simple event and verifying the signature is a 128-character hex string
4. Tests the NIP-04 encryption/decryption by:
   - Encrypting a test message using the signer's own public key
   - Decrypting the message and verifying it matches the original
5. Tests the NIP-44 encryption/decryption with the same approach as NIP-04

The function uses Vitest's describe/it pattern for test organization and expect() for assertions.

related: ISigner

import/access examples:
import { testSigner } from '@welshman/signer/__tests__/common';


=========================
type: file
workspace: packages/signer
path: packages/signer/__tests__/common.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/__tests__/common.ts
summary: This file exports a test suite function `testSigner` that provides standardized tests for any implementation of the `ISigner` interface. The function creates a test suite that verifies the core functionality of a signer including public key retrieval, event signing, and message encryption/decryption using both NIP-04 and NIP-44 protocols.

details: The implementation creates a reusable test suite using Vitest that:
1. Takes a name and a factory function that creates an instance of ISigner
2. Sets up a fresh signer instance before each test
3. Tests four main areas of functionality:
   - `getPubkey()` - verifies it returns a valid 64-character hex string
   - `sign()` - checks if it properly signs a StampedEvent with a 128-character hex signature
   - `nip04` - tests encryption and decryption of messages between the signer and itself
   - `nip44` - tests encryption and decryption using the newer NIP-44 protocol

The test suite is designed to be imported and reused across different signer implementation tests.

=========================
type: dir
workspace: packages/signer
path: packages/signer/__tests__/
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/__tests__/
summary: The __tests__ directory contains test suites for various Nostr Implementation Possibilities (NIPs), focusing on testing signer implementations and protocol-specific functionality. The main exported utility is the `testSigner` function from common.ts, which provides standardized tests for any implementation of the `ISigner` interface, verifying core functionality like public key retrieval, event signing, and message encryption/decryption using both NIP-04 and NIP-44 protocols. The directory includes tests for NIP-01 (basic protocol), NIP-07 (browser extension), and NIP-55 (specific protocol features).

=========================
type: file
workspace: packages/signer
path: packages/signer/src/nip59.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/nip59.ts
summary: This file implements NIP-59 functionality for encrypted Nostr events. It exports functions for creating and unwrapping encrypted events, including `wrap`, `unwrap`, and utility functions like `getRumor`, `getSeal`, and `getWrap`. The `Nip59` class provides a convenient interface for these operations, allowing users to create encrypted events with proper metadata protection.

details: The implementation revolves around a three-layer encryption model:

1. The innermost layer is the 'rumor' (the actual event data)
2. The middle layer is the 'seal' (encrypted rumor)
3. The outermost layer is the 'wrap' (encrypted seal)

Key components:
- A `seen` Map caches previously processed events to avoid redundant decryption
- The `now()` function generates timestamps with configurable drift for privacy
- The wrapping process uses three steps: creating a rumor, sealing it, then wrapping it
- Unwrapping reverses this process, decrypting each layer
- The `Nip59` class provides a higher-level API with methods for creating ephemeral wrapper signers to prevent metadata leakage
- Error handling ensures consistent behavior when decryption fails

=========================
type: file
workspace: packages/signer
path: packages/signer/src/signers/nip01.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/signers/nip01.ts
summary: The Nip01Signer class implements the ISigner interface for handling cryptographic operations in the Nostr protocol. It provides methods for signing events, encrypting/decrypting messages using NIP-04 and NIP-44 standards, and managing public/private key pairs. The class can be instantiated with an existing secret key or created with an ephemeral (temporary) key.

details: Implementation details:
1. The class stores a private secret key and derives a public key from it during initialization.
2. It provides two static factory methods: fromSecret() to create a signer from an existing secret, and ephemeral() to create one with a randomly generated secret.
3. The getPubkey() method returns the derived public key.
4. The sign() method signs events by first hashing the event (with the owner set to the signer's pubkey) and then signing it with the secret key.
5. The class implements two encryption protocols:
   - nip04: For older encryption standard
   - nip44: For newer encryption standard
6. Both encryption protocols expose encrypt/decrypt methods that delegate to utility functions, passing the signer's secret key.

=========================
type: file
workspace: packages/signer
path: packages/signer/src/signers/nip07.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/signers/nip07.ts
summary: This file exports the Nip07 type definition and Nip07Signer class which implements the ISigner interface. It provides a way to interact with NIP-07 browser extensions (like nos2x or Alby) that enable signing Nostr events and encrypting/decrypting messages using NIP-04 and NIP-44 encryption methods. The getNip07 function is provided to access the extension from the window object.

details: The implementation includes:
1. A Nip07 type definition that specifies the expected interface for NIP-07 browser extensions.
2. The Nip07Signer class which implements ISigner with methods for:
   - Getting the user's public key
   - Signing events
   - Encrypting/decrypting messages using NIP-04 and NIP-44
3. A locking mechanism using promises to prevent concurrent operations.
4. The #then private method which handles extension access, error recovery, and sequential execution.
5. Error handling for when the NIP-07 extension is not available in the browser.

=========================
type: file
workspace: packages/signer
path: packages/signer/src/signers/nip46.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/signers/nip46.ts
summary: This file implements NIP-46 (Nostr Connect) protocol for delegated signing. It exports several classes: `Nip46Broker` for managing communication between client and remote signer, `Nip46Signer` implementing the ISigner interface using a remote signer, `Nip46Sender` and `Nip46Receiver` for handling message exchange, and `Nip46Request` for creating and managing requests. The module also provides types and utilities for NIP-46 operations, including connection establishment, event signing, and encryption/decryption methods.

details: The implementation is built around several key components:

1. A popup manager (lines 59-94) that handles opening authentication windows when needed.

2. `Nip46Receiver` (lines 96-143) listens for incoming events from a remote signer, decrypts them, and emits them for processing.

3. `Nip46Sender` (lines 145-208) handles sending requests to the remote signer with queue management to ensure orderly processing.

4. `Nip46Request` (lines 211-249) represents individual requests with promise-based resolution.

5. `Nip46Broker` (lines 251-439) orchestrates the entire process, providing high-level methods for NIP-46 operations like connecting, signing events, and encryption/decryption. It manages the lifecycle of sender and receiver components.

6. `Nip46Signer` (lines 441-468) implements the ISigner interface by delegating operations to the broker.

The implementation uses both NIP-04 and NIP-44 encryption algorithms and includes utilities for parsing and generating Nostr Connect URLs. Error handling and debugging features are integrated throughout the code.

=========================
type: file
workspace: packages/signer
path: packages/signer/src/signers/nip55.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/signers/nip55.ts
summary: This file exports functionality for NIP-55 Nostr signer integration. It provides `getNip55()` to retrieve installed signer apps and the `Nip55Signer` class which implements the `ISigner` interface. The signer allows getting public keys, signing events, and performing NIP-04 and NIP-44 encryption/decryption operations using external signer applications.

details: The implementation uses the Capacitor plugin 'nostr-signer-capacitor-plugin' to communicate with external signer apps. Key aspects include:

1. A locking mechanism to ensure sequential execution of operations
2. Lazy initialization of the package name setting
3. Caching of public key information (both hex and bech32 formats)
4. Error handling for failed operations
5. The `#then` private method that manages the execution queue and ensures the package name is set
6. Implementation of the ISigner interface with methods for:
   - Getting public keys
   - Signing events
   - NIP-04 encryption/decryption
   - NIP-44 encryption/decryption
7. Automatic public key retrieval when needed for encryption/decryption operations

=========================
type: dir
workspace: packages/signer
path: packages/signer/src/signers/
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/signers/
summary: The signers directory implements various Nostr protocol signer interfaces that handle cryptographic operations like event signing and message encryption/decryption. It contains four main implementations: Nip01Signer (using direct key pairs), Nip07Signer (browser extension integration), Nip46Signer (delegated signing via Nostr Connect protocol), and Nip55Signer (mobile app integration via Capacitor). All classes implement the ISigner interface, providing consistent methods for getPubkey(), sign(), and encryption operations through nip04 and nip44 objects. These implementations enable applications to perform Nostr cryptographic operations through different key management approaches without changing the application logic.

=========================
type: dir
workspace: packages/signer
path: packages/signer/src/
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/
summary: This directory implements various Nostr protocol functionalities with a focus on cryptographic operations and protocol extensions. The main exports include different signer implementations (NIP-01, NIP-07, NIP-46, NIP-55) that handle event signing and message encryption/decryption, NIP-59 functionality for encrypted events, and utility functions for key management and cryptographic operations. All signers implement the ISigner interface, providing a consistent API for applications to perform Nostr operations regardless of the underlying key management approach. The directory serves as a comprehensive toolkit for building Nostr-compatible applications with support for various authentication methods and privacy-preserving communication.

=========================
type: file
workspace: packages/signer
path: packages/signer/src/util.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/src/util.ts
summary: This file provides utilities for working with Nostr protocol, including key generation, event signing, and encryption. It exports functions for creating secrets, getting public keys, hashing and signing events, as well as implementations for NIP-04 and NIP-44 encryption standards. It also defines the ISigner interface for signing and encryption operations, and a WrappedSigner class that implements this interface with method wrapping capabilities.

details: The implementation includes:
1. Basic cryptographic utilities (makeSecret, getPubkey, getHash, getSig) that wrap functions from nostr-tools and noble libraries
2. Event manipulation functions (stamp, own, hash, sign) for building Nostr events step by step
3. Two encryption implementations: nip04 and nip44, with the latter using a cached shared secret for performance
4. Type definitions for signing and encryption operations (Sign, Encrypt, Decrypt, EncryptionImplementation)
5. A decrypt function that automatically detects and uses the appropriate encryption method
6. A WrappedSigner class that extends Emitter and implements ISigner, allowing method execution to be wrapped with custom logic via the SignerMethodWrapper

=========================
type: dir
workspace: packages/signer
path: packages/signer/
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/signer/
summary: This directory implements a comprehensive Nostr protocol toolkit focusing on cryptographic operations and authentication methods. The main exports include various signer implementations (NIP-01, NIP-07, NIP-46, NIP-55) that conform to the ISigner interface, providing consistent APIs for event signing and message encryption/decryption. The package also includes NIP-59 functionality for encrypted events and utility functions for key management. The test suite in __tests__ validates the signers' functionality, ensuring they correctly handle public key retrieval, event signing, and message encryption using both NIP-04 and NIP-44 protocols. This library serves as a foundation for building Nostr-compatible applications with support for different authentication methods and privacy-preserving communication.

=========================
type: file
workspace: packages/store
file: packages/store/package.json
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/store/package.json
include: always
{
  "name": "@welshman/store",
  "version": "0.4.6",
  "author": "hodlbod",
  "license": "MIT",
  "description": "A collection of utilities based on svelte/store for use with welshman",
  "publishConfig": {
    "access": "public"
  },
  "type": "module",
  "main": "dist/store/src/index.js",
  "types": "dist/store/src/index.d.ts",
  "files": [
    "dist"
  ],
  "scripts": {
    "build": "pnpm run clean && pnpm run compile --force",
    "clean": "rimraf ./dist",
    "compile": "tsc -b tsconfig.build.json",
    "prepublishOnly": "pnpm run build"
  },
  "dependencies": {
    "@welshman/lib": "workspace:*",
    "@welshman/util": "workspace:*",
    "@welshman/relay": "workspace:*",
    "svelte": "^4.2.18"
  },
  "devDependencies": {
    "rimraf": "~6.0.0",
    "typescript": "~5.8.0"
  }
}


=========================
type: file
workspace: packages/store
file: packages/store/tsconfig.json
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/store/tsconfig.json
include: always
{
  "extends": "../../tsconfig.json"
}


=========================
workspace: packages/store
file: packages/store/src/getter.ts
lines: 3:11
id: e50f66fee7ba9b5add6d1bda5f77a50b0cb1cce11c63d5e65266743115c0e1f6
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/store/src/getter.ts#L3

declaration:
getter = <T>(store: Readable<T>) => {
  let value: T

  store.subscribe((newValue: T) => {
    value = newValue
  })

  return () => value
}

summary:
A function that creates a getter for a Svelte store. It takes a Readable store as input and returns a function that provides synchronous access to the current store value without having to use a subscription.

details:
The implementation works by:
1. Creating a local variable `value` to cache the store's current value
2. Setting up a subscription to the provided store that updates the local variable whenever the store value changes
3. Returning a closure function that simply returns the cached value

This effectively creates a memory leak since the subscription is never unsubscribed, but it's designed for stores that typically live for the entire application lifecycle.

import/access examples:
import { getter } from '@welshman/store';
import { getter } from '@welshman/store/getter';


=========================
workspace: packages/store
file: packages/store/src/getter.ts
lines: 13:13
id: 1daf16c12b1d3d425f0fb4119954646d7ed2a5f30b7c5c4459ed213eb515a57a
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/store/src/getter.ts#L13

declaration:
export type WritableWithGetter<T> = Writable<T> & {get: () => T}

summary:
A type alias that extends the Svelte `Writable<T>` store type by adding a `get` method which returns the current value of the store. This allows direct access to the store's value without having to use a subscription.

details:
This type alias combines the standard Svelte `Writable<T>` interface with an additional property `get` that is a function returning the current store value of type T. It's used in conjunction with the `withGetter` function to create enhanced store objects that maintain the original store functionality while adding value retrieval capability.

import/access examples:
import type { WritableWithGetter } from '@welshman/store';
import type { WritableWithGetter } from '@welshman/store/getter';


=========================
workspace: packages/store
file: packages/store/src/getter.ts
lines: 14:14
id: 8a21efcdc93cc8cb92e8b7308f14e40f169d50725d223001de951ae504994a3d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/store/src/getter.ts#L14

declaration:
export type ReadableWithGetter<T> = Readable<T> & {get: () => T}

summary:
ReadableWithGetter<T> is a type alias that extends the Svelte Readable<T> store type by adding a get() method that returns the current value of the store. This allows direct synchronous access to the store's value without having to use the subscribe method.

details:
This type alias combines the standard Svelte Readable<T> interface with an additional property 'get' that is a function returning the current store value of type T. It's used in conjunction with the withGetter function to create enhanced store objects that maintain the original store functionality while adding convenient value access.

import/access examples:
import type { ReadableWithGetter } from '@welshman/store';
import type { ReadableWithGetter } from '@welshman/store/getter';


=========================
workspace: packages/store
file: packages/store/src/getter.ts
lines: 16:16
id: 6f627755d8eba09cdcc472b060556135aaec1b4f1059d98b23e5a2dff86f91ea
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/store/src/getter.ts#L16

declaration:
export function withGetter<T>(store: Writable<T>): WritableWithGetter<T>

summary:
The `withGetter` function enhances a Svelte store (either Readable or Writable) by adding a `get` method that allows direct access to the current store value without subscribing. It accepts a store as input and returns the same store augmented with a getter function.

details:
The implementation uses function overloads to provide proper type definitions for both Writable and Readable stores. When called, it spreads the original store properties into a new object and adds a `get` method created by the `getter` utility function. The `getter` function internally subscribes to the store once, keeps track of the latest value, and returns a function that provides access to that value without needing to subscribe again. This pattern allows for synchronous access to store values outside of Svelte components.

related: WritableWithGetter

import/access examples:
import { withGetter } from '@welshman/store';
import { withGetter } from '@welshman/store/getter';


=========================
workspace: packages/store
file: packages/store/src/getter.ts
lines: 17:17
id: e2536784966ace6f2d822f9c811ecedc6bb2c8dbce210bd8b4ec7921d84dcff6
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/store/src/getter.ts#L17

declaration:
export function withGetter<T>(store: Readable<T>): ReadableWithGetter<T>

summary:
The `withGetter` function enhances a Svelte store by adding a `get` method that allows synchronous access to the store's current value. This overload accepts a `Readable<T>` store and returns a `ReadableWithGetter<T>`, which is the original store augmented with a getter function.

details:
The implementation works by spreading the properties of the original store into a new object and adding a `get` method created by the `getter` utility function. The `getter` function subscribes to the store once, keeps track of the current value in a closure, and returns a function that provides access to that value without needing to use the subscription pattern. This allows for synchronous access to the store's state outside of Svelte's reactive context.

import/access examples:
import { withGetter } from '@welshman/store';
import { withGetter } from '@welshman/store/getter';


=========================
workspace: packages/store
file: packages/store/src/getter.ts
lines: 18:20
id: 5810ec50c6f33f46189c335596c4e1116f7418b8046b09dbec7d24b2f0b34de6
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/store/src/getter.ts#L18

declaration:
export function withGetter<T>(store: Readable<T> | Writable<T>)

summary:
The `withGetter` function enhances a Svelte store (either Readable or Writable) by adding a `get` method that allows synchronous access to the current store value without subscribing. It returns a new store object that combines all the original store's properties with the added getter function.

details:
The implementation works by:
1. Taking a Svelte store (either Readable or Writable) as input
2. Creating a new object that spreads all properties from the original store
3. Adding a `get` method to this object by using the `getter` utility function
4. The `getter` function (defined earlier in the file) creates a closure that:
   - Maintains an internal `value` variable
   - Subscribes to the store to keep this value updated
   - Returns a function that simply returns the current value

The function is overloaded to maintain proper typing, ensuring that when a Writable store is passed, a WritableWithGetter is returned, and when a Readable store is passed, a ReadableWithGetter is returned.

code:
export function withGetter<T>(store: Readable<T> | Writable<T>) {
  return {...store, get: getter<T>(store)}
}

import/access examples:
import { withGetter } from '@welshman/store';
import { withGetter } from '@welshman/store/getter';


=========================
workspace: packages/store
file: packages/store/src/collection.ts
lines: 7:11
id: de07618aa87b75510bf6193275c95fd25fa5feb3aa4d39f5f51f8bea3c819b09
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/store/src/collection.ts#L7

declaration:
export type FreshnessUpdate = {
  ns: string
  key: string
  ts: number
}

summary:
The `FreshnessUpdate` type represents an update to the freshness timestamp of a cached item. It contains three properties: `ns` (namespace string), `key` (item identifier string), and `ts` (timestamp number).

details:
This type is used throughout the collection utility to track when items were last updated or accessed. It provides a structured way to pass freshness information to functions like `setFreshnessImmediate` and `setFreshnessThrottled`. The namespace and key combination creates a unique identifier for each cached item, while the timestamp tracks when the item was last updated.

import/access examples:
import type { FreshnessUpdate } from '@welshman/store';
import type { FreshnessUpdate } from '@welshman/store/collection';


=========================
workspace: packages/store
file: packages/store/src/collection.ts
lines: 13:13
id: 7c46b9d43be7ad68d90b891e7a436e39876df41d10114e512d51391f8e6e0dc4
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/store/src/collection.ts#L13

declaration:
freshness = withGetter(writable<Record<string, number>>({}))

summary:
A writable store with getter functionality that tracks the freshness timestamps for various namespaced keys. It stores a record where keys are formatted as 'namespace:key' and values are timestamp numbers indicating when the data was last updated.

details:
This variable is implemented using the `withGetter` function (imported from './getter.js') wrapped around a Svelte writable store. The store contains a record mapping namespaced keys to timestamp values. The initial value is an empty object. The freshness store is used throughout the collection utility to track when data was last fetched or updated, enabling caching and throttling mechanisms.

related: withGetter,withGetter

import/access examples:
import { freshness } from '@welshman/store';
import { freshness } from '@welshman/store/collection';


=========================
workspace: packages/store
file: packages/store/src/collection.ts
lines: 15:15
id: b000691f9d45fbb68ecec5ce876a4d90834137fc5cf706428fb6799c701c32b2
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/store/src/collection.ts#L15

declaration:
getFreshnessKey = (ns: string, key: string) => `${ns}:${key}`

summary:
A function that generates a unique key for freshness tracking by combining a namespace and a key with a colon separator. Takes two string parameters: 'ns' (namespace) and 'key', and returns a string in the format 'namespace:key'.

details:
This is a simple arrow function that concatenates two strings with a colon separator. It's used throughout the collection utility to create consistent keys for the freshness tracking system. The function helps maintain a standardized format for keys in the freshness store, which appears to track when data was last updated or accessed.

import/access examples:
import { getFreshnessKey } from '@welshman/store';
import { getFreshnessKey } from '@welshman/store/collection';


=========================
workspace: packages/store
file: packages/store/src/collection.ts
lines: 17:18
id: 2103511665f5beeec8e42442d659307d6e6cbf6ad86a70d8c70270ae6b26c69f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/store/src/collection.ts#L17

declaration:
getFreshness = (ns: string, key: string) =>
  freshness.get()[getFreshnessKey(ns, key)] || 0

summary:
A function that retrieves the freshness timestamp for a specific namespace and key combination. It returns the timestamp value if it exists, or 0 if no freshness data is found for the given namespace and key.

details:
This function works by:
1. Taking a namespace string (`ns`) and a key string as parameters
2. Using the `getFreshnessKey` helper function to create a combined key in the format `${ns}:${key}`
3. Accessing the freshness store's current value via `freshness.get()`
4. Looking up the timestamp using the combined key
5. Returning the found timestamp or 0 as a fallback if no timestamp exists

The function is part of a freshness tracking system that helps determine when data needs to be refreshed.

related: freshness

import/access examples:
import { getFreshness } from '@welshman/store';
import { getFreshness } from '@welshman/store/collection';


=========================
workspace: packages/store
file: packages/store/src/collection.ts
lines: 20:21
id: 59b48b27e1a257791736d2ee98f36be3c4a7a95185aadaf0c8a971317953f9ec
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/store/src/collection.ts#L20

declaration:
setFreshnessImmediate = ({ns, key, ts}: FreshnessUpdate) =>
  freshness.update(assoc(getFreshnessKey(ns, key), ts))

summary:
Updates the freshness timestamp for a specific namespace and key combination immediately. Takes a `FreshnessUpdate` object containing namespace (`ns`), key, and timestamp (`ts`) parameters and updates the freshness store with the new timestamp value.

details:
This function implements an immediate update to the freshness store by:
1. Taking a `FreshnessUpdate` object as its parameter
2. Using the `freshness.update()` method to modify the store
3. Utilizing the `assoc` utility function (imported from '@welshman/lib') to associate the new timestamp with the appropriate key
4. Generating the proper store key by calling `getFreshnessKey(ns, key)` to create a namespaced key format

related: freshness,FreshnessUpdate

import/access examples:
import { setFreshnessImmediate } from '@welshman/store';
import { setFreshnessImmediate } from '@welshman/store/collection';


=========================
workspace: packages/store
file: packages/store/src/collection.ts
lines: 23:31
id: 94d53cff804a5beb13c6654951d39af7660521a4e177653c3a5ca8ed0793cc61
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/store/src/collection.ts#L23

declaration:
setFreshnessThrottled = batch(100, (updates: FreshnessUpdate[]) =>
  freshness.update($freshness => {
    for (const {ns, key, ts} of updates) {
      $freshness[getFreshnessKey(ns, key)] = ts
    }

    return $freshness
  }),
)

summary:
A throttled function that updates the freshness timestamps for multiple items in a batch. It takes an array of `FreshnessUpdate` objects (containing namespace, key, and timestamp) and updates the global freshness store with these values. The updates are batched with a 100ms delay to improve performance when many updates occur in quick succession.

details:
This function uses the `batch` utility from `@welshman/lib` to throttle multiple calls within a 100ms window. When the batch is processed, it:

1. Takes all accumulated `FreshnessUpdate` objects
2. Updates the global `freshness` store in a single operation
3. For each update in the batch, it calculates the combined namespace:key identifier using `getFreshnessKey`
4. Sets the timestamp for each key in the freshness record
5. Returns the updated freshness record

This batched approach is more efficient than individual updates when dealing with many freshness updates in rapid succession.

related: batch

import/access examples:
import { setFreshnessThrottled } from '@welshman/store';
import { setFreshnessThrottled } from '@welshman/store/collection';


=========================
workspace: packages/store
file: packages/store/src/collection.ts
lines: 33:38
id: d198234d1a7d87fd2bc33428c98b2d1994d44bc006f95f9f6cfc26a1a18437ba
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/store/src/collection.ts#L33

declaration:
export type CachedLoaderOptions<T> = {
  name: string
  indexStore: ReadableWithGetter<Map<string, T>>
  load: (key: string, relays: string[]) => Promise<any>
  subscribers?: Subscriber<T>[]
}

summary:
CachedLoaderOptions<T> is a TypeScript interface that defines the configuration options for creating a cached loader. It specifies the parameters needed to set up a system that can load and cache data items of type T. The interface includes properties for naming the collection, providing a store for indexed items, defining a load function for fetching data, and optionally specifying subscribers to be notified when items are updated.

details:
The CachedLoaderOptions<T> interface contains four properties:
1. `name: string` - A unique identifier for the collection, used for tracking freshness of items
2. `indexStore: ReadableWithGetter<Map<string, T>>` - A Svelte store with getter functionality that maintains a map of items indexed by their keys
3. `load: (key: string, relays: string[]) => Promise<any>` - An asynchronous function that fetches data for a given key, with optional relay servers
4. `subscribers?: Subscriber<T>[]` - An optional array of callback functions that will be notified when items are updated

This interface is used as the parameter type for the `makeCachedLoader` function, which implements caching logic with freshness tracking and exponential backoff for failed requests.

import/access examples:
import type { CachedLoaderOptions } from '@welshman/store';
import type { CachedLoaderOptions } from '@welshman/store/collection';


=========================
workspace: packages/store
file: packages/store/src/collection.ts
lines: 40:104
id: ec86d5ccada0a7f960aeebe27fd28a26e8297990e54af630bd312461b6405c3b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/store/src/collection.ts#L40

declaration:
makeCachedLoader = <T>({
  name,
  load,
  indexStore,
  subscribers = [],
}: CachedLoaderOptions<T>) => {
  const pending = new Map<string, Promise<T | void>>()
  const loadAttempts = new Map<string, number>()

  return async (key: string, relays: string[] = [], force = false) => {
    const stale = indexStore.get().get(key)

    // If we have no loader function, nothing we can do
    if (!load) {
      return stale
    }

    const freshness = getFreshness(name, key)

    // If we have an item, reload if it's stale
    if (stale && freshness > now() - 3600 && !force) {
      return stale
    }

    // If we already are loading, await and return
    if (pending.has(key)) {
      return pending.get(key)!.then(() => indexStore.get().get(key))
    }

    const attempt = loadAttempts.get(key) || 0

    // Use exponential backoff to throttle attempts
    if (freshness > now() - Math.pow(2, attempt) && !force) {
      return stale
    }

    loadAttempts.set(key, attempt + 1)

    setFreshnessThrottled({ns: name, key, ts: now()})

    const promise = load(key, relays)

    pending.set(key, promise)

    try {
      await promise
    } catch (e) {
      console.warn(`Failed to load ${name} item ${key}`, e)
    } finally {
      pending.delete(key)
    }

    const fresh = indexStore.get().get(key)

    if (fresh) {
      loadAttempts.delete(key)

      for (const subscriber of subscribers) {
        subscriber(fresh)
      }
    }

    return fresh
  }
}

summary:
Creates a cached loader function for fetching and managing data items. The returned function loads items by key, with built-in caching, freshness tracking, and error handling. It accepts parameters for the item key, optional relay servers, and a force reload flag. The loader avoids redundant requests for the same key, implements exponential backoff for failed attempts, and notifies subscribers when fresh data is available.

details:
The implementation creates a sophisticated data loading mechanism with several key features:

1. Maintains two internal maps:
   - `pending`: Tracks in-flight promises for each key to prevent duplicate requests
   - `loadAttempts`: Counts load attempts for implementing exponential backoff

2. The returned loader function implements a multi-stage decision tree:
   - Returns cached data if available and not stale (freshness within last hour)
   - Returns pending promise result if already loading the requested key
   - Implements exponential backoff based on previous attempts (2^attempt seconds)
   - Tracks freshness timestamps using the global freshness store
   - Handles errors gracefully with console warnings
   - Notifies all subscribers when fresh data is available

3. Uses the provided `load` function to fetch actual data, while managing all the caching, freshness, and subscription logic around it.

related: CachedLoaderOptions

import/access examples:
import { makeCachedLoader } from '@welshman/store';
import { makeCachedLoader } from '@welshman/store/collection';


=========================
workspace: packages/store
file: packages/store/src/collection.ts
lines: 106:111
id: a50fc2927f0310dd00adc5765d3585c19c9e93f5010a4a33a576a1d198c1521b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/store/src/collection.ts#L106

declaration:
export type CollectionOptions<T> = {
  name: string
  store: Readable<T[]>
  getKey: (item: T) => string
  load: (key: string, relays: string[]) => Promise<any>
}

summary:
A generic type definition that specifies the configuration options for creating a collection. It takes a type parameter `T` which represents the type of items in the collection. The options include:
- `name`: A string identifier for the collection
- `store`: A Svelte readable store containing an array of items of type T
- `getKey`: A function that extracts a unique key from an item of type T
- `load`: A function that loads an item by key, potentially from external sources, returning a Promise

import/access examples:
import type { CollectionOptions } from '@welshman/store';
import type { CollectionOptions } from '@welshman/store/collection';


=========================
workspace: packages/store
file: packages/store/src/collection.ts
lines: 113:141
id: e63fb6c9d0d75e03f0b01726f67b96cac2d3535ad3ff3f09dfb536eb69c3fbbe
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/store/src/collection.ts#L113

declaration:
collection = <T>({name, store, getKey, load}: CollectionOptions<T>) => {
  const indexStore = withGetter(derived(store, $items => indexBy(getKey, $items)))

  let subscribers: Subscriber<T>[] = []

  const loadItem = makeCachedLoader({name, load, indexStore, subscribers})

  const deriveItem = (key: string | undefined, relays: string[] = []) => {
    if (!key) {
      return readable(undefined)
    }

    // If we don't yet have the item, or it's stale, trigger a request for it. The derived
    // store will update when it arrives
    loadItem(key, relays)

    return derived(indexStore, $index => $index.get(key))
  }

  const onItem = (cb: Subscriber<T>) => {
    subscribers.push(cb)

    return () => {
      subscribers = remove(cb, subscribers)
    }
  }

  return {indexStore, deriveItem, loadItem, onItem}
}

summary:
Creates a collection utility for managing a collection of items with caching and loading capabilities. Takes options including a name, a Svelte store containing items, a function to get a key from an item, and a load function for fetching items. Returns an object with utilities for working with the collection: indexStore (a map of items by key), deriveItem (creates a readable store for a specific item), loadItem (loads an item by key), and onItem (subscribes to item updates).

details:
Implementation creates a reactive system for managing collections with caching and loading:

1. Creates an indexed version of the store using withGetter and derived, mapping items by their keys
2. Sets up a subscriber system to notify when items are updated
3. Creates a cached loader using makeCachedLoader to handle loading items with proper caching
4. Implements deriveItem which:
   - Returns undefined as a readable if no key is provided
   - Triggers loading of the item if needed
   - Returns a derived store that reactively updates when the item changes
5. Implements onItem to allow subscribing to item updates with proper cleanup

The implementation leverages Svelte's store system for reactivity while adding caching, loading, and subscription capabilities.

related: CollectionOptions

import/access examples:
import { collection } from '@welshman/store';
import { collection } from '@welshman/store/collection';


=========================
workspace: packages/store
file: packages/store/src/synced.ts
lines: 4:7
id: 7e943752a046f15622973e01890c8ce4052f3f08853f9d6d5e8f4605fd40471b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/store/src/synced.ts#L4

declaration:
export interface StorageProvider {
  get: (key: string) => Promise<any>
  set: (key: string, value: any) => Promise<void>
}

summary:
The `StorageProvider` interface defines a contract for storage mechanisms that can asynchronously get and set JSON data. It requires two methods: `get` which retrieves data by key and returns a Promise, and `set` which stores data by key and returns a Promise that resolves when the operation completes.

details:
This interface serves as an abstraction layer for different storage backends, allowing the synced store functionality to work with various storage implementations. It's designed to be simple with just two asynchronous methods, making it easy to implement for different storage solutions like localStorage, sessionStorage, IndexedDB, or remote storage.

import/access examples:
import type { StorageProvider } from '@welshman/store';
import type { StorageProvider } from '@welshman/store/synced';


=========================
workspace: packages/store
file: packages/store/src/synced.ts
lines: 9:12
id: 60f2b8a593a22482831128c5bbfd23606ecf4a8e2598eddba822a583596c2695
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/store/src/synced.ts#L9

declaration:
localStorageProvider: StorageProvider = {
  get: async (key: string) => getJson(key),
  set: async (key: string, value: any) => setJson(key, value),
}

summary:
A constant that implements the `StorageProvider` interface using local storage. It provides methods to get and set JSON data in the browser's localStorage, using utility functions from the `@welshman/lib` package.

details:
The `localStorageProvider` is a simple implementation of the `StorageProvider` interface that:
1. Uses `getJson` from `@welshman/lib` to retrieve data from localStorage by key
2. Uses `setJson` from `@welshman/lib` to store data in localStorage by key
3. Wraps both operations in async functions to conform to the `StorageProvider` interface, even though localStorage operations are synchronous

related: StorageProvider

import/access examples:
import { localStorageProvider } from '@welshman/store';
import { localStorageProvider } from '@welshman/store/synced';


=========================
workspace: packages/store
file: packages/store/src/synced.ts
lines: 14:18
id: b7f09622e3e9081ecd0e2b8a11e507db02d3093a61df47947cca1a00298036c1
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/store/src/synced.ts#L14

declaration:
export interface SyncConfig<T> {
  key: string
  store: Writable<T>
  storage: StorageProvider
}

summary:
The `SyncConfig<T>` interface defines the configuration required for synchronizing a Svelte store with persistent storage. It contains three properties: `key` (the storage key identifier), `store` (the Svelte writable store to be synchronized), and `storage` (the storage provider that handles the actual persistence operations).

details:
This interface serves as a parameter type for the `sync` function, providing all necessary components to establish bidirectional synchronization between a Svelte store and a storage backend. It's designed to be generic, allowing for type-safe synchronization of any data type through the generic parameter `T`.

related: StorageProvider

import/access examples:
import type { SyncConfig } from '@welshman/store';
import type { SyncConfig } from '@welshman/store/synced';


=========================
workspace: packages/store
file: packages/store/src/synced.ts
lines: 20:20
id: 23ad0a92d7495810acfb6dfde2b61a643447881974f572a513a14127627ff58e
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/store/src/synced.ts#L20

declaration:
export type Synced<T> = Writable<T> & {ready: Promise<void>}

summary:
The `Synced<T>` type represents a Svelte writable store that is synchronized with persistent storage. It extends the standard Svelte `Writable<T>` interface by adding a `ready` property, which is a Promise that resolves when the initial synchronization with storage is complete.

details:
This type alias combines the Svelte store functionality with a synchronization status indicator. The `ready` Promise allows consumers to wait for the initial data to be loaded from storage before performing operations that depend on the store's value being properly initialized.

import/access examples:
import type { Synced } from '@welshman/store';
import type { Synced } from '@welshman/store/synced';


=========================
workspace: packages/store
file: packages/store/src/synced.ts
lines: 22:32
id: 83d49c432f0359f260c8e2c5dbb87834674ad5c4d93c2a319d8108c4dfa0f713
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/store/src/synced.ts#L22

declaration:
sync = async <T>({key, store, storage}: SyncConfig<T>) => {
  const storedValue = await storage.get(key)

  if (storedValue !== undefined) {
    store.set(storedValue)
  }

  store.subscribe(async (value: T) => {
    await storage.set(key, value)
  })
}

summary:
Synchronizes a Svelte writable store with a storage provider. It first loads any existing value from storage into the store, then sets up a subscription to save any future store changes back to storage. Returns a Promise that resolves when the initial synchronization is complete.

details:
Implementation works in two steps:
1. First retrieves the stored value using the provided key from the storage provider
2. If a value exists in storage (not undefined), it updates the store with that value
3. Then sets up a subscription to the store that persists any changes back to the storage provider
4. The function doesn't return anything explicitly, but the caller can await the function to know when initial synchronization is complete

related: SyncConfig

import/access examples:
import { sync } from '@welshman/store';
import { sync } from '@welshman/store/synced';


=========================
workspace: packages/store
file: packages/store/src/synced.ts
lines: 34:38
id: 62abdc94c8cdf0d4cdbc8371ebb1ea564237d58531ab9f139cdcbc91920ce9d6
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/store/src/synced.ts#L34

declaration:
export interface SyncedConfig<T> {
  key: string
  storage: StorageProvider
  defaultValue: T
}

summary:
The `SyncedConfig<T>` interface defines the configuration options required to create a synchronized Svelte store using the `synced` function. It includes three properties: `key` (the storage key identifier), `storage` (the storage provider implementation), and `defaultValue` (the initial value for the store when no stored value exists).

details:
This interface is part of a synchronization system that connects Svelte stores with persistent storage. It provides the necessary configuration parameters for the `synced` function to create a store that automatically persists its value to the specified storage provider. The generic type parameter `T` allows for type-safe storage of any data type.

related: StorageProvider

import/access examples:
import type { SyncedConfig } from '@welshman/store';
import type { SyncedConfig } from '@welshman/store/synced';


=========================
workspace: packages/store
file: packages/store/src/synced.ts
lines: 40:46
id: e1ebaa7b29daac3a86d36abc0de34d8fa55c7430ff75bc12fa2a9ea280ef782d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/store/src/synced.ts#L40

declaration:
synced = <T>({key, storage, defaultValue}: SyncedConfig<T>) => {
  const store = writable<T>(defaultValue) as Synced<T>

  store.ready = sync({key, store, storage})

  return store
}

summary:
Creates a synchronized Svelte store that automatically persists its value to a storage provider. The function takes a configuration object with a key for storage identification, a storage provider implementing the StorageProvider interface, and a default value for the store. Returns a Writable store enhanced with a 'ready' Promise that resolves when initial synchronization is complete.

details:
Implementation creates a new Svelte writable store with the provided default value and casts it to the Synced<T> type. It then adds a 'ready' property to the store, which is assigned the Promise returned by the sync function. The sync function handles loading the initial value from storage and setting up a subscription to persist changes.

The function leverages:
1. Svelte's writable store for reactivity
2. The sync function for bidirectional synchronization between the store and storage
3. Type casting to add the 'ready' property to the standard Writable interface

The returned store maintains the standard Writable interface while adding the ability to wait for initial synchronization via the ready Promise.

related: SyncedConfig

import/access examples:
import { synced } from '@welshman/store';
import { synced } from '@welshman/store/synced';


=========================
workspace: packages/store
file: packages/store/src/throttle.ts
lines: 4:12
id: b2a5afd9a00d2acb763bf79f64091f044e8b5ded8a9056ae850deb5fca7d22d9
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/store/src/throttle.ts#L4

declaration:
throttled = <T, S extends Readable<T>>(delay: number, store: S) => {
  if (delay) {
    const {subscribe} = store

    store = {...store, subscribe: (f: Subscriber<T>) => subscribe(throttle(delay, f))}
  }

  return store
}

summary:
A function that wraps a Svelte store to throttle its updates. It takes a delay in milliseconds and a Svelte readable store, then returns a new store that throttles subscription updates according to the specified delay. If delay is falsy (0, null, etc.), the original store is returned unchanged.

details:
The implementation works by:
1. Checking if a delay value is provided (if not, it returns the original store unchanged)
2. Destructuring the subscribe method from the original store
3. Creating a new store object by spreading the original store properties
4. Overriding the subscribe method to wrap subscriber functions with the throttle utility from @welshman/lib
5. The throttled subscriber ensures that notifications to subscribers are limited according to the specified delay

import/access examples:
import { throttled } from '@welshman/store';
import { throttled } from '@welshman/store/throttle';


=========================
workspace: packages/store
file: packages/store/src/custom.ts
lines: 5:5
id: da67dc954f079c05e6363b459abba9e514b489920b06d091da1a9630a658c94d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/store/src/custom.ts#L5

declaration:
type Start<T> = (set: Subscriber<T>) => Unsubscriber

summary:
A type alias `Start<T>` represents a function that initiates a store subscription process. It takes a subscriber function that accepts values of type T and returns an unsubscriber function that can be called to stop the subscription.

details:
This type alias defines the signature for the start function used in custom stores. It's a generic type that works with any data type T. The function takes a setter function (Subscriber<T>) as its parameter, which will be called whenever the store value changes. The Start function returns an Unsubscriber, which is a function that can be called to clean up and stop the subscription process.

=========================
workspace: packages/store
file: packages/store/src/custom.ts
lines: 7:10
id: 2ad3d22678b5f46fce1ef12335b14fe15db8ed4c94c01e1a742bb93c4c426b4d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/store/src/custom.ts#L7

declaration:
export type CustomStoreOpts<T> = {
  throttle?: number
  onUpdate?: (x: T) => void
}

summary:
A type definition for options that can be passed to a custom store. It includes optional parameters for throttling updates and a callback function that runs when the store value is updated.

details:
This type alias defines a configuration object with two optional properties:
1. `throttle`: A number that specifies the throttle delay in milliseconds for subscribers
2. `onUpdate`: A callback function that receives the updated value whenever the store value changes

import/access examples:
import type { CustomStoreOpts } from '@welshman/store';
import type { CustomStoreOpts } from '@welshman/store/custom';


=========================
workspace: packages/store
file: packages/store/src/custom.ts
lines: 12:65
id: 5be92e4b9d401fb7197a159766b9fc9e9bd7faa8d581930415b425fcd2f4d2f5
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/store/src/custom.ts#L12

declaration:
custom = <T>(
  start: Start<T>,
  opts: CustomStoreOpts<T> = {},
): WritableWithGetter<T> => {
  const subs: Subscriber<T>[] = []

  let value: T
  let stop: () => void

  const set = (newValue: T) => {
    for (const sub of subs) {
      sub(newValue)
    }

    value = newValue
  }

  return {
    get: () => value,
    set: (newValue: T) => {
      set(newValue)
      opts.onUpdate?.(newValue)
    },
    update: (f: (value: T) => T) => {
      const newValue = f(value)

      set(newValue)
      opts.onUpdate?.(newValue)
    },
    subscribe: (sub: Subscriber<T>) => {
      if (opts.throttle) {
        sub = throttle(opts.throttle, sub)
      }

      if (subs.length === 0) {
        stop = start(set)
      }

      subs.push(sub)
      sub(value)

      return () => {
        subs.splice(
          subs.findIndex(s => s === sub),
          1,
        )

        if (subs.length === 0) {
          stop()
        }
      }
    },
  }
}

summary:
Creates a custom writable store with getter functionality. The function takes a start function that initializes the store and optional configuration options. Returns a store object with get, set, update, and subscribe methods. The store supports throttling updates and executing a callback on value changes.

details:
Implementation creates a custom Svelte-compatible store with the following features:

1. Maintains an array of subscribers and the current value
2. Implements a private set function that notifies all subscribers and updates the internal value
3. Returns an object with four methods:
   - get: Returns the current value without subscription
   - set: Updates the value and triggers the optional onUpdate callback
   - update: Applies a transformation function to the current value, then updates and triggers onUpdate
   - subscribe: Registers a subscriber with optional throttling support

The subscribe method handles lifecycle management by:
- Applying throttling to the subscriber if configured
- Starting the store when first subscriber is added
- Notifying the subscriber of the current value immediately
- Returning an unsubscribe function that removes the subscriber and stops the store when no subscribers remain

related: Start,CustomStoreOpts

import/access examples:
import { custom } from '@welshman/store';
import { custom } from '@welshman/store/custom';


=========================
workspace: packages/store
file: packages/store/src/repository.ts
lines: 7:13
id: ea3d56dc5dd935089c3b1685c200d2c8e35ea7e3b179d8ab41046c67be272e73
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/store/src/repository.ts#L7

declaration:
export type DeriveEventsMappedOptions<T> = {
  filters: Filter[]
  eventToItem: (event: TrustedEvent) => undefined | T | T[] | Promise<undefined | T | T[]>
  itemToEvent: (item: T) => TrustedEvent
  throttle?: number
  includeDeleted?: boolean
}

summary:
A generic type that defines options for the `deriveEventsMapped` function. It specifies how to transform events from a repository into custom items and back. The type includes required parameters for filtering events, mapping between events and items, and optional settings for throttling and handling deleted events.

details:
This type defines the configuration interface for the `deriveEventsMapped` function with the following properties:
1. `filters`: An array of Filter objects that determine which events to include
2. `eventToItem`: A function that converts a TrustedEvent to a custom type T, multiple items, or a Promise
3. `itemToEvent`: A function that converts an item of type T back to a TrustedEvent
4. `throttle`: Optional number to control update frequency
5. `includeDeleted`: Optional boolean to determine if deleted events should be included

import/access examples:
import type { DeriveEventsMappedOptions } from '@welshman/store';
import type { DeriveEventsMappedOptions } from '@welshman/store/repository';


=========================
workspace: packages/store
file: packages/store/src/repository.ts
lines: 15:121
id: 202b7ae6cf281d4ab716a1f18118ca11a91ab4b20ed9290450b3c868aa89f6be
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/store/src/repository.ts#L15

declaration:
deriveEventsMapped = <T>(
  repository: Repository,
  {
    filters,
    eventToItem,
    itemToEvent,
    throttle = 0,
    includeDeleted = false,
  }: DeriveEventsMappedOptions<T>,
) =>
  custom<T[]>(
    setter => {
      let data: T[] = []
      const deferred = new Set()

      const defer = (event: TrustedEvent, promise: Promise<undefined | T | T[]>) => {
        deferred.add(event.id)

        void promise.then(items => {
          if (deferred.has(event.id)) {
            deferred.delete(event.id)

            for (const item of removeNil(ensurePlural(items))) {
              data.push(item)
            }

            setter(sortBy(item => -itemToEvent(item).created_at, data))
          }
        })
      }

      for (const event of repository.query(filters, {includeDeleted})) {
        const items = eventToItem(event)

        if (!items) {
          continue
        }

        if (items instanceof Promise) {
          defer(event, items)
        } else {
          for (const item of removeNil(ensurePlural(items))) {
            data.push(item)
          }
        }
      }

      setter(sortBy(item => -itemToEvent(item).created_at, data))

      const onUpdate = batch(300, (updates: {added: TrustedEvent[]; removed: Set<string>}[]) => {
        const removed = new Set()
        const added = new Map()

        // Apply updates in order
        for (const update of updates) {
          for (const event of update.added.values()) {
            added.set(event.id, event)
            removed.delete(event.id)
          }

          for (const id of update.removed) {
            removed.add(id)
            added.delete(id)
            deferred.delete(id)
          }
        }

        let dirty = false
        for (const event of added.values()) {
          if (matchFilters(filters, event)) {
            const items = eventToItem(event)

            if (items instanceof Promise) {
              defer(event, items)
            } else if (items) {
              dirty = true

              for (const item of removeNil(ensurePlural(items))) {
                data.push(item as T)
              }
            }
          }
        }

        if (!includeDeleted && removed.size > 0) {
          const [deleted, ok] = partition(
            (item: T) => getIdAndAddress(itemToEvent(item)).some((id: string) => removed.has(id)),
            data,
          )

          if (deleted.length > 0) {
            dirty = true
            data = ok
          }
        }

        if (dirty) {
          setter(sortBy(item => -itemToEvent(item).created_at, data))
        }
      })

      repository.on("update", onUpdate)

      return () => repository.off("update", onUpdate)
    },
    {throttle},
  )

summary:
Creates a reactive store that maps repository events to custom items. It takes a repository and options including filters, mapping functions, throttle time, and whether to include deleted events. The function returns a custom store containing an array of mapped items, sorted by creation time. The store automatically updates when the repository changes, handling both synchronous and asynchronous item mapping.

details:
Implementation works in several stages:
1. Creates a custom store with a setup function that initializes data structures and returns a cleanup function
2. Initially populates data by querying the repository with provided filters
3. Handles both synchronous and asynchronous event-to-item mapping via the defer function
4. Sets up a batched update handler that processes repository changes:
   - Tracks added and removed events
   - Applies filters to new events and maps them to items
   - Removes items corresponding to deleted events (unless includeDeleted is true)
   - Only triggers store updates when data actually changes
5. Sorts items by creation time (newest first) before each update
6. Properly cleans up event listeners when the store is destroyed

The implementation efficiently handles promise-based mapping by tracking deferred operations and ensuring updates are properly applied even when promises resolve out of order.

related: __function,custom,DeriveEventsMappedOptions

import/access examples:
import { deriveEventsMapped } from '@welshman/store';
import { deriveEventsMapped } from '@welshman/store/repository';


=========================
workspace: packages/store
file: packages/store/src/repository.ts
lines: 123:126
id: a9f86f3392c7430dfa16faaa5da27db8cb52c4b92a2ec0229cbf2e5fb68e3665
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/store/src/repository.ts#L123

declaration:
export type DeriveEventsOptions<T> = Omit<
  DeriveEventsMappedOptions<T>,
  "itemToEvent" | "eventToItem"
>

summary:
A type alias that defines options for the `deriveEvents` function. It's a generic type that omits the 'itemToEvent' and 'eventToItem' properties from the `DeriveEventsMappedOptions<T>` type. This type is used to configure how events are derived from a repository, including filtering, throttling, and handling of deleted events.

details:
This type alias is a simplified version of `DeriveEventsMappedOptions<T>` that removes the mapping functions since `deriveEvents` uses identity functions for those mappings. The resulting type includes:
1. `filters`: Array of Filter objects to determine which events to include
2. `throttle?`: Optional number to control update frequency
3. `includeDeleted?`: Optional boolean to determine if deleted events should be included

It's used as the parameter type for the `deriveEvents` function which is a simpler version of `deriveEventsMapped` where events are used directly without transformation.

related: DeriveEventsMappedOptions

import/access examples:
import type { DeriveEventsOptions } from '@welshman/store';
import type { DeriveEventsOptions } from '@welshman/store/repository';


=========================
workspace: packages/store
file: packages/store/src/repository.ts
lines: 128:133
id: 505872bdcacf8a4890e80712ff2000aef5237471f70189f7450b9cd1d425e676
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/store/src/repository.ts#L128

declaration:
deriveEvents = <T>(repository: Repository, opts: DeriveEventsOptions<T>) =>
  deriveEventsMapped<TrustedEvent>(repository, {
    ...opts,
    eventToItem: identity,
    itemToEvent: identity,
  })

summary:
A function that creates a derived store from a repository of events. It takes a Repository instance and options for filtering and handling events. The function returns a store that contains an array of TrustedEvent objects that match the provided filters. The store automatically updates when the repository changes.

details:
This function is a simplified wrapper around `deriveEventsMapped` that specifically works with TrustedEvent objects directly without transformation. It:

1. Takes a repository and options object (which can include filters, throttle settings, and whether to include deleted events)
2. Calls `deriveEventsMapped` with the same repository and options, but adds default identity functions for:
   - `eventToItem`: returns the event itself (identity function)
   - `itemToEvent`: returns the item itself (identity function)

This creates a reactive store that will contain all events matching the specified filters, updating automatically when the repository changes.

related: __function,deriveEventsMapped,DeriveEventsOptions

import/access examples:
import { deriveEvents } from '@welshman/store';
import { deriveEvents } from '@welshman/store/repository';


=========================
workspace: packages/store
file: packages/store/src/repository.ts
lines: 135:142
id: 77e250813aa22aae479531fda0863260b81b87ba07bc7201a47fc077432e7beb
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/store/src/repository.ts#L135

declaration:
deriveEvent = (repository: Repository, idOrAddress: string) =>
  derived(
    deriveEvents(repository, {
      filters: getIdFilters([idOrAddress]),
      includeDeleted: true,
    }),
    first,
  )

summary:
A function that creates a derived store for a single event from a repository. It takes a repository instance and an event ID or address, and returns a Svelte store that contains the event matching the provided identifier. The store automatically updates when the repository changes.

details:
The implementation uses the `derived` function from Svelte's store API to create a reactive store. It works by:

1. First calling `deriveEvents` to create a store of all events matching the ID or address filter
2. Then applying the `first` function to extract just the first matching event from the array

The function uses `getIdFilters` to create appropriate filters from the provided ID or address, and sets `includeDeleted: true` to ensure that even deleted events are included in the results.

related: derived

import/access examples:
import { deriveEvent } from '@welshman/store';
import { deriveEvent } from '@welshman/store/repository';


=========================
workspace: packages/store
file: packages/store/src/repository.ts
lines: 144:153
id: cb742f09c2724780bf96002dd83cca19f952b54ff2dfbb7a9f988ce36c5e5641
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/store/src/repository.ts#L144

declaration:
deriveIsDeleted = (repository: Repository, event: TrustedEvent) =>
  custom<boolean>(setter => {
    setter(repository.isDeleted(event))

    const onUpdate = batch(300, () => setter(repository.isDeleted(event)))

    repository.on("update", onUpdate)

    return () => repository.off("update", onUpdate)
  })

summary:
A function that creates a reactive store tracking whether a specific event is marked as deleted in a repository. It takes a Repository instance and a TrustedEvent as parameters and returns a custom store that holds a boolean value indicating the deletion status of the event. The store automatically updates when the repository changes.

details:
Implementation details:
1. Uses the `custom` store creator to create a reactive boolean store
2. Initially sets the store value by checking if the event is deleted using `repository.isDeleted(event)`
3. Creates a batched update handler that rechecks the deletion status when repository updates occur
4. Sets up an event listener for the repository's "update" event using the batched handler
5. Returns a cleanup function that removes the event listener when the store is destroyed
6. The batched handler uses a 300ms throttle to prevent excessive updates

related: __function,custom

import/access examples:
import { deriveIsDeleted } from '@welshman/store';
import { deriveIsDeleted } from '@welshman/store/repository';


=========================
workspace: packages/store
file: packages/store/src/repository.ts
lines: 155:164
id: f1f4d0741f96dd3d5ebab786efafb75fac96f4e22785a65b30b1641ec8d2bc6b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/store/src/repository.ts#L155

declaration:
deriveIsDeletedByAddress = (repository: Repository, event: TrustedEvent) =>
  custom<boolean>(setter => {
    setter(repository.isDeletedByAddress(event))

    const onUpdate = batch(300, () => setter(repository.isDeletedByAddress(event)))

    repository.on("update", onUpdate)

    return () => repository.off("update", onUpdate)
  })

summary:
A function that creates a reactive store tracking whether an event is deleted by address in a repository. It takes a Repository instance and a TrustedEvent, and returns a custom store that updates whenever the repository changes. The store's value is a boolean indicating if the event is deleted by address.

details:
Implementation creates a custom reactive store that:
1. Initially sets the store value to the result of repository.isDeletedByAddress(event)
2. Sets up an event listener for repository 'update' events using a batched callback (300ms)
3. When updates occur, rechecks if the event is deleted by address and updates the store value
4. Returns a cleanup function that removes the event listener when the store is destroyed

The implementation uses the 'custom' store creator and the 'batch' utility to throttle updates for performance.

related: __function,custom

import/access examples:
import { deriveIsDeletedByAddress } from '@welshman/store';
import { deriveIsDeletedByAddress } from '@welshman/store/repository';


=========================
workspace: packages/store
file: packages/store/__tests__/index.test.ts
lines: 18:29
id: 57aa64a235b8b7ccfec832dc8bac49fe45a039f1e6983bbd2659201e5ae5dd10
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/store/__tests__/index.test.ts#L18

declaration:
localStorageMock = (() => {
  let store: Record<string, string> = {}
  return {
    getItem: (key: string) => store[key] || null,
    setItem: (key: string, value: string) => {
      store[key] = value
    },
    clear: () => {
      store = {}
    },
  }
})()

summary:
A mock implementation of the localStorage API for testing purposes. It provides three methods: `getItem` to retrieve stored values, `setItem` to store values, and `clear` to reset the storage. The mock maintains an in-memory store object to simulate localStorage behavior.

details:
The implementation uses an Immediately Invoked Function Expression (IIFE) that:
1. Creates a private `store` variable as a Record<string, string> to hold key-value pairs
2. Returns an object with three methods that mimic the localStorage API:
   - `getItem`: Returns the value for a given key or null if not found
   - `setItem`: Stores a key-value pair in the in-memory store
   - `clear`: Resets the store to an empty object

This mock is used in tests to avoid actual browser localStorage interactions and to provide a controlled environment for testing storage-related functionality.

related: __function

=========================
type: file
workspace: packages/store
path: packages/store/__tests__/index.test.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/store/__tests__/index.test.ts
summary: This test file validates various Svelte store utilities exported from the main package. It tests functionality for synced stores (with localStorage), getter utilities, throttled stores, custom stores, and event-related stores that interact with a repository. The tests cover synchronization with storage, throttling updates, custom store creation, and deriving stores from events with mapping capabilities.

details: The implementation tests several store utilities:

1. Setup includes mocking localStorage and configuring Vitest timers.
2. Tests for `synced` verify localStorage integration, saving/loading values.
3. Tests for `getter` and `withGetter` confirm they correctly access store values.
4. `throttled` tests validate that updates are properly delayed and batched.
5. `custom` store tests verify proper update handling and value retrieval.
6. Event-related store tests mock a Repository and test:
   - `deriveEvents` for creating stores from repository events
   - `deriveEventsMapped` for transforming events with mapping functions (including async mapping)
   - `deriveIsDeleted` for tracking deletion status of events

The tests use vi.runAllTimersAsync() to handle async operations and verify correct behavior through expect assertions.

=========================
type: dir
workspace: packages/store
path: packages/store/__tests__/
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/store/__tests__/
summary: The __tests__ directory contains test files for Svelte store utilities. The tests validate functionality for synchronized stores with localStorage persistence, getter utilities for accessing store values, throttled stores for batched updates, custom store creation, and event-related stores that interact with repositories. These tests ensure the store utilities work correctly with proper value handling, timing, and integration with external systems.

=========================
type: file
workspace: packages/store
path: packages/store/src/collection.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/store/src/collection.ts
summary: This file provides utilities for managing collections of data with caching and freshness tracking. It exports functions like `makeCachedLoader` and `collection` that help create systems for loading, caching, and subscribing to data items. The module handles stale data detection, throttled loading with exponential backoff, and provides a way to derive Svelte stores from collection items.

details: The implementation revolves around several key components:

1. Freshness tracking system that maintains timestamps for when data was last updated, with both immediate and throttled update methods.
2. `makeCachedLoader` function that creates a loader with caching capabilities, handling:
   - Stale data detection
   - Pending request tracking to avoid duplicate loads
   - Exponential backoff for failed requests
   - Subscriber notifications
3. `collection` function that combines the loader with Svelte stores to create a complete data management system with:
   - Indexed access to collection items
   - Derived stores for individual items
   - Subscription capabilities
   - Loading functionality

The code uses Svelte's store system extensively and incorporates utility functions from a custom library (@welshman/lib).

=========================
type: file
workspace: packages/store
path: packages/store/src/custom.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/store/src/custom.ts
summary: The `custom.ts` file exports a function `custom` that creates a custom Svelte store with additional features. It returns a `WritableWithGetter<T>` which extends Svelte's writable store with a getter method. The store can be configured with options like throttling updates and executing callbacks on value changes.

details: The implementation creates a custom Svelte store with these key aspects:

1. It maintains an array of subscribers and the current value internally
2. The `set` function updates the value and notifies all subscribers
3. The returned store object includes:
   - `get()`: Returns the current value without subscription
   - `set()`: Updates the value and calls the optional onUpdate callback
   - `update()`: Applies a function to transform the current value
   - `subscribe()`: Adds subscribers with optional throttling support
4. The store handles lifecycle management by starting when the first subscriber is added and stopping when the last one unsubscribes
5. Throttling is applied to subscribers when the throttle option is provided

=========================
type: file
workspace: packages/store
path: packages/store/src/getter.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/store/src/getter.ts
summary: This file exports utility functions for Svelte stores. The `getter` function creates a closure that returns the current value of a Readable store. The `withGetter` function enhances Svelte stores by adding a `get` method to access the current value without subscribing. It works with both Readable and Writable stores, returning appropriately typed enhanced store objects.

details: The implementation uses a simple subscription pattern to track store values. The `getter` function subscribes to the provided store and keeps the value updated in a closure variable, then returns a function that can access this value. The `withGetter` function is overloaded to handle both Readable and Writable stores, using the spread operator to preserve the original store's methods while adding the getter function. Type definitions `WritableWithGetter<T>` and `ReadableWithGetter<T>` extend the original store types with the additional `get` method.

=========================
type: file
workspace: packages/store
path: packages/store/src/repository.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/store/src/repository.ts
summary: This file exports utilities for deriving Svelte stores from a Repository of events. The main functions include `deriveEventsMapped` for transforming events into custom items, `deriveEvents` for working with raw events, `deriveEvent` for retrieving a single event by ID or address, and `deriveIsDeleted`/`deriveIsDeletedByAddress` for tracking deletion status of events.

details: The implementation centers around the `custom` store creator (imported from './custom.js') to create reactive stores that respond to repository updates.

The core function `deriveEventsMapped` creates a store that:
1. Initializes with events matching provided filters
2. Transforms events to custom items using the provided mapping function
3. Handles both synchronous and asynchronous transformations via promises
4. Maintains sorted data based on event timestamps
5. Efficiently processes repository updates with batching (300ms default)
6. Tracks added/removed events and updates the derived data accordingly
7. Properly cleans up event listeners when the store is destroyed

The other functions are simpler wrappers around this core functionality, with `deriveEvents` using identity functions for mapping, `deriveEvent` focusing on a single event by ID, and the deletion-tracking functions creating simple boolean stores.

=========================
type: dir
workspace: packages/store
path: packages/store/src/
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/store/src/
summary: This directory provides a collection of utilities for enhancing Svelte stores with additional functionality. The main exports include tools for creating reactive data collections with caching (`collection`), custom stores with getter methods (`custom`, `withGetter`), synchronization with storage providers (`synced`), throttled store updates (`throttled`), and utilities for deriving stores from repositories of events. Together, these utilities extend Svelte's reactive store system with features for data management, caching, persistence, and performance optimization while maintaining the standard Svelte store contract.

=========================
type: file
workspace: packages/store
path: packages/store/src/synced.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/store/src/synced.ts
summary: This module provides utilities for synchronizing Svelte stores with persistent storage. It exports interfaces for storage providers, configuration types, and functions to create synchronized stores. The `localStorageProvider` implementation uses local storage, while `sync` and `synced` functions handle the synchronization logic between stores and storage.

details: The implementation uses Svelte's writable stores as the foundation. The main components are:

1. `StorageProvider` interface defining the contract for storage implementations with get/set methods
2. `localStorageProvider` implementation using helper functions from '@welshman/lib'
3. `sync` function that handles bidirectional synchronization by:
   - Loading initial value from storage to the store
   - Setting up a subscription to persist store changes to storage
4. `synced` function that creates a new writable store with synchronization capabilities and adds a `ready` Promise to track initialization

The code extends Svelte's Writable type with additional functionality while maintaining a clean API.

=========================
type: file
workspace: packages/store
path: packages/store/src/throttle.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/store/src/throttle.ts
summary: The file exports a `throttled` function that wraps a Svelte store with throttling functionality. It takes a delay in milliseconds and a Svelte readable store, then returns a new store with the same interface but with its subscribe method throttled by the specified delay.

details: The implementation is straightforward:
1. It imports the necessary types from Svelte's store module and a throttle utility from '@welshman/lib'
2. If a positive delay is provided, it extracts the subscribe method from the original store
3. It then creates a new store object by spreading the original store properties and overriding the subscribe method with a throttled version
4. The throttling is applied to the subscriber function passed to subscribe, not to the store updates themselves
5. If no delay (or zero) is provided, it returns the original store unchanged

=========================
type: dir
workspace: packages/store
path: packages/store/
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/store/
summary: This package provides enhanced utilities for Svelte stores, extending the standard store functionality with features for data management, persistence, and performance optimization. Key exports include tools for reactive data collections with caching, custom stores with getter methods, synchronization with localStorage, throttled store updates for batching, and utilities for deriving stores from event repositories. The package maintains compatibility with Svelte's store contract while adding powerful capabilities for more complex state management scenarios.

=========================
type: file
workspace: packages/util
file: packages/util/package.json
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/package.json
include: always
{
  "name": "@welshman/util",
  "version": "0.4.6",
  "author": "hodlbod",
  "license": "MIT",
  "description": "A collection of nostr-related utilities.",
  "publishConfig": {
    "access": "public"
  },
  "type": "module",
  "main": "dist/util/src/index.js",
  "types": "dist/util/src/index.d.ts",
  "files": [
    "dist"
  ],
  "scripts": {
    "build": "pnpm run clean && pnpm run compile --force",
    "clean": "rimraf ./dist",
    "compile": "tsc -b tsconfig.build.json",
    "prepublishOnly": "pnpm run build"
  },
  "dependencies": {
    "@types/ws": "^8.5.13",
    "@welshman/lib": "workspace:*",
    "js-base64": "^3.7.7",
    "nostr-tools": "^2.14.2",
    "nostr-wasm": "^0.1.0"
  },
  "devDependencies": {
    "rimraf": "~6.0.0",
    "typescript": "~5.8.0"
  }
}


=========================
type: file
workspace: packages/util
file: packages/util/tsconfig.json
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/tsconfig.json
include: always
{
  "extends": "../../tsconfig.json"
}


=========================
workspace: packages/util
file: packages/util/src/Address.ts
lines: 4:8
id: ded8ba1b9f1bf2208533e1e9c3037136b5df22072cc2aaabe4c65845b29d1f30
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Address.ts#L4

declaration:
type AddressableEvent = {
  kind: number
  pubkey: string
  tags: string[][]
}

summary:
A type alias representing an event that can be addressed in the Nostr protocol. It includes essential properties: `kind` (a number), `pubkey` (a string), and `tags` (a two-dimensional string array).

details:
This type is defined locally to avoid circular dependencies as noted in the comment above it. It captures the minimal structure needed for an event to be addressable in the Nostr protocol context, containing only the three properties necessary for addressing functionality: kind, pubkey, and tags. The tags property is particularly important as it's used in the Address.fromEvent method to extract the identifier from the 'd' tag.

=========================
workspace: packages/util
file: packages/util/src/Address.ts
lines: 10:55
id: 6354f40364cd59702751d68adda3efe5ef9af2b887c31665acecf9b3f6fb610e
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Address.ts#L10

declaration:
export class Address{
  constructor(
      readonly kind: number,
      readonly pubkey: string,
      readonly identifier: string,
      readonly relays: string[] = [],
    );
  static isAddress(address: string);
  static from(address: string, relays: string[] = []);
  static fromNaddr(naddr: string);
  static fromEvent(event: AddressableEvent, relays: string[] = []);
  toString: () => string;
  toNaddr: () => `naddr1${string}`;
}

summary:
The `Address` class represents a Nostr address with kind, pubkey, identifier, and optional relays. It provides methods to create addresses from strings, naddr format, or events, as well as methods to convert addresses to string or naddr format. The class helps standardize the handling of Nostr addressable resources.

details:
The implementation details include:

1. The class stores four readonly properties: kind (number), pubkey (string), identifier (string), and relays (string array).

2. Static methods for address creation:
   - `isAddress`: Validates if a string matches the address format using regex
   - `from`: Parses a string address into its components using regex
   - `fromNaddr`: Decodes a naddr (NIP-19 encoded address) using nostr-tools
   - `fromEvent`: Extracts address components from a Nostr event

3. Instance methods:
   - `toString`: Returns the canonical string representation as `kind:pubkey:identifier`
   - `toNaddr`: Encodes the address to naddr format using nostr-tools

4. The class works with a locally defined `AddressableEvent` type to avoid circular dependencies.

code:
export class Address {
  constructor(
    readonly kind: number,
    readonly pubkey: string,
    readonly identifier: string,
    readonly relays: string[] = [],
  ) {}

  static isAddress(address: string) {
    return Boolean(address.match(/^\d+:\w+:.*$/))
  }

  static from(address: string, relays: string[] = []) {
    const [kind, pubkey, identifier = ""] = address.match(/^(\d+):(\w+):(.*)$/)!.slice(1)

    return new Address(parseInt(kind), pubkey, identifier, relays)
  }

  static fromNaddr(naddr: string) {
    let decoded: any

    try {
      decoded = decode(naddr)
    } catch (e) {
      // pass
    }

    if (decoded?.type !== "naddr") {
      throw new Error(`Invalid naddr ${naddr}`)
    }

    const {kind, pubkey, identifier, relays} = decoded.data

    return new Address(kind, pubkey, identifier, relays)
  }

  static fromEvent(event: AddressableEvent, relays: string[] = []) {
    const identifier = event.tags.find(t => t[0] === "d")?.[1] || ""

    return new Address(event.kind, event.pubkey, identifier, relays)
  }

  toString = () => `${this.kind}:${this.pubkey}:${this.identifier}`

  toNaddr = () => naddrEncode(this)
}

import/access examples:
import { Address } from '@welshman/util';
import { Address } from '@welshman/util/Address';


=========================
workspace: packages/util
file: packages/util/src/Address.ts
lines: 59:59
id: 161c9e99b88a57fdf48e3a2abbf42279ada8677103b0385cbee95e40c8f6fa36
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Address.ts#L59

declaration:
getAddress = (e: AddressableEvent) => Address.fromEvent(e).toString()

summary:
A utility function that converts an AddressableEvent object into a string representation of its address. The function takes an event with kind, pubkey, and tags properties, creates an Address instance from it using Address.fromEvent(), and then returns the string representation of that address.

details:
The implementation is straightforward:
1. It takes an AddressableEvent parameter 'e'
2. It calls Address.fromEvent(e) to create an Address instance from the event
3. It immediately calls toString() on that instance to convert it to a string in the format 'kind:pubkey:identifier'
4. The function is exported and available for external use

related: __function,fromEvent,Address,toString,AddressableEvent

import/access examples:
import { getAddress } from '@welshman/util';
import { getAddress } from '@welshman/util/Address';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 3:8
id: c1942198eb37b35d842cc9fbb8a86b72ca5369f888cfb12533bb77390b4db572
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L3

declaration:
export function isRegularKind(kind: number): boolean

summary:
Determines if a given event kind is a 'regular' kind, which means it's expected to be stored by relays. Regular kinds include specific numbers (1, 2, 4, 5, 6, 7, 8, 16, 40, 41, 42, 43, 44) and any number in the range 1000-9999.

@param kind - The numeric event kind to check
@returns boolean - True if the kind is a regular kind, false otherwise

details:
The implementation is straightforward, using a simple condition that checks:
1. If the kind is in the range 1000-9999 (using a comparison: 1000 <= kind && kind < 10000)
2. OR if the kind is in a specific list of predefined regular kinds [1, 2, 4, 5, 6, 7, 8, 16, 40, 41, 42, 43, 44]

The function returns true if either condition is met, indicating the event is a regular kind.

code:
export function isRegularKind(kind: number): boolean {
  return (
    (1000 <= kind && kind < 10000) || [1, 2, 4, 5, 6, 7, 8, 16, 40, 41, 42, 43, 44].includes(kind)
  )
}

import/access examples:
import { isRegularKind } from '@welshman/util';
import { isRegularKind } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 10:13
id: 194248856f66f608f4564d75e5caab92f4842a7356589191c4187301c085272f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L10

declaration:
export function isPlainReplaceableKind(kind: number): boolean

summary:
Determines if a given event kind is a plain replaceable kind. Plain replaceable events are those where, for each combination of `pubkey` and `kind`, only the latest event should be stored by relays, with older versions being discarded. This includes kinds 0 and 3, as well as kinds in the range 10000-19999.

@param kind - The numeric event kind to check
@returns boolean - True if the kind is plain replaceable, false otherwise

details:
The implementation is straightforward, using a simple conditional check that returns true if:
1. The kind is either 0 or 3 (which are specific plain replaceable kinds), or
2. The kind falls within the range 10000 to 19999 (inclusive of 10000, exclusive of 20000)

The function uses JavaScript's includes() method for the specific kinds and a range check for the numeric interval.

code:
export function isPlainReplaceableKind(kind: number): boolean {
  return [0, 3].includes(kind) || (10000 <= kind && kind < 20000)
}

import/access examples:
import { isPlainReplaceableKind } from '@welshman/util';
import { isPlainReplaceableKind } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 15:18
id: 4520df01c290c5254b90eae3ad270aa3e44d9376258fa91c578f066ba211a1d8
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L15

declaration:
export function isEphemeralKind(kind: number): boolean

summary:
Determines if a given event kind is ephemeral. Ephemeral events are not expected to be stored by relays. Takes a numeric kind parameter and returns true if the kind is in the range 20000-29999, false otherwise.

details:
The implementation is straightforward, using a simple range check to determine if the provided kind number falls within the ephemeral event range (20000 <= kind < 30000). This function is part of a set of utilities for categorizing Nostr event kinds based on their expected handling by relays.

code:
export function isEphemeralKind(kind: number): boolean {
  return 20000 <= kind && kind < 30000
}

import/access examples:
import { isEphemeralKind } from '@welshman/util';
import { isEphemeralKind } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 20:23
id: 64abb946b879a9117c633927fa3792cf62778c65136d62acbe6688fef7b5e699
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L20

declaration:
export function isParameterizedReplaceableKind(kind: number): boolean

summary:
Determines if a given event kind is a parameterized replaceable event. Parameterized replaceable events are those where, for each combination of `pubkey`, `kind`, and the `d` tag, only the latest event is expected to be stored by relays, with older versions being discarded. These events have kind numbers in the range 30000-39999.

details:
The implementation is straightforward - it checks if the provided kind number falls within the range of 30000 (inclusive) to 40000 (exclusive) using a simple comparison expression. This follows the Nostr protocol specification where event kinds are categorized into specific ranges based on their behavior.

code:
export function isParameterizedReplaceableKind(kind: number): boolean {
  return 30000 <= kind && kind < 40000
}

import/access examples:
import { isParameterizedReplaceableKind } from '@welshman/util';
import { isParameterizedReplaceableKind } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 25:26
id: 16f7fb4fb0173b2f3b5443748b05bbe0e74670730c591cf9eedf0007e6d1d8d9
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L25

declaration:
isReplaceableKind = (kind: number) =>
  isPlainReplaceableKind(kind) || isParameterizedReplaceableKind(kind)

summary:
A function that determines if a given event kind is replaceable. It returns true if the kind is either a plain replaceable kind or a parameterized replaceable kind, false otherwise. Replaceable kinds are those where newer events of the same kind (and possibly other parameters) are expected to replace older ones in relay storage.

details:
The implementation combines two other functions:
1. isPlainReplaceableKind - checks if the kind is in the range 10000-19999 or is one of the specific values [0, 3]
2. isParameterizedReplaceableKind - checks if the kind is in the range 30000-39999

The function is implemented as an arrow function that returns the logical OR of these two checks.

related: isPlainReplaceableKind,isParameterizedReplaceableKind

import/access examples:
import { isReplaceableKind } from '@welshman/util';
import { isReplaceableKind } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 28:28
id: cd960d95b615234997bacade706fb8504f1b56daa93a853f80c0c64a25ba0f61
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L28

declaration:
isDVMKind = (kind: number) => between([4999, 7001], kind)

summary:
A function that checks if a given event kind number falls within the range of DVM (Decentralized Virtual Machine) kinds. It returns true if the kind is between 4999 and 7001 (inclusive), false otherwise.

details:
This function uses the imported `between` utility from "@welshman/lib" to check if the provided kind number falls within the DVM range. The implementation is straightforward - it passes an array with the lower and upper bounds [4999, 7001] and the kind number to the `between` function, which determines if the number is within that range (inclusive of both bounds).

related: between

import/access examples:
import { isDVMKind } from '@welshman/util';
import { isDVMKind } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 30:30
id: 368a746a9ec2b0f5941f94401bd0017fde06934ad18f811c15dab51308d04110
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L30

declaration:
PROFILE = 0

summary:
A constant representing the event kind for a user profile in the Nostr protocol. The value is 0, which is a plain replaceable kind, meaning only the latest event of this kind for a given pubkey should be stored by relays.

details:
This constant is part of a collection of event kind identifiers used in the Nostr protocol. It's defined as a plain replaceable kind (as indicated by the `isPlainReplaceableKind` function which includes 0 in its check). Profile events (kind 0) contain metadata about a user such as name, picture, about information, etc.

import/access examples:
import { PROFILE } from '@welshman/util';
import { PROFILE } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 31:31
id: ad009e21bcb7ae318007f13bf414fd53b072affea33af3206e1c698cf610047f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L31

declaration:
NOTE = 1

summary:
A constant representing the Nostr event kind for a standard note (kind 1). In the Nostr protocol, notes are regular events that contain text content posted by users and are expected to be stored by relays.

details:
This is a simple constant definition that maps the semantic name 'NOTE' to its numerical kind value (1) in the Nostr protocol. It's part of a larger collection of constants that define the various event kinds in the Nostr ecosystem. Notes (kind 1) are classified as regular events as indicated by the `isRegularKind` function in the same file, which means they are expected to be permanently stored by relays.

import/access examples:
import { NOTE } from '@welshman/util';
import { NOTE } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 32:32
id: 83d4a889f6801b1e57290ff011d924f3b4e5fdc45ecd1078b1420dc0cc2f4d19
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L32

declaration:
FOLLOWS = 3

summary:
A constant representing the Nostr event kind for 'FOLLOWS' with a value of 3. This is a plain replaceable kind of event, meaning that for each pubkey, only the latest event of this kind should be stored by relays, with older versions being discarded.

details:
This constant is part of a collection of Nostr event kind definitions in the Kinds.ts file. It represents the standard Nostr event kind for user follows/contacts lists. As a replaceable event (kind 3), it typically contains a list of pubkeys in 'p' tags representing the accounts a user follows. The implementation is straightforward - just a named constant export with the value 3.

import/access examples:
import { FOLLOWS } from '@welshman/util';
import { FOLLOWS } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 33:33
id: 44ebad78c5dd1f5b0e8574909fd703d31c319073ffebf0adb522371536c4d6f8
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L33

declaration:
DELETE = 5

summary:
A constant representing the DELETE event kind in the Nostr protocol with a value of 5. This event kind is classified as a regular event, which means it's expected to be stored by relays. DELETE events are typically used to indicate that a user wants to delete previously published events.

details:
This is a simple constant declaration that assigns the numeric value 5 to the DELETE identifier. It's part of a larger collection of event kind constants defined in the Kinds.ts file. According to the implementation in the same file (line 6), DELETE (kind 5) is included in the list of regular event kinds, which means relays are expected to store these events rather than treating them as replaceable or ephemeral.

import/access examples:
import { DELETE } from '@welshman/util';
import { DELETE } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 34:34
id: aed651466e00b761e73a51520a908f9fbe74f306cfa37b71dfffde5e7138af0f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L34

declaration:
REPOST = 6

summary:
A constant representing the Nostr event kind for reposts. In the Nostr protocol, REPOST is defined as kind 6, which is a regular event type that should be stored by relays. Reposts are used to share or rebroadcast another user's note.

details:
This is a simple constant declaration that assigns the numeric value 6 to the exported variable REPOST. It's part of a larger collection of constants that define the various event kinds in the Nostr protocol. This constant is categorized as a regular kind (as opposed to replaceable, parameterized replaceable, or ephemeral) based on the implementation of the isRegularKind function in the same file.

import/access examples:
import { REPOST } from '@welshman/util';
import { REPOST } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 35:35
id: 511fdfdeb69e079099073cceebcc71c037fb90ae5faf35a962e5bb4fa09f7fff
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L35

declaration:
REACTION = 7

summary:
A constant representing the REACTION kind in the Nostr protocol, with a value of 7. This kind is used for events that represent reactions to other events, such as likes or other emoji reactions. It is classified as a regular kind, meaning these events are expected to be stored by relays.

details:
This is a simple constant declaration that maps the semantic name 'REACTION' to its numeric kind value (7) in the Nostr protocol. As part of the regular kinds (as determined by the `isRegularKind` function), reaction events are meant to be permanently stored by relays. This constant is exported from both the Kinds module and the main index file, making it available for external use throughout the application.

import/access examples:
import { REACTION } from '@welshman/util';
import { REACTION } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 36:36
id: 308c3cd140e549353eff050cf2d177ab34ddb772037f9b98cefb25a2405a57eb
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L36

declaration:
BADGE_AWARD = 8

summary:
A constant representing the Nostr event kind for badge awards. The value is 8, which is a regular kind event that is expected to be stored by relays. Badge awards are used to assign badges to users in the Nostr protocol.

details:
This is a simple constant declaration that maps the semantic name `BADGE_AWARD` to the numeric value 8. It's part of a larger collection of constants that define the various event kinds in the Nostr protocol. The constant is exported, making it available for import by other modules. Based on the surrounding code, this falls into the category of regular kinds (as defined by the `isRegularKind` function), which means these events are expected to be permanently stored by relays.

import/access examples:
import { BADGE_AWARD } from '@welshman/util';
import { BADGE_AWARD } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 37:37
id: b0bd2159403c0398e71f7b0b709609b6760d50390c1920853fe224525da43cec
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L37

declaration:
MESSAGE = 9

summary:
A constant representing the Nostr event kind for messages. In the Nostr protocol, kind 9 is used to identify message events.

import/access examples:
import { MESSAGE } from '@welshman/util';
import { MESSAGE } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 38:38
id: 4f84caed62f0bfb139ef85beaf7b2c6684020d3851307640d05d64c0485b4c97
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L38

declaration:
THREAD = 11

summary:
A constant representing the event kind for a thread in the Nostr protocol. The value is 11, which falls within the range of regular kinds (1-10000), meaning these events are expected to be stored by relays.

details:
This is a simple constant declaration that defines the numeric value for thread events in the Nostr protocol. It's part of a larger collection of event kind constants that categorize different types of Nostr events. As a regular kind (between 1-10000), thread events are meant to be persistently stored by relays rather than being ephemeral or replaceable.

import/access examples:
import { THREAD } from '@welshman/util';
import { THREAD } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 39:39
id: 4d65a9267908eb4323f6f5386f9d90f4ab4e2cdb037fc8578bb6f0cdfa2ee85c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L39

declaration:
SEAL = 13

summary:
A constant representing the SEAL event kind in the Nostr protocol with a value of 13. This is a regular event kind, which means it's expected to be stored by relays.

details:
This is a simple constant definition that assigns the numeric value 13 to the SEAL event kind. Based on the context of the file, this falls into the category of regular event kinds (as determined by the `isRegularKind` function), which means these events are expected to be stored persistently by relays rather than being ephemeral or replaceable.

import/access examples:
import { SEAL } from '@welshman/util';
import { SEAL } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 40:40
id: b3d4e1eda10205a984a06480a52cc3595a97b640b27878a04381c0d011db8ba5
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L40

declaration:
DIRECT_MESSAGE = 14

summary:
A constant representing the kind number for direct messages in the Nostr protocol. The value is 14, which is a regular kind event that is expected to be stored by relays.

details:
This constant is part of a larger collection of event kind constants defined in the Kinds.ts file. It represents a direct message event type in the Nostr protocol ecosystem. As a regular kind (between 1-10000 or in the specific list of kinds), direct messages are expected to be stored persistently by relays rather than being ephemeral or replaceable.

import/access examples:
import { DIRECT_MESSAGE } from '@welshman/util';
import { DIRECT_MESSAGE } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 41:41
id: 309e3d3f5891d13caed63889d31620eae8ba48c2ee9a153b505afbe16d9a924e
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L41

declaration:
DIRECT_MESSAGE_FILE = 15

summary:
A constant representing the kind number for direct message files in the Nostr protocol. The value is 15, which indicates a regular kind event that is expected to be stored by relays.

details:
This constant is part of a collection of event kind identifiers used in the Nostr protocol. It belongs to the regular kind category (as defined by the `isRegularKind` function), which means events of this kind are expected to be stored permanently by relays. The constant is exported from the module and likely used throughout the application to identify direct message file events.

import/access examples:
import { DIRECT_MESSAGE_FILE } from '@welshman/util';
import { DIRECT_MESSAGE_FILE } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 42:42
id: 5a071c962ea51fd9f812b6391c02b5c93859d6d3d67dc835697e6767c5751a89
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L42

declaration:
GENERIC_REPOST = 16

summary:
A constant representing the Nostr event kind for generic reposts. In the Nostr protocol, this kind (16) is used to identify events that are reposts of other content without specific formatting requirements.

details:
This is a simple constant declaration that assigns the numeric value 16 to the GENERIC_REPOST identifier. This constant is part of a larger collection of Nostr event kind definitions in the Kinds.ts file. It belongs to the regular kinds category (as defined by isRegularKind function), which means events of this kind are expected to be stored by relays.

import/access examples:
import { GENERIC_REPOST } from '@welshman/util';
import { GENERIC_REPOST } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 43:43
id: b110ea8d155ea0ae337c2f2f37052d4b1c0b34dacec5bf481ab3db5549df6eae
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L43

declaration:
PICTURE_NOTE = 20

summary:
A constant representing the kind number for a picture note event in the Nostr protocol. The value is 20, which falls within the range of regular kinds (1-9999), meaning these events are expected to be stored by relays.

details:
This is a simple constant definition that assigns the numeric value 20 to the PICTURE_NOTE identifier. Based on the surrounding code in the file, this appears to be part of a collection of constants that define various event kinds in the Nostr protocol. The value 20 falls within the range checked by the isRegularKind function, indicating that picture notes are regular events that relays are expected to store.

import/access examples:
import { PICTURE_NOTE } from '@welshman/util';
import { PICTURE_NOTE } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 44:44
id: 06b9545b4b0d07cb8e4ee0d1b44f52c08bc48c9f4c9be57ac249f07029964079
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L44

declaration:
CHANNEL_CREATE = 40

summary:
A constant representing the Nostr event kind for channel creation. In the Nostr protocol, this kind (40) is used to identify events that create a new channel. This is a regular kind event, which means it's expected to be stored by relays.

details:
This constant is part of a comprehensive set of Nostr event kind definitions. It belongs to the regular kind category (as defined by the `isRegularKind` function in the same file), which means events of this kind are expected to be persistently stored by relays. The value 40 is specifically reserved in the Nostr protocol for channel creation events.

import/access examples:
import { CHANNEL_CREATE } from '@welshman/util';
import { CHANNEL_CREATE } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 45:45
id: 535c4b48cbe37dabb4daef1899be193d0d3bc4e53efcdc9d3691567a02d06c66
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L45

declaration:
CHANNEL_UPDATE = 41

summary:
A constant representing the Nostr event kind for channel updates. In the Nostr protocol, kind 41 is used to identify events that update channel information. This is part of a collection of constants defining standardized event kinds in the Nostr ecosystem.

details:
This is a simple constant declaration that assigns the numeric value 41 to the exported variable CHANNEL_UPDATE. It's part of a larger collection of event kind constants that categorize different types of Nostr events. Kind 41 falls within the regular event category (as defined by isRegularKind function), meaning these events are expected to be stored by relays rather than being ephemeral or replaceable.

import/access examples:
import { CHANNEL_UPDATE } from '@welshman/util';
import { CHANNEL_UPDATE } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 46:46
id: bd639bbab2b0bc6b297bea2c317ee4819fa8d069a4de9f6a9ccfc7bf3bf7665a
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L46

declaration:
CHANNEL_MESSAGE = 42

summary:
A constant representing the kind number for channel messages in the Nostr protocol. The value is 42, which falls within the range of regular kinds (1-9999), meaning these events are expected to be stored by relays.

details:
This constant is part of a comprehensive set of kind definitions for the Nostr protocol. It represents messages sent within a channel (kind 42). As a regular kind (between 1-9999), channel messages are expected to be persistently stored by relays. This kind works in conjunction with other channel-related kinds like CHANNEL_CREATE (40), CHANNEL_UPDATE (41), CHANNEL_HIDE_MESSAGE (43), and CHANNEL_MUTE_USER (44) to provide a complete channel messaging system within Nostr.

import/access examples:
import { CHANNEL_MESSAGE } from '@welshman/util';
import { CHANNEL_MESSAGE } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 47:47
id: 4140b0e810e98784f8cca205a4bf977d35f564b87dcd294b336778a7b68f2c08
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L47

declaration:
CHANNEL_HIDE_MESSAGE = 43

summary:
A constant representing the Nostr event kind for hiding a message in a channel. The value is 43, which falls within the range of regular event kinds (1-9999) that are expected to be stored by relays.

details:
This constant is part of a comprehensive set of Nostr event kind definitions. It belongs to the channel-related event kinds (along with CHANNEL_CREATE, CHANNEL_UPDATE, CHANNEL_MESSAGE, and CHANNEL_MUTE_USER). As a regular event kind (below 10000), it's expected to be stored persistently by relays rather than being ephemeral or replaceable.

import/access examples:
import { CHANNEL_HIDE_MESSAGE } from '@welshman/util';
import { CHANNEL_HIDE_MESSAGE } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 48:48
id: fc5ef11be5a4013e0e29f8c3ba86bfbbdd42a4a78e73d37181746359a1e574a4
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L48

declaration:
CHANNEL_MUTE_USER = 44

summary:
A constant representing the Nostr event kind for channel mute user actions. The value is 44, which is a regular kind event that is expected to be stored by relays.

details:
This constant is part of a collection of event kind identifiers used in the Nostr protocol. It belongs to the regular kind category (as defined by the `isRegularKind` function in the same file), which means events of this kind are expected to be stored permanently by relays. The constant is exported from the module, making it available for use by other components that need to identify or create channel mute user events.

import/access examples:
import { CHANNEL_MUTE_USER } from '@welshman/util';
import { CHANNEL_MUTE_USER } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 49:49
id: 4020eb3dc5c395a75a12f78767b175795c53b2793ba2e1711bcd0ed38c44a0c9
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L49

declaration:
VANISH = 62

summary:
A constant representing the VANISH event kind in the Nostr protocol with a value of 62. This constant is used to identify events that are related to vanishing or disappearing content.

details:
This is a simple constant declaration that assigns the numeric value 62 to the VANISH identifier. It's part of a larger collection of event kind constants defined in the Kinds.ts file that categorize different types of Nostr events. The VANISH kind appears to be a regular event kind (based on the isRegularKind function in the same file) which means it's expected to be stored by relays.

import/access examples:
import { VANISH } from '@welshman/util';
import { VANISH } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 50:50
id: 67753872625d31b7738da4657f637cbf898625598b6386125ac7e9e1568812ad
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L50

declaration:
BID = 1021

summary:
A constant representing the Nostr event kind for a bid. The value is 1021, which falls within the range of regular kinds (1000-10000), meaning these events are expected to be stored by relays.

details:
This is a simple constant declaration that defines the numeric identifier for bid events in the Nostr protocol. It's part of a larger collection of event kind constants that categorize different types of Nostr events. The value 1021 indicates this is a regular event kind (as opposed to replaceable, ephemeral, or parameterized replaceable).

import/access examples:
import { BID } from '@welshman/util';
import { BID } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 51:51
id: 9d9e37e5d15ea4784daa5268eb02d4d2b144d82b150fe77e860c31a0155a361f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L51

declaration:
BID_CONFIRMATION = 1022

summary:
A constant representing the Nostr event kind for bid confirmation events with a value of 1022. This is a regular kind of event, which means it's expected to be stored by relays.

details:
This constant is part of a collection of event kind identifiers used in the Nostr protocol. It belongs to the regular event category (between 1000 and 10000), which means relays are expected to store these events. BID_CONFIRMATION events likely work in conjunction with BID events (kind 1021) as part of a bidding system implementation in Nostr.

import/access examples:
import { BID_CONFIRMATION } from '@welshman/util';
import { BID_CONFIRMATION } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 52:52
id: 7228fd8d77618806856cb41308f8c4676ca56955645984314efe1a9dad9edfb4
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L52

declaration:
OTS = 1040

summary:
A constant representing the Nostr event kind for OTS (OpenTimestamps) events with a value of 1040. This kind is categorized as a regular event, which means it's expected to be stored by relays.

details:
This is a simple constant declaration that defines the numeric identifier for OTS (OpenTimestamps) events in the Nostr protocol. Based on the value (1040), it falls within the range of regular events (1000-10000) as defined by the `isRegularKind` function in the same file. OpenTimestamps is a standard for creating blockchain-based timestamps, so this event kind likely represents timestamp-related data in the Nostr ecosystem.

import/access examples:
import { OTS } from '@welshman/util';
import { OTS } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 53:53
id: 9849691ec89e4fc6b5aaadf79366fc4069a5a84b5da9f46b6b8bdb55912a014f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L53

declaration:
WRAP = 1059

summary:
A constant representing the WRAP event kind in the Nostr protocol with a value of 1059. This kind is used to identify events that wrap or encapsulate other content.

details:
This is a simple constant declaration that assigns the numeric value 1059 to the WRAP identifier. Based on its position in the code (between 1000 and 10000), it appears to be a regular kind event, which means these events are expected to be stored by relays according to the isRegularKind function in the same file.

import/access examples:
import { WRAP } from '@welshman/util';
import { WRAP } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 54:54
id: 416c750990be50e08ec8771af4ac2a54a3e9283405a6bc5c411fede2d3498cc2
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L54

declaration:
WRAP_NIP04 = 1060

summary:
A constant representing the Nostr event kind 1060, which is used for NIP-04 wrapped messages. This kind is part of the regular event types (1000-10000 range) that are expected to be stored by relays.

details:
This constant is part of a comprehensive collection of Nostr event kind definitions in the Kinds.ts file. It specifically defines the WRAP_NIP04 kind with value 1060, which falls within the regular event kinds range (1000-10000) as defined by the isRegularKind function in the same file. NIP-04 typically refers to the Nostr Implementation Possibility for encrypted direct messages, so this kind likely represents a wrapped or encapsulated form of such encrypted content.

import/access examples:
import { WRAP_NIP04 } from '@welshman/util';
import { WRAP_NIP04 } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 55:55
id: dab37692e8268f5c629a597708b26f5775d9a73d27580c287e97fe3ded796a3b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L55

declaration:
FILE_METADATA = 1063

summary:
A constant representing the Nostr event kind for file metadata. In the Nostr protocol, this kind (1063) is used to identify events that contain metadata about files.

details:
This constant is part of a comprehensive collection of Nostr event kind identifiers. The FILE_METADATA constant with value 1063 falls within the range of 1000-10000, which according to the isRegularKind function in this file, categorizes it as a "regular" event kind. Regular events are expected to be stored by relays rather than being ephemeral or replaceable.

import/access examples:
import { FILE_METADATA } from '@welshman/util';
import { FILE_METADATA } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 56:56
id: 5182a67f89102fee1b28a0608349767262a1fd1af2e6fd2009ceb6186e7551a5
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L56

declaration:
COMMENT = 1111

summary:
A constant representing the Nostr event kind for comments, with a value of 1111. This kind is used to identify comment events in the Nostr protocol.

details:
This is a simple constant declaration that defines the numeric value for the COMMENT event kind in the Nostr protocol. It's part of a larger collection of event kind constants defined in this file. Based on its value (1111), it falls within the range of regular kinds (1000-10000), which means these events are expected to be stored by relays as defined by the `isRegularKind` function in the same file.

import/access examples:
import { COMMENT } from '@welshman/util';
import { COMMENT } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 57:57
id: 090d318452dad33ec137b431aea1fd2881ac5274792057c22af987ec900ed63c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L57

declaration:
LIVE_CHAT_MESSAGE = 1311

summary:
A constant representing the Nostr event kind for live chat messages, with a value of 1311. This kind is used to identify events that contain live chat messages in the Nostr protocol.

details:
This is a simple constant declaration that assigns the numeric value 1311 to the LIVE_CHAT_MESSAGE identifier. It's part of a larger collection of event kind constants in the Nostr protocol. Based on the file context, this appears to be a regular kind (between 1000 and 10000), which means these events are expected to be stored by relays.

import/access examples:
import { LIVE_CHAT_MESSAGE } from '@welshman/util';
import { LIVE_CHAT_MESSAGE } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 58:58
id: 584cfe8148e41456c0978965f43fbe337cab9b0654df594daefb8370dc3779b9
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L58

declaration:
GIT_PATCH = 1617

summary:
A constant representing the Nostr event kind for Git patches. The value is 1617, which falls within the range of regular event kinds (1000-10000), meaning these events are expected to be stored by relays.

details:
This constant is part of a collection of Nostr event kind definitions in the Kinds.ts file. It represents the specific kind number for Git patch events (1617). Based on the implementation in the file, this would be classified as a regular kind event since it falls between 1000 and 10000, which means relays are expected to store these events rather than treating them as replaceable or ephemeral.

import/access examples:
import { GIT_PATCH } from '@welshman/util';
import { GIT_PATCH } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 59:59
id: 1dbce1e6d8e86d9ad19fae298f1fa1542a2b58846e1689236b6686e718be2565
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L59

declaration:
GIT_ISSUE = 1621

summary:
A constant representing the Nostr event kind for Git issues. The value is 1621, which falls within the range of regular event kinds (1000-10000), meaning these events are expected to be stored by relays.

details:
This constant is part of a collection of predefined Nostr event kind identifiers. It specifically identifies Git issue events with the numeric value 1621. Based on its value range, it's classified as a regular event kind according to the `isRegularKind` function in the same file, which means relays are expected to store these events rather than treating them as replaceable or ephemeral.

import/access examples:
import { GIT_ISSUE } from '@welshman/util';
import { GIT_ISSUE } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 60:60
id: 0e1cb05c2f3069cdfab3350fa98d39c982690061f7bcc51360ee67267f8eef5d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L60

declaration:
GIT_REPLY = 1622

summary:
A constant representing the Nostr event kind for Git replies, with a value of 1622. This kind is used to identify events that are replies to Git issues or other Git-related content in the Nostr protocol.

details:
This is a simple constant declaration that defines the numeric value for the GIT_REPLY event kind. It's part of a larger collection of constants that define various Nostr event kinds. Based on its value (1622), it falls within the regular kind range (1000-10000), which means these events are expected to be stored by relays as indicated by the `isRegularKind` function in the same file.

import/access examples:
import { GIT_REPLY } from '@welshman/util';
import { GIT_REPLY } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 61:61
id: 076def106900a9c0616e0cbbdc0515bfc2f421779940a06a56a49630bea2483c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L61

declaration:
GIT_STATUS_OPEN = 1630

summary:
A constant representing the Nostr event kind for Git status open events. The value is 1630, which falls within the range of regular event kinds (1000-10000), meaning these events are expected to be stored by relays.

details:
This constant is part of a larger collection of Nostr event kind definitions in the Kinds.ts file. It specifically defines the event kind for indicating an open status in a Git-related context. It belongs to a group of Git-related event kinds (along with GIT_PATCH, GIT_ISSUE, GIT_REPLY, etc.) that are used for Git-related operations in the Nostr protocol.

import/access examples:
import { GIT_STATUS_OPEN } from '@welshman/util';
import { GIT_STATUS_OPEN } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 62:62
id: d0523aa0e0f260aed366aff1de03b67013d30811662bb71ad933d0687b458a2e
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L62

declaration:
GIT_STATUS_COMPLETE = 1631

summary:
A constant representing the Nostr event kind for a Git status marked as 'complete'. The value is 1631, which falls within the regular event kind range (1000-10000), meaning these events are expected to be stored by relays.

details:
This constant is part of a collection of predefined Nostr event kind constants in the Kinds module. It specifically represents a Git-related status update indicating that something has been completed. As a regular event kind (between 1000 and 10000), relays are expected to store these events rather than treating them as replaceable or ephemeral.

import/access examples:
import { GIT_STATUS_COMPLETE } from '@welshman/util';
import { GIT_STATUS_COMPLETE } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 63:63
id: 62ccd0e75a98758c8dbe9a5aecc4bdf439b8255fe627620e4bba6c6ddd2f1225
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L63

declaration:
GIT_STATUS_CLOSED = 1632

summary:
A constant representing the kind number for a Git status closed event in the Nostr protocol. The value is 1632, which falls within the range of regular kinds (1000-10000), meaning it's expected to be stored by relays.

details:
This constant is part of a collection of predefined event kind constants used in the Nostr protocol. It specifically represents a Git status closed event (kind 1632), which is categorized as a regular event kind based on the `isRegularKind` function in the same file. Regular kinds are stored permanently by relays, as opposed to replaceable or ephemeral kinds.

import/access examples:
import { GIT_STATUS_CLOSED } from '@welshman/util';
import { GIT_STATUS_CLOSED } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 64:64
id: 693f3ea838a7e09c5cf34d4fb3e898247e836d9de4a6b8c1404a865412b7390a
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L64

declaration:
GIT_STATUS_DRAFT = 1633

summary:
A constant representing the Nostr event kind for Git status draft events. The value is 1633, which falls within the range of regular event kinds (1000-10000), meaning these events are expected to be stored by relays.

details:
This constant is part of a larger collection of Nostr event kind definitions in the Kinds.ts file. It specifically represents the Git status draft event type (1633), which is likely used to indicate that a Git-related item (such as an issue or pull request) is in draft status. It belongs to a group of Git-related status constants (along with OPEN, COMPLETE, and CLOSED statuses) that are defined in the same file.

import/access examples:
import { GIT_STATUS_DRAFT } from '@welshman/util';
import { GIT_STATUS_DRAFT } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 65:65
id: 79163ac8ddccf81d371fd2e2c5b50a34576936bc19a21db6fa953137d5197f7e
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L65

declaration:
GIT_REPOSITORY = 30403

summary:
A constant representing the Nostr event kind for Git repositories. The value is 30403, which falls within the range of parameterized replaceable kinds (30000-40000), meaning that for each combination of pubkey, kind, and d tag, only the latest event should be stored by relays.

details:
This constant is part of a larger collection of Nostr event kind definitions. As a parameterized replaceable kind (30000-40000), GIT_REPOSITORY events follow specific storage rules in the Nostr protocol. The value 30403 indicates this is for Git repository metadata that can be updated over time, with relays expected to only keep the most recent version for a given pubkey and d tag combination.

import/access examples:
import { GIT_REPOSITORY } from '@welshman/util';
import { GIT_REPOSITORY } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 66:66
id: 128d1fd6f5c98e122de9a2894b06a46e278d7358222cc94bb6a5061e07759025
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L66

declaration:
REMIX = 1808

summary:
A constant representing the REMIX event kind in the Nostr protocol with a value of 1808. This kind is used to identify events that are remixes of other content.

details:
This constant is part of a larger collection of event kind constants defined in the Kinds.ts file. It falls within the range of regular kinds (1000-10000), which means these events are expected to be stored by relays. The constant is exported and can be imported from both the Kinds module and the main index module.

import/access examples:
import { REMIX } from '@welshman/util';
import { REMIX } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 67:67
id: d8764916106844076c4f5b7a47211016a4a36f50ff32fdb1b2efc566f5a871f1
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L67

declaration:
NOSTROCKET_PROBLEM = 1971

summary:
A constant representing the Nostrocket Problem event kind in the Nostr protocol with a value of 1971. This is a regular event kind, meaning it's expected to be stored by relays.

details:
This constant is part of a larger collection of event kind definitions for the Nostr protocol. It belongs to the regular kind range (between 1000 and 10000), which means relays are expected to store these events. The NOSTROCKET_PROBLEM constant appears to be related to the Nostrocket project and is likely used for reporting or documenting problems within that ecosystem.

import/access examples:
import { NOSTROCKET_PROBLEM } from '@welshman/util';
import { NOSTROCKET_PROBLEM } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 68:68
id: a35934266df3d689d8bac7d94b17c8e0ad9554cb0b11718d30c713714eb42ae5
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L68

declaration:
REPORT = 1984

summary:
A constant representing the REPORT event kind in the Nostr protocol with a value of 1984. This kind is used for reporting content or users, typically for moderation purposes.

details:
This constant is part of a collection of event kind definitions used in the Nostr protocol. Based on its numerical value (1984), it falls within the regular event kind range (1000-10000), meaning reports are expected to be stored by relays rather than being ephemeral or replaceable. The number 1984 likely has symbolic significance related to moderation and reporting.

import/access examples:
import { REPORT } from '@welshman/util';
import { REPORT } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 69:69
id: f9f3a15b3a692db679e10349e82aa66e8bba2a86145a45fb4af535b1d196832f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L69

declaration:
LABEL = 1985

summary:
A constant representing the LABEL event kind in the Nostr protocol with a value of 1985. This kind is used for labeling or tagging content or entities within the Nostr ecosystem.

details:
This is a simple constant declaration that defines the numeric value for the LABEL event kind. It's part of a larger collection of event kind constants in the Kinds.ts file that define various event types in the Nostr protocol. Based on its value (1985), it falls within the range of regular event kinds (1000-10000), which means these events are expected to be stored by relays according to the isRegularKind function in the same file.

import/access examples:
import { LABEL } from '@welshman/util';
import { LABEL } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 70:70
id: 426d032de7b7b3bc841bfe79ad553b1be7ca9340d4bc386cbbf648ac65487684
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L70

declaration:
REVIEW = 1986

summary:
A constant representing the kind number for REVIEW events in the Nostr protocol. The value is 1986, which falls within the range of regular kinds (1000-10000), meaning these events are expected to be stored by relays.

details:
This is a simple constant declaration that defines the numeric identifier for REVIEW events in the Nostr protocol ecosystem. As a regular kind (between 1000 and 10000), REVIEW events are part of the standard event types that relays are expected to store persistently. The value 1986 specifically identifies events that contain reviews, likely of content, services, or other entities within the Nostr ecosystem.

import/access examples:
import { REVIEW } from '@welshman/util';
import { REVIEW } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 71:71
id: fed5e86fcaf0cfca3a8fe19058daeb42103b71ffdb099660877b2db43d3e4320
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L71

declaration:
APPROVAL = 4550

summary:
A constant representing the Nostr event kind for approval events with a value of 4550. This is a regular kind of event that is expected to be stored by relays.

details:
This constant is part of a collection of event kind definitions for the Nostr protocol. Based on its value (4550), it falls within the range of regular events (1000-10000), which means relays are expected to store these events. The APPROVAL kind likely represents events where a user approves something, possibly related to content moderation or verification processes.

import/access examples:
import { APPROVAL } from '@welshman/util';
import { APPROVAL } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 72:72
id: ab67e8452ebbf2b1e364eb016fb8253ffb7a5a5d00071bdbb6f30260d9efe816
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L72

declaration:
DVM_REQUEST_TEXT_EXTRACTION = 5000

summary:
A constant representing the event kind for DVM (Decentralized Virtual Machine) text extraction requests in the Nostr protocol. The value is 5000, which falls within the range of DVM kinds (4999-7001).

details:
This constant is part of a collection of event kind identifiers used in the Nostr protocol. It specifically represents a request for text extraction services from a DVM. Based on the surrounding code, it belongs to a group of DVM request constants (values 5000-5999) that have corresponding response constants (6000-6999). The value 5000 is classified as a regular kind according to the `isRegularKind` function, meaning events of this kind are expected to be stored by relays.

import/access examples:
import { DVM_REQUEST_TEXT_EXTRACTION } from '@welshman/util';
import { DVM_REQUEST_TEXT_EXTRACTION } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 73:73
id: cc69bf6e370c8271a226bcc1dac7588280b74379b036cc3d4a483560202ceab7
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L73

declaration:
DVM_REQUEST_TEXT_SUMMARY = 5001

summary:
A constant representing the kind number 5001 for DVM (Decentralized Virtual Machine) text summary request events in the Nostr protocol. This kind is used to identify events that request text summarization services from DVMs.

details:
This constant is part of a collection of event kind identifiers used in the Nostr protocol. It falls within the DVM request range (5000-7000) as verified by the `isDVMKind` function in the same file. DVM request kinds are typically paired with corresponding response kinds (in this case, DVM_RESPONSE_TEXT_SUMMARY = 6001).

import/access examples:
import { DVM_REQUEST_TEXT_SUMMARY } from '@welshman/util';
import { DVM_REQUEST_TEXT_SUMMARY } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 74:74
id: d23d8b06deeca039255f3bb424d3484854e611723477c222f4793d22a9cc9358
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L74

declaration:
DVM_REQUEST_TEXT_TRANSLATION = 5002

summary:
A constant representing the Nostr event kind for DVM (Decentralized Virtual Machine) text translation requests. The value is 5002, which falls within the DVM request range (5000-7000).

details:
This constant is part of a comprehensive set of Nostr event kind definitions. It specifically identifies events that request text translation services from DVMs. The constant follows the Nostr event kind numbering convention where kinds between 4999 and 7001 are designated for DVM-related operations, as indicated by the `isDVMKind` function in the same file.

import/access examples:
import { DVM_REQUEST_TEXT_TRANSLATION } from '@welshman/util';
import { DVM_REQUEST_TEXT_TRANSLATION } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 75:75
id: 58f71d0bcea7d68e2060f974224f14657358cdfdb0a5b9cf44c51061c2c70686
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L75

declaration:
DVM_REQUEST_TEXT_GENERATION = 5050

summary:
A constant representing the kind number for DVM (Decentralized Virtual Machine) text generation requests in the Nostr protocol. The value is 5050, which falls within the range of DVM request kinds (5000-7000).

details:
This constant is part of a larger collection of event kind definitions used in the Nostr protocol. It specifically identifies requests for text generation services from DVMs. Based on the surrounding code, this constant belongs to a group of DVM request types (5000-5999) that have corresponding response types (6000-6999). The implementation is straightforward - just a named constant with a numeric value.

import/access examples:
import { DVM_REQUEST_TEXT_GENERATION } from '@welshman/util';
import { DVM_REQUEST_TEXT_GENERATION } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 76:76
id: 22632aa6a9e968822314ad24ce62bcf1a0b46265d68ba46c115fe57f2539475a
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L76

declaration:
DVM_REQUEST_IMAGE_GENERATION = 5100

summary:
A constant representing the kind number for DVM (Decentralized Virtual Machine) image generation requests in the Nostr protocol. The value is 5100, which falls within the range of DVM request kinds (5000-7000).

details:
This constant is part of a larger collection of kind constants used in the Nostr protocol. It specifically identifies requests for image generation services through DVMs. Based on the surrounding code, this constant belongs to a group of DVM request kinds (5000-7000) which appear to be regular kinds (meaning they're expected to be stored by relays). The corresponding response kind for image generation is DVM_RESPONSE_IMAGE_GENERATION with value 6100.

import/access examples:
import { DVM_REQUEST_IMAGE_GENERATION } from '@welshman/util';
import { DVM_REQUEST_IMAGE_GENERATION } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 77:77
id: 27d1fe275709d05197c81461085064410d2bcc73d278fdcfc861ad3b403b4592
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L77

declaration:
DVM_REQUEST_VIDEO_CONVERSION = 5200

summary:
A constant representing the kind number for DVM (Decentralized Virtual Machine) video conversion requests in the Nostr protocol. The value is 5200, which falls within the DVM request range (5000-7000).

details:
This constant is part of a larger set of kind definitions for the Nostr protocol. It specifically identifies requests for video conversion services in the DVM (Decentralized Virtual Machine) ecosystem. The value 5200 is within the range that the `isDVMKind` function would identify as a DVM-related event (between 4999 and 7001). This kind would be classified as a regular event by the `isRegularKind` function, meaning relays are expected to store these events.

import/access examples:
import { DVM_REQUEST_VIDEO_CONVERSION } from '@welshman/util';
import { DVM_REQUEST_VIDEO_CONVERSION } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 78:78
id: 483391d2a82a3efd2ef83a18081374a67140bad491abc6dfb50431cf32def01e
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L78

declaration:
DVM_REQUEST_VIDEO_TRANSLATION = 5201

summary:
A constant representing the kind number for DVM (Decentralized Virtual Machine) video translation requests in the Nostr protocol. The value is 5201, which falls within the range of DVM request kinds (5000-7000).

details:
This constant is part of a larger collection of kind constants used in the Nostr protocol. It specifically belongs to the DVM (Decentralized Virtual Machine) request category, which includes various service requests like text extraction, image generation, and in this case, video translation. The constant is exported and can be imported from both the Kinds module and the main index file. Based on the isDVMKind function in the same file, this kind falls within the range of DVM-related events (between 4999 and 7001).

import/access examples:
import { DVM_REQUEST_VIDEO_TRANSLATION } from '@welshman/util';
import { DVM_REQUEST_VIDEO_TRANSLATION } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 79:79
id: 62ceee150915ff03301a6115865dde6b9961f4c6d9ffbc531ac7752cf66aafff
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L79

declaration:
DVM_REQUEST_IMAGE_TO_VIDEO_CONVERSION = 5202

summary:
A constant representing the kind number for DVM (Decentralized Virtual Machine) requests for image-to-video conversion in the Nostr protocol. The value is 5202, which falls within the DVM request range (5000-7000).

details:
This constant is part of a larger collection of kind constants used in the Nostr protocol. It specifically belongs to the DVM (Decentralized Virtual Machine) request category, as indicated by its value range and naming convention. The constant is exported from the module and can be used to identify or create events related to image-to-video conversion requests in a DVM context.

import/access examples:
import { DVM_REQUEST_IMAGE_TO_VIDEO_CONVERSION } from '@welshman/util';
import { DVM_REQUEST_IMAGE_TO_VIDEO_CONVERSION } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 80:80
id: 51c050a1bb5b969d3e4cdabc7afaa257610d277ffc9eb43663bc2eaa0c9615b3
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L80

declaration:
DVM_REQUEST_TEXT_TO_SPEECH = 5250

summary:
A constant representing the Nostr event kind for DVM (Decentralized Virtual Machine) text-to-speech requests. The value is 5250, which falls within the DVM request range (5000-7000).

details:
This constant is part of a larger collection of Nostr event kind definitions in the Kinds.ts file. It specifically identifies requests for text-to-speech conversion services in the DVM (Decentralized Virtual Machine) ecosystem. The constant follows the Nostr event kind numbering convention where DVM request events are in the 5000-7000 range, with corresponding response kinds typically having values 1000 higher (in this case, DVM_RESPONSE_TEXT_TO_SPEECH is 6250).

import/access examples:
import { DVM_REQUEST_TEXT_TO_SPEECH } from '@welshman/util';
import { DVM_REQUEST_TEXT_TO_SPEECH } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 81:81
id: 4de4a585a028516baf4ad61dc47b33aa688f06d019a04190201354cb9915e4d4
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L81

declaration:
DVM_REQUEST_DISCOVER_CONTENT = 5300

summary:
A constant representing the kind number for DVM (Decentralized Virtual Machine) request to discover content in the Nostr protocol. The value is 5300, which falls within the DVM kind range (4999-7001).

details:
This constant is part of a larger collection of kind constants used in the Nostr protocol. It specifically represents a request to discover content through a DVM service. The constant is exported and can be imported from both the Kinds module and the main index file. It belongs to the DVM request family (kinds 5000-5999) which are used for various decentralized virtual machine operations.

import/access examples:
import { DVM_REQUEST_DISCOVER_CONTENT } from '@welshman/util';
import { DVM_REQUEST_DISCOVER_CONTENT } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 82:82
id: cdfcd514e47073b3e058822ffca63112a3269892988606b92046fa59fa3e1845
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L82

declaration:
DVM_REQUEST_DISCOVER_PEOPLE = 5301

summary:
A constant representing the Nostr event kind for DVM (Decentralized Virtual Machine) requests to discover people, with a value of 5301. This kind is used when making requests to DVMs for people discovery functionality.

details:
This constant is part of a larger collection of event kind constants defined in the Kinds.ts file. It belongs to the DVM request category (5000-5999 range) as indicated by the `isDVMKind` function in the same file. The constant follows the Nostr event kind numbering convention where different ranges have specific meanings regarding how events should be handled by relays.

import/access examples:
import { DVM_REQUEST_DISCOVER_PEOPLE } from '@welshman/util';
import { DVM_REQUEST_DISCOVER_PEOPLE } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 83:83
id: 73e2ad6f6ce3bf1d61ef0c47b9e21a1a6d5032601795e3b7e0a5e41823c85739
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L83

declaration:
DVM_REQUEST_SEARCH_CONTENT = 5302

summary:
A constant representing the kind number for DVM (Decentralized Virtual Machine) search content requests in the Nostr protocol. The value is 5302, which falls within the DVM request range (5000-7000).

details:
This constant is part of a larger set of kind definitions for the Nostr protocol. It specifically identifies events that are requests to search for content through a DVM service. Based on the surrounding code, it belongs to a group of DVM request kinds (5000-7000) which appear to be related to various data processing and service requests within the Nostr ecosystem.

import/access examples:
import { DVM_REQUEST_SEARCH_CONTENT } from '@welshman/util';
import { DVM_REQUEST_SEARCH_CONTENT } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 84:84
id: 538760c0721817495d67081cfe43aa4896bafbd49e88f048c1204e8d137e1e11
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L84

declaration:
DVM_REQUEST_SEARCH_PEOPLE = 5303

summary:
A constant representing the kind number for DVM (Decentralized Virtual Machine) requests to search for people in the Nostr protocol. The value is 5303, which falls within the DVM request range (5000-7000).

details:
This constant is part of a larger set of kind definitions for the Nostr protocol. It specifically represents a request to search for people using a DVM service. Based on the surrounding code, it belongs to a group of DVM request kinds (starting with 5000) that have corresponding response kinds (starting with 6000). The implementation is trivial - it's simply a named constant with the value 5303.

import/access examples:
import { DVM_REQUEST_SEARCH_PEOPLE } from '@welshman/util';
import { DVM_REQUEST_SEARCH_PEOPLE } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 85:85
id: 850e604e65f2126ff1aa79ce6cf886f3b8ed0f5e58b77ac2cebd8e1331ff2fda
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L85

declaration:
DVM_REQUEST_COUNT = 5400

summary:
A constant representing the kind number for DVM_REQUEST_COUNT events in the Nostr protocol. The value is 5400, which falls within the range of DVM (Decentralized Virtual Machine) request kinds (5000-7000).

details:
This constant is part of a larger collection of event kind definitions used in the Nostr protocol. It specifically represents a DVM request for counting operations. As a DVM request kind (between 5000-7000 as checked by the `isDVMKind` function), it's categorized as a regular event kind that should be stored by relays according to the protocol specifications.

import/access examples:
import { DVM_REQUEST_COUNT } from '@welshman/util';
import { DVM_REQUEST_COUNT } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 86:86
id: cb3ac1979daf64ba741deb0ef1a1c49d93cf3a0232532618107cfb393c608ccc
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L86

declaration:
DVM_REQUEST_MALWARE_SCAN = 5500

summary:
A constant representing the kind number for DVM (Decentralized Virtual Machine) malware scan requests in the Nostr protocol. The value is 5500, which falls within the range of DVM request kinds (5000-7000).

details:
This constant is part of a larger collection of event kind definitions for the Nostr protocol. It specifically identifies requests for malware scanning services through a DVM. As a DVM request kind (between 4999 and 7001), it follows the convention established for decentralized virtual machine operations in the Nostr ecosystem. The corresponding response kind would be DVM_RESPONSE_MALWARE_SCAN (6500).

import/access examples:
import { DVM_REQUEST_MALWARE_SCAN } from '@welshman/util';
import { DVM_REQUEST_MALWARE_SCAN } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 87:87
id: 2e733b596c0c59ab2f97b0e640c1aab6ab8574c4805848c382a6090fda20739d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L87

declaration:
DVM_REQUEST_OTS = 5900

summary:
A constant representing the kind number for DVM (Decentralized Virtual Machine) OTS (One-Time Signature) requests in the Nostr protocol. The value is 5900, which falls within the DVM request range (5000-7000).

details:
This constant is part of a larger collection of kind constants used in the Nostr protocol. It specifically identifies requests for OTS (One-Time Signature) operations to be processed by DVMs. Based on the surrounding code, this kind is classified as a regular event (as determined by the isDVMKind function) which means it's expected to be stored by relays. It has a corresponding response kind (DVM_RESPONSE_OTS = 6900) defined elsewhere in the file.

import/access examples:
import { DVM_REQUEST_OTS } from '@welshman/util';
import { DVM_REQUEST_OTS } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 88:88
id: 7f769627b24f4e752072c297f133d8dd1ac9171bf3c01607243997cd60628bc2
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L88

declaration:
DVM_REQUEST_OP_RETURN = 5901

summary:
A constant representing the Nostr event kind for DVM (Decentralized Virtual Machine) OP_RETURN requests with a value of 5901. This kind is used to identify events that request OP_RETURN operations in the Nostr protocol.

details:
This is a simple constant declaration that defines the numeric identifier (5901) for DVM OP_RETURN request events. It falls within the DVM request range (5000-7000) as verified by the `isDVMKind` function in the same file. This constant is exported from both the current module and re-exported from the index file, making it available for use throughout the project.

import/access examples:
import { DVM_REQUEST_OP_RETURN } from '@welshman/util';
import { DVM_REQUEST_OP_RETURN } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 89:89
id: 8271dcbe588d194b244ed5c28bc034510694214b64042bc14dcea62eb452ba5f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L89

declaration:
DVM_REQUEST_PUBLISH_SCHEDULE = 5905

summary:
A constant representing the kind number for DVM (Decentralized Virtual Machine) publish schedule requests in the Nostr protocol. The value is 5905, which falls within the range of DVM request kinds (5000-7000).

details:
This constant is part of a larger collection of event kind constants used in the Nostr protocol. It specifically represents a request to a DVM for scheduling the publication of content. Based on the surrounding code, this kind is classified as a regular event (as determined by the `isDVMKind` function) which means it's expected to be stored by relays. The corresponding response kind is DVM_RESPONSE_PUBLISH_SCHEDULE (6905).

import/access examples:
import { DVM_REQUEST_PUBLISH_SCHEDULE } from '@welshman/util';
import { DVM_REQUEST_PUBLISH_SCHEDULE } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 90:90
id: 2dbcc8faf04fcd956e84ac0fa8282fc6cbc27aabc4ac83668b9b2bed8e2c4d7e
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L90

declaration:
DVM_RESPONSE_TEXT_EXTRACTION = 6000

summary:
A constant representing the kind number for DVM (Decentralized Virtual Machine) responses related to text extraction operations in the Nostr protocol. The value is 6000, which falls within the range of DVM response kinds (6000-7000).

details:
This constant is part of a larger collection of kind constants used in the Nostr protocol to categorize different types of events. It specifically represents responses from DVMs that have performed text extraction operations. It pairs with the corresponding request kind DVM_REQUEST_TEXT_EXTRACTION (5000), forming a request-response pattern common in the DVM ecosystem.

import/access examples:
import { DVM_RESPONSE_TEXT_EXTRACTION } from '@welshman/util';
import { DVM_RESPONSE_TEXT_EXTRACTION } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 91:91
id: dc1e32f22db80ac69416fd1a955081472dbc8e23247d85124e8499891ee9e264
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L91

declaration:
DVM_RESPONSE_TEXT_SUMMARY = 6001

summary:
A constant representing the kind number for DVM (Decentralized Virtual Machine) responses related to text summary operations in the Nostr protocol. The value is 6001, which falls within the range of regular kinds (1000-10000) that are expected to be stored by relays.

details:
This constant is part of a larger collection of kind constants defined for the Nostr protocol. It specifically represents responses from DVMs that provide text summary services. It corresponds to the request kind DVM_REQUEST_TEXT_SUMMARY (5001), forming a request-response pair in the DVM ecosystem. The constant is exported from the module and can be imported by other parts of the application that need to identify or filter these specific kinds of events.

import/access examples:
import { DVM_RESPONSE_TEXT_SUMMARY } from '@welshman/util';
import { DVM_RESPONSE_TEXT_SUMMARY } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 92:92
id: 362e0b0575513ecf68e3faa98f7a2318e828c0517449d98dd8f717b10d6db28b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L92

declaration:
DVM_RESPONSE_TEXT_TRANSLATION = 6002

summary:
A constant representing the kind number for DVM (Decentralized Virtual Machine) response events related to text translation in the Nostr protocol. The value is 6002, which falls within the regular event kind range (1000-10000), meaning these events are expected to be stored by relays.

details:
This constant is part of a larger collection of event kind definitions in the Nostr protocol. It specifically identifies responses from DVMs that have performed text translation services. It corresponds to the request kind DVM_REQUEST_TEXT_TRANSLATION (5002) and follows the pattern where DVM response kinds are typically 1000 higher than their corresponding request kinds.

import/access examples:
import { DVM_RESPONSE_TEXT_TRANSLATION } from '@welshman/util';
import { DVM_RESPONSE_TEXT_TRANSLATION } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 93:93
id: 3a6445f46246c948ab832fffcd1da0fd9e34717134f7406c8ed5327d6ca895dc
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L93

declaration:
DVM_RESPONSE_TEXT_GENERATION = 6050

summary:
A constant representing the kind number for DVM (Decentralized Virtual Machine) text generation response events in the Nostr protocol. The value is 6050, which falls within the range of DVM response kinds (6000-7000).

details:
This constant is part of a collection of event kind identifiers used in the Nostr protocol. It specifically identifies responses from DVMs that have generated text content. It pairs with the corresponding request kind DVM_REQUEST_TEXT_GENERATION (5050), forming a request-response pattern typical in the DVM ecosystem. The value 6050 places it in the regular event category (as defined by isRegularKind), meaning relays are expected to store these events.

import/access examples:
import { DVM_RESPONSE_TEXT_GENERATION } from '@welshman/util';
import { DVM_RESPONSE_TEXT_GENERATION } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 94:94
id: 08afbe55497e713025c7e93c065137982fd135f8534d057ba93eb484bdf7c823
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L94

declaration:
DVM_RESPONSE_IMAGE_GENERATION = 6100

summary:
A constant representing the kind number for DVM (Decentralized Virtual Machine) responses to image generation requests in the Nostr protocol. The value is 6100, which falls within the regular event kind range (1000-10000), meaning these events are expected to be stored by relays.

details:
This constant is part of a larger collection of event kind definitions in the Nostr protocol. It specifically represents responses from DVMs that have processed image generation requests (which would be sent with kind 5100). The constant follows the Nostr convention where request kinds in the 5000-7000 range have corresponding response kinds in the 6000-7000 range.

import/access examples:
import { DVM_RESPONSE_IMAGE_GENERATION } from '@welshman/util';
import { DVM_RESPONSE_IMAGE_GENERATION } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 95:95
id: 31c9ac47597237c94dcc05b3edd013e1395aefb3bba4838dbaa4a9b952d9de3d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L95

declaration:
DVM_RESPONSE_VIDEO_CONVERSION = 6200

summary:
A constant representing the kind number for DVM (Decentralized Virtual Machine) responses related to video conversion operations in the Nostr protocol. The value is 6200, which falls within the regular event kind range (1000-10000), meaning these events are expected to be stored by relays.

details:
This constant is part of a larger set of predefined event kind constants used in the Nostr protocol. It specifically represents responses from DVMs that have processed video conversion requests (which would be sent with kind 5200). The constant follows the Nostr convention where request kinds are in the 5000-5999 range and corresponding response kinds are in the 6000-6999 range.

import/access examples:
import { DVM_RESPONSE_VIDEO_CONVERSION } from '@welshman/util';
import { DVM_RESPONSE_VIDEO_CONVERSION } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 96:96
id: 91280d4aa2cb98c0679de929ba7e76eede7e78bdd9bbe5356d84adfe9834bfa6
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L96

declaration:
DVM_RESPONSE_VIDEO_TRANSLATION = 6201

summary:
A constant representing the kind number for DVM (Decentralized Virtual Machine) responses related to video translation in the Nostr protocol. The value is 6201, which falls within the regular event kind range (1000-10000), meaning these events are expected to be stored by relays.

details:
This constant is part of a larger collection of event kind definitions in the Nostr protocol. It specifically represents responses from DVMs that have performed video translation services (corresponding to the request kind 5201). The implementation is straightforward - it's a named constant with a numeric value that helps standardize and identify specific types of events within the Nostr ecosystem.

import/access examples:
import { DVM_RESPONSE_VIDEO_TRANSLATION } from '@welshman/util';
import { DVM_RESPONSE_VIDEO_TRANSLATION } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 97:97
id: d64b17b6e9ce6b5dc9dbde6d76945c44abef129e526e6cafef74b4451dca1c99
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L97

declaration:
DVM_RESPONSE_IMAGE_TO_VIDEO_CONVERSION = 6202

summary:
A constant representing the Nostr event kind for DVM (Decentralized Virtual Machine) responses to image-to-video conversion requests. The value is 6202, which falls within the regular event kind range (1000-10000), meaning these events are expected to be stored by relays.

details:
This constant is part of a comprehensive set of Nostr event kind definitions. It specifically identifies responses from DVMs that have processed image-to-video conversion requests (which would be sent as kind 5202). The constant follows the Nostr convention where request kinds are in the 5000s range and their corresponding responses are in the 6000s range with matching suffixes.

import/access examples:
import { DVM_RESPONSE_IMAGE_TO_VIDEO_CONVERSION } from '@welshman/util';
import { DVM_RESPONSE_IMAGE_TO_VIDEO_CONVERSION } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 98:98
id: 7e46cf4eda7944757118387202088a154848f2ef44b0b3d37c4f5c4937f90c82
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L98

declaration:
DVM_RESPONSE_TEXT_TO_SPEECH = 6250

summary:
A constant representing the Nostr event kind for DVM (Decentralized Virtual Machine) responses to text-to-speech conversion requests. The value is 6250, which falls within the regular event kind range (1000-10000), meaning these events are expected to be stored by relays.

details:
This constant is part of a comprehensive set of Nostr event kind definitions in the Kinds.ts file. It specifically identifies responses from DVMs that have processed text-to-speech conversion requests (which would be sent as kind 5250). The constant follows the Nostr convention where DVM response kinds (6xxx) correspond to their request kinds (5xxx).

import/access examples:
import { DVM_RESPONSE_TEXT_TO_SPEECH } from '@welshman/util';
import { DVM_RESPONSE_TEXT_TO_SPEECH } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 99:99
id: 8d53240b78904f2509eaa5826e8a8fa0e040cc912f82d3afb9eb3abbcc83b0da
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L99

declaration:
DVM_RESPONSE_DISCOVER_CONTENT = 6300

summary:
A constant representing the Nostr event kind for DVM (Decentralized Virtual Machine) responses related to content discovery. The value is 6300, which falls within the regular event kind range (1000-10000), meaning these events are expected to be stored by relays.

details:
This constant is part of a comprehensive set of event kind definitions for the Nostr protocol. It specifically represents responses from DVMs that provide content discovery services. The constant is exported and can be imported from both the Kinds module and the main index. It corresponds to the DVM_REQUEST_DISCOVER_CONTENT (kind 5300) which would be the request that triggers this response.

import/access examples:
import { DVM_RESPONSE_DISCOVER_CONTENT } from '@welshman/util';
import { DVM_RESPONSE_DISCOVER_CONTENT } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 100:100
id: 7e173dfffa8f9e063258fca36d6aa6a4ff155aae8e53d725bcd5ad7f0e7f5cc8
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L100

declaration:
DVM_RESPONSE_DISCOVER_PEOPLE = 6301

summary:
A constant representing the kind number for DVM (Decentralized Virtual Machine) responses related to discovering people in the Nostr protocol. The value is 6301, which falls within the range of DVM response kinds (6000-7000).

details:
This constant is part of a larger collection of event kind definitions used in the Nostr protocol. It specifically represents responses from DVMs that provide people discovery functionality. It's paired with the corresponding request kind DVM_REQUEST_DISCOVER_PEOPLE (5301). The constant follows the Nostr convention where request kinds are in the 5000s range and their corresponding responses are in the 6000s range with matching last digits.

import/access examples:
import { DVM_RESPONSE_DISCOVER_PEOPLE } from '@welshman/util';
import { DVM_RESPONSE_DISCOVER_PEOPLE } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 101:101
id: 9687083d70680f2afc4d352e055dddbf148ea9be7d66a896e5080b77eb842d25
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L101

declaration:
DVM_RESPONSE_SEARCH_CONTENT = 6302

summary:
A constant representing the kind number for DVM (Decentralized Virtual Machine) responses to search content requests in the Nostr protocol. The value is 6302, which falls within the range of regular event kinds (1000-10000) that are expected to be stored by relays.

details:
This constant is part of a larger set of predefined event kinds for the Nostr protocol. It specifically represents responses from DVMs that have processed search content requests (which would be sent with kind 5302). The implementation is straightforward - it's a simple numeric constant export. The value 6302 is in the 6000-7000 range which appears to be reserved for DVM response events, as evidenced by the pattern of other DVM response constants in the file.

import/access examples:
import { DVM_RESPONSE_SEARCH_CONTENT } from '@welshman/util';
import { DVM_RESPONSE_SEARCH_CONTENT } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 102:102
id: 9acd11617227fe4c7c5920e8dc1df89c28781365ca52f9e61b1aa1e315029d00
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L102

declaration:
DVM_RESPONSE_SEARCH_PEOPLE = 6303

summary:
A constant representing the Nostr event kind for DVM (Decentralized Virtual Machine) responses to search people requests. The value is 6303, which falls within the regular event kind range (1000-10000), meaning these events are expected to be stored by relays.

details:
This constant is part of a comprehensive set of Nostr event kind definitions in the codebase. It specifically represents responses from DVMs that have processed requests to search for people. The constant follows the Nostr numbering convention where DVM response kinds (6xxx) correspond to their request counterparts (5xxx) - in this case, DVM_REQUEST_SEARCH_PEOPLE (5303) and DVM_RESPONSE_SEARCH_PEOPLE (6303).

import/access examples:
import { DVM_RESPONSE_SEARCH_PEOPLE } from '@welshman/util';
import { DVM_RESPONSE_SEARCH_PEOPLE } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 103:103
id: 155c5f6c592d820944a2fd1a722eec6ce6d29202307aa8f01d5dcd032405b6cf
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L103

declaration:
DVM_RESPONSE_COUNT = 6400

summary:
A constant representing the Nostr event kind for DVM (Decentralized Virtual Machine) response count events. The value is 6400, which falls within the regular event kind range (1000-10000), meaning these events are expected to be stored by relays.

details:
This constant is part of a comprehensive set of Nostr event kind definitions in the Kinds.ts file. It specifically defines the kind number for DVM response count events (6400). Based on the file structure, this appears to be paired with a corresponding request kind (DVM_REQUEST_COUNT = 5400) defined elsewhere in the file. The constant follows the Nostr convention where response kinds (6xxx) mirror request kinds (5xxx) in the DVM context.

import/access examples:
import { DVM_RESPONSE_COUNT } from '@welshman/util';
import { DVM_RESPONSE_COUNT } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 104:104
id: 4101c37d128463633badc7e128c833b0d724f38437322e32f34a933bc5bae50c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L104

declaration:
DVM_RESPONSE_MALWARE_SCAN = 6500

summary:
A constant representing the kind number for DVM (Decentralized Virtual Machine) responses to malware scan requests in the Nostr protocol. The value is 6500, which falls within the range of DVM response kinds (6000-7000).

details:
This constant is part of a larger collection of kind constants used in the Nostr protocol. It specifically represents responses from DVMs that have performed malware scanning operations. It corresponds to the request kind DVM_REQUEST_MALWARE_SCAN (5500), following the pattern where request kinds are in the 5000s and their corresponding responses are in the 6000s with the same last three digits.

import/access examples:
import { DVM_RESPONSE_MALWARE_SCAN } from '@welshman/util';
import { DVM_RESPONSE_MALWARE_SCAN } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 105:105
id: de45d0644a273a38907c94cc51520af3be854e73ae25e561af719e02092430d1
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L105

declaration:
DVM_RESPONSE_OTS = 6900

summary:
A constant representing the Nostr event kind for DVM (Decentralized Virtual Machine) OTS (OpenTimestamps) responses. The value is 6900, which falls within the range of DVM response kinds (6000-7000).

details:
This constant is part of a collection of predefined Nostr event kind identifiers. It specifically represents responses from DVMs related to OpenTimestamps operations. The constant follows the Nostr event kind numbering convention where DVM response kinds are in the 6000-7000 range, with this particular constant (6900) corresponding to the request kind DVM_REQUEST_OTS (5900).

import/access examples:
import { DVM_RESPONSE_OTS } from '@welshman/util';
import { DVM_RESPONSE_OTS } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 106:106
id: ae0b47386980b35b6dc39be9891505a4adbd52d1b0840df1705b90f047c558d9
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L106

declaration:
DVM_RESPONSE_OP_RETURN = 6901

summary:
A constant representing the kind number for DVM (Decentralized Virtual Machine) response to OP_RETURN requests in the Nostr protocol. The value is 6901, which falls within the DVM response range (6000-7000).

details:
This constant is part of a larger collection of kind constants used in the Nostr protocol. It specifically represents responses from DVMs that handle OP_RETURN operations (likely related to Bitcoin transactions). It corresponds to the request kind DVM_REQUEST_OP_RETURN (5901) defined earlier in the file. The constant is exported and can be imported from both this module directly or through the index file.

import/access examples:
import { DVM_RESPONSE_OP_RETURN } from '@welshman/util';
import { DVM_RESPONSE_OP_RETURN } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 107:107
id: a239039b8479c40c6232e5ebb222e09c07f23d0956f09646efba3719bfc429ae
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L107

declaration:
DVM_RESPONSE_PUBLISH_SCHEDULE = 6905

summary:
A constant representing the kind number for DVM (Decentralized Virtual Machine) response to publish schedule requests in the Nostr protocol. The value is 6905.

details:
This constant is part of a larger collection of kind constants used in the Nostr protocol. It specifically represents the response kind for publish schedule requests in the DVM (Decentralized Virtual Machine) context. It belongs to the DVM response range (6000-7000) as indicated by the naming convention and value range in the file.

import/access examples:
import { DVM_RESPONSE_PUBLISH_SCHEDULE } from '@welshman/util';
import { DVM_RESPONSE_PUBLISH_SCHEDULE } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 108:108
id: 4e4c0d48874d3fdd09e1c7ac1d14796d181720f5ec380d27fcda3e816487f967
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L108

declaration:
DVM_FEEDBACK = 7000

summary:
A constant representing the DVM_FEEDBACK event kind with a value of 7000. This is used to identify feedback events in the Decentralized Virtual Machine (DVM) context within the Nostr protocol.

details:
This constant is part of a larger collection of event kind definitions in the Nostr protocol. Based on its value (7000), it falls within the range of DVM-related kinds (between 4999 and 7001) as determined by the `isDVMKind` function in the same file. It represents a feedback mechanism for DVM operations, likely used to provide user or system feedback about DVM requests and responses.

import/access examples:
import { DVM_FEEDBACK } from '@welshman/util';
import { DVM_FEEDBACK } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 109:109
id: 5d9650bb746cd06c4d35fb9da5a87ef5330736d6953bafe8801c4f29467400be
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L109

declaration:
ROOM_ADD_USER = 9000

summary:
A constant representing the Nostr event kind for adding a user to a room. The value is 9000, which falls within the range of regular event kinds (1000-10000) that are expected to be stored by relays.

details:
This constant is part of a comprehensive collection of Nostr event kind definitions in the Kinds.ts file. It belongs to a group of room-related event kinds (9000-9022) that handle various room operations. The constant follows the Nostr protocol's event kind numbering convention, where different ranges indicate different event behaviors (regular, replaceable, ephemeral, or parameterized replaceable).

import/access examples:
import { ROOM_ADD_USER } from '@welshman/util';
import { ROOM_ADD_USER } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 110:110
id: 5b0f055be54636e354d016731016f659b2f35a36b4ca54fa7b8a4ae077e99604
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L110

declaration:
ROOM_REMOVE_USER = 9001

summary:
A constant representing the Nostr event kind for removing a user from a room. The value is 9001.

details:
This is a simple constant declaration that defines the numeric value for the ROOM_REMOVE_USER event kind in the Nostr protocol. It's part of a larger collection of event kind constants defined in this file. The value 9001 falls within the range of regular event kinds (1000-10000), which means these events are expected to be stored by relays according to the isRegularKind function defined in the same file.

import/access examples:
import { ROOM_REMOVE_USER } from '@welshman/util';
import { ROOM_REMOVE_USER } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 111:111
id: 9c5e0113736eca36d69fe7e4f03f9aa37a19733d376dad38a701156616881453
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L111

declaration:
ROOM_EDIT_META = 9002

summary:
A constant representing the Nostr event kind for room metadata editing operations. The value is 9002, which falls within the range of regular event kinds (1000-10000), meaning it's expected to be stored by relays.

details:
This constant is part of a comprehensive collection of Nostr event kind definitions. It belongs to the room-related event kinds (which include other operations like adding/removing users, permissions, etc.). The value 9002 indicates this is a regular event kind according to the classification system defined in this file, which means relays are expected to store these events rather than treating them as replaceable or ephemeral.

import/access examples:
import { ROOM_EDIT_META } from '@welshman/util';
import { ROOM_EDIT_META } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 112:112
id: 2e4b826d659839d95ca4493a338c3a72a5cfbd9f0538b941e56a68679c58a2e8
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L112

declaration:
ROOM_ADD_PERM = 9003

summary:
A constant that represents the event kind for adding permissions to a room in the Nostr protocol. The value is 9003, which falls within the range of regular kinds (1000-10000), meaning these events are expected to be stored by relays.

details:
This is a simple constant declaration that maps the semantic name `ROOM_ADD_PERM` to the numeric kind value 9003. It's part of a larger collection of event kind constants in the Nostr protocol. Based on its value (9003), it would be classified as a regular kind according to the `isRegularKind` function in the same file, which means relays are expected to store these events.

import/access examples:
import { ROOM_ADD_PERM } from '@welshman/util';
import { ROOM_ADD_PERM } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 113:113
id: 1656100df58a285694548caa182ed3665451e2f9c8bbf2d520c004e0216d6ec8
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L113

declaration:
ROOM_REMOVE_PERM = 9004

summary:
A constant representing the Nostr event kind for removing permissions from a room. The value is 9004, which falls within the range of regular event kinds (1000-10000), meaning it's expected to be stored by relays.

details:
This constant is part of a larger collection of Nostr event kind definitions in the Kinds.ts file. It belongs to the room-related event kinds (which include other operations like adding users, editing metadata, etc.). The value 9004 indicates this is a regular event kind according to the classification functions defined in the same file.

import/access examples:
import { ROOM_REMOVE_PERM } from '@welshman/util';
import { ROOM_REMOVE_PERM } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 114:114
id: b8cf042e4c1c6e7808ed144f3d1ca6d98d36c67041e70227e1db7f798bfae75c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L114

declaration:
ROOM_DELETE_EVENT = 9005

summary:
A constant representing the Nostr event kind for room delete events, with a value of 9005. This kind is used to identify events that signal the deletion of a message or content within a room in the Nostr protocol.

details:
This constant is part of a larger collection of event kind constants defined in the Kinds.ts file. It belongs to the room-related event kinds (which typically have values in the 9000 range). The constant is exported from the module, making it available for use by other components that need to identify or create room delete events.

import/access examples:
import { ROOM_DELETE_EVENT } from '@welshman/util';
import { ROOM_DELETE_EVENT } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 115:115
id: 9a772101eee4138e60dc5f31104a6a015b8b95d7a4632792208a48fa0bf60b10
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L115

declaration:
ROOM_EDIT_STATUS = 9006

summary:
A constant representing the Nostr event kind for room status editing operations. The value is 9006, which falls within the range of regular event kinds (1000-10000), meaning it's expected to be stored by relays.

details:
This constant is part of a larger collection of Nostr event kind definitions in the Kinds.ts file. It belongs to the room-related event kinds (which include other operations like ROOM_ADD_USER, ROOM_REMOVE_USER, etc.). The value 9006 indicates this is a regular event kind according to the isRegularKind function defined in the same file, which means relays are expected to store these events.

import/access examples:
import { ROOM_EDIT_STATUS } from '@welshman/util';
import { ROOM_EDIT_STATUS } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 116:116
id: 07d76237ce57598b038946a492dfe299839854689103f1b54a5c308b950ebb48
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L116

declaration:
ROOM_CREATE = 9007

summary:
A constant representing the Nostr event kind for room creation with a value of 9007. This kind is used to identify events that create a new room in the Nostr protocol.

details:
This is a simple constant declaration that maps the semantic meaning 'ROOM_CREATE' to the numeric kind value 9007 in the Nostr protocol. It's part of a larger collection of event kind constants defined in this file. Based on its position in the file (line 116), it appears to be grouped with other room-related event kinds (9000-9008 range).

import/access examples:
import { ROOM_CREATE } from '@welshman/util';
import { ROOM_CREATE } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 117:117
id: 12604724d8e8947d8c1d6b1ad5cfe645867f0aeb271c671f7ae3417bf7422548
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L117

declaration:
ROOM_DELETE = 9008

summary:
A constant representing the event kind for room deletion in the Nostr protocol. The value is 9008, which falls within the range of regular event kinds (1000-10000), meaning it's expected to be stored by relays.

details:
This constant is part of a larger collection of event kind constants defined in the Kinds.ts file. It belongs to the room-related events (along with other constants like ROOM_CREATE, ROOM_JOIN, etc.) which appear to be in the 9000-9022 range. As a regular kind (not replaceable or ephemeral), ROOM_DELETE events are expected to be permanently stored by relays.

import/access examples:
import { ROOM_DELETE } from '@welshman/util';
import { ROOM_DELETE } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 118:118
id: 4c9b6b8b46a2f54ef49b381c005f98173e3461f7a41f68ef88cec008b51489fd
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L118

declaration:
ROOM_JOIN = 9021

summary:
A constant representing the Nostr event kind for room join events. The value is 9021, which falls within the range of regular event kinds (1000-10000). Regular events are expected to be stored by relays.

details:
This constant is part of a comprehensive collection of Nostr event kind constants defined in the Kinds.ts file. It belongs to the room-related event kinds (along with others like ROOM_CREATE, ROOM_LEAVE, etc.) which appear to implement functionality for managing chat rooms or similar social spaces in the Nostr protocol. The value 9021 indicates it's a regular event kind that relays are expected to store.

import/access examples:
import { ROOM_JOIN } from '@welshman/util';
import { ROOM_JOIN } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 119:119
id: cc2a6ab94962e7d7af1386974dfe0f9dd7af655b55a8d6c042c3242b44c740df
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L119

declaration:
ROOM_LEAVE = 9022

summary:
A constant representing the Nostr event kind for a user leaving a room, with a value of 9022. This is part of the Nostr protocol's event kind system used to categorize different types of events.

details:
This is a simple constant declaration that defines the numeric value for the ROOM_LEAVE event kind. It belongs to the room-related event kinds (9000-9999 range), which are regular events (expected to be stored by relays). This constant is exported from the module, making it available for other parts of the application to reference when creating or filtering events related to users leaving rooms.

import/access examples:
import { ROOM_LEAVE } from '@welshman/util';
import { ROOM_LEAVE } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 120:120
id: e76ea719834116937c3036a8846e68295e104a1ea293a1169fa93b10cf9b1baa
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L120

declaration:
ZAP_GOAL = 9041

summary:
A constant representing the Nostr event kind for zap goals with a value of 9041. Zap goals are used in the Nostr protocol to define targets for receiving zaps (Lightning Network payments).

details:
This is a simple constant declaration that assigns the numeric value 9041 to the ZAP_GOAL identifier. It's part of a larger collection of event kind constants in the Nostr protocol. Based on its position in the file (line 120), it appears to be grouped with other zap-related constants like ZAP_REQUEST (9734) and ZAP_RESPONSE (9735).

import/access examples:
import { ZAP_GOAL } from '@welshman/util';
import { ZAP_GOAL } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 121:121
id: 114b358d42085ad02f87f289fa69650a3dc37e3a4026bf6760f36170642b2175
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L121

declaration:
ZAP_REQUEST = 9734

summary:
A constant representing the Nostr event kind for zap requests. The value is 9734. Zap requests are used in the Nostr protocol to initiate Lightning Network payment requests.

details:
This is a simple constant definition that maps the semantic name `ZAP_REQUEST` to its numerical kind value (9734) in the Nostr protocol. It appears to be part of a comprehensive collection of event kind constants defined in this file. Based on its position in the file (line 121), it's grouped near other zap-related constants like `ZAP_GOAL` and `ZAP_RESPONSE`.

import/access examples:
import { ZAP_REQUEST } from '@welshman/util';
import { ZAP_REQUEST } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 122:122
id: 5da3ccd1fbafc5c064bb9651ed9824b73df1ea3c3183717a50464953c8ad813b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L122

declaration:
ZAP_RESPONSE = 9735

summary:
A constant representing the Nostr event kind for zap responses. The value is 9735. Zap responses are events that acknowledge or respond to zap requests (kind 9734) in the Nostr protocol.

details:
This is a simple constant declaration that defines the numeric kind value for zap response events in the Nostr protocol. It's part of a larger collection of event kind constants defined in this file. The constant is exported, making it available for import by other modules in the project. The value 9735 is a regular kind (between 1000 and 10000), which means these events are expected to be stored by relays according to the `isRegularKind` function defined in the same file.

import/access examples:
import { ZAP_RESPONSE } from '@welshman/util';
import { ZAP_RESPONSE } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 123:123
id: 7ed39d208d937585444d4205ca7a49fa481ddeb5fea99e105417b1388192681c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L123

declaration:
HIGHLIGHT = 9802

summary:
A constant representing the Nostr event kind for HIGHLIGHT events with a value of 9802. This constant is used to identify events that are related to highlighting content in the Nostr protocol.

details:
This is a simple constant declaration that assigns the numeric value 9802 to the HIGHLIGHT identifier. It's part of a larger collection of event kind constants defined in the Kinds.ts file that categorize different types of Nostr events. Based on its position in the file (line 123), it appears to be grouped with other specialized event kinds.

import/access examples:
import { HIGHLIGHT } from '@welshman/util';
import { HIGHLIGHT } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 124:124
id: 52686957d6d649f02266103d8e57d251237c250a1ee3c97e67d5f1125e26182e
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L124

declaration:
MUTES = 10000

summary:
A constant representing the event kind for mutes in the Nostr protocol. The value is 10000, which falls within the range of plain replaceable kinds (10000-19999), meaning that for each pubkey, only the latest event of this kind should be stored by relays.

details:
This constant is part of a larger collection of event kind definitions in the Nostr protocol. As a plain replaceable kind (10000-19999), MUTES events are expected to replace older versions with the same pubkey. The value 10000 specifically represents a list of muted users or content that a user has chosen to filter out from their experience.

import/access examples:
import { MUTES } from '@welshman/util';
import { MUTES } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 125:125
id: 5ab6c074a14ed797eae15fd370adb99bb19d645afe495499471683ed956008b5
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L125

declaration:
PINS = 10001

summary:
A constant representing the PINS event kind in the Nostr protocol with a value of 10001. This is a plain replaceable kind, meaning for each pubkey, only the latest event of this kind should be stored by relays, with older versions being discarded.

details:
This constant is part of a collection of event kind identifiers used in the Nostr protocol. The PINS kind (10001) falls within the range of 10000-20000, which according to the `isPlainReplaceableKind` function in this file, categorizes it as a plain replaceable event. This means relays should only store the most recent version of this event for each pubkey.

import/access examples:
import { PINS } from '@welshman/util';
import { PINS } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 126:126
id: e764feeed794bcef7f1d7242a50dc00242b6f8a356b784c4b147021b3b57ffaa
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L126

declaration:
RELAYS = 10002

summary:
A constant representing the kind number for RELAYS events in the Nostr protocol. The value is 10002, which falls within the range of plain replaceable kinds (10000-19999), meaning that for each pubkey, only the latest event of this kind should be stored by relays.

details:
This constant is part of a larger collection of event kind constants defined in the Kinds.ts file. RELAYS (10002) is categorized as a plain replaceable kind based on its value range, as defined by the isPlainReplaceableKind function in the same file. This means relays should only store the most recent event of this kind for each pubkey, discarding older versions. The RELAYS kind is typically used for users to publish their preferred list of relays.

import/access examples:
import { RELAYS } from '@welshman/util';
import { RELAYS } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 127:127
id: 515be80fd586cf38594c28121c881ba1ed4347514ff99a0d2ad08a94c7c8d180
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L127

declaration:
BOOKMARKS = 10003

summary:
A constant representing the Nostr event kind for BOOKMARKS with a value of 10003. This is a replaceable kind, meaning for each pubkey, only the latest event of this kind should be stored by relays, with older versions being discarded.

details:
This constant is part of a collection of Nostr event kind definitions. It falls within the range of 10000-20000, which according to the isPlainReplaceableKind function in this file, categorizes it as a replaceable event type. Bookmarks events are typically used to store a user's saved/bookmarked content in the Nostr protocol.

import/access examples:
import { BOOKMARKS } from '@welshman/util';
import { BOOKMARKS } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 128:128
id: 76c6b992817bb814a420c5d90816f594064ad2c2a542483a8f1a2ab7c51adbfa
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L128

declaration:
COMMUNITIES = 10004

summary:
A constant representing the event kind for COMMUNITIES in the Nostr protocol. The value is 10004, which falls within the range of plain replaceable kinds (10000-19999), meaning for each pubkey and this kind, only the latest event should be stored by relays.

details:
This constant is part of a larger collection of event kind definitions in the Nostr protocol. As a plain replaceable kind (between 10000 and 20000), COMMUNITIES events are expected to replace older versions with the same pubkey. This is used for storing community-related data that a user might want to update over time, such as community memberships or preferences.

import/access examples:
import { COMMUNITIES } from '@welshman/util';
import { COMMUNITIES } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 129:129
id: cf2b00550a87fbe423e6490d98b9b3c3f33b7b77a3c64a20078526f5a9a2a0e5
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L129

declaration:
CHANNELS = 10005

summary:
A constant representing the Nostr event kind for CHANNELS with a value of 10005. This is a replaceable kind, meaning for each pubkey and kind combination, only the latest event should be stored by relays.

details:
This constant is part of a collection of Nostr event kind definitions. It belongs to the replaceable kind category (10000-19999 range), specifically in the list kinds (10000-10099). CHANNELS (10005) is used to store a user's list of channels they're interested in or participating in.

import/access examples:
import { CHANNELS } from '@welshman/util';
import { CHANNELS } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 130:130
id: cf95dd47c965b24d3f35460c72f633529ac061ac3c18249871f79db081ff072e
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L130

declaration:
BLOCKED_RELAYS = 10006

summary:
A constant representing the event kind for blocked relays in the Nostr protocol. The value is 10006, which falls within the range of replaceable kinds (10000-20000), meaning for each pubkey, only the latest event of this kind should be stored by relays.

details:
This constant is part of a larger collection of event kind definitions in the Nostr protocol. It belongs to the replaceable kinds category (specifically plain replaceable kinds between 10000-20000), which means relays should only store the most recent event of this kind for each pubkey. The BLOCKED_RELAYS constant is likely used to maintain a user's list of relays they want to block or avoid connecting to.

import/access examples:
import { BLOCKED_RELAYS } from '@welshman/util';
import { BLOCKED_RELAYS } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 131:131
id: 0b1e0888fe56938926083f7e83273cb9421ada8042f50c040ded47d592a7893c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L131

declaration:
SEARCH_RELAYS = 10007

summary:
A constant representing the Nostr event kind for search relays with a value of 10007. This is a replaceable kind, meaning for each pubkey, only the latest event of this kind should be stored by relays.

details:
This constant is part of a larger collection of Nostr event kind definitions. It belongs to the replaceable kind range (10000-19999) as defined by the isPlainReplaceableKind function in the same file. Search relays (kind 10007) are used to specify which relays a user prefers for search functionality in the Nostr protocol.

import/access examples:
import { SEARCH_RELAYS } from '@welshman/util';
import { SEARCH_RELAYS } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 132:132
id: 00402e48b5b667d85874d63b859b475ca1949e1f4668e26f35b83e7c12d84f0a
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L132

declaration:
ROOMS = 10009

summary:
A constant representing the Nostr event kind for ROOMS with a value of 10009. This is a replaceable kind, meaning for each pubkey and kind combination, only the latest event should be stored by relays.

details:
This constant is part of a collection of Nostr event kind definitions. It falls within the range 10000-20000, which according to the isPlainReplaceableKind function in the same file, categorizes it as a replaceable event type. This means relays should only store the most recent version of this event for a given pubkey.

import/access examples:
import { ROOMS } from '@welshman/util';
import { ROOMS } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 133:133
id: 754a539abed763ebe3a494e53e66e00d964a1a07159afeacb1210df017a935c8
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L133

declaration:
FEEDS = 10014

summary:
A constant representing the Nostr event kind for FEEDS with a value of 10014. This is a replaceable kind, meaning for each pubkey and kind combination, only the latest event should be stored by relays.

details:
This constant is part of a collection of Nostr event kind definitions. It falls within the 10000-19999 range, which according to the implementation in this file (see `isPlainReplaceableKind`), makes it a plain replaceable kind. Replaceable kinds are intended to be used for data that should be updated rather than accumulated, with relays expected to only keep the most recent version.

import/access examples:
import { FEEDS } from '@welshman/util';
import { FEEDS } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 134:134
id: b94651deee83f1addf0a78dd504f32315fad5d53b5a48ff795432adafd57cc8d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L134

declaration:
TOPICS = 10015

summary:
A constant representing the TOPICS kind in the Nostr protocol with a value of 10015. This kind is categorized as a replaceable kind, meaning for each pubkey and kind combination, only the latest event should be stored by relays.

details:
This constant is part of a collection of event kind identifiers used in the Nostr protocol. Based on its value (10015), it falls within the range of 10000-20000, which according to the `isPlainReplaceableKind` function in the same file, categorizes it as a plain replaceable kind. This means that relays should only store the most recent event of this kind for a given pubkey, discarding older versions.

import/access examples:
import { TOPICS } from '@welshman/util';
import { TOPICS } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 135:135
id: 66a78ad3ce44843a4f102b6bd1efd9b02c53cf512215b9ecb1ef841bda8cae4f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L135

declaration:
EMOJIS = 10030

summary:
A constant representing the Nostr event kind for EMOJIS with a value of 10030. This is a replaceable kind event, meaning for each pubkey and this kind, only the latest event should be stored by relays.

details:
This constant is part of a larger collection of Nostr event kind definitions in the Kinds.ts file. It falls within the range of 10000-20000, which according to the isPlainReplaceableKind function in the same file, categorizes it as a replaceable event type. This means relays should only store the most recent version of this event for a given pubkey.

import/access examples:
import { EMOJIS } from '@welshman/util';
import { EMOJIS } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 136:136
id: 4493383cb4f21256bf9a5030bd745f375b9e223fffba57fd036459d5e291491f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L136

declaration:
INBOX_RELAYS = 10050

summary:
A constant representing the Nostr event kind for inbox relays, with a value of 10050. This kind is used to identify events that contain information about relays designated for receiving direct messages or other personal communications.

details:
This is a simple constant declaration that assigns the numeric value 10050 to the variable INBOX_RELAYS. It's part of a larger collection of constants that define various Nostr event kinds. The constant is exported from the module, making it available for use in other parts of the application. Based on its value (10050), it falls into the category of replaceable kinds (10000-19999), meaning only the latest event of this kind from a pubkey should be stored by relays.

import/access examples:
import { INBOX_RELAYS } from '@welshman/util';
import { INBOX_RELAYS } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 137:137
id: 2b6bbcae6e0aa8de62c599b4b72f72f696996a021a86b009126b41c18a940902
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L137

declaration:
BLOSSOM_SERVERS = 10063

summary:
A constant representing the Nostr event kind for BLOSSOM_SERVERS with a value of 10063. This is a replaceable kind event, meaning for each pubkey, only the latest event of this kind should be stored by relays.

details:
This constant is part of a collection of Nostr event kind definitions. It falls within the range 10000-20000, which according to the isPlainReplaceableKind function in the same file, categorizes it as a replaceable event. Replaceable events are expected to have only their latest version stored by relays for a given pubkey, with older versions being discarded.

import/access examples:
import { BLOSSOM_SERVERS } from '@welshman/util';
import { BLOSSOM_SERVERS } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 138:138
id: 204ef3b2499d7c59f8e6a6697f1873cef061c7f4869d527cc13f89d3c290cc54
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L138

declaration:
FILE_SERVERS = 10096

summary:
A constant representing the Nostr event kind for file servers, with a value of 10096. This kind is categorized as a replaceable event, meaning for each pubkey, only the latest event of this kind should be stored by relays.

details:
This constant is part of a larger collection of Nostr event kind definitions in the Kinds.ts file. It belongs to the 10000-19999 range, which according to the implementation in the same file (isPlainReplaceableKind function), classifies it as a plain replaceable kind. This means relays should only store the most recent event of this kind for each pubkey, discarding older versions.

import/access examples:
import { FILE_SERVERS } from '@welshman/util';
import { FILE_SERVERS } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 139:139
id: 7fc6380aa9f8c2fb832f3c8ab3f82fbd38edde93874860fd3d5190193557666f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L139

declaration:
LIGHTNING_PUB_RPC = 21000

summary:
A constant representing the Nostr event kind for Lightning Public RPC. This kind is used for events related to Lightning Network RPC operations in the Nostr protocol. The value is 21000, which falls within the ephemeral event range (20000-30000), meaning these events are not expected to be stored by relays.

details:
This is a simple constant declaration that assigns the numeric value 21000 to the LIGHTNING_PUB_RPC identifier. As an ephemeral kind (between 20000 and 30000), it follows the Nostr protocol specification for events that relays are not expected to persist. The constant is exported from the module, making it available for use in other parts of the application that need to identify or create Lightning Public RPC events.

import/access examples:
import { LIGHTNING_PUB_RPC } from '@welshman/util';
import { LIGHTNING_PUB_RPC } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 140:140
id: eb325d03426a9688761e15c4e17cb9182877d3ae0976955c5d32e0c6c869ed74
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L140

declaration:
CLIENT_AUTH = 22242

summary:
A constant representing the Nostr event kind for client authentication, with a value of 22242. This kind is used to identify events related to client authentication in the Nostr protocol.

details:
This is a simple constant declaration that defines the numeric value for the CLIENT_AUTH event kind in the Nostr protocol. It's part of a larger collection of event kind constants in the Kinds.ts file, which categorizes different types of Nostr events. Based on its numeric value (22242), it appears to be an ephemeral kind (20000-30000 range), meaning these events are not expected to be stored by relays.

import/access examples:
import { CLIENT_AUTH } from '@welshman/util';
import { CLIENT_AUTH } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 141:141
id: 2668dfb96bc1bfc3c2417a09b25cf19915fd2f7ac9a80e114db01d413e3c519b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L141

declaration:
BLOSSOM_AUTH = 24242

summary:
A constant representing the Nostr event kind for Blossom authentication with a value of 24242. This is part of the ephemeral event kinds range (20000-30000), meaning these events are not expected to be stored by relays.

details:
This constant is part of a larger collection of Nostr event kind definitions in the Kinds.ts file. The BLOSSOM_AUTH constant with value 24242 falls within the ephemeral event kinds range (20000-30000) as defined by the isEphemeralKind function in the same file. Ephemeral events are meant for transient communication and not for persistent storage by relays.

import/access examples:
import { BLOSSOM_AUTH } from '@welshman/util';
import { BLOSSOM_AUTH } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 142:142
id: afe384538188e48ec2261a61d93a3ff1ebbbc7acf62bec88ce6ddee4e83b7156
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L142

declaration:
AUTH_JOIN = 28934

summary:
A constant representing the AUTH_JOIN event kind in the Nostr protocol with a value of 28934. This kind is likely used for authentication-related events, specifically for joining or requesting access to a resource that requires authentication.

details:
This constant is part of a larger collection of event kind constants defined in the Kinds.ts file. Based on its value (28934), it falls outside the ranges defined for regular, replaceable, ephemeral, or parameterized replaceable kinds. It appears to be related to authentication functionality, possibly working in conjunction with AUTH_INVITE (kind 28935) as they have sequential numbers.

import/access examples:
import { AUTH_JOIN } from '@welshman/util';
import { AUTH_JOIN } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 143:143
id: f15adc5c2c41a3f49c7dcefc7d17abc3b5afc7a14afe4417df3c824438c5e911
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L143

declaration:
AUTH_INVITE = 28935

summary:
A constant representing the AUTH_INVITE event kind in the Nostr protocol with a value of 28935. This kind is used for authentication invitation events in the Nostr ecosystem.

details:
This constant is part of a comprehensive collection of Nostr event kind definitions. Based on its value (28935), it appears to be related to authentication and invitation processes in Nostr. The constant is exported from the module, making it available for use in other parts of the application. It's positioned in the code among other authentication-related constants like AUTH_JOIN (28934).

import/access examples:
import { AUTH_INVITE } from '@welshman/util';
import { AUTH_INVITE } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 144:144
id: 1e5d9b3bec965c641d06fbe671492ccf76d51aafc6a8b47b532a3f052127d160
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L144

declaration:
WALLET_INFO = 13194

summary:
A constant representing the Nostr event kind for wallet information with a value of 13194. This kind is used to identify events related to wallet information in the Nostr protocol.

details:
This constant is part of a comprehensive collection of Nostr event kind identifiers defined in the Kinds.ts file. The WALLET_INFO constant with value 13194 appears to be in the regular kind range (1000-10000), which means events of this kind are expected to be stored by relays according to the isRegularKind function defined in the same file.

import/access examples:
import { WALLET_INFO } from '@welshman/util';
import { WALLET_INFO } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 145:145
id: 16659140997f3b3de0139ec024f34b72d5aa67548e6c98f4352b829e165dbabc
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L145

declaration:
WALLET_REQUEST = 23194

summary:
A constant representing the Nostr event kind for wallet requests with a value of 23194. This kind is used to identify events that contain wallet requests in the Nostr protocol.

details:
This constant is part of a comprehensive collection of Nostr event kind definitions. It belongs to the ephemeral event category (20000-30000 range), which means these events are not expected to be stored by relays. Wallet request events (kind 23194) are typically paired with wallet response events (kind 23195) in the Nostr wallet interaction flow.

import/access examples:
import { WALLET_REQUEST } from '@welshman/util';
import { WALLET_REQUEST } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 146:146
id: dc277f3ab486ef29b5eef1cf08d3102e5b6f2ea31a907aaa846a5c2fe50947f2
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L146

declaration:
WALLET_RESPONSE = 23195

summary:
A constant representing the Nostr event kind for wallet responses with a value of 23195. This kind is used to identify events that contain responses to wallet requests in the Nostr protocol.

details:
This constant is part of a comprehensive collection of Nostr event kind definitions in the Kinds.ts file. It belongs to the ephemeral event category (20000-30000 range), meaning these events are not expected to be stored by relays. The WALLET_RESPONSE constant is paired with WALLET_REQUEST (23194) as part of the wallet interaction flow in Nostr applications.

import/access examples:
import { WALLET_RESPONSE } from '@welshman/util';
import { WALLET_RESPONSE } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 147:147
id: b92c44bfdd471d53eb424df8dea0b9d8a89c1fefb5d4530bb8bdc0dbf146bead
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L147

declaration:
NOSTR_CONNECT = 24133

summary:
A constant representing the Nostr Connect event kind with a value of 24133. This kind is used for Nostr Connect protocol events, which facilitate secure communication between applications and signing devices in the Nostr ecosystem.

details:
This is a simple constant declaration that assigns the numeric value 24133 to the NOSTR_CONNECT identifier. The constant is exported from the module, making it available for import in other files. It's part of a larger collection of event kind constants defined in the Kinds.ts file, which categorizes different types of Nostr events.

import/access examples:
import { NOSTR_CONNECT } from '@welshman/util';
import { NOSTR_CONNECT } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 148:148
id: 9d6c2908f64407dcc0da07bf98f3da2b2047fdb9cb4551c89dbb73dd6a181baa
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L148

declaration:
HTTP_AUTH = 27235

summary:
A constant representing the HTTP_AUTH event kind in the Nostr protocol with a value of 27235. This kind is used for HTTP authentication events in the Nostr ecosystem.

details:
This constant is part of a comprehensive collection of Nostr event kind definitions. It belongs to the ephemeral event range (20000-30000), which means these events are not expected to be stored by relays. HTTP_AUTH is specifically defined with the value 27235, indicating its purpose for HTTP authentication within the Nostr protocol.

import/access examples:
import { HTTP_AUTH } from '@welshman/util';
import { HTTP_AUTH } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 149:149
id: ca583d523339a999063c1563046f3a699e6dc57e48ac4cd93688fd8299c32350
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L149

declaration:
NAMED_PEOPLE = 30000

summary:
A constant representing the Nostr event kind for 'NAMED_PEOPLE' with a value of 30000. This is a parameterized replaceable kind of event, which means that for each combination of pubkey, kind, and the 'd' tag, only the latest event is expected to be stored by relays.

details:
This constant is part of a comprehensive collection of Nostr event kind definitions. It falls within the range of 30000-40000, which according to the implementation in this file (see isParameterizedReplaceableKind function) identifies it as a parameterized replaceable event. The constant is exported from the module, making it available for use in other parts of the application that need to identify or work with NAMED_PEOPLE events.

import/access examples:
import { NAMED_PEOPLE } from '@welshman/util';
import { NAMED_PEOPLE } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 150:150
id: 02edb7e2b55e6e5e503e0fb7c4d2b8eaf8b9eb0cb5bb2e004f24dbd859a0faeb
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L150

declaration:
NAMED_RELAYS = 30002

summary:
A constant representing the Nostr event kind for named relays. The value is 30002, which falls within the parameterized replaceable kind range (30000-40000), meaning for each combination of pubkey, kind, and d tag, only the latest event should be stored by relays.

details:
This constant is part of a comprehensive collection of Nostr event kind definitions. It's categorized as a parameterized replaceable event (30000-40000 range), which means relays should only store the latest version of this event for a given pubkey and d tag combination. Named relays (kind 30002) are typically used to store lists of relays with names/labels for organization purposes.

import/access examples:
import { NAMED_RELAYS } from '@welshman/util';
import { NAMED_RELAYS } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 151:151
id: 0eec06a52967d5e6496203c755a953f0e80bf155899c2a03e4ae1cd4def382b0
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L151

declaration:
NAMED_BOOKMARKS = 30003

summary:
A constant representing the Nostr event kind for named bookmarks with a value of 30003. This is a parameterized replaceable kind, meaning that for each combination of pubkey, kind, and d tag, only the latest event should be stored by relays.

details:
This constant is part of a comprehensive collection of Nostr event kind definitions in the Kinds.ts file. It falls within the parameterized replaceable kind range (30000-39999) as defined by the isParameterizedReplaceableKind function in the same file. Named bookmarks (30003) are likely used to store user bookmark collections with names/identifiers specified in the d tag.

import/access examples:
import { NAMED_BOOKMARKS } from '@welshman/util';
import { NAMED_BOOKMARKS } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 152:152
id: fa4c816675f39cd5dc46d0ae281a86373e96d579d84b615a1a4041940889f50c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L152

declaration:
NAMED_CURATIONS = 30004

summary:
A constant representing the Nostr event kind for named curations, with a value of 30004. This is a parameterized replaceable kind, meaning that for each combination of pubkey, kind, and d tag, only the latest event should be stored by relays.

details:
This constant is part of a larger collection of Nostr event kind definitions in the Kinds.ts file. It falls within the parameterized replaceable kind range (30000-39999) as defined by the isParameterizedReplaceableKind function in the same file. Named curations (30004) are likely used for storing curated lists of content that can be referenced by a name parameter.

import/access examples:
import { NAMED_CURATIONS } from '@welshman/util';
import { NAMED_CURATIONS } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 153:153
id: 6123039062b7bbca4c5a881ae706ed753d147cba8f1520e02b5051857f8b4c95
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L153

declaration:
NAMED_WIKI_AUTHORS = 30101

summary:
A constant representing the Nostr event kind for named wiki authors with a value of 30101. This is a parameterized replaceable kind of event, meaning that for each combination of pubkey, kind, and d tag, only the latest event is expected to be stored by relays.

details:
This constant is part of a larger collection of Nostr event kind definitions in the Kinds.ts file. It falls within the parameterized replaceable kind range (30000-39999) as defined by the isParameterizedReplaceableKind function in the same file. The constant is exported from both the Kinds module and the main index file, making it available for use throughout the project.

import/access examples:
import { NAMED_WIKI_AUTHORS } from '@welshman/util';
import { NAMED_WIKI_AUTHORS } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 154:154
id: b82ec8793d43e90d6163bb724e39d3c840abc907ac479e71b4ed052a872699ec
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L154

declaration:
NAMED_WIKI_RELAYS = 30102

summary:
A constant representing the Nostr event kind for named wiki relays with a value of 30102. This is a parameterized replaceable kind, meaning that for each combination of pubkey, kind, and d tag, only the latest event should be stored by relays.

details:
This constant is part of a comprehensive collection of Nostr event kind definitions. It falls within the parameterized replaceable kind range (30000-39999), which means these events are intended to replace older versions with the same pubkey, kind, and d tag. The NAMED_WIKI_RELAYS constant specifically represents events related to named collections of relays used for wiki functionality in the Nostr ecosystem.

import/access examples:
import { NAMED_WIKI_RELAYS } from '@welshman/util';
import { NAMED_WIKI_RELAYS } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 155:155
id: 474c4b129aea946af8e75e6e04f5bab2e2f8dccecee971f1095f6e662f723db8
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L155

declaration:
NAMED_EMOJIS = 30030

summary:
A constant representing the Nostr event kind for named emojis with a value of 30030. This is a parameterized replaceable kind, meaning that for each combination of pubkey, kind, and d tag, only the latest event should be stored by relays.

details:
This constant is part of a comprehensive collection of Nostr event kind definitions. It falls within the range 30000-40000, which classifies it as a parameterized replaceable event kind as defined by the isParameterizedReplaceableKind function in the same file. Named emojis (kind 30030) are likely used for custom emoji definitions that can be referenced across the Nostr protocol.

import/access examples:
import { NAMED_EMOJIS } from '@welshman/util';
import { NAMED_EMOJIS } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 156:156
id: d24ff38d4f0b91e382b986ea2c5e64b25b9b1f41c201579958b6953d74dfe273
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L156

declaration:
NAMED_TOPICS = 30015

summary:
A constant representing the Nostr event kind for named topics. In the Nostr protocol, this kind (30015) is used for parameterized replaceable events that store named topic information. This means for each combination of pubkey, kind (30015), and the 'd' tag, only the latest event is stored by relays.

details:
This constant is part of a comprehensive collection of Nostr event kind definitions. It falls within the parameterized replaceable kind range (30000-39999) as defined by the isParameterizedReplaceableKind function in the same file. Named topics (30015) are likely used for organizing or categorizing content in a way that can be updated over time, with relays only keeping the most recent version.

import/access examples:
import { NAMED_TOPICS } from '@welshman/util';
import { NAMED_TOPICS } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 157:157
id: a03d30b3783f9047f6a479f476b172ea909b4c52f27adfa448aa5dfbc497dc66
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L157

declaration:
NAMED_ARTIFACTS = 30063

summary:
A constant representing the Nostr event kind for named artifacts. The value is 30063, which falls within the parameterized replaceable kind range (30000-40000), meaning that for each combination of pubkey, kind, and d tag, only the latest event should be stored by relays.

details:
This constant is part of a comprehensive collection of Nostr event kind definitions in the Kinds.ts file. It belongs to the parameterized replaceable kinds category (30000-40000) as indicated by its value. The naming convention follows the pattern of other 'NAMED_*' constants in the file, suggesting it's used for identifying or categorizing artifacts within the Nostr protocol.

import/access examples:
import { NAMED_ARTIFACTS } from '@welshman/util';
import { NAMED_ARTIFACTS } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 158:158
id: c4af4326e10f79098b8fdc8c6c7ecf0531f0077c87d7ee4e1670ceca4525235e
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L158

declaration:
NAMED_COMMUNITIES = 30064

summary:
A constant representing the Nostr event kind for named communities. The value is 30064, which falls within the range of parameterized replaceable events (30000-40000), meaning that for each combination of pubkey, kind, and d tag, only the latest event should be stored by relays.

details:
This constant is part of a larger collection of Nostr event kind definitions in the Kinds.ts file. It specifically defines the NAMED_COMMUNITIES kind (30064), which is categorized as a parameterized replaceable event based on its numerical range. The implementation is straightforward - it's a simple constant export that can be imported and used throughout the application to maintain consistent event kind references.

import/access examples:
import { NAMED_COMMUNITIES } from '@welshman/util';
import { NAMED_COMMUNITIES } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 159:159
id: 2f57253c2c544b153b33e017911029c43cd599235f02cd3f27519e8e8e73a49d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L159

declaration:
BADGES = 30008

summary:
A constant representing the Nostr event kind for badges, with a value of 30008. This kind is categorized as a parameterized replaceable event, meaning that for each combination of pubkey, kind, and d tag, only the latest event should be stored by relays.

details:
This constant is part of a larger collection of Nostr event kind definitions in the Kinds.ts file. The value 30008 falls within the range of 30000-40000, which according to the implementation in this file, classifies it as a parameterized replaceable kind (as defined by the isParameterizedReplaceableKind function). The constant is exported and made available through both the Kinds module and the main index export.

import/access examples:
import { BADGES } from '@welshman/util';
import { BADGES } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 160:160
id: 0c19b8e04970aec06a0050249de67734377fa39f208efb567881e47d03abb512
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L160

declaration:
BADGE_DEFINITION = 30009

summary:
A constant representing the Nostr event kind for badge definition, with a value of 30009. This is a parameterized replaceable kind of event, meaning that for each combination of pubkey, kind, and d tag, only the latest event should be stored by relays.

details:
This constant is part of a comprehensive collection of Nostr event kind definitions in the Kinds.ts file. The BADGE_DEFINITION constant with value 30009 falls within the range of parameterized replaceable kinds (30000-39999) as defined by the isParameterizedReplaceableKind function in the same file. These constants are used throughout the application to identify different types of Nostr events in a type-safe manner.

import/access examples:
import { BADGE_DEFINITION } from '@welshman/util';
import { BADGE_DEFINITION } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 161:161
id: 19748dbd4b481a55e19e7c0cab457c1574bebae654133cfe516c19eccee86ead
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L161

declaration:
STALL = 30017

summary:
A constant representing the Nostr event kind for a 'STALL', with a value of 30017. This is a parameterized replaceable kind event, meaning that for each combination of pubkey, kind, and the 'd' tag, only the latest event is expected to be stored by relays, with older versions being discarded.

details:
This constant is part of a collection of Nostr event kind identifiers. The value 30017 falls within the range of 30000-40000, which classifies it as a parameterized replaceable kind as defined by the isParameterizedReplaceableKind function in the same file. It appears to be related to marketplace or e-commerce functionality within the Nostr protocol, as it's defined alongside other related constants like PRODUCT (30018) and MARKET_UI (30019).

import/access examples:
import { STALL } from '@welshman/util';
import { STALL } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 162:162
id: 0792f2cc33052541e2cde0174a07d59146515c565cfbabdf877c086d9c1b7ba5
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L162

declaration:
PRODUCT = 30018

summary:
A constant representing the Nostr event kind for a product. In the Nostr protocol, kind 30018 is used to identify events that contain product information. This is a parameterized replaceable kind, meaning that for each combination of pubkey, kind, and d tag, only the latest event should be stored by relays.

details:
This constant is part of a larger collection of Nostr event kind identifiers. The value 30018 falls within the range of 30000-40000, which as defined by the isParameterizedReplaceableKind function in this file, indicates it's a parameterized replaceable event type. This means relays should only store the most recent version of this event for a given combination of pubkey, kind, and d tag value.

The constant appears to be related to e-commerce or marketplace functionality within the Nostr ecosystem, as it's defined near other related constants like STALL (30017) and MARKET_UI (30019).

import/access examples:
import { PRODUCT } from '@welshman/util';
import { PRODUCT } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 163:163
id: 78accb2849186c9aef0a6a429dbaadf1c8c8f5713fb6e3a82c9b309297123f41
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L163

declaration:
MARKET_UI = 30019

summary:
A constant representing the MARKET_UI event kind in the Nostr protocol with a value of 30019. This is a parameterized replaceable kind, meaning that for each combination of pubkey, kind, and d tag, only the latest event is expected to be stored by relays.

details:
This constant is part of a larger collection of event kind constants defined in the Kinds.ts file. The MARKET_UI kind (30019) falls within the range of 30000-40000, which classifies it as a parameterized replaceable event according to the isParameterizedReplaceableKind function in the same file. It appears to be related to market user interfaces in the context of the Nostr protocol, possibly used for defining or updating market UI configurations.

import/access examples:
import { MARKET_UI } from '@welshman/util';
import { MARKET_UI } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 164:164
id: f955e8879e2b83158ac2f133d6244fbe01cd6e0d680ab0170df9cadcb61e2dea
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L164

declaration:
PRODUCT_SOLD_AS_AUCTION = 30020

summary:
A constant representing the Nostr event kind for products sold as auctions. The value is 30020, which falls within the parameterized replaceable kind range (30000-40000), meaning for each combination of pubkey, kind, and d tag, only the latest event should be stored by relays.

details:
This constant is part of a comprehensive collection of Nostr event kind definitions. As a parameterized replaceable kind (30000-40000), PRODUCT_SOLD_AS_AUCTION events are designed to be updated over time while maintaining a stable identifier through the combination of pubkey, kind, and d tag. It appears to be related to e-commerce functionality within the Nostr ecosystem, specifically for auction-based product sales, and is likely used alongside other marketplace-related kinds like STALL (30017), PRODUCT (30018), and MARKET_UI (30019).

import/access examples:
import { PRODUCT_SOLD_AS_AUCTION } from '@welshman/util';
import { PRODUCT_SOLD_AS_AUCTION } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 165:165
id: db5a8998c52aa6daacd12b9d8217d48ed4fdc5a46301b736b22c1932bfdcee9e
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L165

declaration:
WIKI = 30818

summary:
A constant representing the kind number for WIKI events in the Nostr protocol. The value is 30818, which falls within the range of parameterized replaceable kinds (30000-40000), meaning that for each combination of pubkey, kind, and d tag, only the latest event should be stored by relays.

details:
This constant is part of a larger collection of event kind constants defined in the Kinds.ts file. It represents a parameterized replaceable kind (30000-40000 range) specifically for wiki content in the Nostr protocol. Being in this range means that relays should only store the latest event for each combination of pubkey, kind (30818), and d tag value, discarding older versions.

import/access examples:
import { WIKI } from '@welshman/util';
import { WIKI } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 166:166
id: c5a36644af36119343241d04e55f910c56d9f728e4e745f0fa1fbb6be6c2f789
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L166

declaration:
LONG_FORM = 30023

summary:
A constant representing the kind number for long-form content in the Nostr protocol. The value is 30023, which falls within the parameterized replaceable kind range (30000-40000), meaning that for each combination of pubkey, kind, and d tag, only the latest event should be stored by relays.

details:
This constant is part of a larger collection of kind constants defined in the Kinds.ts file. It represents long-form content in the Nostr protocol ecosystem. Being in the 30000-40000 range, it's classified as a parameterized replaceable kind, as indicated by the isParameterizedReplaceableKind function in the same file. This means relays should only store the latest version of content with this kind for a specific combination of pubkey and d tag value.

import/access examples:
import { LONG_FORM } from '@welshman/util';
import { LONG_FORM } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 167:167
id: fed6da1c8799beacf9231ff8d83a0bd29cbc4cfddd0eaa8e8856675cd09a263d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L167

declaration:
LONG_FORM_DRAFT = 30024

summary:
A constant representing the Nostr event kind for long-form content drafts, with a value of 30024. This is a parameterized replaceable kind, meaning that for each combination of pubkey, kind, and d tag, only the latest event should be stored by relays.

details:
This constant is part of a comprehensive collection of Nostr event kind definitions. As a parameterized replaceable kind (30000-39999 range), LONG_FORM_DRAFT events are designed to be updated/replaced rather than accumulated. The value 30024 indicates it's related to LONG_FORM (30023), but specifically represents draft content that's still being worked on and not yet published as a final long-form post.

import/access examples:
import { LONG_FORM_DRAFT } from '@welshman/util';
import { LONG_FORM_DRAFT } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 168:168
id: ad0efb60011dc47e7e3fbe5d6f73c32c9449a383559f5d35759b78553f3ba8a2
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L168

declaration:
APP_DATA = 30078

summary:
A constant representing the Nostr event kind for application data. The APP_DATA kind is defined as 30078, which falls within the parameterized replaceable event range (30000-40000). This means that for each combination of pubkey, kind (30078), and the 'd' tag, only the latest event should be stored by relays.

details:
This constant is part of a comprehensive collection of Nostr event kind definitions. It's categorized as a parameterized replaceable event (30000-40000 range), which means relays should only keep the latest version of events with this kind for a specific combination of pubkey and 'd' tag value. APP_DATA (30078) is likely intended for applications to store their specific data in a way that can be updated over time while maintaining a consistent identifier.

import/access examples:
import { APP_DATA } from '@welshman/util';
import { APP_DATA } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 169:169
id: b98ea4b458b262e6ba90f8c726e012f1f74c18c038de8db69916476d72a0de79
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L169

declaration:
LIVE_EVENT = 30311

summary:
A constant representing the kind number for a LIVE_EVENT in the Nostr protocol. The value is 30311, which falls within the range of parameterized replaceable events (30000-40000), meaning that for each combination of pubkey, kind, and d tag, only the latest event is expected to be stored by relays.

details:
This is a simple constant declaration that defines the numeric identifier for LIVE_EVENT kind in the Nostr protocol ecosystem. As a parameterized replaceable kind (in the 30000-40000 range), it follows the behavior where relays should only keep the most recent event with the same pubkey, kind, and d tag value, discarding older versions. This constant is exported from both the Kinds module and the main index file, making it available for use throughout the application.

import/access examples:
import { LIVE_EVENT } from '@welshman/util';
import { LIVE_EVENT } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 170:170
id: 26c95fc393be1aa7c25447baeb36e23c76bc0604bb54a7c9a001a1ac74f0d02d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L170

declaration:
STATUS = 30315

summary:
A constant representing the Nostr event kind for status updates. The value is 30315, which falls within the range of parameterized replaceable events (30000-40000), meaning that for each combination of pubkey, kind, and d tag, only the latest event should be stored by relays.

details:
This is a simple constant declaration that defines the numeric value for the STATUS event kind in the Nostr protocol. As a parameterized replaceable kind (in the 30000-40000 range), it follows the behavior defined by the isParameterizedReplaceableKind function in the same file. The constant is exported and made available through both the Kinds module and the main index export.

import/access examples:
import { STATUS } from '@welshman/util';
import { STATUS } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 171:171
id: 985edea84cb67fc8ed36c3ae6d66661ff7ae494b228e29fff3c92c617fa072de
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L171

declaration:
CLASSIFIED = 30402

summary:
A constant representing the Nostr event kind for classified content with a value of 30402. This is a parameterized replaceable kind, meaning that for each combination of pubkey, kind, and d tag, only the latest event should be stored by relays.

details:
This constant is part of a larger collection of Nostr event kind definitions. As a parameterized replaceable kind (30000-39999 range), CLASSIFIED events follow the behavior where relays should only store the most recent version for a given pubkey+kind+d-tag combination. This allows for updating classified content while maintaining a consistent identifier.

import/access examples:
import { CLASSIFIED } from '@welshman/util';
import { CLASSIFIED } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 172:172
id: 733e2626ddb9f48467b024ef83ae220e48c22d3c59b9cc215d686591602a2239
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L172

declaration:
DRAFT_CLASSIFIED = 30403

summary:
A constant representing the Nostr event kind for draft classified content. The value is 30403, which falls within the parameterized replaceable event range (30000-40000), meaning for each combination of pubkey, kind, and d tag, only the latest event should be stored by relays.

details:
This constant is part of a comprehensive collection of Nostr event kind definitions. As a parameterized replaceable kind (30000-40000), DRAFT_CLASSIFIED events allow users to update their draft classified content while maintaining only the latest version on relays. The implementation is straightforward - it's simply a named constant with the value 30403 that makes the code more readable and maintainable by providing semantic meaning to this specific event kind number.

import/access examples:
import { DRAFT_CLASSIFIED } from '@welshman/util';
import { DRAFT_CLASSIFIED } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 173:173
id: 2a2f9a08f95e8b6e28c3178a5b2eb8fdd2babe78ae83f5cb4b85ed1c1992f978
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L173

declaration:
AUDIO = 31337

summary:
A constant representing the AUDIO event kind in the Nostr protocol with a value of 31337. This kind is used to identify audio-related events in the Nostr network and is categorized as a parameterized replaceable kind, meaning that for each combination of pubkey, kind, and d tag, only the latest event should be stored by relays.

details:
This constant is part of a comprehensive set of event kind definitions for the Nostr protocol. Based on its value (31337), it falls within the range of parameterized replaceable kinds (30000-39999) as defined by the isParameterizedReplaceableKind function in the same file. This means that relays should only store the latest version of an audio event for a specific combination of pubkey, kind, and d tag value.

import/access examples:
import { AUDIO } from '@welshman/util';
import { AUDIO } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 174:174
id: 1c837c4383e67cf4bc3eebc7de62e2d23876872c4fb048f7269dda9c7943279c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L174

declaration:
FEED = 31890

summary:
A constant representing the FEED event kind in the Nostr protocol with a value of 31890. This kind is used to identify feed-related events in the Nostr network. It falls into the parameterized replaceable kind category (30000-39999), meaning for each combination of pubkey, kind, and d tag, only the latest event should be stored by relays.

details:
This constant is part of a comprehensive collection of Nostr event kind definitions. As a parameterized replaceable kind (31890 falls between 30000-40000), it follows the behavior defined by the isParameterizedReplaceableKind function. This means relays should only store the most recent version of an event with this kind for a specific combination of pubkey and d tag value.

import/access examples:
import { FEED } from '@welshman/util';
import { FEED } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 175:175
id: 373eff9f69e2e70f21d8ac800ec0a161d5b29a1b7c1087a57544710268f8bc15
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L175

declaration:
CALENDAR = 31924

summary:
A constant representing the CALENDAR event kind in the Nostr protocol with a value of 31924. This is a parameterized replaceable kind, meaning that for each combination of pubkey, kind, and d tag, only the latest event is expected to be stored by relays.

details:
This constant is part of a comprehensive collection of Nostr event kind definitions. Based on its value (31924), it falls within the range of parameterized replaceable kinds (30000-40000), which means events of this kind are intended to be replaceable based on a combination of pubkey, kind, and the d tag parameter. The CALENDAR kind is likely used for calendar-related data in Nostr applications, and appears to be related to other calendar/event constants like EVENT_DATE, EVENT_TIME, and EVENT_RSVP which are defined nearby in the file.

import/access examples:
import { CALENDAR } from '@welshman/util';
import { CALENDAR } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 176:176
id: d1462b855a86a0042e3a28857af6d6915ec117557e1af3d1eeadf5eebcb490d6
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L176

declaration:
EVENT_DATE = 31922

summary:
A constant representing the Nostr event kind for EVENT_DATE with a value of 31922. This is a parameterized replaceable kind (30000-39999 range) used in the Nostr protocol to represent date information for events.

details:
This constant is part of a comprehensive collection of Nostr event kind definitions. As a parameterized replaceable kind (in the 30000-39999 range), it means that for each combination of pubkey, kind (31922), and the 'd' tag, only the latest event should be stored by relays, with older versions being discarded. It appears to be related to calendar functionality in the Nostr ecosystem, likely working alongside other calendar-related kinds like CALENDAR (31924), EVENT_TIME (31923), and EVENT_RSVP (31925).

import/access examples:
import { EVENT_DATE } from '@welshman/util';
import { EVENT_DATE } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 177:177
id: 08cde781756a60d51c4f385d012ba1619cbd22dab2bf2ae32818a568821f2823
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L177

declaration:
EVENT_TIME = 31923

summary:
A constant representing the event kind number for EVENT_TIME in the Nostr protocol. The value is 31923, which falls within the range of parameterized replaceable events (30000-40000), meaning that for each combination of pubkey, kind, and d tag, only the latest event should be stored by relays.

details:
This constant is part of a comprehensive collection of Nostr event kind definitions. EVENT_TIME (31923) appears to be related to calendar functionality in the Nostr ecosystem, as it's defined near other calendar-related constants like CALENDAR (31924) and EVENT_DATE (31922). As a parameterized replaceable kind (in the 30000-40000 range), relays are expected to only keep the latest version of these events for a given pubkey and d tag combination.

import/access examples:
import { EVENT_TIME } from '@welshman/util';
import { EVENT_TIME } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 178:178
id: 1d4275e8717af85b671d2fd9424f5f181640b8da7832b2c707688b07c419a508
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L178

declaration:
EVENT_RSVP = 31925

summary:
A constant representing the Nostr event kind for event RSVPs (Répondez s'il vous plaît - response to an invitation). The value is 31925, which falls within the parameterized replaceable event range (30000-40000), meaning for each combination of pubkey, kind, and d tag, only the latest event should be stored by relays.

details:
This constant is part of a comprehensive collection of Nostr event kind definitions. It belongs to the calendar/event-related kinds (along with CALENDAR, EVENT_DATE, EVENT_TIME) in the 31900s range. As a parameterized replaceable event (30000-40000 range), it follows the Nostr protocol specification where relays should only keep the latest version of an event with this kind for a specific combination of pubkey and d tag value.

import/access examples:
import { EVENT_RSVP } from '@welshman/util';
import { EVENT_RSVP } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 179:179
id: 2f08980d129ae2e276de9cf8b80c0c974636ff72b5aa0d8f7f8277106646fb3e
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L179

declaration:
HANDLER_RECOMMENDATION = 31989

summary:
A constant representing the Nostr event kind for handler recommendations, with a value of 31989. This is a parameterized replaceable kind of event, meaning that for each combination of pubkey, kind, and d tag, only the latest event should be stored by relays.

details:
This constant is part of a comprehensive collection of Nostr event kind definitions in the Kinds.ts file. It falls within the range 30000-40000, which according to the implementation in this file, categorizes it as a parameterized replaceable kind (as defined by the isParameterizedReplaceableKind function). The constant is exported from both the Kinds module and the main index file, making it available for use throughout the project.

import/access examples:
import { HANDLER_RECOMMENDATION } from '@welshman/util';
import { HANDLER_RECOMMENDATION } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 180:180
id: 3672264d3529dc3272bcb0a12dd995edad652a58da3a051b1b4dbfba291063c2
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L180

declaration:
HANDLER_INFORMATION = 31990

summary:
A constant representing the Nostr event kind for handler information, with a value of 31990. This kind is used to identify events that provide information about handlers in the Nostr protocol.

details:
This is a simple constant declaration that's part of a larger collection of Nostr event kind identifiers. It belongs to the parameterized replaceable kind range (30000-40000), which means that for each combination of pubkey, kind, and d tag, only the latest event should be stored by relays. The constant is exported from the module, making it available for use in other parts of the application.

import/access examples:
import { HANDLER_INFORMATION } from '@welshman/util';
import { HANDLER_INFORMATION } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 181:181
id: 065026efaace78d86f90a25218a845d9b2a36dbe4683315aaa788e86ed719a4b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L181

declaration:
ALERT_EMAIL = 32830

summary:
A constant representing the ALERT_EMAIL event kind in the Nostr protocol with a value of 32830. This kind is likely used for events related to email alerts or notifications within the Nostr ecosystem. It falls into the parameterized replaceable event category (30000-39999 range), meaning for each combination of pubkey, kind, and d tag, only the latest event should be stored by relays.

details:
This constant is part of a comprehensive collection of Nostr event kind definitions. Based on its numerical value (32830), it's classified as a parameterized replaceable event (30000-39999 range). It appears to be grouped with other alert-related constants (ALERT_STATUS, ALERT_WEB, ALERT_ANDROID, ALERT_IOS) which suggests it's part of a notification system within the Nostr protocol. The implementation is straightforward - just a named constant with a specific numerical value that conforms to the Nostr event kind classification system.

import/access examples:
import { ALERT_EMAIL } from '@welshman/util';
import { ALERT_EMAIL } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 182:182
id: 56b6356a5b78159c2f7ce8fc67dbc9e3bfb9cc39f6730bbaa1bd040f72c16651
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L182

declaration:
ALERT_STATUS = 32831

summary:
A constant representing the ALERT_STATUS event kind in the Nostr protocol with a value of 32831. This kind is categorized as a parameterized replaceable event, meaning that for each combination of pubkey, kind, and d tag, only the latest event should be stored by relays.

details:
This constant is part of a comprehensive collection of Nostr event kind definitions. Based on its value (32831), it falls within the range of parameterized replaceable events (30000-40000). It appears to be part of an alert system alongside other related constants like ALERT_EMAIL, ALERT_WEB, ALERT_ANDROID, and ALERT_IOS, suggesting it's used for status notifications in a multi-platform alert system.

import/access examples:
import { ALERT_STATUS } from '@welshman/util';
import { ALERT_STATUS } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 183:183
id: c4467fad1632b4c27a368316663c1754b00795cd3de1a2efc58ebd26dc27f630
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L183

declaration:
ALERT_WEB = 32832

summary:
A constant representing the ALERT_WEB kind number (32832) in the Nostr protocol. This kind is likely used for web-based alerts or notifications within the Nostr ecosystem.

details:
This is a simple constant declaration that assigns the numeric value 32832 to the ALERT_WEB identifier. It belongs to a collection of event kind constants defined in the Kinds.ts file, which categorizes different types of Nostr events. Based on its value (32832), it appears to be a parameterized replaceable kind (30000-40000 range) and is grouped with other alert-related constants (ALERT_EMAIL, ALERT_STATUS, ALERT_ANDROID, ALERT_IOS).

import/access examples:
import { ALERT_WEB } from '@welshman/util';
import { ALERT_WEB } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 184:184
id: 13edbf77ee865545231b0bf1a3461f8bc82659edc590f56d5382a6d0823fab7a
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L184

declaration:
ALERT_ANDROID = 32833

summary:
A constant representing the Nostr event kind for Android alerts with a value of 32833. This kind is used to identify events related to Android alert notifications in the Nostr protocol.

details:
This constant is part of a comprehensive collection of Nostr event kind definitions. It belongs to the parameterized replaceable kind range (30000-40000), which means that for each combination of pubkey, kind, and d tag, only the latest event should be stored by relays. The constant follows the Nostr naming convention where the prefix 'ALERT_' indicates its category, and 'ANDROID' specifies the platform.

import/access examples:
import { ALERT_ANDROID } from '@welshman/util';
import { ALERT_ANDROID } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 185:185
id: 8b471dcbe9ef52d0d2cf1fe219148ddee7eb812aae6ef55f70ae46b265051f99
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L185

declaration:
ALERT_IOS = 32834

summary:
A constant representing the kind number for iOS alerts in the Nostr protocol. The value is 32834, which falls within the parameterized replaceable kind range (30000-40000), meaning for each combination of pubkey, kind, and d tag, only the latest event should be stored by relays.

details:
This constant is part of a comprehensive collection of Nostr event kind definitions. It belongs to a group of alert-related constants (along with ALERT_EMAIL, ALERT_STATUS, ALERT_WEB, and ALERT_ANDROID) in the 32830-32834 range. As a parameterized replaceable kind (30000-40000), it follows the Nostr protocol specification where relays are expected to only keep the latest version of events with this kind for a specific combination of pubkey and d tag value.

import/access examples:
import { ALERT_IOS } from '@welshman/util';
import { ALERT_IOS } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 186:186
id: 8981955bb28d39c5311b37258968dc5868b28ce2730d9b69ca8e4633f9eae1d1
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L186

declaration:
COMMUNITY = 34550

summary:
A constant representing the Nostr event kind for community events with a value of 34550. This kind is a parameterized replaceable event type, meaning that for each combination of pubkey, kind, and 'd' tag, only the latest event should be stored by relays.

details:
This constant is part of a larger collection of Nostr event kind definitions. As a parameterized replaceable kind (in the 30000-39999 range), COMMUNITY events follow specific storage rules in the Nostr protocol. The value 34550 indicates this is a specialized event type for community-related data that relays should handle according to the parameterized replaceable rules.

import/access examples:
import { COMMUNITY } from '@welshman/util';
import { COMMUNITY } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 187:187
id: ee63fca7b20e490c65423a234bacc4f3c489f9d47402403d822e4ffbd43f6af3
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L187

declaration:
ROOM = 35834

summary:
A constant representing the Nostr event kind for a room, with a value of 35834. This kind is used to identify events related to room functionality in the Nostr protocol.

details:
This is a simple constant declaration that defines the numeric value for the ROOM event kind in the Nostr protocol. It belongs to the parameterized replaceable kind range (30000-40000), which means that for each combination of pubkey, kind, and d tag, only the latest event should be stored by relays. This constant is part of a larger collection of event kind definitions that categorize different types of Nostr events.

import/access examples:
import { ROOM } from '@welshman/util';
import { ROOM } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 188:188
id: 3de07dc5053a2ab1f72561c511cb40f4437a862112e0e5a1415b5b64499fec77
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L188

declaration:
ROOM_META = 39000

summary:
A constant representing the ROOM_META event kind in the Nostr protocol with a value of 39000. This kind is likely used for storing metadata about rooms in the Nostr network.

details:
This constant is part of a larger collection of event kind definitions in the Nostr protocol. Based on its value (39000), it falls into the parameterized replaceable kind range (30000-40000), which means that for each combination of pubkey, kind, and d tag, only the latest event should be stored by relays. It appears to be related to room functionality, possibly storing configuration or descriptive information about rooms.

import/access examples:
import { ROOM_META } from '@welshman/util';
import { ROOM_META } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 189:189
id: 03b45ce93d2487a9f8896de0ab98412c20acc68395c4868d60bfe84003555f3b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L189

declaration:
ROOM_ADMINS = 39001

summary:
A constant representing the Nostr event kind for room administrators with a value of 39001. This kind is used to identify events that contain information about administrators of a room in the Nostr protocol.

details:
This constant is part of a larger collection of Nostr event kind definitions in the Kinds.ts file. It belongs to the room-related event kinds (along with ROOM, ROOM_META, etc.) and is used to categorize events that specify who has administrative privileges in a Nostr room. Based on its value (39001), it appears to be a parameterized replaceable kind, meaning that for each combination of pubkey, kind, and d-tag, only the latest event should be stored by relays.

import/access examples:
import { ROOM_ADMINS } from '@welshman/util';
import { ROOM_ADMINS } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 190:190
id: 358a8507eff39e06f870a67c2d4ce5a3118c23cc1d5ee2187b989385408b1c18
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L190

declaration:
FOLLOW_PACK = 39089

summary:
A constant representing the kind number for a 'FOLLOW_PACK' event in the Nostr protocol. The value is 39089, which falls within the range of parameterized replaceable events (30000-40000), meaning that for each combination of pubkey, kind, and 'd' tag, only the latest event should be stored by relays.

details:
This constant is part of a larger collection of event kind definitions in the Nostr protocol. As a parameterized replaceable kind (in the 30000-40000 range), FOLLOW_PACK events are designed to be replaceable based on the combination of pubkey, kind, and 'd' tag. The implementation is straightforward - it's simply a named constant with the value 39089 that's exported from the module.

import/access examples:
import { FOLLOW_PACK } from '@welshman/util';
import { FOLLOW_PACK } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 192:192
id: 8f23d4053862d4623acc3067fde0f5fc81f44c802b809fc03501ed787b527e67
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L192

declaration:
DEPRECATED_RELAY_RECOMMENDATION = 2

summary:
A constant representing the deprecated relay recommendation event kind in the Nostr protocol with a value of 2. This event kind is no longer recommended for use in current implementations.

details:
This is a simple constant declaration that defines the numeric value for a deprecated event kind in the Nostr protocol. It's part of a larger collection of event kind constants that categorize different types of events in the Nostr ecosystem. The constant is exported from the module, making it available for import by other parts of the application.

import/access examples:
import { DEPRECATED_RELAY_RECOMMENDATION } from '@welshman/util';
import { DEPRECATED_RELAY_RECOMMENDATION } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 193:193
id: b9a207896eb5d9a46d970fa01c6d518e87c51fd347114bcadd500d00b95281cb
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L193

declaration:
DEPRECATED_DIRECT_MESSAGE = 4

summary:
A constant representing the deprecated direct message kind in the Nostr protocol with a value of 4. This kind was previously used for direct messages but has been replaced by newer kinds.

details:
This is a simple constant declaration that assigns the value 4 to the variable DEPRECATED_DIRECT_MESSAGE. It's part of a collection of constants that define various event kinds in the Nostr protocol. The constant is marked as deprecated, indicating that it should no longer be used in new code, likely in favor of newer message kinds like DIRECT_MESSAGE (14) or MESSAGE (9).

import/access examples:
import { DEPRECATED_DIRECT_MESSAGE } from '@welshman/util';
import { DEPRECATED_DIRECT_MESSAGE } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Kinds.ts
lines: 194:194
id: 35ec24b8de2cb3dd7726fbe356eac22d70d9cf58bc4c365ad92953fe962e1968
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts#L194

declaration:
DEPRECATED_NAMED_GENERIC = 30001

summary:
A constant representing a deprecated Nostr event kind with value 30001, previously used for named generic events. This constant is exported from the module and is part of the Nostr protocol's kind numbering system.

details:
This is a simple constant declaration that defines the value 30001 for a deprecated Nostr event kind. It's marked with the 'DEPRECATED_' prefix to indicate it should no longer be used. The constant is part of a larger collection of event kind definitions in the Kinds.ts file, which categorizes different types of Nostr events (regular, replaceable, ephemeral, etc.). This particular kind was likely superseded by more specific named event kinds in the 30000-39999 range.

import/access examples:
import { DEPRECATED_NAMED_GENERIC } from '@welshman/util';
import { DEPRECATED_NAMED_GENERIC } from '@welshman/util/Kinds';


=========================
workspace: packages/util
file: packages/util/src/Relay.ts
lines: 5:9
id: e6488c1c05cb4f72a90ffebc83bdaec3f192362d8e74d0eaeba0e581c545d687
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Relay.ts#L5

declaration:
export enum RelayMode {
  Read = "read",
  Write = "write",
  Inbox = "inbox",
}

summary:
The `RelayMode` enum represents the different operational modes for a relay in a Nostr network. It defines three possible states: `Read` for read-only access, `Write` for write access, and `Inbox` for inbox functionality.

details:
This is a simple TypeScript enum that maps string literal values to named constants. Each mode has a specific string value that likely corresponds to how the relay functionality is identified in the application:
- Read: "read" - Likely used when the relay is in read-only mode
- Write: "write" - Likely used when the relay allows write operations
- Inbox: "inbox" - Likely used when the relay functions as a message inbox

import/access examples:
import { RelayMode } from '@welshman/util';
import { RelayMode } from '@welshman/util/Relay';


=========================
workspace: packages/util
file: packages/util/src/Relay.ts
lines: 11:31
id: e9ba2fb9d09d0f778a5a93cb360eb7e95dc13721022cae0d9e5c73dab8a5eba5
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Relay.ts#L11

declaration:
export type RelayProfile = {
  url: string
  icon?: string
  banner?: string
  name?: string
  self?: string
  pubkey?: string
  contact?: string
  software?: string
  version?: string
  negentropy?: number
  description?: string
  supported_nips?: number[]
  privacy_policy?: string
  terms_of_service?: string
  limitation?: {
    min_pow_difficulty?: number
    payment_required?: boolean
    auth_required?: boolean
  }
}

summary:
A TypeScript type definition representing the profile information of a relay server in a Nostr network. It contains various optional properties that describe the relay's identity, capabilities, and operational parameters.

details:
The `RelayProfile` type is a comprehensive structure that captures metadata about a relay server with:
1. Required `url` field for the relay's address
2. Optional display-related fields (`icon`, `banner`, `name`)
3. Identity fields (`self`, `pubkey`)
4. Technical information (`software`, `version`, `negentropy`)
5. Descriptive text (`description`)
6. Protocol support (`supported_nips` as an array of NIP numbers)
7. Legal documents (`privacy_policy`, `terms_of_service`)
8. Usage limitations as a nested object with fields for:
   - Proof-of-work requirements (`min_pow_difficulty`)
   - Payment requirements (`payment_required`)
   - Authentication requirements (`auth_required`)

import/access examples:
import type { RelayProfile } from '@welshman/util';
import type { RelayProfile } from '@welshman/util/Relay';


=========================
workspace: packages/util
file: packages/util/src/Relay.ts
lines: 35:56
id: fb415901862b31596b71bb253631167fcc76cb6cd10761b8177a82e7bb1504ec
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Relay.ts#L35

declaration:
isRelayUrl = (url: string) => {
  if (!url.includes("://")) {
    url = "wss://" + url
  }

  // Skip non-ws urls
  if (!url.match(/^wss?:\/\//)) return false

  // Skip urls with a slash before the dot
  if (url.match(/\\.*\./)) return false

  // Skip non-localhost urls without a dot
  if (!url.match(/\./) && !url.includes("localhost")) return false

  try {
    new URL(url)
  } catch (e) {
    return false
  }

  return true
}

summary:
A function that validates if a string is a valid relay URL. It accepts a string parameter and returns a boolean indicating whether the string represents a valid relay URL. The function automatically prepends 'wss://' if no protocol is specified.

details:
The implementation performs several validation checks:
1. If the URL doesn't include a protocol ('://'), it prepends 'wss://' to it
2. Rejects URLs that don't use WebSocket protocol (must start with 'ws://' or 'wss://')
3. Rejects URLs with a backslash before a dot (invalid URL pattern)
4. Rejects URLs without a dot unless they contain 'localhost'
5. Attempts to construct a URL object to validate the overall URL structure

The function returns true only if all validation checks pass, otherwise returns false.

import/access examples:
import { isRelayUrl } from '@welshman/util';
import { isRelayUrl } from '@welshman/util/Relay';


=========================
workspace: packages/util
file: packages/util/src/Relay.ts
lines: 58:58
id: 4a9df12c0329e719f51936c56ee847d3040910f9d935e5864702a62e6f749265
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Relay.ts#L58

declaration:
isOnionUrl = (url: string) => Boolean(stripProtocol(url).match(/^[a-z2-7]{56}.onion/))

summary:
A function that checks if a URL is an Onion URL (Tor hidden service). It takes a string URL as input and returns a boolean indicating whether the URL matches the pattern for an Onion v3 address.

details:
The implementation uses the `stripProtocol` utility function to remove the protocol part of the URL (like 'http://' or 'https://'), then applies a regular expression to check if the remaining string matches the Onion address format. Specifically, it checks for 56 characters in the range [a-z2-7] followed by '.onion'. This pattern identifies Tor hidden service addresses (version 3).

import/access examples:
import { isOnionUrl } from '@welshman/util';
import { isOnionUrl } from '@welshman/util/Relay';


=========================
workspace: packages/util
file: packages/util/src/Relay.ts
lines: 60:61
id: d148351d6294d51bd832473b861d989602b223e04d72954d8e52e28b28591ce6
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Relay.ts#L60

declaration:
isLocalUrl = (url: string) =>
  Boolean(url.match(/\.local(:[\d]+)?\/?$/) || stripProtocol(url).match(/^localhost:/))

summary:
A function that checks if a URL is a local URL. It returns true if the URL ends with '.local' (optionally followed by a port number) or if it's a localhost URL.

details:
The implementation uses regular expressions to identify two types of local URLs:
1. URLs ending with '.local', optionally followed by a port number and slash (e.g., 'example.local', 'example.local:8080', 'example.local/')
2. URLs that start with 'localhost:' after stripping the protocol

It uses the Boolean constructor to ensure a boolean return value and the stripProtocol utility function to remove the protocol part of the URL when checking for localhost.

import/access examples:
import { isLocalUrl } from '@welshman/util';
import { isLocalUrl } from '@welshman/util/Relay';


=========================
workspace: packages/util
file: packages/util/src/Relay.ts
lines: 63:63
id: b807b47946e51c50a333ae67b336b9297991aac4fb065df46da735af0605c580
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Relay.ts#L63

declaration:
isIPAddress = (url: string) => Boolean(url.match(/\d+\.\d+\.\d+\.\d+/))

summary:
A utility function that checks if a given URL string contains an IP address in the format of four numbers separated by dots (e.g., 192.168.1.1). Returns true if the URL contains an IP address pattern, false otherwise.

details:
The implementation uses a regular expression to match the standard IPv4 address pattern (\d+\.\d+\.\d+\.\d+) within the provided URL string. The function wraps the result in a Boolean constructor to ensure a boolean return value. This is a simple, single-line implementation with no side effects or complex logic.

import/access examples:
import { isIPAddress } from '@welshman/util';
import { isIPAddress } from '@welshman/util/Relay';


=========================
workspace: packages/util
file: packages/util/src/Relay.ts
lines: 65:65
id: 06971825bf93bdcdefb19c9785f1240882bfb1710254b063c1e914aa7f2df25c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Relay.ts#L65

declaration:
isShareableRelayUrl = (url: string) => Boolean(isRelayUrl(url) && !isLocalUrl(url))

summary:
A function that checks if a given URL is a shareable relay URL. It returns true if the URL is a valid relay URL and not a local URL.

details:
This function combines two other utility functions:
1. `isRelayUrl` - Checks if the URL is a valid relay URL
2. `isLocalUrl` - Checks if the URL is a local URL

The implementation uses Boolean() to ensure a boolean return value from the logical expression that checks if the URL is both a valid relay URL AND not a local URL.

import/access examples:
import { isShareableRelayUrl } from '@welshman/util';
import { isShareableRelayUrl } from '@welshman/util/Relay';


=========================
workspace: packages/util
file: packages/util/src/Relay.ts
lines: 67:82
id: f82b1efa7cf351de7c458dcd2b2dab17a286f2102596df9e74d537ab9f07294b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Relay.ts#L67

declaration:
normalizeRelayUrl = (url: string) => {
  const prefix = url.match(/^wss?:\/\//)?.[0] || (isOnionUrl(url) ? "ws://" : "wss://")

  // Use our library to normalize
  url = normalizeUrl(url, {stripHash: true, stripAuthentication: false})

  // Strip the protocol, lowercase
  url = stripProtocol(url).toLowerCase()

  // Urls without pathnames are supposed to have a trailing slash
  if (!url.includes("/")) {
    url += "/"
  }

  return prefix + url
}

summary:
Normalizes a relay URL to ensure consistent formatting. It takes a URL string as input and returns a standardized version with appropriate protocol prefix (wss:// or ws://), lowercase domain, and proper trailing slash. This function helps maintain consistency when storing or comparing relay URLs.

details:
The implementation:
1. Determines the appropriate protocol prefix:
   - Preserves existing websocket protocol if present
   - Uses 'ws://' for onion URLs (Tor hidden services)
   - Defaults to 'wss://' for all other URLs
2. Normalizes the URL using an external 'normalizeUrl' utility, stripping hash fragments but preserving authentication
3. Removes the protocol prefix and converts the remaining URL to lowercase
4. Ensures URLs without pathnames have a trailing slash
5. Reconstructs the final URL by combining the prefix with the normalized URL

import/access examples:
import { normalizeRelayUrl } from '@welshman/util';
import { normalizeRelayUrl } from '@welshman/util/Relay';


=========================
workspace: packages/util
file: packages/util/src/Relay.ts
lines: 84:84
id: 4e217f0a2d8d85a349b5813eabc26ba1ae33b2867b648c4b537ec3c2778e99e9
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Relay.ts#L84

declaration:
displayRelayUrl = (url: string) => last(url.split("://")).replace(/\/$/, "")

summary:
A utility function that formats a relay URL for display by removing the protocol prefix and trailing slash. It takes a URL string as input and returns a more user-friendly version of the URL.

details:
This function performs two operations on the input URL:
1. Removes the protocol prefix (like 'wss://' or 'ws://') by splitting the URL at '://' and taking the last part
2. Removes any trailing slash with a regular expression replacement

It uses the 'last' utility function imported from '@welshman/lib' to get the final segment after splitting.

related: last

import/access examples:
import { displayRelayUrl } from '@welshman/util';
import { displayRelayUrl } from '@welshman/util/Relay';


=========================
workspace: packages/util
file: packages/util/src/Relay.ts
lines: 86:87
id: 2c473d4c2a6e74e17c4a59e5d942216ba7b220c64477c42dd137a40263c81f91
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Relay.ts#L86

declaration:
displayRelayProfile = (profile?: RelayProfile, fallback = "") =>
  profile?.name || fallback

summary:
A utility function that returns a display name for a relay profile. It takes an optional RelayProfile object and a fallback string (defaulting to an empty string). Returns the profile's name if available, otherwise returns the fallback value.

details:
This is a simple arrow function that uses the optional chaining operator (?.) to safely access the name property of the profile object if it exists. If the profile is undefined or doesn't have a name property, it returns the fallback value instead. The implementation is straightforward with no side effects or complex logic.

related: name,RelayProfile

import/access examples:
import { displayRelayProfile } from '@welshman/util';
import { displayRelayProfile } from '@welshman/util/Relay';


=========================
workspace: packages/util
file: packages/util/src/Tags.ts
lines: 5:9
id: 3db9ccfa79a530727f68a884edcf627e9253466afab48905c878c8386a8a333e
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Tags.ts#L5

declaration:
getTags = (types: string | string[], tags: string[][]) => {
  types = ensurePlural(types)

  return tags.filter(t => types.includes(t[0]))
}

summary:
The `getTags` function filters an array of tags based on specified types. It accepts a string or array of strings representing tag types and an array of tag arrays, returning only those tags whose first element (type) matches any of the specified types.

details:
This function implements a simple tag filtering mechanism:
1. It first ensures the `types` parameter is always an array by using the `ensurePlural` utility function
2. It then uses the standard JavaScript `filter` method to return only those tag arrays where the first element (the tag type at index 0) is included in the provided types array
3. The implementation is straightforward with no complex logic or side effects

import/access examples:
import { getTags } from '@welshman/util';
import { getTags } from '@welshman/util/Tags';


=========================
workspace: packages/util
file: packages/util/src/Tags.ts
lines: 11:15
id: 3e268fa5ed438639edc9d7599f75582736ab8804dd21b3398e9421e91dcd019c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Tags.ts#L11

declaration:
getTag = (types: string | string[], tags: string[][]) => {
  types = ensurePlural(types)

  return tags.find(t => types.includes(t[0]))
}

summary:
The `getTag` function retrieves the first tag from an array of tags that matches any of the specified types. It accepts a single type or an array of types to match against the first element of each tag, and returns the matching tag array or undefined if no match is found.

details:
The implementation is straightforward:
1. It first ensures the `types` parameter is an array by using the `ensurePlural` utility function, which converts a single string to an array if needed.
2. It then uses the JavaScript `find()` method on the tags array to return the first tag where its first element (the tag type at index 0) is included in the types array.
3. If no matching tag is found, it returns undefined (implicit in the `find()` method behavior).

import/access examples:
import { getTag } from '@welshman/util';
import { getTag } from '@welshman/util/Tags';


=========================
workspace: packages/util
file: packages/util/src/Tags.ts
lines: 17:18
id: d28ec4c30daf779b766e69c4e47b725b5371218ac14127fb78b80d65cf707885
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Tags.ts#L17

declaration:
getTagValues = (types: string | string[], tags: string[][]) =>
  getTags(types, tags).map(nth(1))

summary:
The `getTagValues` function extracts values from tags that match specified types. It takes a string or array of strings representing tag types and a two-dimensional array of tags, and returns an array containing only the values (second element) of matching tags.

details:
This function works by:
1. Using the `getTags` function to filter tags that match the specified types
2. Then mapping over the filtered tags using the `nth(1)` function to extract only the second element (index 1) of each tag array

It's a simple utility function that combines filtering and mapping operations to extract specific values from a tag collection.

related: __function,getTags

import/access examples:
import { getTagValues } from '@welshman/util';
import { getTagValues } from '@welshman/util/Tags';


=========================
workspace: packages/util
file: packages/util/src/Tags.ts
lines: 20:20
id: efe273ce1b6ca5ad8a72ee2182d4ddc4b067c766a56e44d10054278dc879a1b9
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Tags.ts#L20

declaration:
getTagValue = (types: string | string[], tags: string[][]) => getTag(types, tags)?.[1]

summary:
The `getTagValue` function retrieves the value (second element) of the first tag that matches any of the specified types from an array of tags. It accepts a string or array of strings representing tag types to match, and a two-dimensional array of strings representing tags. Returns the value of the first matching tag or undefined if no match is found.

details:
This function is a simple utility that builds on the `getTag` function. It first finds a matching tag using `getTag`, then uses the optional chaining operator (`?.[1]`) to safely access the second element (index 1) of the found tag array, which represents the tag's value. If no matching tag is found, it returns undefined.

related: __function,getTag

import/access examples:
import { getTagValue } from '@welshman/util';
import { getTagValue } from '@welshman/util/Tags';


=========================
workspace: packages/util
file: packages/util/src/Tags.ts
lines: 22:23
id: 23fa497a80fd15bb027218aeff23b0a3669fca4667805e72fadcae1ffd9e95f1
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Tags.ts#L22

declaration:
getEventTags = (tags: string[][]) =>
  tags.filter(t => ["e"].includes(t[0]) && t[1].length === 64)

summary:
The `getEventTags` function filters an array of tags to return only event tags. It accepts a 2D string array of tags and returns a subset of those tags where the first element is 'e' and the second element is a 64-character string (likely a hex event ID).

details:
This function implements a simple filter operation on the provided tags array. It checks two conditions:
1. The tag type (first element) must be 'e' (representing an event reference)
2. The tag value (second element) must be exactly 64 characters long, which is the standard length for Nostr event IDs (hex-encoded 32 bytes)

The implementation uses the Array.filter() method with a predicate function that applies these two conditions.

import/access examples:
import { getEventTags } from '@welshman/util';
import { getEventTags } from '@welshman/util/Tags';


=========================
workspace: packages/util
file: packages/util/src/Tags.ts
lines: 25:25
id: 62ad9e016da3e28994ced630a503e2b8ec598ed1b7e1483805024465773de495
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Tags.ts#L25

declaration:
getEventTagValues = (tags: string[][]) => getEventTags(tags).map(nth(1))

summary:
The `getEventTagValues` function extracts values from event tags in a Nostr event. It takes an array of string arrays (tags) and returns an array of event IDs (64-character hexadecimal strings) by filtering for tags with type 'e' and extracting their values.

details:
This function works in two steps:
1. It calls `getEventTags(tags)` which filters the input tags array for entries where the first element is 'e' and the second element is a 64-character string (likely a Nostr event ID)
2. It then maps over the filtered tags using the `nth(1)` function to extract just the second element (index 1) from each tag array

The implementation is concise and leverages helper functions to maintain clean code.

related: __function,getEventTags

import/access examples:
import { getEventTagValues } from '@welshman/util';
import { getEventTagValues } from '@welshman/util/Tags';


=========================
workspace: packages/util
file: packages/util/src/Tags.ts
lines: 27:28
id: b8b73c91d79cc67e26425dd42fcb441411107e8cb5bb22de1f1086583529d180
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Tags.ts#L27

declaration:
getAddressTags = (tags: string[][]) =>
  tags.filter(t => ["a"].includes(t[0]) && Address.isAddress(t[1]))

summary:
The `getAddressTags` function filters an array of tags to return only those that are address tags. It identifies address tags by checking if the first element is 'a' and the second element is a valid address according to the Address.isAddress validation function.

details:
This function implements a simple filter operation on the provided tags array. It uses two criteria for filtering:
1. The tag's first element must be the string 'a' (checked using array.includes)
2. The tag's second element must be a valid address, validated using the Address.isAddress utility function

The implementation is a straightforward arrow function that returns the filtered array directly.

import/access examples:
import { getAddressTags } from '@welshman/util';
import { getAddressTags } from '@welshman/util/Tags';


=========================
workspace: packages/util
file: packages/util/src/Tags.ts
lines: 30:30
id: 465e7ecd35e38d404bc822f24a06027330dee2ba81535d8b8ab42db7c25041d2
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Tags.ts#L30

declaration:
getAddressTagValues = (tags: string[][]) => getAddressTags(tags).map(nth(1))

summary:
The `getAddressTagValues` function extracts values from address tags in a Nostr event. It takes an array of string arrays (tags) and returns an array of address values from tags that have 'a' as their first element and contain valid addresses.

details:
This function works in two steps:
1. It calls `getAddressTags(tags)` to filter the input tags array for tags that start with 'a' and contain valid addresses (using the Address.isAddress validation)
2. It then maps over the filtered tags using the `nth(1)` function to extract the second element (index 1) from each tag array, which is the address value

The implementation is concise and follows the same pattern as other tag value extraction functions in this module.

related: __function,getAddressTags

import/access examples:
import { getAddressTagValues } from '@welshman/util';
import { getAddressTagValues } from '@welshman/util/Tags';


=========================
workspace: packages/util
file: packages/util/src/Tags.ts
lines: 32:33
id: 813d9e6cd881965b2bfb337f308c4214ab474089214d3a081c4942136ea44aea
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Tags.ts#L32

declaration:
getPubkeyTags = (tags: string[][]) =>
  tags.filter(t => ["p"].includes(t[0]) && t[1].length === 64)

summary:
The `getPubkeyTags` function filters an array of tags to return only those that are pubkey tags. It identifies pubkey tags as those where the first element is 'p' and the second element is a 64-character string (representing a public key in hex format).

details:
This function implements a simple filter operation on the provided tags array. It uses the Array.filter method with a predicate function that checks two conditions:
1. The tag's first element (t[0]) must be 'p' (checked using the includes method)
2. The tag's second element (t[1]) must be exactly 64 characters long, which is the standard length for a hex-encoded public key in Nostr

The implementation is straightforward with no complex logic or side effects.

import/access examples:
import { getPubkeyTags } from '@welshman/util';
import { getPubkeyTags } from '@welshman/util/Tags';


=========================
workspace: packages/util
file: packages/util/src/Tags.ts
lines: 35:35
id: a46cb58e96c8bf511b4b00c486bedcb3388b1255d8e8fdd349ce2c3cfb41e04d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Tags.ts#L35

declaration:
getPubkeyTagValues = (tags: string[][]) => getPubkeyTags(tags).map(nth(1))

summary:
A function that extracts values from pubkey tags in a Nostr event. It takes an array of string arrays (tags) and returns an array of pubkey values (hex strings of length 64) from tags that have 'p' as their first element.

details:
This function works in two steps:
1. It first calls `getPubkeyTags()` to filter the input tags array for tags that start with 'p' and have a second element of length 64 (valid pubkey format)
2. Then it maps over the filtered tags using the `nth(1)` function (imported from @welshman/lib) to extract just the second element (index 1) from each tag

The implementation is a simple one-liner that composes these two operations.

related: __function,getPubkeyTags

import/access examples:
import { getPubkeyTagValues } from '@welshman/util';
import { getPubkeyTagValues } from '@welshman/util/Tags';


=========================
workspace: packages/util
file: packages/util/src/Tags.ts
lines: 37:37
id: e80c5377037ac515824b91548b2dc3ec89520663be548c79547b512b7c2f1e67
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Tags.ts#L37

declaration:
getTopicTags = (tags: string[][]) => tags.filter(nthEq(0, "t"))

summary:
The `getTopicTags` function filters an array of tags to return only those that have 't' as their first element, which represents topic tags in the Nostr protocol.

details:
This function uses the `nthEq` utility function to create a predicate that checks if the 0th element of each tag array equals 't'. It then applies this predicate with Array.filter() to return only the topic tags from the input tags array. This is a simple implementation that's part of a larger tag filtering system in the codebase.

import/access examples:
import { getTopicTags } from '@welshman/util';
import { getTopicTags } from '@welshman/util/Tags';


=========================
workspace: packages/util
file: packages/util/src/Tags.ts
lines: 39:40
id: ec95c305fa26d271c07356804c1c8842fee391183d85562f1396bd532b6c7db7
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Tags.ts#L39

declaration:
getTopicTagValues = (tags: string[][]) =>
  getTopicTags(tags).map(t => t[1].replace(/^#/, ""))

summary:
The `getTopicTagValues` function extracts topic values from an array of tags. It filters for tags with 't' as the first element (topic tags), then maps each tag to return the second element with any leading '#' character removed.

details:
This function works in two steps:
1. It calls `getTopicTags(tags)` which filters the input tags array for entries where the first element equals 't'
2. It then maps over the filtered tags, taking the second element (index 1) of each tag and removing any leading '#' character using a regular expression replacement

The implementation is concise and leverages the `getTopicTags` helper function to handle the filtering logic.

related: __function,getTopicTags

import/access examples:
import { getTopicTagValues } from '@welshman/util';
import { getTopicTagValues } from '@welshman/util/Tags';


=========================
workspace: packages/util
file: packages/util/src/Tags.ts
lines: 42:43
id: cc0159b25f8e643ce5176947a4fcb4157ab7ba9f73aefb59e84144725e8eb134
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Tags.ts#L42

declaration:
getRelayTags = (tags: string[][]) =>
  tags.filter(t => ["r", "relay"].includes(t[0]) && isRelayUrl(t[1] || ""))

summary:
The `getRelayTags` function filters an array of tags to return only those that are relay tags. It identifies relay tags by checking if the first element of each tag array is either 'r' or 'relay', and if the second element is a valid relay URL.

details:
This function implements tag filtering logic specific to relay tags in the Nostr protocol. It:
1. Takes a 2D array of strings (tags) as input
2. Uses the Array.filter() method to select only tags where:
   - The first element (t[0]) is either 'r' or 'relay'
   - The second element (t[1]) is a valid relay URL (validated by the imported isRelayUrl function)
   - Uses a logical OR with empty string to handle undefined values

The function is part of a larger tag utility module that provides specialized filtering for different Nostr tag types.

import/access examples:
import { getRelayTags } from '@welshman/util';
import { getRelayTags } from '@welshman/util/Tags';


=========================
workspace: packages/util
file: packages/util/src/Tags.ts
lines: 45:45
id: 3c24c321d97b2dc101b4b680185a51e2224f1901204409eb287a40c2fb94dee6
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Tags.ts#L45

declaration:
getRelayTagValues = (tags: string[][]) => getRelayTags(tags).map(nth(1))

summary:
The `getRelayTagValues` function extracts relay URLs from a list of tags. It takes an array of string arrays (tags) as input and returns an array of relay URLs by filtering for tags with type 'r' or 'relay' that contain valid relay URLs, then extracting the URL value from each matching tag.

details:
This function works in two steps:
1. It calls `getRelayTags(tags)` which filters the input tags array for entries where the first element is either 'r' or 'relay' and the second element is a valid relay URL (validated by the `isRelayUrl` function)
2. It then maps over the filtered tags using the `nth(1)` function to extract just the second element (index 1) from each tag array, which contains the relay URL

The implementation is concise and leverages helper functions to maintain clean code.

related: __function,getRelayTags

import/access examples:
import { getRelayTagValues } from '@welshman/util';
import { getRelayTagValues } from '@welshman/util/Tags';


=========================
workspace: packages/util
file: packages/util/src/Tags.ts
lines: 47:48
id: 60ad511dfa063cb645095368ca2cdece084e4bcd10470ea89c5137f023a4fbef
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Tags.ts#L47

declaration:
getGroupTags = (tags: string[][]) =>
  tags.filter(t => ["h", "group"].includes(t[0]) && t[1] && isRelayUrl(t[2] || ""))

summary:
The `getGroupTags` function filters an array of tags to extract group tags. It identifies tags where the first element is either 'h' or 'group', the second element exists (has a value), and the third element is a valid relay URL. Returns an array of matching tag arrays.

details:
This function implements a simple filtering operation on a tags array. It uses three criteria for filtering:
1. The tag type (first element) must be either 'h' or 'group'
2. The tag must have a value in the second position (t[1] must be truthy)
3. The third element (t[2]) must be a valid relay URL, which is validated using the imported `isRelayUrl` function

The function returns all tag arrays that match these criteria, preserving their original structure.

import/access examples:
import { getGroupTags } from '@welshman/util';
import { getGroupTags } from '@welshman/util/Tags';


=========================
workspace: packages/util
file: packages/util/src/Tags.ts
lines: 50:50
id: 944b7b981ebe45ee4ba7bc5f6ea94f1046dfc1b35bf21686616a6bdfb78a3fca
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Tags.ts#L50

declaration:
getGroupTagValues = (tags: string[][]) => getGroupTags(tags).map(nth(1))

summary:
A function that extracts values from group tags in a Nostr event. It takes an array of tags and returns an array of group identifiers from tags with type 'h' or 'group' that have a valid relay URL in the third position.

details:
This function works in two steps:
1. It calls `getGroupTags()` to filter the input tags array for entries that have 'h' or 'group' as their first element, a non-empty second element, and a valid relay URL in the third position
2. It then maps over the filtered tags using the `nth(1)` function to extract just the second element (the group identifier) from each tag

The implementation relies on the `getGroupTags` function defined earlier in the file and the `nth` utility function imported from '@welshman/lib'.

related: __function,getGroupTags

import/access examples:
import { getGroupTagValues } from '@welshman/util';
import { getGroupTagValues } from '@welshman/util/Tags';


=========================
workspace: packages/util
file: packages/util/src/Tags.ts
lines: 52:53
id: 373b5699f3f056c712afe8040778f271d7d1bca250d68871cae18573d1602727
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Tags.ts#L52

declaration:
getKindTags = (tags: string[][]) =>
  tags.filter(t => ["k"].includes(t[0]) && t[1].match(/^\d+$/))

summary:
The `getKindTags` function filters an array of tag arrays to return only those that have 'k' as their first element and a numeric string as their second element. It's used to extract kind tags from a collection of tags.

details:
This function implements a simple filter operation on the input tags array. It checks two conditions for each tag:
1. The first element (t[0]) must be 'k'
2. The second element (t[1]) must match the regular expression /^\d+$/, which ensures it contains only digits

The implementation is a one-liner that uses Array.filter() with these conditions combined in a logical AND expression.

import/access examples:
import { getKindTags } from '@welshman/util';
import { getKindTags } from '@welshman/util/Tags';


=========================
workspace: packages/util
file: packages/util/src/Tags.ts
lines: 55:55
id: 85a59c84ff4668c1b57ab5b9176f9b04645dd040679e2ee8601bca5032b092a9
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Tags.ts#L55

declaration:
getKindTagValues = (tags: string[][]) => getKindTags(tags).map(t => parseInt(t[1]))

summary:
A function that extracts and parses kind tag values from a list of tags. It returns an array of integers representing the kind values found in the tags array.

details:
This function works in two steps:
1. It first calls `getKindTags()` to filter the input tags array for tags that have 'k' as their first element and a numeric string as their second element
2. Then it maps over the filtered tags, converting each tag's second element (the kind value) from string to integer using `parseInt()`

The function is a simple composition that leverages the `getKindTags` helper function and array mapping to transform string values to integers.

related: __function,getKindTags

import/access examples:
import { getKindTagValues } from '@welshman/util';
import { getKindTagValues } from '@welshman/util/Tags';


=========================
workspace: packages/util
file: packages/util/src/Tags.ts
lines: 57:62
id: 2b240ea395a963261744b9835f0ee4c43ea206f4c1e1ddcb7ca9bb3c034d285d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Tags.ts#L57

declaration:
getCommentTags = (tags: string[][]) => {
  const roots = tags.filter(t => ["A", "E", "P", "K"].includes(t[0]))
  const replies = tags.filter(t => ["a", "e", "p", "k"].includes(t[0]))

  return {roots, replies}
}

summary:
The `getCommentTags` function extracts comment-related tags from a given array of tags. It categorizes tags into two groups: 'roots' (uppercase tag types A, E, P, K) and 'replies' (lowercase tag types a, e, p, k). Returns an object with these two categorized arrays.

details:
This function implements a simple filtering mechanism to separate tags into two categories based on their first element (tag type):

1. It first filters the input tags array to find 'root' tags, which are identified by uppercase letters A, E, P, K in the first position.
2. It then filters the input tags array again to find 'reply' tags, which are identified by lowercase letters a, e, p, k in the first position.
3. Finally, it returns an object containing both filtered arrays as properties 'roots' and 'replies'.

The implementation is straightforward, using array filtering with includes() checks on the first element of each tag.

import/access examples:
import { getCommentTags } from '@welshman/util';
import { getCommentTags } from '@welshman/util/Tags';


=========================
workspace: packages/util
file: packages/util/src/Tags.ts
lines: 64:68
id: f02c5a1d45252cf17d7c92f9c04abf8b51fa1803409b0d2d7d011671607a82c6
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Tags.ts#L64

declaration:
getCommentTagValues = (tags: string[][]) =>
  mapVals(
    tags => tags.filter(t => ["a", "e"].includes(t[0].toLowerCase())).map(nth(1)),
    getCommentTags(tags),
  )

summary:
Extracts comment tag values from a list of tags. This function takes an array of string arrays (tags) and returns an object with 'roots' and 'replies' properties, each containing arrays of tag values (second element) from tags that have 'a' or 'e' as their first element.

details:
This function works by:
1. Calling `getCommentTags(tags)` to get an object with 'roots' and 'replies' properties
2. Using `mapVals` to transform each property in that object
3. For each property, it filters the tags to only include those with first element ('a' or 'e') and extracts the second element using `nth(1)`
4. The filtering is case-insensitive through the use of `toLowerCase()`

It relies on the `getCommentTags` function which separates tags into 'roots' (uppercase tag types) and 'replies' (lowercase tag types).

related: mapVals

import/access examples:
import { getCommentTagValues } from '@welshman/util';
import { getCommentTagValues } from '@welshman/util/Tags';


=========================
workspace: packages/util
file: packages/util/src/Tags.ts
lines: 70:104
id: b50712878b76ada258cb34b9d787461fef13085ec19ff67cd694c792929b3007
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Tags.ts#L70

declaration:
getReplyTags = (tags: string[][]) => {
  const validTags = tags.filter(t => ["a", "e", "q"].includes(t[0]))
  const mentionTags = validTags.filter(nthEq(0, "q"))
  const roots: string[][] = []
  const replies: string[][] = []
  const mentions: string[][] = []

  const dispatchTags = (thisTags: string[][]) =>
    thisTags.forEach((t: string[], i: number) => {
      if (t[3] === "root") {
        if (validTags.filter(nthEq(3, "reply")).length === 0) {
          replies.push(t)
        } else {
          roots.push(t)
        }
      } else if (t[3] === "reply") {
        replies.push(t)
      } else if (t[3] === "mention") {
        mentions.push(t)
      } else if (i === thisTags.length - 1) {
        replies.push(t)
      } else if (i === 0) {
        roots.push(t)
      } else {
        mentions.push(t)
      }
    })

  // Add different types separately so positional logic works
  dispatchTags(validTags.filter(nthEq(0, "e")))
  dispatchTags(validTags.filter(nthEq(0, "a")).filter(t => Boolean(t[3])))
  mentionTags.forEach((t: string[]) => mentions.push(t))

  return {roots, replies, mentions}
}

summary:
Processes an array of tags to categorize them into roots, replies, and mentions based on their type and position. It filters for valid tags (those with first element 'a', 'e', or 'q'), then sorts them into appropriate categories based on their marker (position 3) or position in the array. Returns an object with three arrays: roots, replies, and mentions.

details:
The implementation works by:
1. Filtering the input tags for valid types ('a', 'e', 'q')
2. Separately identifying mention tags (type 'q')
3. Creating empty arrays for roots, replies, and mentions
4. Defining a helper function 'dispatchTags' that categorizes tags based on:
   - Marker value at position 3 ('root', 'reply', 'mention')
   - Special case handling for 'root' tags when no 'reply' tags exist
   - Position in the array (last item defaults to reply, first to root, others to mentions)
5. Processing tags in specific order:
   - First all 'e' type tags
   - Then 'a' type tags that have a marker (position 3)
   - Finally adding all mention tags to the mentions array
6. Returning the categorized collections

import/access examples:
import { getReplyTags } from '@welshman/util';
import { getReplyTags } from '@welshman/util/Tags';


=========================
workspace: packages/util
file: packages/util/src/Tags.ts
lines: 106:107
id: 9f5673ca27cb20965730f33d05eeb7526565af4e642930a2fbaf42f6fa0fb610
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Tags.ts#L106

declaration:
getReplyTagValues = (tags: string[][]) =>
  mapVals(tags => tags.map(nth(1)), getReplyTags(tags))

summary:
A function that extracts values from reply tags in a Nostr event. It takes an array of tags and returns an object with 'roots', 'replies', and 'mentions' properties, each containing arrays of tag values (the second element of each tag).

details:
This function works by:
1. Calling `getReplyTags(tags)` to get an object with categorized tags (roots, replies, mentions)
2. Using `mapVals` to transform each category by extracting just the second element (index 1) from each tag using the `nth(1)` utility function
3. The implementation relies on the `getReplyTags` function which does the complex work of categorizing tags based on their type and position

related: mapVals

import/access examples:
import { getReplyTagValues } from '@welshman/util';
import { getReplyTagValues } from '@welshman/util/Tags';


=========================
workspace: packages/util
file: packages/util/src/Tags.ts
lines: 109:109
id: 943c7aa27e60a4e76638b5cc17a3e18d227f63519d5aabf7b3224d41a93e8c1d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Tags.ts#L109

declaration:
getEmojiTags = (name: string, tags: string[][]) => tags.filter(spec(["emoji", name]))

summary:
The `getEmojiTags` function filters an array of tags to find emoji tags that match a specific name. It takes a name string and an array of string arrays (tags) as parameters, and returns an array of matching emoji tags.

details:
This function uses the `filter` method on the tags array, applying the `spec` utility function (imported from '@welshman/lib') with an array argument containing 'emoji' and the provided name. The `spec` function likely creates a predicate that checks if a tag's first element is 'emoji' and the second element matches the provided name.

import/access examples:
import { getEmojiTags } from '@welshman/util';
import { getEmojiTags } from '@welshman/util/Tags';


=========================
workspace: packages/util
file: packages/util/src/Tags.ts
lines: 111:111
id: 84dbaa72e06abc4b53d3633cfe320bfe09a4e74a3bf1119d538db1bee8b0c61d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Tags.ts#L111

declaration:
getEmojiTag = (name: string, tags: string[][]) => first(getEmojiTags(name, tags))

summary:
Retrieves the first emoji tag matching the specified name from a collection of tags. This function takes a name parameter (string) and a tags parameter (string[][]) and returns the first tag array that matches the emoji name or undefined if no match is found.

details:
This function is a simple wrapper around two other functions:
1. It calls `getEmojiTags(name, tags)` to filter all tags that match the specified emoji name
2. It then uses the `first()` utility function (imported from '@welshman/lib') to return just the first matching tag

The implementation is straightforward and relies on the `getEmojiTags` function to do the actual filtering work.

related: first

import/access examples:
import { getEmojiTag } from '@welshman/util';
import { getEmojiTag } from '@welshman/util/Tags';


=========================
workspace: packages/util
file: packages/util/src/Tags.ts
lines: 113:114
id: e50dc02f481dd69ec04d63c967480a0ca4fda8bb9e9899da18d086dcd88f294f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Tags.ts#L113

declaration:
getEmojiTagUrls = (name: string, tags: string[][]) =>
  getEmojiTags(name, tags).map(nth(2))

summary:
A function that retrieves URLs from emoji tags with a specific name. It takes a string parameter 'name' representing the emoji name and a 'tags' parameter which is a 2D array of strings. Returns an array of URLs (strings) extracted from the third position of matching emoji tags.

details:
This function works by:
1. Calling the `getEmojiTags` function to filter tags that match the specified emoji name
2. Using the `map` method with the `nth(2)` function to extract the third element (index 2) from each matching tag, which represents the URL

The implementation is a simple one-liner that chains these operations together to transform the filtered tags into an array of URLs.

related: __function,getEmojiTags

import/access examples:
import { getEmojiTagUrls } from '@welshman/util';
import { getEmojiTagUrls } from '@welshman/util/Tags';


=========================
workspace: packages/util
file: packages/util/src/Tags.ts
lines: 116:116
id: 1630612840fb6460930df653aea5f095e0fab0fbaa48bb20d1c7523fb6ab2876
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Tags.ts#L116

declaration:
getEmojiTagUrl = (name: string, tags: string[][]) => first(getEmojiTagUrls(name, tags))

summary:
The `getEmojiTagUrl` function retrieves the URL associated with a specific emoji name from a collection of tags. It takes two parameters: `name` (the emoji name to search for) and `tags` (a two-dimensional array of strings representing tag data). It returns the first URL found for the specified emoji name, or undefined if no matching emoji tag is found.

details:
This function works by first calling `getEmojiTagUrls` with the provided name and tags parameters to get all URLs associated with the specified emoji name. Then it uses the `first` utility function (imported from '@welshman/lib') to return only the first URL from that collection. The implementation is a simple one-liner that composes these two operations together.

related: first

import/access examples:
import { getEmojiTagUrl } from '@welshman/util';
import { getEmojiTagUrl } from '@welshman/util/Tags';


=========================
workspace: packages/util
file: packages/util/src/Tags.ts
lines: 118:118
id: a4a50880360fcc3b2b4b33add5692cda252114539812d156f700e15154c199e6
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Tags.ts#L118

declaration:
uniqTags = (tags: string[][]) => uniqBy(t => t.slice(0, 2).join(":"), tags)

summary:
The `uniqTags` function removes duplicate tags from an array of tags. It considers tags to be duplicates if they have the same tag type and value (the first two elements of each tag array).

details:
This function uses the `uniqBy` utility from the @welshman/lib package to filter out duplicate tags. It creates a unique identifier for each tag by:
1. Taking the first two elements of each tag array (type and value) using `slice(0, 2)`
2. Joining them with a colon separator using `join(":")`

This approach ensures that tags with the same type and value but different additional metadata are considered duplicates, keeping only the first occurrence in the resulting array.

related: uniqBy

import/access examples:
import { uniqTags } from '@welshman/util';
import { uniqTags } from '@welshman/util/Tags';


=========================
workspace: packages/util
file: packages/util/src/Tags.ts
lines: 120:120
id: 107803f0d4d1b59dbc7b76eb68a3a35f5d8902b68d0b02472ca49b81220e75d8
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Tags.ts#L120

declaration:
tagsFromIMeta = (imeta: string[]) => imeta.map((m: string) => m.split(" "))

summary:
Converts an array of strings (imeta) into a two-dimensional array of tags by splitting each string at spaces. This function is useful for parsing metadata strings into the tag format used by Nostr events.

details:
This is a simple transformation function that takes an array of strings and maps over each string, splitting it at spaces to create tag arrays. The implementation is straightforward - it uses JavaScript's built-in map and split methods to transform each string in the input array into an array of substrings.

import/access examples:
import { tagsFromIMeta } from '@welshman/util';
import { tagsFromIMeta } from '@welshman/util/Tags';


=========================
workspace: packages/util
file: packages/util/src/Tags.ts
lines: 122:124
id: 59e4de22d53d6dca4b15808d5b325a767afc61b76573e7cb13f3f43c3491e460
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Tags.ts#L122

declaration:
tagger =
  (name: string) =>
  (value: string, ...args: unknown[]) => [name, value]

summary:
The `tagger` function is a higher-order function that creates tag generators for Nostr events. It takes a tag name and returns a function that accepts a value and additional arguments, producing a tag array with the name and value.

details:
This is a simple curried function implementation that:
1. Takes a tag name as its first parameter
2. Returns a new function that accepts a value and additional arguments (though the additional args are not used in the returned array)
3. The returned function creates a basic tag array in the format [name, value]

This utility helps with creating consistent tag structures for Nostr events, allowing developers to easily generate tag creators for specific tag types.

import/access examples:
import { tagger } from '@welshman/util';
import { tagger } from '@welshman/util/Tags';


=========================
workspace: packages/util
file: packages/util/src/Events.ts
lines: 15:18
id: 71f45c2f33943a8c2e3ecd4a91dd7fc80a4464dcc23148db890f1e46834c8be6
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Events.ts#L15

declaration:
export type EventContent = {
  tags: string[][]
  content: string
}

summary:
EventContent is a TypeScript type alias that represents the basic content structure of a Nostr event. It consists of two properties: 'tags' which is an array of string arrays (representing Nostr event tags), and 'content' which is a string containing the event's content.

details:
This type serves as a foundation for the event type hierarchy in the Nostr protocol implementation. It defines the minimal data structure needed to represent event content without metadata like timestamps, signatures, or identifiers. It's used as a building block for more complex event types like EventTemplate, which adds the 'kind' property to specify the event type.

import/access examples:
import type { EventContent } from '@welshman/util';
import type { EventContent } from '@welshman/util/Events';


=========================
workspace: packages/util
file: packages/util/src/Events.ts
lines: 20:22
id: f5618d6cea3c005180ace790c597c9435e3719e024d1bddc33cddf6bbecdc30e
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Events.ts#L20

declaration:
export type EventTemplate = EventContent & {
  kind: number
}

summary:
EventTemplate is a TypeScript type that represents a template for a Nostr event. It extends EventContent (which includes tags and content) by adding a kind property. This type serves as a base for more complete event types in the Nostr protocol hierarchy.

details:
This type is part of a hierarchy of increasingly specific Nostr event types in the codebase. It builds upon the EventContent type (which contains tags and content) by adding the 'kind' property that specifies the numeric type of the Nostr event. EventTemplate serves as a foundation for more complete event types like StampedEvent, OwnedEvent, HashedEvent, etc., which add additional properties required for a fully formed Nostr event. The type is used throughout the codebase for functions that work with events that have a kind but may not yet have timestamps, signatures, or other required properties of a complete event.

related: EventContent

import/access examples:
import type { EventTemplate } from '@welshman/util';
import type { EventTemplate } from '@welshman/util/Events';


=========================
workspace: packages/util
file: packages/util/src/Events.ts
lines: 24:26
id: d30dbddc10d30f22c1c53072c8b526e719dad3ce4465435217838abdeae1278d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Events.ts#L24

declaration:
export type StampedEvent = EventTemplate & {
  created_at: number
}

summary:
StampedEvent is a TypeScript type that extends EventTemplate by adding a timestamp. It represents a Nostr event that has been assigned a creation timestamp but may not yet have other required fields like pubkey, id, or signature. The created_at field is a Unix timestamp (number) indicating when the event was created.

details:
This type is part of a hierarchy of Nostr event types in the codebase, each adding more properties to represent different stages in an event's lifecycle:

1. EventContent → basic content and tags
2. EventTemplate → adds kind
3. StampedEvent → adds created_at timestamp
4. OwnedEvent → adds pubkey
5. HashedEvent → adds id
6. SignedEvent/UnwrappedEvent → adds signature or wrapping

The type is used throughout the codebase for type checking and ensuring events have the necessary timestamp information before further processing.

related: EventTemplate

import/access examples:
import type { StampedEvent } from '@welshman/util';
import type { StampedEvent } from '@welshman/util/Events';


=========================
workspace: packages/util
file: packages/util/src/Events.ts
lines: 28:30
id: ee2a74e8a26a0e42ba883023fb65c26e4f48ff21e10b49864f8eb32bd4ec70ae
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Events.ts#L28

declaration:
export type OwnedEvent = StampedEvent & {
  pubkey: string
}

summary:
OwnedEvent is a TypeScript type that represents a Nostr event with ownership information. It extends the StampedEvent type by adding a 'pubkey' field, which identifies the public key of the event's creator. This type is part of a hierarchy of event types with increasing levels of completeness.

details:
OwnedEvent sits in the middle of the Nostr event type hierarchy defined in this file:

1. EventContent (basic content and tags)
2. EventTemplate (adds kind)
3. StampedEvent (adds timestamp)
4. OwnedEvent (adds pubkey)
5. HashedEvent (adds id)
6. SignedEvent/UnwrappedEvent/TrustedEvent (adds verification)

The pubkey field is a string that represents the public key of the event creator, which is essential for event ownership verification in the Nostr protocol. This type is used as a building block for more complete event representations that include hashing and signatures.

related: StampedEvent

import/access examples:
import type { OwnedEvent } from '@welshman/util';
import type { OwnedEvent } from '@welshman/util/Events';


=========================
workspace: packages/util
file: packages/util/src/Events.ts
lines: 32:34
id: 6370ef888bbffc5f87b1b9bb0ef1e779a33850474fb97fb9df1bcdbe73498551
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Events.ts#L32

declaration:
export type HashedEvent = OwnedEvent & {
  id: string
}

summary:
HashedEvent is a TypeScript type that represents a Nostr event with a hash identifier. It extends OwnedEvent by adding an 'id' property which contains the event's unique hash string. This type represents an event that has been hashed but may not yet be signed.

details:
HashedEvent builds on the event type hierarchy in this Nostr implementation:
1. It extends OwnedEvent (which already has kind, tags, content, created_at, and pubkey)
2. It adds the 'id' string property which is the unique hash identifier for the event
3. It sits between OwnedEvent and SignedEvent in the type hierarchy
4. It's used in various utility functions like getIdOrAddress, getIdAndAddress, and isChildOf to identify events

related: OwnedEvent

import/access examples:
import type { HashedEvent } from '@welshman/util';
import type { HashedEvent } from '@welshman/util/Events';


=========================
workspace: packages/util
file: packages/util/src/Events.ts
lines: 36:39
id: 89f47113ce3da8f3e97f84b5908c85b25dc0766ce2cc280eda5ed5383efe26a8
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Events.ts#L36

declaration:
export type SignedEvent = HashedEvent & {
  sig: string
  [verifiedSymbol]?: boolean
}

summary:
A type representing a fully signed Nostr event. It extends HashedEvent by adding a signature ('sig') property and an optional verification status marker. This type represents an event that has been cryptographically signed by its creator and can be verified.

details:
This type builds upon the event type hierarchy in the Nostr protocol implementation:
1. It extends HashedEvent (which already contains id, pubkey, created_at, kind, tags, content)
2. Adds the 'sig' property which contains the cryptographic signature
3. Includes an optional verifiedSymbol property that can be used to cache verification status

The verifiedSymbol is imported from nostr-tools/pure and serves as a performance optimization to avoid re-verifying events that have already been checked.

related: HashedEvent

import/access examples:
import type { SignedEvent } from '@welshman/util';
import type { SignedEvent } from '@welshman/util/Events';


=========================
workspace: packages/util
file: packages/util/src/Events.ts
lines: 41:43
id: 5ed1283ada10844fe9a53f13eea2eed56db8d687b0441dccac322adb2325f021
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Events.ts#L41

declaration:
export type UnwrappedEvent = HashedEvent & {
  wrap: SignedEvent
}

summary:
The `UnwrappedEvent` type represents a Nostr event that contains a hashed event with a reference to its original signed version. It extends `HashedEvent` by adding a `wrap` property that holds the original `SignedEvent`. This type is useful for scenarios where you need to work with the content of an event while maintaining a reference to its original signed form.

details:
This type is part of a type hierarchy for Nostr events, sitting between `HashedEvent` and `TrustedEvent`. The `wrap` property contains the original signed event, which allows the system to maintain a reference to the signature and verification status while working with the unwrapped content. This pattern enables verification of the event's authenticity without needing to keep the signature directly on the main event object. The implementation is straightforward - it simply extends `HashedEvent` with an additional `wrap` property of type `SignedEvent`.

related: HashedEvent,SignedEvent

import/access examples:
import type { UnwrappedEvent } from '@welshman/util';
import type { UnwrappedEvent } from '@welshman/util/Events';


=========================
workspace: packages/util
file: packages/util/src/Events.ts
lines: 45:49
id: 9b402300e55fee1926d6f07a27dc15228b8fd211d6aeacfaa0d9570bdbd8557f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Events.ts#L45

declaration:
export type TrustedEvent = HashedEvent & {
  sig?: string
  wrap?: SignedEvent
  [verifiedSymbol]?: boolean
}

summary:
TrustedEvent is a TypeScript type that represents a Nostr event that can be trusted without verification. It extends HashedEvent and can have either a signature (sig), a wrapped signed event (wrap), or a verification symbol. This type is used to represent events that have already been verified or can be trusted without verification.

details:
TrustedEvent is a union type that combines properties from HashedEvent with optional signature and verification properties. It's designed to handle different verification scenarios in the Nostr protocol:

1. It extends HashedEvent which already contains id, pubkey, created_at, kind, tags, and content
2. It adds optional properties:
   - sig?: string - An optional signature
   - wrap?: SignedEvent - An optional wrapped signed event
   - [verifiedSymbol]?: boolean - An optional verification symbol

This type allows the application to work with events that might be verified through different mechanisms (direct signature or wrapped event) or that have already been marked as verified.

related: HashedEvent,SignedEvent

import/access examples:
import type { TrustedEvent } from '@welshman/util';
import type { TrustedEvent } from '@welshman/util/Events';


=========================
workspace: packages/util
file: packages/util/src/Events.ts
lines: 51:55
id: e8c56a1cba1dab5958ac44aba1e05c34f8232323f76cc415cdb679e5f77c5cd0
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Events.ts#L51

declaration:
export type MakeEventOpts = {
  content?: string
  tags?: string[][]
  created_at?: number
}

summary:
MakeEventOpts is a TypeScript interface that defines the optional parameters for creating a Nostr event. It includes three optional properties: content (string), tags (array of string arrays), and created_at (timestamp number).

details:
This type is used as the options parameter for the makeEvent function, providing a structured way to pass optional event properties. The interface is designed to match the Nostr event specification, allowing users to customize event creation without needing to specify all properties. Each property is optional with the makeEvent function providing default values when not specified.

import/access examples:
import type { MakeEventOpts } from '@welshman/util';
import type { MakeEventOpts } from '@welshman/util/Events';


=========================
workspace: packages/util
file: packages/util/src/Events.ts
lines: 59:62
id: 377e40afd1680656e42c5d43c11f9a75187b135d67e4938cd79b0ea448cb8123
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Events.ts#L59

declaration:
makeEvent = (
  kind: number,
  {content = "", tags = [], created_at = now()}: MakeEventOpts = {},
) => ({kind, content, tags, created_at})

summary:
Creates a new event template with specified kind and optional properties. This function is used to initialize a basic event structure in the Nostr protocol.

Parameters:
- kind: number - The kind of event to create
- options: MakeEventOpts (optional) - Configuration object with the following optional properties:
  - content: string - The content of the event (defaults to empty string)
  - tags: string[][] - Array of tags for the event (defaults to empty array)
  - created_at: number - Timestamp for the event (defaults to current time)

Returns: An EventTemplate object containing the kind, content, tags, and created_at properties.

details:
The implementation is straightforward - it's an arrow function that takes a kind parameter and an optional options object with default values. It uses object destructuring with defaults to extract and provide default values for content (empty string), tags (empty array), and created_at (current timestamp from the now() function). The function then returns a new object with these properties using shorthand property notation.

related: MakeEventOpts

import/access examples:
import { makeEvent } from '@welshman/util';
import { makeEvent } from '@welshman/util/Events';


=========================
workspace: packages/util
file: packages/util/src/Events.ts
lines: 66:83
id: cc8df174310df43e1888b3df16b67c84a7e5c84ecebe6bd335b81cbadbe472e1
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Events.ts#L66

declaration:
verifyEvent = (() => {
  let verify = verifyEventPure

  if (typeof WebAssembly === "object") {
    initNostrWasm().then(
      nostrWasm => {
        setNostrWasm(nostrWasm)
        verify = verifyEventWasm
      },
      e => {
        console.warn(e)
      },
    )
  }

  return (event: TrustedEvent) =>
    Boolean(event.sig && (event[verifiedSymbol] || verify(event as SignedEvent)))
})()

summary:
A function that verifies the signature of a Nostr event. It takes a TrustedEvent object as input and returns a boolean indicating whether the event's signature is valid. The function attempts to use WebAssembly for verification if available, falling back to pure JavaScript implementation otherwise.

details:
This function is implemented as an immediately invoked function expression (IIFE) that sets up the verification mechanism and returns the actual verification function. The implementation:

1. Starts with the pure JavaScript implementation (verifyEventPure) as default
2. Checks if WebAssembly is available in the environment
3. If WebAssembly is available, it asynchronously initializes Nostr WASM and switches to the WASM-based verification method for better performance
4. The returned function checks if:
   - The event has a signature (event.sig)
   - AND either:
     - The event is already marked as verified (event[verifiedSymbol])
     - OR the signature can be verified using the selected verification method

The function handles the WebAssembly initialization asynchronously, so it may start with the pure implementation and switch to WASM later if initialization succeeds.

related: __function

import/access examples:
import { verifyEvent } from '@welshman/util';
import { verifyEvent } from '@welshman/util/Events';


=========================
workspace: packages/util
file: packages/util/src/Events.ts
lines: 87:88
id: ea015b9779ae45b7a0e850c73ced7f9a975a42d4f8e2654b6d2c0761a3f514e2
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Events.ts#L87

declaration:
isEventTemplate = (e: EventTemplate): e is EventTemplate =>
  Boolean(typeof e.kind === "number" && Array.isArray(e.tags) && typeof e.content === "string")

summary:
A type guard function that checks if a given object is a valid EventTemplate. It verifies that the object has a numeric 'kind' property, an array 'tags' property, and a string 'content' property. Returns true if the object conforms to the EventTemplate type, false otherwise.

details:
The implementation is a simple type guard that uses Boolean() to ensure a boolean return value. It performs three checks combined with logical AND (&&):
1. Checks if e.kind is a number using typeof
2. Verifies e.tags is an array using Array.isArray()
3. Confirms e.content is a string using typeof

This is a straightforward implementation with no complex logic or side effects.

related: EventTemplate

import/access examples:
import { isEventTemplate } from '@welshman/util';
import { isEventTemplate } from '@welshman/util/Events';


=========================
workspace: packages/util
file: packages/util/src/Events.ts
lines: 90:91
id: 217c6acea5efcb3ad9280a96b6fa068d28a53751db9eeac8a053379b95637ca5
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Events.ts#L90

declaration:
isStampedEvent = (e: StampedEvent): e is StampedEvent =>
  Boolean(isEventTemplate(e) && e.created_at >= 0)

summary:
A type guard function that checks if a given object is a valid StampedEvent. It returns true if the object is an EventTemplate (has kind, tags, and content properties) and has a created_at timestamp that is greater than or equal to 0.

details:
The implementation is straightforward:
1. It uses the Boolean constructor to ensure a boolean return value
2. Inside, it performs two checks:
   - First calls isEventTemplate() to verify the object has the basic event properties
   - Then checks if created_at is a valid timestamp (>= 0)
3. This function is part of a series of type guards that validate different event types in the Nostr protocol hierarchy

related: StampedEvent

import/access examples:
import { isStampedEvent } from '@welshman/util';
import { isStampedEvent } from '@welshman/util/Events';


=========================
workspace: packages/util
file: packages/util/src/Events.ts
lines: 93:94
id: d9c147f7f152dcd98e36ba8814abd01ad79e8fc7da712ce50ae274c4ea534b77
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Events.ts#L93

declaration:
isOwnedEvent = (e: OwnedEvent): e is OwnedEvent =>
  Boolean(isStampedEvent(e) && e.pubkey)

summary:
A type guard function that checks if a given event object is an OwnedEvent. It returns true if the event has a valid timestamp (created_at) and a pubkey property.

details:
The implementation is straightforward:
1. It takes an OwnedEvent parameter and returns a boolean type predicate (e is OwnedEvent)
2. It uses the Boolean constructor to ensure a boolean return value
3. Inside, it performs two checks:
   - First calls isStampedEvent(e) to verify the event has valid timestamp properties
   - Then checks if e.pubkey exists (truthy check)
4. Both conditions must be true for the function to return true

related: OwnedEvent

import/access examples:
import { isOwnedEvent } from '@welshman/util';
import { isOwnedEvent } from '@welshman/util/Events';


=========================
workspace: packages/util
file: packages/util/src/Events.ts
lines: 96:96
id: 3f9e6f651ac29406d45dd02bd5dc39e468b3bfe5322c2759b784fbecc68f2a11
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Events.ts#L96

declaration:
isHashedEvent = (e: HashedEvent): e is HashedEvent => Boolean(isOwnedEvent(e) && e.id)

summary:
A type guard function that checks if an object is a HashedEvent. It returns true if the input is an OwnedEvent (has pubkey and created_at) and also has an 'id' property.

details:
This function implements a TypeScript type guard pattern that narrows the type of the parameter 'e' to HashedEvent if it returns true. It works by:
1. Calling the isOwnedEvent() function to verify the object has the required properties of an OwnedEvent
2. Checking that the object has an 'id' property
3. Using Boolean() to ensure the return value is strictly a boolean

It's part of a chain of type guards in this module that validate increasingly specific event types.

related: HashedEvent

import/access examples:
import { isHashedEvent } from '@welshman/util';
import { isHashedEvent } from '@welshman/util/Events';


=========================
workspace: packages/util
file: packages/util/src/Events.ts
lines: 98:99
id: 38ead9f2ae66fa5c54ecdc33b9ebcd1149646879d0e5f2b35afa171b562df845
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Events.ts#L98

declaration:
isSignedEvent = (e: TrustedEvent): e is SignedEvent =>
  Boolean(isHashedEvent(e) && e.sig)

summary:
A type guard function that checks if a given event is a SignedEvent. It returns true if the event is a HashedEvent and has a 'sig' property, indicating it has been signed.

details:
The implementation is straightforward:
1. It takes a TrustedEvent parameter 'e'
2. It first checks if the event is a HashedEvent using the isHashedEvent() function
3. Then it checks if the event has a 'sig' property
4. It wraps both conditions in Boolean() to ensure a boolean return value
5. The function uses TypeScript's type predicate syntax (e is SignedEvent) to provide type narrowing when used in conditional statements

related: TrustedEvent

import/access examples:
import { isSignedEvent } from '@welshman/util';
import { isSignedEvent } from '@welshman/util/Events';


=========================
workspace: packages/util
file: packages/util/src/Events.ts
lines: 101:102
id: 96355d3f158b4160ca792ec923970ee6914f8a8feb0ad59ab17bc87e9dd2d221
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Events.ts#L101

declaration:
isUnwrappedEvent = (e: TrustedEvent): e is UnwrappedEvent =>
  Boolean(isHashedEvent(e) && e.wrap)

summary:
A type guard function that checks if a given event is an UnwrappedEvent. It returns true if the event is a HashedEvent and has a 'wrap' property, indicating it's an unwrapped event.

details:
The implementation is straightforward:
1. It takes a parameter 'e' of type TrustedEvent
2. It returns a boolean result of a type predicate (e is UnwrappedEvent)
3. It uses the Boolean() constructor to ensure a boolean return value
4. Inside Boolean(), it checks two conditions:
   - First verifies the event is a HashedEvent using the isHashedEvent() function
   - Then checks if the event has a 'wrap' property
5. The function is part of a series of type guards for different event types in the Nostr protocol

related: TrustedEvent

import/access examples:
import { isUnwrappedEvent } from '@welshman/util';
import { isUnwrappedEvent } from '@welshman/util/Events';


=========================
workspace: packages/util
file: packages/util/src/Events.ts
lines: 104:105
id: 7c5d4770be3236d7aed4ce16a001156457854141c830e417aee87e5243edf3dc
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Events.ts#L104

declaration:
isTrustedEvent = (e: TrustedEvent): e is TrustedEvent =>
  isSignedEvent(e) || isUnwrappedEvent(e)

summary:
A type guard function that checks if an event is a trusted event. It returns true if the event is either a signed event or an unwrapped event, confirming that the event can be safely treated as a TrustedEvent type.

details:
This function implements a simple type guard by combining two other type guards: `isSignedEvent` and `isUnwrappedEvent`. It uses a logical OR operation to determine if the provided event meets either criteria. The implementation is straightforward - it doesn't perform any complex validation but relies on the existing type guard functions to verify the event's structure.

related: __function,isSignedEvent,__function,isUnwrappedEvent,TrustedEvent

import/access examples:
import { isTrustedEvent } from '@welshman/util';
import { isTrustedEvent } from '@welshman/util/Events';


=========================
workspace: packages/util
file: packages/util/src/Events.ts
lines: 109:110
id: e838e6662186cb548b137015d6fb295ee2dddc01521480a6397ea024f608b12b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Events.ts#L109

declaration:
asEventTemplate = (e: EventTemplate): EventTemplate =>
  pick(["kind", "tags", "content"], e)

summary:
A function that takes an EventTemplate object and returns a new object containing only the essential properties of an EventTemplate: 'kind', 'tags', and 'content'. This function effectively strips any additional properties from the input object, ensuring it conforms to the EventTemplate type definition.

details:
This function uses the 'pick' utility function (imported from '@welshman/lib') to extract only the specified keys from the input object. It creates a new object with just these three properties, effectively removing any extraneous properties that might have been present in the original object. This is a simple implementation of the type coercion pattern, which ensures that the returned object strictly adheres to the EventTemplate interface.

related: pick,EventTemplate,EventContent

import/access examples:
import { asEventTemplate } from '@welshman/util';
import { asEventTemplate } from '@welshman/util/Events';


=========================
workspace: packages/util
file: packages/util/src/Events.ts
lines: 112:113
id: 247dec24279f172c4a2addc3f71c34e9ef7c62997070495f08de3d0066066d9b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Events.ts#L112

declaration:
asStampedEvent = (e: StampedEvent): StampedEvent =>
  pick(["kind", "tags", "content", "created_at"], e)

summary:
The `asStampedEvent` function takes a `StampedEvent` object and returns a new `StampedEvent` object containing only the essential properties of a stamped event: 'kind', 'tags', 'content', and 'created_at'. This function effectively strips any additional properties that might be present in the input object.

details:
This function uses the `pick` utility function (imported from '@welshman/lib') to extract only the specified properties from the input event object. It's a simple utility function that helps maintain type safety and ensures that the returned object conforms to the `StampedEvent` type definition. The implementation is straightforward - it just selects the specified properties from the input object and returns a new object with only those properties.

related: pick,StampedEvent,EventContent

import/access examples:
import { asStampedEvent } from '@welshman/util';
import { asStampedEvent } from '@welshman/util/Events';


=========================
workspace: packages/util
file: packages/util/src/Events.ts
lines: 115:116
id: e378639e62c17cd7b853c47fb7bf219bc717ba13b4c9ad554153931362ba0bca
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Events.ts#L115

declaration:
asOwnedEvent = (e: OwnedEvent): OwnedEvent =>
  pick(["kind", "tags", "content", "created_at", "pubkey"], e)

summary:
The `asOwnedEvent` function takes an `OwnedEvent` object and returns a new `OwnedEvent` object containing only the essential properties of an owned event: 'kind', 'tags', 'content', 'created_at', and 'pubkey'. This function is used to strip any additional properties from an event object, ensuring it conforms to the `OwnedEvent` type definition.

details:
This function uses the `pick` utility function (imported from '@welshman/lib') to extract only the specified properties from the input event object. It's a simple implementation that creates a clean representation of an `OwnedEvent` by filtering out any extraneous properties that might be present in the input object. The function is part of a series of similar 'as[EventType]' functions that provide type coercion and attribute stripping for different event types in the Nostr protocol.

related: pick,OwnedEvent,EventContent

import/access examples:
import { asOwnedEvent } from '@welshman/util';
import { asOwnedEvent } from '@welshman/util/Events';


=========================
workspace: packages/util
file: packages/util/src/Events.ts
lines: 118:119
id: af6219760f9c6c158ecaa17b9d17339adc87e7c345755de3b5578b2ccccb2e4b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Events.ts#L118

declaration:
asHashedEvent = (e: HashedEvent): HashedEvent =>
  pick(["kind", "tags", "content", "created_at", "pubkey", "id"], e)

summary:
The `asHashedEvent` function takes a `HashedEvent` object and returns a new object containing only the essential properties of a hashed event: kind, tags, content, created_at, pubkey, and id. This function is used to strip any additional properties from an event object, ensuring it contains only the expected fields of a hashed event.

details:
This function uses the `pick` utility function (imported from '@welshman/lib') to extract only the specified properties from the input event object. It's a simple utility function that helps maintain type safety and consistency when working with event objects by ensuring only the expected properties are included in the returned object. The implementation is straightforward - it just selects the specified fields from the input object and returns a new object with only those fields.

related: pick,HashedEvent,EventContent

import/access examples:
import { asHashedEvent } from '@welshman/util';
import { asHashedEvent } from '@welshman/util/Events';


=========================
workspace: packages/util
file: packages/util/src/Events.ts
lines: 121:122
id: ba41faeaffa456e6f3b8427c8c713e0611adb8fd1963051f7942d7a10c8b747d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Events.ts#L121

declaration:
asSignedEvent = (e: SignedEvent): SignedEvent =>
  pick(["kind", "tags", "content", "created_at", "pubkey", "id", "sig"], e)

summary:
The `asSignedEvent` function takes a SignedEvent object and returns a new SignedEvent object containing only the standard event properties. It strips any additional properties that might be present on the input object, ensuring the returned object has only the expected Nostr event fields (kind, tags, content, created_at, pubkey, id, and sig).

details:
This function uses the `pick` utility function (imported from '@welshman/lib') to extract only the specified properties from the input event. It's part of a series of type coercion and attribute stripping functions in the Events module that ensure events conform to their expected shapes. The implementation is straightforward - it simply calls `pick` with an array of property names and the input event object.

related: pick,SignedEvent,EventContent

import/access examples:
import { asSignedEvent } from '@welshman/util';
import { asSignedEvent } from '@welshman/util/Events';


=========================
workspace: packages/util
file: packages/util/src/Events.ts
lines: 124:125
id: 29d49eb06b5fb8effe120a3cc7d06a397741326cbd9fa4568df179c0ce666a5b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Events.ts#L124

declaration:
asUnwrappedEvent = (e: UnwrappedEvent): UnwrappedEvent =>
  pick(["kind", "tags", "content", "created_at", "pubkey", "id", "wrap"], e)

summary:
A function that takes an UnwrappedEvent object and returns a new UnwrappedEvent object containing only the standard UnwrappedEvent properties. This function effectively strips any additional properties from the input event, keeping only: kind, tags, content, created_at, pubkey, id, and wrap.

details:
This function uses the 'pick' utility function (imported from '@welshman/lib') to create a new object that only contains the specified properties from the input event. It's a type coercion utility that ensures the returned object conforms to the UnwrappedEvent type by removing any extraneous properties that might have been added to the original event object.

related: pick,UnwrappedEvent,EventContent

import/access examples:
import { asUnwrappedEvent } from '@welshman/util';
import { asUnwrappedEvent } from '@welshman/util/Events';


=========================
workspace: packages/util
file: packages/util/src/Events.ts
lines: 127:128
id: 7896c9614b2b09432d08626cba99dd426c2d2c974ed66efd295e81c8b9e0831c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Events.ts#L127

declaration:
asTrustedEvent = (e: TrustedEvent): TrustedEvent =>
  pick(["kind", "tags", "content", "created_at", "pubkey", "id", "sig", "wrap"], e)

summary:
The `asTrustedEvent` function takes a TrustedEvent object and returns a new TrustedEvent object containing only the essential properties of the event. It extracts and preserves the 'kind', 'tags', 'content', 'created_at', 'pubkey', 'id', 'sig', and 'wrap' properties from the input event.

details:
This function uses the `pick` utility function (imported from '@welshman/lib') to create a new object with only the specified properties from the input event. It's a type coercion utility that ensures the returned object conforms to the TrustedEvent type by stripping any extraneous properties. This is part of a series of similar functions in the file that handle different event types in the Nostr protocol.

related: pick,TrustedEvent,EventContent

import/access examples:
import { asTrustedEvent } from '@welshman/util';
import { asTrustedEvent } from '@welshman/util/Events';


=========================
workspace: packages/util
file: packages/util/src/Events.ts
lines: 132:132
id: 39208cdcacd62afb450a15c6c709db65b52fee592c97065a58f80fab4059331f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Events.ts#L132

declaration:
getIdentifier = (e: EventTemplate) => e.tags.find(t => t[0] === "d")?.[1]

summary:
A function that extracts the identifier value from an event template by finding the first tag with the name 'd' and returning its value. Returns undefined if no such tag exists.

details:
This function searches through the event's tags array for a tag where the first element is 'd' (which represents the identifier tag in Nostr events). It uses the Array.find() method to locate the first matching tag, then returns the second element of that tag (index 1) which contains the actual identifier value. The optional chaining operator (?.) is used to safely handle cases where no matching tag is found.

related: tags,EventTemplate

import/access examples:
import { getIdentifier } from '@welshman/util';
import { getIdentifier } from '@welshman/util/Events';


=========================
workspace: packages/util
file: packages/util/src/Events.ts
lines: 134:134
id: 5a5f1e9e2e535950ca2574ad189c23530600ebbc870cb1760f6b23912212ad10
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Events.ts#L134

declaration:
getIdOrAddress = (e: HashedEvent) => (isReplaceable(e) ? getAddress(e) : e.id)

summary:
A function that returns either the address (for replaceable events) or the ID (for non-replaceable events) of a HashedEvent. This provides a consistent way to get the primary identifier for an event based on its type.

details:
This function takes a HashedEvent parameter and uses the `isReplaceable` function to determine if the event is of a replaceable kind. If it is replaceable, it calls `getAddress(e)` to generate the appropriate address for the event. Otherwise, it simply returns the event's `id` property. This is a simple conditional expression with no complex implementation details.

related: __function,getAddress,id,HashedEvent

import/access examples:
import { getIdOrAddress } from '@welshman/util';
import { getIdOrAddress } from '@welshman/util/Events';


=========================
workspace: packages/util
file: packages/util/src/Events.ts
lines: 136:137
id: 7c7545a9620351f1af74f0253b2898c04822114c9c2713120f52f5354f79309f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Events.ts#L136

declaration:
getIdAndAddress = (e: HashedEvent) =>
  isReplaceable(e) ? [e.id, getAddress(e)] : [e.id]

summary:
The `getIdAndAddress` function takes a `HashedEvent` and returns an array containing the event's identifiers. If the event is replaceable, it returns both the event ID and its address. Otherwise, it returns an array with just the event ID.

details:
This function determines how to identify an event based on its type. It uses the `isReplaceable()` function to check if the event has a replaceable kind. For replaceable events, both the standard ID and the address (obtained via `getAddress()`) are returned as an array, since replaceable events can be referenced by either identifier. For non-replaceable events, only the event ID is returned in an array format for consistency in return type.

related: id,__function,getAddress,HashedEvent

import/access examples:
import { getIdAndAddress } from '@welshman/util';
import { getIdAndAddress } from '@welshman/util/Events';


=========================
workspace: packages/util
file: packages/util/src/Events.ts
lines: 139:139
id: 6080996b6955833e0bcedb1c39a7ed1b258229e5ad475f1fd873cf0bf6497704
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Events.ts#L139

declaration:
isEphemeral = (e: EventTemplate) => isEphemeralKind(e.kind)

summary:
A function that checks if an event is ephemeral based on its kind. Takes an EventTemplate object as input and returns a boolean indicating whether the event is of an ephemeral kind.

details:
This function is a simple wrapper around the `isEphemeralKind` function imported from "./Kinds.js". It extracts the `kind` property from the provided EventTemplate and passes it to `isEphemeralKind` to determine if the event is ephemeral. Ephemeral events are typically short-lived and not meant to be stored permanently.

related: isEphemeralKind,isEphemeralKind,EventTemplate

import/access examples:
import { isEphemeral } from '@welshman/util';
import { isEphemeral } from '@welshman/util/Events';


=========================
workspace: packages/util
file: packages/util/src/Events.ts
lines: 141:141
id: 8385865c5246f590a1a5b0eb7a4676bd732734dcdcc6cab3df70ffd0dc9119ad
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Events.ts#L141

declaration:
isReplaceable = (e: EventTemplate) => isReplaceableKind(e.kind)

summary:
A function that checks if an event is of a replaceable kind. It takes an EventTemplate object as input and returns a boolean indicating whether the event's kind is replaceable.

details:
This function is a simple wrapper around the `isReplaceableKind` function imported from './Kinds.js'. It extracts the `kind` property from the provided EventTemplate and passes it to `isReplaceableKind` to determine if the event is replaceable. Replaceable events are special types of Nostr events that can be updated or replaced by newer versions.

related: __function,isReplaceableKind,EventTemplate

import/access examples:
import { isReplaceable } from '@welshman/util';
import { isReplaceable } from '@welshman/util/Events';


=========================
workspace: packages/util
file: packages/util/src/Events.ts
lines: 143:143
id: ba67a728b0da04cc8d5419296678d02aae297104cd253c98ed3e1a7c9b7d8600
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Events.ts#L143

declaration:
isPlainReplaceable = (e: EventTemplate) => isPlainReplaceableKind(e.kind)

summary:
A function that checks if an event is of a plain replaceable kind. It takes an EventTemplate object as input and returns a boolean indicating whether the event's kind is a plain replaceable kind.

details:
This function is a simple wrapper around the `isPlainReplaceableKind` function from the Kinds module. It extracts the `kind` property from the provided EventTemplate and passes it to `isPlainReplaceableKind` to determine if the event is of a plain replaceable kind. Plain replaceable kinds are a specific category of Nostr event kinds that can be replaced by newer events of the same kind.

related: isPlainReplaceableKind,isPlainReplaceableKind,EventTemplate

import/access examples:
import { isPlainReplaceable } from '@welshman/util';
import { isPlainReplaceable } from '@welshman/util/Events';


=========================
workspace: packages/util
file: packages/util/src/Events.ts
lines: 145:146
id: 19aa114d20e372f063de1cac968074616bddb1a0dd1e1f3d1d266cf0e369a4af
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Events.ts#L145

declaration:
isParameterizedReplaceable = (e: EventTemplate) =>
  isParameterizedReplaceableKind(e.kind)

summary:
A function that checks if an event is a parameterized replaceable event by examining its kind property. Returns true if the event's kind is a parameterized replaceable kind, false otherwise.

details:
This function takes an EventTemplate object as input and delegates to the `isParameterizedReplaceableKind` function from the Kinds module, passing the event's `kind` property. It's a simple wrapper that provides a more semantic way to check if an event follows the parameterized replaceable event pattern in the Nostr protocol.

related: isParameterizedReplaceableKind,isParameterizedReplaceableKind,EventTemplate

import/access examples:
import { isParameterizedReplaceable } from '@welshman/util';
import { isParameterizedReplaceable } from '@welshman/util/Events';


=========================
workspace: packages/util
file: packages/util/src/Events.ts
lines: 148:149
id: 480685e36f1b599ec936a910ff6b69a9ba10e7cd14778e6c739f7ee03c3e46a3
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Events.ts#L148

declaration:
getAncestorTags = ({kind, tags}: EventTemplate) =>
  kind === COMMENT ? getCommentTags(tags) : getReplyTags(tags)

summary:
A function that retrieves the ancestor tags from an event template based on its kind. If the event kind is a COMMENT, it returns comment tags, otherwise it returns reply tags.

details:
This function takes an EventTemplate object with destructured 'kind' and 'tags' properties and determines which type of ancestor tags to return based on the event kind. It uses a ternary operator to check if the kind equals the COMMENT constant - if true, it calls getCommentTags() with the tags array, otherwise it calls getReplyTags(). Both helper functions are imported from the Tags.js module and process the tags array differently depending on the event type context.

related: __function,getCommentTags,__function,getReplyTags,EventTemplate

import/access examples:
import { getAncestorTags } from '@welshman/util';
import { getAncestorTags } from '@welshman/util/Events';


=========================
workspace: packages/util
file: packages/util/src/Events.ts
lines: 151:152
id: d7cfca7c384380aadfef404658f9c88fea0e540fbe9cba9d043bb1b1858b1278
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Events.ts#L151

declaration:
getAncestors = ({kind, tags}: EventTemplate) =>
  kind === COMMENT ? getCommentTagValues(tags) : getReplyTagValues(tags)

summary:
A function that extracts ancestor references from an event's tags based on the event kind. For comment events (kind === COMMENT), it returns comment tag values, otherwise it returns reply tag values. The function takes an EventTemplate object with kind and tags properties and returns the ancestor references.

details:
This function implements a simple conditional logic to determine which tag extraction function to use based on the event kind:

1. It destructures the input EventTemplate to get `kind` and `tags`
2. If the event kind equals the COMMENT constant, it calls `getCommentTagValues(tags)`
3. Otherwise, it calls `getReplyTagValues(tags)`

Both tag value extraction functions are imported from "./Tags.js" and presumably return structured data about the event's ancestors. The implementation leverages the ternary operator for concise conditional logic.

related: __function,getCommentTagValues,__function,getReplyTagValues,EventTemplate

import/access examples:
import { getAncestors } from '@welshman/util';
import { getAncestors } from '@welshman/util/Events';


=========================
workspace: packages/util
file: packages/util/src/Events.ts
lines: 154:158
id: d5c25cfb7fc92eaab8566cb99ca9671f3988c724fd137b375001cf6a389affae
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Events.ts#L154

declaration:
getParentIdsAndAddrs = (event: EventTemplate) => {
  const {roots, replies} = getAncestors(event)

  return replies.length > 0 ? replies : roots
}

summary:
A function that extracts parent identifiers and addresses from a Nostr event. It returns either the 'replies' array if it contains elements, or falls back to the 'roots' array when no replies are present.

details:
This function works by:
1. Calling the `getAncestors` function with the provided event, which returns an object containing 'roots' and 'replies' arrays
2. Using a ternary operator to determine which array to return - if replies has elements (length > 0), it returns the replies array; otherwise it returns the roots array
3. This implements a priority system where direct replies take precedence over root references

related: EventTemplate

import/access examples:
import { getParentIdsAndAddrs } from '@welshman/util';
import { getParentIdsAndAddrs } from '@welshman/util/Events';


=========================
workspace: packages/util
file: packages/util/src/Events.ts
lines: 160:160
id: 7f1445656bab7084429636f590f0b5c963db1a8a2cea00ce1dbb883f3377cf40
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Events.ts#L160

declaration:
getParentIdOrAddr = (event: EventTemplate) => first(getParentIdsAndAddrs(event))

summary:
A function that extracts the first parent ID or address from an event template. It returns either an event ID or an address string that represents the immediate parent of the given event, or undefined if there are no parents.

details:
This function works by first calling `getParentIdsAndAddrs(event)` to get all parent IDs and addresses from the event's tags, then uses the `first()` utility function to return just the first item from that array. The implementation is straightforward - it delegates the actual tag extraction logic to `getParentIdsAndAddrs` and simply returns the first element of the resulting array.

related: first,EventTemplate

import/access examples:
import { getParentIdOrAddr } from '@welshman/util';
import { getParentIdOrAddr } from '@welshman/util/Events';


=========================
workspace: packages/util
file: packages/util/src/Events.ts
lines: 162:169
id: d41404df64c7d79b8649c7c43aa6739fe2e7a6a666b9979ba447ef82acd27336
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Events.ts#L162

declaration:
getParentIds = (event: EventTemplate) => {
  const {roots, replies} = mapVals(
    ids => ids.filter(id => !Address.isAddress(id)),
    getAncestors(event),
  )

  return replies.length > 0 ? replies : roots
}

summary:
A function that extracts parent event IDs from an event template. It returns an array of parent event IDs (excluding addresses), prioritizing 'replies' over 'roots' if replies exist.

details:
The implementation:
1. Uses `mapVals` to transform both 'roots' and 'replies' arrays from the event's ancestors
2. Filters out any addresses from both arrays using `!Address.isAddress(id)` predicate
3. Gets the ancestors using `getAncestors(event)` which returns an object with 'roots' and 'replies' properties
4. Returns the 'replies' array if it has elements, otherwise returns the 'roots' array

This function is part of a hierarchy of parent-related functions, focusing specifically on extracting only the event IDs (not addresses) from the parent references.

related: EventTemplate

import/access examples:
import { getParentIds } from '@welshman/util';
import { getParentIds } from '@welshman/util/Events';


=========================
workspace: packages/util
file: packages/util/src/Events.ts
lines: 171:171
id: 380e680228696aa490f663f5d78639df88d1a84cc89b533b093666e1355ea2f5
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Events.ts#L171

declaration:
getParentId = (event: EventTemplate) => first(getParentIds(event))

summary:
A function that extracts the first parent ID from an event template. It returns the first event ID (not an address) from the parent references in the event's tags.

details:
This function works by:
1. Calling `getParentIds(event)` to get an array of parent event IDs (filtering out any addresses)
2. Using the `first()` utility function to return the first element of that array or undefined if the array is empty

It's a convenience wrapper that combines the functionality of `getParentIds` and `first` to easily access the primary parent event ID when it exists.

related: first,EventTemplate

import/access examples:
import { getParentId } from '@welshman/util';
import { getParentId } from '@welshman/util/Events';


=========================
workspace: packages/util
file: packages/util/src/Events.ts
lines: 173:180
id: e16fcdc563005d6c1cb6bde3de7a25d7d8fa852fdc262aff79fdbed104521aa7
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Events.ts#L173

declaration:
getParentAddrs = (event: EventTemplate) => {
  const {roots, replies} = mapVals(
    ids => ids.filter(id => Address.isAddress(id)),
    getAncestors(event),
  )

  return replies.length > 0 ? replies : roots
}

summary:
Extracts parent addresses from an event template. This function filters the ancestor tags of an event to return only those that are valid addresses. It prioritizes reply addresses over root addresses if both are present.

details:
The implementation works by:
1. Using `mapVals` to transform both roots and replies arrays from the event's ancestors
2. For each array, filtering to keep only elements that are valid addresses (using `Address.isAddress`)
3. Returning the replies array if it contains any elements, otherwise returning the roots array

The function relies on `getAncestors` to extract the initial tag values from the event, which returns an object with `roots` and `replies` properties.

related: EventTemplate

import/access examples:
import { getParentAddrs } from '@welshman/util';
import { getParentAddrs } from '@welshman/util/Events';


=========================
workspace: packages/util
file: packages/util/src/Events.ts
lines: 182:182
id: 01ad87f6222a71eb95810522ab31d60e0b7b996386cee5586f70175e376aec76
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Events.ts#L182

declaration:
getParentAddr = (event: EventTemplate) => first(getParentAddrs(event))

summary:
A function that retrieves the first parent address from an event template. It extracts the first address from the list of parent addresses associated with the event.

details:
This function works by:
1. Calling `getParentAddrs(event)` to get all parent addresses from the event template
2. Using the `first()` utility function to return the first address from that list or undefined if the list is empty

It's a simple wrapper that combines two operations for convenience when you only need the primary parent address of an event.

related: first,EventTemplate

import/access examples:
import { getParentAddr } from '@welshman/util';
import { getParentAddr } from '@welshman/util/Events';


=========================
workspace: packages/util
file: packages/util/src/Events.ts
lines: 184:188
id: 00b50828708ee103afc4dba295548e3be0a9ff3332d8d318d761e5704ec2952a
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Events.ts#L184

declaration:
isChildOf = (child: EventTemplate, parent: HashedEvent) => {
  const idsAndAddrs = getParentIdsAndAddrs(child)

  return getIdAndAddress(parent).some(x => idsAndAddrs.includes(x))
}

summary:
Determines if an event is a child of another event in a Nostr context. Takes a child event template and a parent hashed event as parameters, and returns a boolean indicating whether the child is a direct descendant of the parent.

details:
The function works by:
1. Getting all parent IDs and addresses from the child event using `getParentIdsAndAddrs()`
2. Getting all possible identifiers (ID and address if replaceable) from the parent event using `getIdAndAddress()`
3. Checking if any of the parent's identifiers are included in the child's parent references

This effectively determines if the child event references the parent event in its ancestry tags.

related: EventTemplate,HashedEvent

import/access examples:
import { isChildOf } from '@welshman/util';
import { isChildOf } from '@welshman/util/Events';


=========================
workspace: packages/util
file: packages/util/src/Nip98.ts
lines: 6:17
id: d20144974f0bcd533a4a78c46273d5628b0490b71f4350e245fa006103d38d46
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Nip98.ts#L6

declaration:
makeHttpAuth = async (url: string, method = "GET", body?: string) => {
  const tags = [
    ["u", url],
    ["method", method],
  ]

  if (body) {
    tags.push(["payload", await sha256(textEncoder.encode(body))])
  }

  return makeEvent(HTTP_AUTH, {tags})
}

summary:
Creates a Nostr HTTP authentication event (NIP-98) for a given URL and HTTP method. This function generates the necessary event structure with tags for URL, method, and optionally a payload hash if a body is provided. The returned event can be used for authentication in Nostr-compatible HTTP requests.

details:
Implementation creates a Nostr event with HTTP_AUTH kind and appropriate tags:
1. Constructs an array of tags with URL and method information
2. If a request body is provided, computes its SHA-256 hash and adds it as a 'payload' tag
3. Uses the makeEvent helper function to create the final event structure with the HTTP_AUTH kind
4. The function is asynchronous to handle the SHA-256 hashing operation

import/access examples:
import { makeHttpAuth } from '@welshman/util';
import { makeHttpAuth } from '@welshman/util/Nip98';


=========================
workspace: packages/util
file: packages/util/src/Nip98.ts
lines: 19:20
id: a54b6ecd2b9abc934388a9bee56bd1e83df2a92bd84b372002ded28782ca62ba
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Nip98.ts#L19

declaration:
makeHttpAuthHeader = (event: SignedEvent) =>
  `Nostr ${Base64.encode(JSON.stringify(event))}`

summary:
Creates a Nostr HTTP authentication header from a signed event. The function takes a SignedEvent object and returns a string formatted as 'Nostr <base64-encoded-event>' which can be used as an Authorization header in HTTP requests following the NIP-98 specification.

details:
The implementation is straightforward:
1. Takes a SignedEvent object as input
2. Converts the event to a JSON string using JSON.stringify
3. Base64 encodes the JSON string using the Base64.encode method from js-base64
4. Returns a template string that prepends 'Nostr ' to the encoded event

This creates the proper format for Nostr HTTP authentication headers as defined in NIP-98.

related: SignedEvent

import/access examples:
import { makeHttpAuthHeader } from '@welshman/util';
import { makeHttpAuthHeader } from '@welshman/util/Nip98';


=========================
workspace: packages/util
file: packages/util/src/Blossom.ts
lines: 6:6
id: d02927cb80b61ce4e1ddbbcfebe2535fc397611d3f7aeef9723f99b7d1af1f3b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Blossom.ts#L6

declaration:
export type BlossomAuthAction = "get" | "upload" | "list" | "delete"

summary:
A type alias that defines the possible actions for Blossom authentication. It can be one of four string literals: 'get', 'upload', 'list', or 'delete', representing the different operations that can be performed on a Blossom server.

details:
This is a simple TypeScript string union type that constrains the possible values to the four basic CRUD-like operations supported by the Blossom protocol. It's used throughout the module to type-check authentication action parameters.

import/access examples:
import type { BlossomAuthAction } from '@welshman/util';
import type { BlossomAuthAction } from '@welshman/util/Blossom';


=========================
workspace: packages/util
file: packages/util/src/Blossom.ts
lines: 8:14
id: 58faa657a959c228e9182cf4776704ecee93d0146cbab3ebab15e79e7218a9b7
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Blossom.ts#L8

declaration:
export type BlossomAuthEventOpts = {
  action: BlossomAuthAction
  server: string
  hashes?: string[]
  expiration?: number
  content?: string
}

summary:
A type definition that specifies the options required to create a Blossom authentication event. It includes properties for the action type, server URL, optional file hashes, expiration time, and content message.

details:
This type alias defines the structure for options passed to the `makeBlossomAuthEvent` function. It contains:
1. `action`: A required field specifying the type of operation (get, upload, list, or delete)
2. `server`: A required string representing the server URL
3. `hashes`: An optional array of string hashes for file identification
4. `expiration`: An optional timestamp for when the authentication expires
5. `content`: An optional message describing the authorization purpose

This type is part of the Blossom protocol implementation, which appears to be a file storage/retrieval system with authentication.

related: BlossomAuthAction

import/access examples:
import type { BlossomAuthEventOpts } from '@welshman/util';
import type { BlossomAuthEventOpts } from '@welshman/util/Blossom';


=========================
workspace: packages/util
file: packages/util/src/Blossom.ts
lines: 16:19
id: 954681915f80697c6c29d3bd7c8031c21973e5688dc99ba3daef0f798273d98b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Blossom.ts#L16

declaration:
export type BlossomServer = {
  url: string
  pubkey?: string
}

summary:
BlossomServer is a type definition that represents a Blossom protocol server configuration. It contains the URL of the server and an optional public key. This type is used throughout the Blossom API for operations like file uploads, downloads, and management.

details:
This is a simple type alias that defines the structure for representing a Blossom server. It has two properties:
1. `url`: A required string that specifies the server's URL endpoint
2. `pubkey`: An optional string that represents the server's public key

The type is used in various Blossom operations to identify and connect to servers that implement the Blossom protocol for blob storage.

import/access examples:
import type { BlossomServer } from '@welshman/util';
import type { BlossomServer } from '@welshman/util/Blossom';


=========================
workspace: packages/util
file: packages/util/src/Blossom.ts
lines: 21:24
id: 65612c8ac246633cba5a6204b553a976c0436a81858d3d4b8677ad8392458f8c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Blossom.ts#L21

declaration:
export type BlossomErrorResponse = {
  message: string
  reason?: string
}

summary:
BlossomErrorResponse is a type definition that represents an error response from a Blossom server. It contains a required 'message' field that provides the error message, and an optional 'reason' field that can provide additional details about the error.

details:
This is a simple type alias that defines the structure for error responses in the Blossom API. It doesn't contain any implementation logic, just the type definition with two properties:
1. message: A required string containing the main error message
2. reason: An optional string providing additional context about the error

import/access examples:
import type { BlossomErrorResponse } from '@welshman/util';
import type { BlossomErrorResponse } from '@welshman/util/Blossom';


=========================
workspace: packages/util
file: packages/util/src/Blossom.ts
lines: 26:49
id: b9f3720197d8985dea73a0f27578d4511fc18a54615004dd87d76009503f6b40
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Blossom.ts#L26

declaration:
makeBlossomAuthEvent = ({
  action,
  server,
  hashes = [],
  expiration = now() + 60,
  content = `Authorization for ${action} at ${server}`,
}: BlossomAuthEventOpts) => {
  const tags: string[][] = [
    ["t", action],
    ["expiration", expiration.toString()],
  ]

  if (server) {
    tags.push(["u", server])
  }

  if (hashes) {
    for (const hash of hashes) {
      tags.push(["x", hash])
    }
  }

  return makeEvent(BLOSSOM_AUTH, {content, tags})
}

summary:
Creates a Blossom authentication event for various operations on a Blossom server. This function takes a BlossomAuthEventOpts object containing the action type (get, upload, list, delete), server URL, optional file hashes, expiration time, and custom content. Returns an unsigned event of kind BLOSSOM_AUTH that can be used for authorization with Blossom servers.

details:
The implementation:
1. Creates a tags array with two initial tags:
   - 't' tag with the action type
   - 'expiration' tag with the timestamp when the auth expires
2. Conditionally adds a 'u' tag with the server URL if provided
3. Iterates through any provided hashes and adds 'x' tags for each hash
4. Uses makeEvent() to create a BLOSSOM_AUTH event with the provided content and assembled tags
5. Default values are provided for optional parameters:
   - Empty array for hashes
   - Expiration time of 60 seconds from now
   - Auto-generated content string describing the authorization

related: BlossomAuthEventOpts

import/access examples:
import { makeBlossomAuthEvent } from '@welshman/util';
import { makeBlossomAuthEvent } from '@welshman/util/Blossom';


=========================
workspace: packages/util
file: packages/util/src/Blossom.ts
lines: 51:55
id: a6f6302eccf597a78d064d821c1e9915fbba1f20d2a41219bbed6b3534f39cbd
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Blossom.ts#L51

declaration:
buildBlobUrl = (server: string, sha256: string, extension?: string): string => {
  const url = new URL(server)
  const filename = extension ? `${sha256}.${extension}` : sha256
  return `${url.origin}/${filename}`
}

summary:
Constructs a URL for accessing a blob resource on a Blossom server. Takes a server URL, a SHA256 hash that identifies the blob, and an optional file extension. Returns a string URL in the format 'server-origin/sha256[.extension]'.

details:
The function builds a URL for a blob by:
1. Creating a URL object from the server parameter to extract the origin
2. Constructing a filename from the SHA256 hash, optionally appending an extension if provided
3. Returning a string that combines the server's origin with the filename

This is a simple utility function that handles proper URL formatting for blob access.

import/access examples:
import { buildBlobUrl } from '@welshman/util';
import { buildBlobUrl } from '@welshman/util/Blossom';


=========================
workspace: packages/util
file: packages/util/src/Blossom.ts
lines: 57:86
id: e6cb86860a00f65c2fc22ac94193c25652cb6a4a18d7ba34923c291cb22cb72c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Blossom.ts#L57

declaration:
checkBlobExists = async (
  server: string,
  sha256: string,
  options: {
    authEvent?: SignedEvent
  } = {},
): Promise<{exists: boolean; size?: number}> => {
  const url = buildBlobUrl(server, sha256)
  const headers: Record<string, string> = {}

  if (options.authEvent) {
    headers.Authorization = makeHttpAuthHeader(options.authEvent)
  }

  try {
    const response = await fetch(url, {method: "HEAD", headers})

    if (response.status === 200) {
      const contentLength = response.headers.get("content-length")
      return {
        exists: true,
        size: contentLength ? parseInt(contentLength, 10) : undefined,
      }
    }

    return {exists: false}
  } catch (error) {
    throw new Error(`Failed to check blob existence: ${error}`)
  }
}

summary:
Checks if a blob exists on a Blossom server by its SHA256 hash. Takes a server URL, SHA256 hash, and optional authentication event. Returns a Promise resolving to an object with `exists` boolean and optional `size` in bytes if the blob exists. Throws an error if the request fails.

details:
Implementation performs a HEAD request to the blob URL constructed from server and SHA256 hash. If authentication is provided, it adds an Authorization header using makeHttpAuthHeader. The function:
1. Builds the blob URL using buildBlobUrl
2. Sets up headers, including authorization if provided
3. Makes a HEAD request to check existence without downloading content
4. Interprets HTTP 200 as blob exists, parsing content-length header for size
5. Returns {exists: false} for non-200 responses
6. Catches network errors and throws a descriptive error message

related: SignedEvent

import/access examples:
import { checkBlobExists } from '@welshman/util';
import { checkBlobExists } from '@welshman/util/Blossom';


=========================
workspace: packages/util
file: packages/util/src/Blossom.ts
lines: 88:110
id: 834463448b0aa46943ef775b7171cf5ad337a18ffa525f2992a037f8097374e2
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Blossom.ts#L88

declaration:
getBlob = async (
  server: string,
  sha256: string,
  options: {
    authEvent?: SignedEvent
    range?: {start: number; end?: number}
  } = {},
) => {
  const url = buildBlobUrl(server, sha256)
  const headers: Record<string, string> = {}

  if (options.authEvent) {
    headers.Authorization = makeHttpAuthHeader(options.authEvent)
  }

  if (options.range) {
    const {end, start} = options.range

    headers.Range = end !== undefined ? `bytes=${start}-${end}` : `bytes=${start}-`
  }

  return fetch(url, {headers})
}

summary:
Fetches a blob from a Blossom server. Takes a server URL, a SHA256 hash identifying the blob, and optional parameters including an authentication event and a byte range specification. Returns a fetch response that can be processed for the blob data.

details:
The function implements a simple HTTP GET request to retrieve a blob from a Blossom server:

1. Builds the complete URL for the blob using the buildBlobUrl helper function
2. Sets up request headers, including:
   - Authorization header if an authEvent is provided (using makeHttpAuthHeader)
   - Range header if range parameters are specified, formatted as standard HTTP byte ranges
3. Performs the fetch request with the constructed URL and headers
4. Returns the raw fetch response for the caller to handle (no error handling is done within this function)

related: SignedEvent

import/access examples:
import { getBlob } from '@welshman/util';
import { getBlob } from '@welshman/util/Blossom';


=========================
workspace: packages/util
file: packages/util/src/Blossom.ts
lines: 112:129
id: df075ac960dc461499c98142d5366754836dd014555a0b9d6808306ff27e2b33
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Blossom.ts#L112

declaration:
uploadBlob = async (
  server: string,
  blob: Blob | ArrayBuffer,
  options: {
    authEvent?: SignedEvent
  } = {},
) => {
  const url = new URL(server)
  const uploadUrl = `${url.origin}/upload`
  const body = blob instanceof Blob ? blob : new Blob([blob])
  const headers: Record<string, string> = {}

  if (options.authEvent) {
    headers.Authorization = makeHttpAuthHeader(options.authEvent)
  }

  return fetch(uploadUrl, {method: "PUT", headers, body})
}

summary:
Uploads a blob (binary data) to a specified Blossom server. The function accepts a server URL, the blob data (either as a Blob or ArrayBuffer), and optional configuration including an authentication event. Returns a Promise that resolves to the fetch response from the server.

details:
Implementation details:
1. Constructs the upload URL by taking the origin from the provided server URL and appending '/upload'
2. Ensures the data is in Blob format by converting ArrayBuffer to Blob if needed
3. Sets up request headers, including authorization if an authEvent is provided
4. Uses the fetch API with PUT method to upload the blob to the server
5. Returns the raw fetch response, allowing the caller to handle success/failure states

related: SignedEvent

import/access examples:
import { uploadBlob } from '@welshman/util';
import { uploadBlob } from '@welshman/util/Blossom';


=========================
workspace: packages/util
file: packages/util/src/Blossom.ts
lines: 131:147
id: 28c6ef010ccc2dff825dcfb1ae66a1e0e1451f7acc42889daff2fed1b3b9b542
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Blossom.ts#L131

declaration:
deleteBlob = async (
  server: string,
  sha256: string,
  options: {
    authEvent?: SignedEvent
  } = {},
) => {
  const url = buildBlobUrl(server, sha256)

  const headers: Record<string, string> = {}

  if (options.authEvent) {
    headers.Authorization = makeHttpAuthHeader(options.authEvent)
  }

  return fetch(url, {method: "DELETE", headers})
}

summary:
Deletes a blob from a Blossom server. Takes the server URL, the SHA256 hash of the blob to delete, and optional authentication event. Returns a Promise that resolves to the fetch response from the DELETE request.

details:
The function implements a blob deletion operation for the Blossom protocol by:
1. Building the complete URL for the blob using the buildBlobUrl helper function
2. Setting up request headers, adding authorization if an authEvent is provided
3. Making a DELETE HTTP request to the server using the fetch API
4. Returning the fetch response directly to the caller

related: SignedEvent

import/access examples:
import { deleteBlob } from '@welshman/util';
import { deleteBlob } from '@welshman/util/Blossom';


=========================
workspace: packages/util
file: packages/util/src/Blossom.ts
lines: 149:178
id: f563a5d77faf1e99f6a7eb3838e7f915b6fd8afec80b02052681d4d2af1b032c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Blossom.ts#L149

declaration:
listBlobs = async (
  server: string,
  pubkey: string,
  options: {
    authEvent?: SignedEvent
    since?: number
    until?: number
  } = {},
) => {
  const url = new URL(server)
  const listUrl = `${url.origin}/list/${pubkey}`

  const searchParams = new URLSearchParams()
  if (options.since !== undefined) {
    searchParams.append("since", options.since.toString())
  }
  if (options.until !== undefined) {
    searchParams.append("until", options.until.toString())
  }

  const fullUrl = searchParams.toString() ? `${listUrl}?${searchParams.toString()}` : listUrl

  const headers: Record<string, string> = {}

  if (options.authEvent) {
    headers.Authorization = makeHttpAuthHeader(options.authEvent)
  }

  return fetch(fullUrl, {headers})
}

summary:
Asynchronous function that lists blobs from a Blossom server for a specific public key. It accepts a server URL, a public key, and optional parameters including an authentication event, since timestamp, and until timestamp for filtering results. Returns a fetch Promise that will resolve to the server's response.

details:
The implementation:
1. Constructs a URL to the server's list endpoint with the pubkey as part of the path
2. Creates URLSearchParams to handle optional time-based filtering parameters (since/until)
3. Builds the full URL by conditionally appending search parameters
4. Sets up request headers, adding Authorization if an authEvent is provided
5. Makes a GET request to the server using the fetch API and returns the Promise

related: SignedEvent

import/access examples:
import { listBlobs } from '@welshman/util';
import { listBlobs } from '@welshman/util/Blossom';


=========================
workspace: packages/util
file: packages/util/src/Blossom.ts
lines: 180:185
id: 4a77dbb2444d9c1da00af4d4668ac66ec5c89d86182c1a64368c815e3c2fdcdd
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Blossom.ts#L180

declaration:
export interface EncryptedFile {
  key: string
  nonce: string
  ciphertext: Uint8Array
  algorithm: string
}

summary:
Interface representing an encrypted file in the Blossom system. It contains all necessary information to decrypt the file later, including the encryption key, nonce (initialization vector), the encrypted data itself, and the encryption algorithm used.

details:
The `EncryptedFile` interface defines the structure for encrypted file data with the following properties:
1. `key`: A string containing the hexadecimal representation of the encryption key
2. `nonce`: A string containing the hexadecimal representation of the initialization vector (IV)
3. `ciphertext`: A Uint8Array containing the encrypted file data
4. `algorithm`: A string identifying the encryption algorithm used (currently supports "aes-gcm")

This interface is used in conjunction with the `encryptFile` and `decryptFile` functions in the Blossom module.

import/access examples:
import type { EncryptedFile } from '@welshman/util';
import type { EncryptedFile } from '@welshman/util/Blossom';


=========================
workspace: packages/util
file: packages/util/src/Blossom.ts
lines: 187:203
id: aaa62aae134df0831569ed9825d9563b829227f5a44e642ca6083809f3edbc8f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Blossom.ts#L187

declaration:
export async function encryptFile(file: Blob): Promise<EncryptedFile>

summary:
Encrypts a file using AES-GCM encryption. Takes a Blob as input and returns an EncryptedFile object containing the encryption key, nonce (initialization vector), ciphertext, and algorithm identifier.

details:
Implementation details:
1. Generates a random 256-bit AES-GCM key using the Web Crypto API
2. Creates a random 12-byte initialization vector (IV/nonce)
3. Converts the input Blob to an ArrayBuffer
4. Encrypts the file data using the generated key and IV
5. Exports the key to raw format and converts it to hexadecimal string
6. Returns an EncryptedFile object with:
   - ciphertext: the encrypted data as Uint8Array
   - key: the encryption key as a hex string
   - nonce: the IV as a hex string
   - algorithm: set to "aes-gcm"

related: EncryptedFile

code:
export async function encryptFile(file: Blob): Promise<EncryptedFile> {
  const key = await crypto.subtle.generateKey({name: "AES-GCM", length: 256}, true, [
    "encrypt",
    "decrypt",
  ])
  const iv = crypto.getRandomValues(new Uint8Array(12))
  const fileBuffer = await file.arrayBuffer()
  const ciphertext = await crypto.subtle.encrypt({name: "AES-GCM", iv}, key, fileBuffer)
  const keyBytes = await crypto.subtle.exportKey("raw", key)

  return {
    ciphertext: new Uint8Array(ciphertext),
    key: bytesToHex(keyBytes),
    nonce: bytesToHex(iv),
    algorithm: "aes-gcm",
  }
}

import/access examples:
import { encryptFile } from '@welshman/util';
import { encryptFile } from '@welshman/util/Blossom';


=========================
workspace: packages/util
file: packages/util/src/Blossom.ts
lines: 205:223
id: bc25ac10892d352b9ec3ddd32b04d494f2bb719b92e76b18c3559bd967809099
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Blossom.ts#L205

declaration:
export async function decryptFile({
  key,
  nonce,
  ciphertext,
  algorithm,
}: EncryptedFile): Promise<Uint8Array>

summary:
Decrypts a file that was previously encrypted with the AES-GCM algorithm. Takes an `EncryptedFile` object containing the encryption key, nonce (initialization vector), ciphertext, and algorithm identifier, and returns a Promise that resolves to a Uint8Array containing the decrypted data.

details:
The implementation follows these steps:
1. Validates that the algorithm is 'aes-gcm', throwing an error for unsupported algorithms
2. Converts the hexadecimal key and nonce strings to byte arrays using the hexToBytes utility
3. Imports the raw key bytes into a CryptoKey object using the Web Crypto API
4. Decrypts the ciphertext using the AES-GCM algorithm with the provided initialization vector
5. Returns the decrypted data as a Uint8Array

related: EncryptedFile

code:
export async function decryptFile({
  key,
  nonce,
  ciphertext,
  algorithm,
}: EncryptedFile): Promise<Uint8Array> {
  if (algorithm !== "aes-gcm") {
    throw new Error(`Unknown algorithm ${algorithm}`)
  }

  const keyBytes = hexToBytes(key)
  const iv = hexToBytes(nonce)
  const cryptoKey = await crypto.subtle.importKey("raw", keyBytes, {name: "AES-GCM"}, false, [
    "decrypt",
  ])
  const decryptedBuffer = await crypto.subtle.decrypt({name: "AES-GCM", iv}, cryptoKey, ciphertext)

  return new Uint8Array(decryptedBuffer)
}

import/access examples:
import { decryptFile } from '@welshman/util';
import { decryptFile } from '@welshman/util/Blossom';


=========================
workspace: packages/util
file: packages/util/src/Encryptable.ts
lines: 3:3
id: fe6111d643167370f642d5fb8d3803bbac2d814d1a4eb01f03fc2b0906d9ed71
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Encryptable.ts#L3

declaration:
export type Encrypt = (x: string) => Promise<string>

summary:
A type alias representing an encryption function that takes a string input and returns a Promise resolving to the encrypted string. This type is used throughout the library to define functions that handle encryption operations.

details:
This is a simple type alias that defines the signature for encryption functions used in the Encryptable class and related components. It represents a function that takes a plaintext string and returns a Promise containing the encrypted string result.

import/access examples:
import type { Encrypt } from '@welshman/util';
import type { Encrypt } from '@welshman/util/Encryptable';


=========================
workspace: packages/util
file: packages/util/src/Encryptable.ts
lines: 5:5
id: 7b8e05e80fc2a563f9a508d214553f3db82316cde9147a4c327b2b999f0dcfd3
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Encryptable.ts#L5

declaration:
export type EncryptableUpdates = Partial<EventContent>

summary:
A type alias representing partial updates to an event's content. It allows for specifying a subset of properties from the EventContent type that should be updated, making it useful for partial updates to events in a Nostr-like system.

details:
This type alias is a simple wrapper around Partial<EventContent>, which means it creates a type where all properties of EventContent are optional. It's used in the Encryptable class to represent plaintext updates that will be encrypted and merged with an existing event template.

related: EventContent

import/access examples:
import type { EncryptableUpdates } from '@welshman/util';
import type { EncryptableUpdates } from '@welshman/util/Encryptable';


=========================
workspace: packages/util
file: packages/util/src/Encryptable.ts
lines: 7:9
id: 13029983f2ce8aa2d2c18e21563eb4cfb970c1f0627dc02d1bbbfdea462d2e8d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Encryptable.ts#L7

declaration:
export type DecryptedEvent = TrustedEvent & {
  plaintext: EncryptableUpdates
}

summary:
The `DecryptedEvent` type represents a trusted event that includes plaintext content. It extends the `TrustedEvent` type by adding a `plaintext` property of type `EncryptableUpdates`, which contains the decrypted content of the event.

details:
This type alias combines the `TrustedEvent` type with an additional property `plaintext` that holds the decrypted version of the event's content. The `plaintext` property is of type `EncryptableUpdates`, which is defined elsewhere as a partial of `EventContent`. This type is used in the Nostr protocol context to represent events that have been successfully decrypted, maintaining both the original encrypted event data and its decrypted content.

related: TrustedEvent,EncryptableUpdates

import/access examples:
import type { DecryptedEvent } from '@welshman/util';
import type { DecryptedEvent } from '@welshman/util/Encryptable';


=========================
workspace: packages/util
file: packages/util/src/Encryptable.ts
lines: 11:12
id: 2c4a0da35d2d47a12d08c8707da577279a0b4a5319f3cea3f8921d60e84a997c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Encryptable.ts#L11

declaration:
asDecryptedEvent = (event: TrustedEvent, plaintext: EncryptableUpdates = {}) =>
  ({...event, plaintext}) as DecryptedEvent

summary:
A utility function that converts a TrustedEvent into a DecryptedEvent by adding a plaintext property. The function takes a TrustedEvent and an optional plaintext object (defaulting to an empty object) and returns a new object that combines the original event with the plaintext data.

details:
The implementation is straightforward, using object spread syntax to create a new object that contains all properties from the original event plus the plaintext property. The function then uses a type assertion to ensure the returned object is treated as a DecryptedEvent type. This is a simple helper function that doesn't involve complex logic or side effects.

related: TrustedEvent,EncryptableUpdates,DecryptedEvent,EventContent

import/access examples:
import { asDecryptedEvent } from '@welshman/util';
import { asDecryptedEvent } from '@welshman/util/Encryptable';


=========================
workspace: packages/util
file: packages/util/src/Encryptable.ts
lines: 14:68
id: 58169fb7dfd9d35b0eef343dcdb5a901f10696810e68bb684c8389af4895e7f2
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Encryptable.ts#L14

declaration:
/**
 * Represents an encryptable event with optional updates.
 */
export class Encryptable<T extends EventTemplate>{
  /**
     * Creates an instance of Encryptable.
     * @param event - An EventTemplate with optional tags and content.
     * @param updates - Plaintext updates to be applied to the event content.
     * @example
     * Here's an example which enables updating a private mute list:
     * ```
     * const event = {kind: 10000, content: "", tags: []} // An event, only kind is required
     * const encryptable = new Encryptable(event, {content: JSON.stringify([["e", "bad word"]])})
     * const eventTemplate = await encryptable.reconcile(myEncryptFunction)
     * ```
     */
    constructor(
      readonly event: Partial<T>,
      readonly updates: EncryptableUpdates,
    );
  /**
     * Encrypts plaintext updates and merges them into the event template.
     * @param encrypt - The encryption function to be used.
     * @returns A promise that resolves to the reconciled and encrypted event.
     */
    async reconcile(encrypt: Encrypt);
}

summary:
The `Encryptable` class represents an encryptable event with optional updates. It provides functionality to encrypt and reconcile event content and tags. The class is generic, accepting an event template type parameter that extends `EventTemplate`. It allows for creating encrypted events by applying plaintext updates to an existing event template and then encrypting those updates.

details:
The implementation works as follows:

1. The class stores two main properties:
   - `event`: The base event template to be modified
   - `updates`: Plaintext updates to be applied to the event content

2. The `reconcile` method handles the encryption process:
   - It defines two inner functions:
     - `encryptContent()`: Encrypts the content field if it exists in updates
     - `encryptTags()`: Encrypts each tag's second element (tag[1]) if tags exist in updates
   - Both encryption operations are executed concurrently using `Promise.all`
   - Finally, it merges the encrypted content and tags with the original event template
   - The method returns a complete event template with encrypted fields

The class provides a clean abstraction for handling encrypted Nostr events, separating the encryption logic from the event structure.

related: EncryptableUpdates

code:
export class Encryptable<T extends EventTemplate> {
  /**
   * Creates an instance of Encryptable.
   * @param event - An EventTemplate with optional tags and content.
   * @param updates - Plaintext updates to be applied to the event content.
   * @example
   * Here's an example which enables updating a private mute list:
   * ```
   * const event = {kind: 10000, content: "", tags: []} // An event, only kind is required
   * const encryptable = new Encryptable(event, {content: JSON.stringify([["e", "bad word"]])})
   * const eventTemplate = await encryptable.reconcile(myEncryptFunction)
   * ```
   */
  constructor(
    readonly event: Partial<T>,
    readonly updates: EncryptableUpdates,
  ) {}

  /**
   * Encrypts plaintext updates and merges them into the event template.
   * @param encrypt - The encryption function to be used.
   * @returns A promise that resolves to the reconciled and encrypted event.
   */
  async reconcile(encrypt: Encrypt) {
    const encryptContent = () => {
      if (!this.updates.content) return undefined

      return encrypt(this.updates.content)
    }

    const encryptTags = () => {
      if (!this.updates.tags) return undefined

      return Promise.all(
        this.updates.tags.map(async tag => {
          tag[1] = await encrypt(tag[1])

          return tag
        }),
      )
    }

    const [content, tags] = await Promise.all([encryptContent(), encryptTags()])

    // Updates are optional. If not provided, fall back to the event's content and tags.
    return {
      ...this.event,
      tags: tags || this.event.tags || [],
      content: content || this.event.content || "",
    } as T
  }
}

import/access examples:
import { Encryptable } from '@welshman/util';
import { Encryptable } from '@welshman/util/Encryptable';


=========================
workspace: packages/util
file: packages/util/src/Filters.ts
lines: 18:18
id: 4ee47ab390182cd47714b877e057f562597c9d55d9f16c2c851d9413321b720b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Filters.ts#L18

declaration:
EPOCH = 1609459200

summary:
A constant representing the UNIX timestamp for January 1, 2021 00:00:00 UTC (1609459200), which serves as an epoch reference point for time-based operations in the Nostr protocol.

details:
This constant defines a specific point in time (January 1, 2021) that likely serves as a reference timestamp for the Nostr protocol implementation. Epoch timestamps are commonly used as starting points for relative time calculations or as default values when filtering events by time.

import/access examples:
import { EPOCH } from '@welshman/util';
import { EPOCH } from '@welshman/util/Filters';


=========================
workspace: packages/util
file: packages/util/src/Filters.ts
lines: 20:20
id: 580eadb64450b01930058e23741ed40bd4b7b2e236f65aa2a52cf1c14a7ce4bc
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Filters.ts#L20

declaration:
neverFilter = {ids: []}

summary:
A constant filter object that will never match any event. It contains an empty array of IDs, which means it will only match events with IDs in that array (which is none).

details:
This is a simple constant object that serves as a utility filter that will never match any events in the Nostr protocol. It works because a filter with an empty `ids` array can only match events whose IDs are in that array, which is impossible since the array is empty.

import/access examples:
import { neverFilter } from '@welshman/util';
import { neverFilter } from '@welshman/util/Filters';


=========================
workspace: packages/util
file: packages/util/src/Filters.ts
lines: 22:31
id: c16bb763987ded9d61651106447f86c315f90c4d55d11942820243a011fce53c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Filters.ts#L22

declaration:
export type Filter = {
  ids?: string[]
  kinds?: number[]
  authors?: string[]
  since?: number
  until?: number
  limit?: number
  search?: string
  [key: `#${string}`]: string[]
}

summary:
The `Filter` type defines the structure for filtering Nostr events. It includes optional properties for filtering by event IDs, kinds, authors, time ranges (since/until), limiting results, and searching content. It also allows for arbitrary tag-based filtering through the indexed signature `[key: `#${string}`]: string[]`.

details:
This type definition is a core part of the Nostr protocol implementation, representing the filter structure used when querying events from relays. The structure includes:

1. `ids?`: Optional array of event IDs to match
2. `kinds?`: Optional array of event kinds to match
3. `authors?`: Optional array of pubkeys (authors) to match
4. `since?`: Optional timestamp to filter events after a certain time
5. `until?`: Optional timestamp to filter events before a certain time
6. `limit?`: Optional number to limit the amount of returned events
7. `search?`: Optional string for content searching
8. `[key: `#${string}`]: string[]`: An indexed signature allowing for tag-based filtering where keys start with '#' (like '#e' for event references or '#p' for pubkey references)

This type is used throughout the codebase for relay queries and event filtering operations.

import/access examples:
import type { Filter } from '@welshman/util';
import type { Filter } from '@welshman/util/Filters';


=========================
workspace: packages/util
file: packages/util/src/Filters.ts
lines: 33:52
id: 28c6cb1342c502f67e5dd3a3a520b9e37b2377540c04e3e545cf0d4658aaa183
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Filters.ts#L33

declaration:
matchFilter = <E extends HashedEvent>(filter: Filter, event: E) => {
  if (!nostrToolsMatchFilter(filter, event as unknown as SignedEvent)) {
    return false
  }

  if (filter.search) {
    const content = event.content.toLowerCase()
    const terms = filter.search.toLowerCase().split(/\s+/g)

    for (const term of terms) {
      if (content.includes(term)) {
        return true
      }

      return false
    }
  }

  return true
}

summary:
A function that checks if a given event matches a filter. It extends the basic filter matching from nostr-tools by adding support for text search. The function takes a Filter object and an event of type HashedEvent, and returns a boolean indicating whether the event matches the filter criteria.

details:
The implementation works in two steps:

1. First, it uses the `nostrToolsMatchFilter` function from the nostr-tools library to perform basic filter matching. If this fails, it immediately returns false.

2. If the filter includes a search term, it performs additional text search logic:
   - Converts both the event content and search terms to lowercase
   - Splits search terms by whitespace
   - Checks if any term is included in the content
   - Returns true on the first match, false otherwise

Note: There appears to be a logical bug in the search implementation - it will return false after checking only the first term if that term isn't found, rather than checking all terms.

related: Filter

import/access examples:
import { matchFilter } from '@welshman/util';
import { matchFilter } from '@welshman/util/Filters';


=========================
workspace: packages/util
file: packages/util/src/Filters.ts
lines: 54:62
id: 24c9bca141ac1be0c651dced866d2cd60363daa73af811cc57f5628faa71428f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Filters.ts#L54

declaration:
matchFilters = <E extends HashedEvent>(filters: Filter[], event: E) => {
  for (const filter of filters) {
    if (matchFilter(filter, event)) {
      return true
    }
  }

  return false
}

summary:
Checks if an event matches any of the provided filters. Returns true if at least one filter matches the event, otherwise returns false. The function is generic, accepting any event type that extends HashedEvent.

details:
The implementation iterates through each filter in the provided array and uses the `matchFilter` function to check if the event matches that filter. As soon as a match is found, it returns true. If no matches are found after checking all filters, it returns false.

This is a simple implementation of the logical OR operation across multiple filters - an event passes if it matches ANY of the provided filters.

related: Filter

import/access examples:
import { matchFilters } from '@welshman/util';
import { matchFilters } from '@welshman/util/Filters';


=========================
workspace: packages/util
file: packages/util/src/Filters.ts
lines: 64:78
id: 733891dc77bdeebdd23d8312da8e2a920b0add0313657aa7634c8bfbb6a72005
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Filters.ts#L64

declaration:
getFilterId = (filter: Filter) => {
  const keys = Object.keys(filter)

  keys.sort()

  const parts = []
  for (const k of keys) {
    const v = filter[k as keyof Filter]
    const s = Array.isArray(v) ? v.join(",") : v

    parts.push(`${k}:${s}`)
  }

  return hash(parts.join("|"))
}

summary:
A function that generates a unique hash identifier for a given Nostr filter. It takes a Filter object as input and returns a string hash that represents the filter's content in a deterministic way.

details:
The implementation works by:
1. Getting all keys from the filter object
2. Sorting the keys alphabetically for consistent ordering
3. Creating an array of string parts where each part is formatted as "key:value"
4. For array values, it joins the array elements with commas
5. For non-array values, it uses the value directly
6. Finally, it joins all parts with a pipe character and hashes the resulting string using an imported hash function

This creates a consistent, unique identifier for filters with the same content regardless of the original property order.

related: Filter

import/access examples:
import { getFilterId } from '@welshman/util';
import { getFilterId } from '@welshman/util/Filters';


=========================
workspace: packages/util
file: packages/util/src/Filters.ts
lines: 80:89
id: 34e0c46afbf817f2a6e8fa3aee40a788d477e71b6bd1a57eda6b0e524735cdbf
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Filters.ts#L80

declaration:
calculateFilterGroup = ({since, until, limit, search, ...filter}: Filter) => {
  const group = Object.keys(filter)

  if (since) group.push(`since:${since}`)
  if (until) group.push(`until:${until}`)
  if (limit) group.push(`limit:${randomId()}`)
  if (search) group.push(`search:${search}`)

  return group.sort().join("-")
}

summary:
Calculates a string identifier for a filter group based on its properties. It takes a Filter object as input and returns a string that represents the filter's grouping characteristics. The function handles special properties like 'since', 'until', 'limit', and 'search' separately from other filter properties.

details:
The implementation works by:
1. Destructuring the input Filter object to separate special properties (since, until, limit, search) from other filter properties
2. Starting with the keys of the remaining filter properties as the base group
3. Adding special properties to the group with specific formatting:
   - 'since' and 'until' are added with their values
   - 'limit' is added with a random ID (making each limit filter unique)
   - 'search' is added with its value
4. Finally, sorting the group elements and joining them with hyphens to create a consistent string identifier

The function is used for grouping similar filters, particularly in the unionFilters function (line 95).

related: Filter

import/access examples:
import { calculateFilterGroup } from '@welshman/util';
import { calculateFilterGroup } from '@welshman/util/Filters';


=========================
workspace: packages/util
file: packages/util/src/Filters.ts
lines: 91:110
id: fdba606801556a333c9d3f9ed608e74718f7b3a46ec5544e8fdd9ef81bb2c052
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Filters.ts#L91

declaration:
unionFilters = (filters: Filter[]) => {
  const result = []

  // Group, but also get unique filters by ids because duplicates can come through subscribe
  for (const group of groupBy(calculateFilterGroup, uniqBy(getFilterId, filters)).values()) {
    const newFilter: Record<string, any> = {}

    for (const k of Object.keys(group[0])) {
      if (["since", "until", "limit", "search"].includes(k)) {
        newFilter[k] = (group[0] as Record<string, any>)[k]
      } else {
        newFilter[k] = uniq(group.flatMap(prop(k)))
      }
    }

    result.push(newFilter as Filter)
  }

  return result
}

summary:
Combines multiple Filter objects into a unified set of filters. This function groups similar filters together and merges their properties, creating a more efficient representation. It handles special properties like 'since', 'until', 'limit', and 'search' differently than array-based properties.

details:
The implementation works by:
1. First deduplicating filters by their ID (using getFilterId)
2. Then grouping similar filters together using calculateFilterGroup
3. For each group of similar filters:
   - Special properties (since, until, limit, search) are taken from the first filter in the group
   - Array properties are combined using flatMap and made unique with uniq
4. The function uses helper functions like groupBy, uniqBy, prop, and uniq from an external library
5. The result is a new array of Filter objects that represents the union of all input filters

related: Filter

import/access examples:
import { unionFilters } from '@welshman/util';
import { unionFilters } from '@welshman/util/Filters';


=========================
workspace: packages/util
file: packages/util/src/Filters.ts
lines: 112:142
id: ce7515ccc8a8df0182c131fe0cfddd71104870fb9627aa12f8c4cef6d0774467
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Filters.ts#L112

declaration:
intersectFilters = (groups: Filter[][]) => {
  let result = groups[0]

  for (const filters of groups.slice(1)) {
    result = result.flatMap(f1 => {
      return filters.map(f2 => {
        const f3: Filter = {}

        for (const k of uniq([...Object.keys(f1), ...Object.keys(f2)]) as (keyof Filter)[]) {
          if (k === "since" || k === "limit") {
            f3[k] = Math.max(f1[k] || 0, f2[k] || 0)
          } else if (k === "until") {
            f3[k] = Math.min(f1[k] || f2[k] || 0, f2[k] || f1[k] || 0)
          } else if (k === "search") {
            if (f1[k] && f2[k] && f1[k] !== f2[k]) {
              f3[k] = [f1[k], f2[k]].join(" ")
            } else {
              f3[k] = f1[k] || f2[k]
            }
          } else {
            f3[k] = uniq([...(f1[k] || []), ...(f2[k] || [])]) as any[]
          }
        }

        return f3
      })
    })
  }

  return unionFilters(result)
}

summary:
Intersects multiple groups of Nostr filters. Takes an array of filter groups (Filter[][]) and returns a unified array of filters that represent the intersection of all groups. This function is useful for combining multiple filter sets in a way that ensures all conditions from each group are met.

details:
The implementation works by:

1. Starting with the first group of filters as the base result
2. For each subsequent group, it creates a cartesian product by combining each filter from the current result with each filter from the new group
3. When combining filters, it handles special fields differently:
   - For 'since' and 'limit': takes the maximum value
   - For 'until': takes the minimum value
   - For 'search': joins search terms with a space if they differ
   - For all other fields (arrays): concatenates and removes duplicates
4. Finally, it calls unionFilters() to merge similar filters and remove duplicates

The function effectively creates a more complex filter set that represents the intersection of all conditions from the input filter groups.

related: Filter

import/access examples:
import { intersectFilters } from '@welshman/util';
import { intersectFilters } from '@welshman/util/Filters';


=========================
workspace: packages/util
file: packages/util/src/Filters.ts
lines: 144:169
id: a5973bd0579b525ab68d4c75f730e6be2c557567aaba03e23f093275b3787943
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Filters.ts#L144

declaration:
getIdFilters = (idsOrAddresses: string[]) => {
  const ids = []
  const aFilters = []

  for (const idOrAddress of idsOrAddresses) {
    if (Address.isAddress(idOrAddress)) {
      const {kind, pubkey, identifier} = Address.from(idOrAddress)

      if (identifier) {
        aFilters.push({kinds: [kind], authors: [pubkey], "#d": [identifier]})
      } else {
        aFilters.push({kinds: [kind], authors: [pubkey]})
      }
    } else {
      ids.push(idOrAddress)
    }
  }

  const filters = unionFilters(aFilters)

  if (ids.length > 0) {
    filters.push({ids})
  }

  return filters
}

summary:
Converts an array of IDs or Nostr addresses into a set of filters that can be used to query events. It processes each input string, determining if it's a Nostr address (using Address.isAddress) or a regular ID. For addresses, it extracts components and creates appropriate filters based on kind, pubkey, and optional identifier. Regular IDs are collected separately. The function returns a unified set of filters that will match all the provided IDs and addresses.

details:
The implementation works in these steps:

1. Initializes two arrays: `ids` for regular event IDs and `aFilters` for address-based filters
2. Iterates through each input string in `idsOrAddresses`:
   - If the string is a Nostr address (checked with `Address.isAddress`), it:
     - Extracts components (kind, pubkey, identifier) using `Address.from`
     - Creates appropriate filter objects with these components
     - Adds different filter structures based on whether an identifier exists
   - Otherwise, adds the string to the `ids` array as a regular event ID
3. Combines all address filters using `unionFilters` to optimize and deduplicate
4. If any regular IDs were found, adds an additional filter with those IDs
5. Returns the complete set of filters that will match any of the input IDs or addresses

related: Filter

import/access examples:
import { getIdFilters } from '@welshman/util';
import { getIdFilters } from '@welshman/util/Filters';


=========================
workspace: packages/util
file: packages/util/src/Filters.ts
lines: 171:198
id: 2dc0283561eb1bb6cb069869afa06ef8f9a60445ff0c247e47cf3e707d2b125b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Filters.ts#L171

declaration:
getReplyFilters = (events: TrustedEvent[], filter: Filter = {}) => {
  const a = []
  const e = []

  for (const event of events) {
    e.push(event.id)

    if (isReplaceableKind(event.kind)) {
      a.push(getAddress(event))
    }

    if (event.wrap) {
      e.push(event.wrap.id)
    }
  }

  const filters = []

  if (a.length > 0) {
    filters.push({...filter, "#a": a})
  }

  if (e.length > 0) {
    filters.push({...filter, "#e": e})
  }

  return filters
}

summary:
Creates filters for finding replies to a set of events. Takes an array of TrustedEvent objects and an optional Filter object. Returns an array of Filter objects that can be used to find events that reference the input events either by their ID or by their address (for replaceable events).

details:
The function works by:
1. Creating two arrays: 'a' for addresses and 'e' for event IDs
2. For each event in the input array:
   - Adds the event ID to the 'e' array
   - If the event has a replaceable kind, gets its address and adds it to the 'a' array
   - If the event has a 'wrap' property, also adds the wrapped event ID to the 'e' array
3. Creates filters based on these collections:
   - If there are addresses, creates a filter with '#a' tag containing those addresses
   - If there are event IDs, creates a filter with '#e' tag containing those IDs
4. Both filters include any properties from the optional filter parameter
5. Returns the array of created filters

related: TrustedEvent,Filter

import/access examples:
import { getReplyFilters } from '@welshman/util';
import { getReplyFilters } from '@welshman/util/Filters';


=========================
workspace: packages/util
file: packages/util/src/Filters.ts
lines: 200:219
id: c362df998713818237ad87cd62014f82693883ce9f4c9280ca25cc0c1d235304
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Filters.ts#L200

declaration:
addRepostFilters = (filters: Filter[]) =>
  filters.flatMap(original => {
    const filterChunk = [original]

    if (!original.kinds) {
      filterChunk.push({...original, kinds: [6, 16]})
    } else {
      if (original.kinds.includes(1)) {
        filterChunk.push({...original, kinds: [6]})
      }

      const otherKinds = without([1], original.kinds)

      if (otherKinds.length > 0) {
        filterChunk.push({...original, kinds: [16], "#k": otherKinds.map(String)})
      }
    }

    return filterChunk
  })

summary:
A function that enhances a list of Nostr filters to include repost events. It takes an array of Filter objects and returns an expanded array that includes the original filters plus additional filters for repost kinds (6 and 16). This allows queries to find both original events and their reposts.

details:
The implementation works by processing each filter in the input array and creating additional filters for reposts:

1. For each original filter, it creates a new array starting with the original filter
2. If the original filter doesn't specify kinds, it adds a new filter with kinds 6 and 16 (both repost kinds)
3. If the original filter includes kind 1 (text notes), it adds a filter specifically for kind 6 (reposts of notes)
4. For other kinds, it adds a filter for kind 16 (generic reposts) with a #k tag containing the original kinds
5. The function uses flatMap to combine all these filter chunks into a single array

The function handles the complexity of Nostr's two different repost kinds (6 for notes, 16 for other kinds) appropriately.

related: Filter

import/access examples:
import { addRepostFilters } from '@welshman/util';
import { addRepostFilters } from '@welshman/util/Filters';


=========================
workspace: packages/util
file: packages/util/src/Filters.ts
lines: 221:237
id: f5d49c8c5a604fea191d945d0fd2ae3baaa0eaf05d65c5d704d492d35f7097c0
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Filters.ts#L221

declaration:
getFilterGenerality = (filter: Filter) => {
  if (filter.ids || filter["#e"] || filter["#a"]) {
    return 0
  }

  const hasTags = Object.keys(filter).find((k: string) => k.startsWith("#"))

  if (filter.authors && hasTags) {
    return 0.2
  }

  if (filter.authors) {
    return Math.min(1, filter.authors.length / 300)
  }

  return 1
}

summary:
The `getFilterGenerality` function calculates a generality score for a Nostr filter, indicating how broad or specific the filter is. It returns a value between 0 and 1, where 0 means very specific (targeting exact events) and 1 means very general (potentially matching many events). This score can be used to optimize filter handling and caching strategies.

details:
The implementation works by analyzing the filter properties to determine specificity:

1. Returns 0 (most specific) if the filter contains direct identifiers like `ids`, `#e` (event references), or `#a` (address references)
2. Returns 0.2 if the filter specifies both `authors` and has tag-based filtering
3. For filters with only `authors`, calculates a score based on the number of authors (more authors = more general), with a maximum of 1 when authors.length ≥ 300
4. Returns 1 (most general) for all other cases

This function is used by `guessFilterDelta` to estimate appropriate time windows for queries based on filter specificity.

related: Filter

import/access examples:
import { getFilterGenerality } from '@welshman/util';
import { getFilterGenerality } from '@welshman/util/Filters';


=========================
workspace: packages/util
file: packages/util/src/Filters.ts
lines: 239:240
id: c3bdd61811ba5ea03f7923792309914dee914f128f5b4877ff2b5718bdab842f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Filters.ts#L239

declaration:
guessFilterDelta = (filters: Filter[], max = 60 * 60 * 24) =>
  Math.round(max * Math.max(0.01, 1 - avg(filters.map(getFilterGenerality))))

summary:
Estimates a time delta (in seconds) for a set of filters based on their generality. The function takes an array of Filter objects and an optional maximum delta value (defaults to 24 hours in seconds). It returns a rounded number representing the suggested time window for the filters, with more specific filters getting larger deltas and more general filters getting smaller deltas.

details:
The implementation works by:
1. Mapping each filter through the getFilterGenerality function to get a generality score between 0 and 1
2. Taking the average generality score using the avg utility function
3. Subtracting the average from 1 to invert the scale (so more specific filters get higher values)
4. Ensuring a minimum value of 0.01 using Math.max
5. Multiplying by the max parameter (default 86400 seconds = 24 hours)
6. Rounding the result to the nearest integer

This function is useful for determining appropriate time windows when querying events, with more specific filters allowing for larger time windows.

related: Filter

import/access examples:
import { guessFilterDelta } from '@welshman/util';
import { guessFilterDelta } from '@welshman/util/Filters';


=========================
workspace: packages/util
file: packages/util/src/Filters.ts
lines: 243:249
id: 6d9b9f51cb638c642a572be7d72c2b3aa91494e672be1eb473663c34749f508c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Filters.ts#L243

declaration:
getFilterResultCardinality = (filter: Filter) => {
  if (filter.ids) {
    return filter.ids.length
  }

  return undefined
}

summary:
A function that determines the expected number of results from a filter. If the filter specifies 'ids', it returns the length of the ids array (since each id corresponds to exactly one result). Otherwise, it returns undefined as the cardinality cannot be determined.

details:
The implementation is straightforward:
1. It checks if the filter has an 'ids' property
2. If 'ids' exists, it returns the length of the array, which represents the exact number of results to expect
3. If 'ids' doesn't exist, it returns undefined since there's no way to determine how many results the filter will match

related: Filter

import/access examples:
import { getFilterResultCardinality } from '@welshman/util';
import { getFilterResultCardinality } from '@welshman/util/Filters';


=========================
workspace: packages/util
file: packages/util/src/Filters.ts
lines: 251:255
id: 714945f19499d51cce0d6c998a8a670ea06ed649e5689f3b771a92408ada0423
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Filters.ts#L251

declaration:
trimFilter = (filter: Filter): Filter =>
  mapVals(
    v => (Array.isArray(v) && v.length > 1000 ? shuffle(v as string[]).slice(0, 1000) : v),
    filter,
  ) as Filter

summary:
A function that trims arrays in a Nostr filter to a maximum of 1000 elements. It takes a Filter object and returns a new Filter with any arrays longer than 1000 elements randomly shuffled and reduced to 1000 elements.

details:
The implementation uses the `mapVals` utility function to transform each value in the filter. For each value, it checks if it's an array with more than 1000 elements. If so, it:
1. Shuffles the array using the `shuffle` function
2. Slices the first 1000 elements
3. Returns the trimmed array

If the value is not an array or has fewer than 1000 elements, it returns the original value unchanged. The result is cast back to the Filter type.

related: mapVals,Filter

import/access examples:
import { trimFilter } from '@welshman/util';
import { trimFilter } from '@welshman/util/Filters';


=========================
workspace: packages/util
file: packages/util/src/Filters.ts
lines: 257:257
id: cb2843d0bd3664dd71b87e9af512f0ea261e4580776f5709efede7fbf76ca906
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Filters.ts#L257

declaration:
trimFilters = (filters: Filter[]) => filters.map(trimFilter)

summary:
The `trimFilters` function takes an array of Filter objects and applies the `trimFilter` function to each filter in the array. It returns a new array of trimmed filters, ensuring that large filter arrays are reduced to a manageable size.

details:
This is a simple utility function that maps the `trimFilter` function over an array of filters. It doesn't contain complex implementation details - it's just a one-liner that applies the `trimFilter` function (defined earlier in the file) to each filter in the input array. The `trimFilter` function reduces arrays in filter properties to a maximum of 1000 elements by shuffling and slicing when necessary.

related: Filter

import/access examples:
import { trimFilters } from '@welshman/util';
import { trimFilters } from '@welshman/util/Filters';


=========================
workspace: packages/util
file: packages/util/src/Handler.ts
lines: 6:16
id: 548e366f617dd80ff37c173e5bd9574b929206edcb3c3647f50a6dce411a7758
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Handler.ts#L6

declaration:
export type Handler = {
  kind: number
  name: string
  about: string
  image: string
  identifier: string
  event: TrustedEvent
  website?: string
  lud16?: string
  nip05?: string
}

summary:
The `Handler` type represents a handler entity in the system, containing metadata about a handler such as its kind, name, about information, image, identifier, and associated event. It also includes optional fields for website, Lightning address (lud16), and NIP-05 identifier.

details:
This type alias defines the structure for handler objects used throughout the application. It combines metadata from Nostr events with specific handler information. The type includes required fields (kind, name, about, image, identifier, event) and optional fields (website, lud16, nip05) that represent various attributes of a handler entity. The `event` field is of type `TrustedEvent`, suggesting this is used in a Nostr-related application where events have been validated or trusted in some way.

related: TrustedEvent

import/access examples:
import type { Handler } from '@welshman/util';
import type { Handler } from '@welshman/util/Handler';


=========================
workspace: packages/util
file: packages/util/src/Handler.ts
lines: 18:41
id: b4f0173471e3a9ea46a57eecb920029ad48bf627667a23a53cca48379a13a9ab
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Handler.ts#L18

declaration:
readHandlers = (event: TrustedEvent) => {
  const {d: identifier} = fromPairs(event.tags)
  const meta = parseJson(event.content)
  const normalizedMeta = {
    name: meta?.name || meta?.display_name || "",
    image: meta?.image || meta?.picture || "",
    about: meta?.about || "",
    website: meta?.website || "",
    lud16: meta?.lud16 || "",
    nip05: meta?.nip05 || "",
  }

  // If our meta is missing important stuff, don't bother showing it
  if (!normalizedMeta.name || !normalizedMeta.image) {
    return []
  }

  return getKindTagValues(event.tags).map(kind => ({
    ...normalizedMeta,
    kind,
    identifier,
    event,
  })) as Handler[]
}

summary:
Parses a trusted event and extracts handler information. Takes a TrustedEvent parameter and returns an array of Handler objects. Each Handler contains metadata like name, image, about, website, etc., along with kind, identifier, and the original event. Returns an empty array if essential metadata (name or image) is missing.

details:
The function works in several steps:
1. Extracts the identifier from the event tags using the 'd' tag via fromPairs
2. Parses the JSON content from the event
3. Normalizes metadata with fallbacks for various fields (name/display_name, image/picture, etc.)
4. Performs validation - returns empty array if name or image is missing
5. Maps over kind tag values from the event to create Handler objects
6. Each Handler combines the normalized metadata with kind, identifier and original event

The function uses helper functions like getKindTagValues to extract specific tag information from the event.

related: TrustedEvent,Handler

import/access examples:
import { readHandlers } from '@welshman/util';
import { readHandlers } from '@welshman/util/Handler';


=========================
workspace: packages/util
file: packages/util/src/Handler.ts
lines: 43:43
id: 8b968b84e1e9427cdd256dc4cd5aed8efd6d22f279b60ff2c4357ab122bf464a
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Handler.ts#L43

declaration:
getHandlerKey = (handler: Handler) => `${handler.kind}:${getAddress(handler.event)}`

summary:
A function that generates a unique key for a Handler object by combining its kind and address. The key is formatted as 'kind:address'.

details:
This function takes a Handler object as input and returns a string that serves as a unique identifier for the handler. It concatenates the handler's kind (a number) with the address obtained from the handler's event property using the getAddress function, separated by a colon. This key can be used for indexing or identifying handlers in collections.

related: Handler

import/access examples:
import { getHandlerKey } from '@welshman/util';
import { getHandlerKey } from '@welshman/util/Handler';


=========================
workspace: packages/util
file: packages/util/src/Handler.ts
lines: 45:45
id: ad8a0c418a7d6c93b741788f2fab37bbeddf0440133461fb1979db480320eacb
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Handler.ts#L45

declaration:
displayHandler = (handler?: Handler, fallback = "") => handler?.name || fallback

summary:
A utility function that returns the name of a Handler object or a fallback value if the handler is undefined or has no name. This function is useful for displaying handler names in UI components.

details:
This is a simple arrow function that takes two parameters:
1. `handler`: An optional Handler object
2. `fallback`: A string with a default value of an empty string

The function uses the optional chaining operator (`?.`) to safely access the name property of the handler if it exists, and returns that value. If the handler is undefined or has no name property, it returns the fallback value instead.

related: name,Handler

import/access examples:
import { displayHandler } from '@welshman/util';
import { displayHandler } from '@welshman/util/Handler';


=========================
workspace: packages/util
file: packages/util/src/Handler.ts
lines: 47:52
id: 5509bdbefa2de5698d1f60b92c0ab5f2f6c1df174b154c5c86d1806e5425a637
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Handler.ts#L47

declaration:
getHandlerAddress = (event: TrustedEvent) => {
  const tags = getAddressTags(event.tags)
  const tag = tags.find(t => last(t) === "web") || first(tags)

  return tag?.[1]
}

summary:
Extracts the address from a TrustedEvent by examining its tags. The function prioritizes tags marked with 'web' relay, falling back to the first address tag if no web-specific tag is found. Returns the address string (the second element of the tag) or undefined if no address tags exist.

details:
Implementation details:
1. Uses getAddressTags() to filter the event's tags for address-related tags
2. Searches for a tag with 'web' as its last element using Array.find()
3. If no 'web' tag is found, falls back to the first address tag using first()
4. Returns the second element of the found tag (index 1), which contains the actual address
5. Uses optional chaining (?.) to safely handle cases where no tag is found

related: TrustedEvent

import/access examples:
import { getHandlerAddress } from '@welshman/util';
import { getHandlerAddress } from '@welshman/util/Handler';


=========================
workspace: packages/util
file: packages/util/src/Links.ts
lines: 1:1
id: 1620c9e6528e4b91e73531a137d8d69a206fda644b9f87e39806af3a4ccd3504
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Links.ts#L1

declaration:
fromNostrURI = (s: string) => s.replace(/^nostr:\/?\/?/, "")

summary:
Removes the 'nostr:' or 'nostr://' prefix from a string. Takes a string parameter and returns the string with the Nostr protocol prefix removed.

details:
A simple arrow function that uses string's replace method with a regular expression to match and remove the 'nostr:' prefix, including optional one or two forward slashes that might follow it. The regex pattern `^nostr:\/?\/?' matches 'nostr:', 'nostr:/' or 'nostr://' at the beginning of the string and replaces it with an empty string.

import/access examples:
import { fromNostrURI } from '@welshman/util';
import { fromNostrURI } from '@welshman/util/Links';


=========================
workspace: packages/util
file: packages/util/src/Links.ts
lines: 3:3
id: 6dea8b039a4df0cc52200516432edea78b4763344ed5feffa666fd4766a53f4b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Links.ts#L3

declaration:
toNostrURI = (s: string) => (s.startsWith("nostr:") ? s : `nostr:${s}`)

summary:
Converts a string to a Nostr URI format. If the string already starts with 'nostr:', it returns the original string. Otherwise, it prepends 'nostr:' to the string.

details:
This is a simple arrow function that takes a string parameter and performs a conditional check using the ternary operator. It checks if the input string already starts with 'nostr:' using the startsWith() method. If true, it returns the original string unchanged. If false, it uses a template literal to concatenate 'nostr:' with the input string.

import/access examples:
import { toNostrURI } from '@welshman/util';
import { toNostrURI } from '@welshman/util/Links';


=========================
workspace: packages/util
file: packages/util/src/List.ts
lines: 8:10
id: 98d8f0d8e2dbf2179499d1555ffba927bcdfd534bf9665df8e22e7177e0db15f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/List.ts#L8

declaration:
export type ListParams = {
  kind: number
}

summary:
A type alias that defines the basic parameters for a list in the system. Currently, it only includes a `kind` property which is a number representing the type or category of the list.

details:
This is a simple type definition that serves as the foundation for more complex list types in the system. It's used as a base type that gets extended by other list-related types like `List` and `PublishedList`. The `kind` property likely corresponds to Nostr event kinds, which are numerical identifiers for different types of events in the Nostr protocol.

import/access examples:
import type { ListParams } from '@welshman/util';
import type { ListParams } from '@welshman/util/List';


=========================
workspace: packages/util
file: packages/util/src/List.ts
lines: 12:16
id: 890b33088b5a0c5c0c1782a846b47bc4f04f94058ba7241ec3d3d29b012a21dc
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/List.ts#L12

declaration:
export type List = ListParams & {
  publicTags: string[][]
  privateTags: string[][]
  event?: DecryptedEvent
}

summary:
A type alias representing a list in the system. It extends `ListParams` and includes properties for public and private tags, as well as an optional event. This type is used to represent lists that may or may not have been published yet.

details:
The `List` type combines the `ListParams` type (which contains a `kind` number) with additional properties:
1. `publicTags`: A two-dimensional array of strings representing tags that are publicly visible
2. `privateTags`: A two-dimensional array of strings representing tags that are encrypted/private
3. `event`: An optional `DecryptedEvent` that represents the underlying Nostr event if the list has been published

This type is part of a system that handles both published and unpublished lists, with functions in the module for creating, reading, and manipulating these lists.

related: ListParams,DecryptedEvent

import/access examples:
import type { List } from '@welshman/util';
import type { List } from '@welshman/util/List';


=========================
workspace: packages/util
file: packages/util/src/List.ts
lines: 18:20
id: 6b7b8e8533c6f875791e8332af488298dc07b2456967c130b5c3a8bf921ac32b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/List.ts#L18

declaration:
export type PublishedList = Omit<List, "event"> & {
  event: DecryptedEvent
}

summary:
PublishedList is a type alias that represents a published list in the system. It extends the base List type but replaces the optional event property with a required DecryptedEvent. This type is used to represent lists that have been published and therefore must have an associated event.

details:
The PublishedList type is defined using TypeScript's utility type Omit<List, "event"> to remove the optional event property from the List type, and then adds back a required event property of type DecryptedEvent. This ensures that any PublishedList instance must have an associated event, unlike a regular List where the event is optional. This type is used in functions like readList which converts a DecryptedEvent into a PublishedList.

related: List,DecryptedEvent

import/access examples:
import type { PublishedList } from '@welshman/util';
import type { PublishedList } from '@welshman/util/List';


=========================
workspace: packages/util
file: packages/util/src/List.ts
lines: 22:26
id: a21afc6ecab9aa23a7e986928a8f466d0c9b6ab4c5ce167c29ee31ebbbd19e25
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/List.ts#L22

declaration:
makeList = (list: ListParams & Partial<List>): List => ({
  publicTags: [],
  privateTags: [],
  ...list,
})

summary:
Creates a new List object with default values for publicTags and privateTags. Takes a ListParams object with optional List properties and returns a complete List object with the provided values merged with defaults.

details:
A simple factory function that initializes a List object with empty arrays for publicTags and privateTags, then spreads the provided list parameter to override defaults. This ensures that any List created with this function will always have the required properties even if they weren't specified in the input.

related: ListParams,List

import/access examples:
import { makeList } from '@welshman/util';
import { makeList } from '@welshman/util/List';


=========================
workspace: packages/util
file: packages/util/src/List.ts
lines: 28:37
id: cbf8380fdcabb3487b7c71ad8371493aa8391ce024329e16883b1f0d6d214243
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/List.ts#L28

declaration:
isValidTag = (tag: string[]) => {
  if (tag[0] === "p") return tag[1]?.length === 64
  if (tag[0] === "e") return tag[1]?.length === 64
  if (tag[0] === "a") return Address.isAddress(tag[1] || "")
  if (tag[0] === "t") return tag[1]?.length > 0
  if (tag[0] === "r") return isRelayUrl(tag[1])
  if (tag[0] === "relay") return isRelayUrl(tag[1])

  return true
}

summary:
A function that validates if a tag array is properly formatted based on its type. It checks different tag types: 'p' and 'e' tags must have a 64-character string as their second element, 'a' tags must contain a valid address, 't' tags must have a non-empty second element, and 'r' or 'relay' tags must contain a valid relay URL. Returns true if the tag is valid, false otherwise.

details:
The implementation performs a series of conditional checks on the tag's first element (tag[0]) to determine its type, then applies specific validation rules:
1. For 'p' and 'e' tags: checks if the second element is exactly 64 characters long
2. For 'a' tags: uses the Address.isAddress utility to validate the address
3. For 't' tags: ensures the second element exists and is not empty
4. For 'r' and 'relay' tags: uses isRelayUrl utility to validate the URL
5. Returns true by default for any other tag types (allowing unknown tag types to pass validation)

=========================
workspace: packages/util
file: packages/util/src/List.ts
lines: 39:45
id: f14608d925be552599716d97f0e7dae6277c163598aabdc3ad79faeaeea55070
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/List.ts#L39

declaration:
readList = (event: DecryptedEvent): PublishedList => {
  const getTags = (tags: string[][]) => (Array.isArray(tags) ? tags.filter(isValidTag) : [])
  const privateTags = getTags(parseJson(event.plaintext?.content))
  const publicTags = getTags(event.tags)

  return {event, kind: event.kind, publicTags, privateTags}
}

summary:
Converts a DecryptedEvent into a PublishedList by extracting and validating both public and private tags. The function parses the event's plaintext content for private tags and uses the event's tags property for public tags, filtering both through validation checks.

details:
Implementation details:
1. Takes a DecryptedEvent as input
2. Defines a local getTags helper function that:
   - Checks if the input is an array
   - Filters the tags using the isValidTag function
   - Returns an empty array if input is not an array
3. Extracts private tags by parsing the JSON from event.plaintext?.content
4. Extracts public tags directly from event.tags
5. Returns a PublishedList object containing:
   - The original event
   - The event kind
   - The filtered public tags
   - The filtered private tags

related: DecryptedEvent,PublishedList

import/access examples:
import { readList } from '@welshman/util';
import { readList } from '@welshman/util/List';


=========================
workspace: packages/util
file: packages/util/src/List.ts
lines: 47:50
id: 4da82eae7d4ae2983f3ae6f12ee69ba569868ee4f26e5c5c801f4f783f5e9f4e
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/List.ts#L47

declaration:
getListTags = (list: List | undefined) => [
  ...(list?.publicTags || []),
  ...(list?.privateTags || []),
]

summary:
A utility function that extracts and combines all tags from a List object. It takes an optional List parameter and returns an array containing both public and private tags from the list. If the list is undefined, it returns an empty array.

details:
The implementation is straightforward:
1. It uses the spread operator to combine two arrays:
   - The list's publicTags (or an empty array if undefined)
   - The list's privateTags (or an empty array if undefined)
2. The optional chaining operator (?.) is used to safely access properties of potentially undefined list object
3. The function handles the case where list is undefined by defaulting to empty arrays

related: publicTags,privateTags,List

import/access examples:
import { getListTags } from '@welshman/util';
import { getListTags } from '@welshman/util/List';


=========================
workspace: packages/util
file: packages/util/src/List.ts
lines: 52:66
id: 35e9e3d314ebdcf95af0175dfa9804c6e033ad1c436907d4846cc402860b13c2
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/List.ts#L52

declaration:
removeFromListByPredicate = (list: List, pred: (t: string[]) => boolean) => {
  const plaintext: EncryptableUpdates = {}
  const template = {
    kind: list.kind,
    content: list.event?.content || "",
    tags: list.publicTags.filter(t => !pred(t)),
  }

  // Avoid redundant encrypt calls if possible
  if (list.privateTags.some(t => pred(t))) {
    plaintext.content = JSON.stringify(list.privateTags.filter(t => !pred(t)))
  }

  return new Encryptable(template, plaintext)
}

summary:
Removes elements from a List based on a predicate function. Takes a List object and a predicate function that evaluates tags, and returns an Encryptable object with filtered public and private tags. The predicate function determines which tags to remove from both public and private tag collections.

details:
This function creates a filtered version of a List by removing tags that match a given predicate. It works by:

1. Creating an empty EncryptableUpdates object for potential plaintext updates
2. Creating a template object with the list's kind, content, and filtered public tags
3. Only processing private tags if at least one matches the predicate (optimization)
4. When private tags need filtering, it stringifies the filtered private tags as content
5. Returns a new Encryptable instance with the template and plaintext updates

The function handles both public tags (stored directly in the event tags) and private tags (stored in encrypted content) separately, applying the same filtering logic to both collections.

related: List,Encryptable

import/access examples:
import { removeFromListByPredicate } from '@welshman/util';
import { removeFromListByPredicate } from '@welshman/util/List';


=========================
workspace: packages/util
file: packages/util/src/List.ts
lines: 68:69
id: 907ac9ea27b66a1451d46da0e3685b278da58cd89adc7fb7ec315b56667ac91c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/List.ts#L68

declaration:
removeFromList = (list: List, value: string) =>
  removeFromListByPredicate(list, nthEq(1, value))

summary:
Removes an item from a List based on a value. This function takes a List object and a string value, and returns an Encryptable object with the item removed from both public and private tags where the second element (index 1) of the tag matches the provided value.

details:
This function is a specialized wrapper around `removeFromListByPredicate`. It:
1. Takes a List object and a string value to remove
2. Uses the `nthEq(1, value)` predicate function to match tags where the second element equals the provided value
3. Delegates to `removeFromListByPredicate` which handles the actual filtering of both public and private tags
4. Returns an Encryptable object that represents the updated list with matching items removed

related: __function,removeFromListByPredicate,List,Encryptable

import/access examples:
import { removeFromList } from '@welshman/util';
import { removeFromList } from '@welshman/util/List';


=========================
workspace: packages/util
file: packages/util/src/List.ts
lines: 71:79
id: eeb5a9af0cecf00068e720c872128d784ac6265bca13d0ab730fd5f00193e392
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/List.ts#L71

declaration:
addToListPublicly = (list: List, ...tags: string[][]) => {
  const template = {
    kind: list.kind,
    content: list.event?.content || "",
    tags: uniqTags([...list.publicTags, ...tags]),
  }

  return new Encryptable(template, {})
}

summary:
Adds one or more tags to a List object publicly. The function takes a List object and a variable number of string array tags, then returns a new Encryptable object with the combined tags in the public section of the list.

details:
This function:
1. Takes a List object and variable number of string array tags as parameters
2. Creates a template object containing:
   - The kind from the original list
   - The content from the original list's event (or empty string if none)
   - A combined array of tags that merges the original public tags with the new tags, ensuring uniqueness via the uniqTags function
3. Returns a new Encryptable object with the template and an empty updates object, indicating that no private content is being modified
4. The tags are added publicly, meaning they will be visible in the unencrypted part of the resulting event

related: List,Encryptable

import/access examples:
import { addToListPublicly } from '@welshman/util';
import { addToListPublicly } from '@welshman/util/List';


=========================
workspace: packages/util
file: packages/util/src/List.ts
lines: 81:90
id: 3c87f99fc133e88ffda1039aa6252c6ecf583c3ababae071caf32d0032008fab
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/List.ts#L81

declaration:
addToListPrivately = (list: List, ...tags: string[][]) => {
  const template = {
    kind: list.kind,
    tags: list.publicTags,
  }

  return new Encryptable(template, {
    content: JSON.stringify(uniqTags([...list.privateTags, ...tags])),
  })
}

summary:
Adds tags to a List privately by encrypting them in the content field. Takes a List object and one or more string array tags as parameters, and returns an Encryptable object that can be used to create an encrypted event with the updated private tags.

details:
This function creates a new Encryptable object with:
1. A template containing the list's kind and existing public tags
2. An updates object with a content field containing the JSON stringified version of the combined and deduplicated private tags (existing private tags plus new tags)

The function uses uniqTags to ensure no duplicate tags are added, and JSON.stringify to prepare the private tags for encryption. The private nature of these tags comes from them being stored in the encrypted content field rather than in the public tags array.

related: List,Encryptable,EventTemplate,EventContent

import/access examples:
import { addToListPrivately } from '@welshman/util';
import { addToListPrivately } from '@welshman/util/List';


=========================
workspace: packages/util
file: packages/util/src/List.ts
lines: 92:109
id: b68cc891399150d85826696626b4beb61859cf388d70adbd105e8de4ff3f34c2
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/List.ts#L92

declaration:
updateList = (
  list: List,
  {publicTags, privateTags}: {publicTags?: string[][]; privateTags?: string[][]},
) => {
  const template = {
    kind: list.kind,
    content: list.event?.content || "",
    tags: publicTags || list.publicTags,
  }

  const updates: EncryptableUpdates = {}

  if (privateTags) {
    updates.content = JSON.stringify(privateTags)
  }

  return new Encryptable(template, updates)
}

summary:
Updates a List object with new public and/or private tags. This function takes a List object and an object containing optional publicTags and privateTags arrays, and returns an Encryptable object that can be used to update the list. If new publicTags are provided, they replace the existing ones. If new privateTags are provided, they are JSON-stringified and set as the encrypted content.

details:
The implementation:
1. Creates a template object with the list's kind, content (or empty string if not available), and either the provided publicTags or the existing list's publicTags
2. Initializes an empty updates object of type EncryptableUpdates
3. If privateTags are provided, JSON-stringifies them and assigns to updates.content
4. Returns a new Encryptable instance with the template and updates

Unlike some other list modification functions, this one completely replaces tags rather than merging them, giving more direct control over the list's content.

related: List,Encryptable

import/access examples:
import { updateList } from '@welshman/util';
import { updateList } from '@welshman/util/List';


=========================
workspace: packages/util
file: packages/util/src/List.ts
lines: 111:119
id: 826e3a2b3ff32c28442d6896ad3c0afef4ef477aac5a39ec9f784fee9905cc61
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/List.ts#L111

declaration:
getRelaysFromList = (list?: List, mode?: RelayMode): string[] => {
  let tags = getRelayTags(getListTags(list))

  if (mode) {
    tags = tags.filter((t: string[]) => !t[2] || t[2] === mode)
  }

  return uniq(tags.map(t => normalizeRelayUrl(t[1])))
}

summary:
Extracts relay URLs from a List object, optionally filtered by relay mode. Takes an optional List object and an optional RelayMode parameter, and returns an array of unique, normalized relay URLs. If a mode is specified, only relays matching that mode (or with no mode specified) are included.

details:
The function works by:
1. Getting all relay tags from the list using helper functions getRelayTags and getListTags
2. If a mode parameter is provided, filtering the tags to only include those with no mode (t[2]) or with a matching mode
3. Extracting the URL part (t[1]) from each tag, normalizing it with normalizeRelayUrl
4. Removing duplicates with the uniq function

The function handles undefined list input gracefully by using the optional chaining operator.

related: List,RelayMode

import/access examples:
import { getRelaysFromList } from '@welshman/util';
import { getRelaysFromList } from '@welshman/util/List';


=========================
workspace: packages/util
file: packages/util/src/Nip42.ts
lines: 4:10
id: 7e29861b9ebd3809cc4383f33b34566dcb00f81aec6a2899e7d7746507973dd6
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Nip42.ts#L4

declaration:
makeRelayAuth = (url: string, challenge: string) =>
  makeEvent(CLIENT_AUTH, {
    tags: [
      ["relay", url],
      ["challenge", challenge],
    ],
  })

summary:
Creates a relay authentication event according to NIP-42 protocol. Takes a relay URL and a challenge string as parameters and returns an event of kind CLIENT_AUTH with appropriate tags for relay authentication.

details:
Implementation uses the makeEvent function to create a new event with:
1. The CLIENT_AUTH kind (imported from Kinds.js)
2. Tags array containing two entries:
   - A "relay" tag with the provided URL
   - A "challenge" tag with the provided challenge string

This function is a simple wrapper that formats the authentication event according to the NIP-42 specification.

related: __function,makeEvent

import/access examples:
import { makeRelayAuth } from '@welshman/util';
import { makeRelayAuth } from '@welshman/util/Nip42';


=========================
workspace: packages/util
file: packages/util/src/Nip86.ts
lines: 4:23
id: 23a06c5887c822a15f892de9f97a5b5e158565196806c5dd15f16ece30c15f73
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Nip86.ts#L4

declaration:
export enum ManagementMethod {
  SupportedMethods = "supportedmethods",
  BanPubkey = "banpubkey",
  AllowPubkey = "allowpubkey",
  ListBannedPubkeys = "listbannedpubkeys",
  ListAllowedPubkeys = "listallowedpubkeys",
  ListEventsNeedingModeration = "listeventsneedingmoderation",
  AllowEvent = "allowevent",
  BanEvent = "banevent",
  ListBannedEvents = "listbannedevents",
  ChangeRelayName = "changerelayname",
  ChangeRelayDescription = "changerelaydescription",
  ChangeRelayIcon = "changerelayicon",
  AllowKind = "allowkind",
  DisallowKind = "disallowkind",
  ListAllowedKinds = "listallowedkinds",
  BlockIp = "blockip",
  UnblockIp = "unblockip",
  ListBlockedIps = "listblockedips",
}

summary:
An enumeration representing various management methods for Nostr relay administration as defined in NIP-86. These methods include operations like banning/allowing pubkeys, managing events, changing relay metadata, controlling allowed event kinds, and IP blocking.

details:
This enum defines a comprehensive set of string constants that correspond to different relay management operations according to the NIP-86 specification. The values are lowercase strings that would be used in management request methods when communicating with a relay's management API. The enum serves as a type-safe way to reference these operations in TypeScript code.

import/access examples:
import { ManagementMethod } from '@welshman/util';
import { ManagementMethod } from '@welshman/util/Nip86';


=========================
workspace: packages/util
file: packages/util/src/Nip86.ts
lines: 25:28
id: b55d19c908361fa0f08354a2d639ed6b64e62e38ebf847494facebb5ed1d955d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Nip86.ts#L25

declaration:
export type ManagementRequest = {
  method: ManagementMethod
  params: string[]
}

summary:
ManagementRequest is a type definition that represents a request for relay management operations according to NIP-86. It consists of a method field specifying the management operation to perform (from the ManagementMethod enum) and a params array containing string parameters for the operation.

details:
This type is part of the NIP-86 implementation which provides relay management capabilities. It works together with ManagementResponse and the sendManagementRequest function to enable programmatic relay administration. The type is simple and straightforward, containing just two fields: method (which must be one of the predefined ManagementMethod enum values) and params (an array of strings that provide additional information needed for the specified method).

related: ManagementMethod

import/access examples:
import type { ManagementRequest } from '@welshman/util';
import type { ManagementRequest } from '@welshman/util/Nip86';


=========================
workspace: packages/util
file: packages/util/src/Nip86.ts
lines: 30:33
id: 2925c6534c7e44648d8af4e468e853d1d933f926257177fa4a60d99c998f9086
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Nip86.ts#L30

declaration:
export type ManagementResponse = {
  result?: any
  error?: string
}

summary:
ManagementResponse is a type alias representing the response structure from a relay management API request. It contains an optional 'result' field of any type that holds successful response data, and an optional 'error' field of string type that contains error information when the request fails.

details:
This type is part of the NIP-86 implementation for relay management. It's designed as a simple response object with a discriminated union pattern where either the 'result' or 'error' field will be populated based on whether the management request succeeded or failed. The type is used as the return type for the 'sendManagementRequest' function which handles communication with relay management endpoints.

import/access examples:
import type { ManagementResponse } from '@welshman/util';
import type { ManagementResponse } from '@welshman/util/Nip86';


=========================
workspace: packages/util
file: packages/util/src/Nip86.ts
lines: 35:56
id: 1b71985eafa7f6d1ab6341acc806fc1b038e29baeb5d5d920c635749355bbedd
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Nip86.ts#L35

declaration:
sendManagementRequest = async (
  url: string,
  request: ManagementRequest,
  authEvent: SignedEvent,
): Promise<ManagementResponse> => {
  try {
    const res = await fetch(url, {
      method: "POST",
      body: JSON.stringify(request),
      headers: {
        "Content-Type": "application/nostr+json+rpc",
        Authorization: makeHttpAuthHeader(authEvent),
      },
    })

    return await res.json()
  } catch (e) {
    const msg = "Failed to send management request"
    console.log(msg, ":", e)
    return {error: "failed to send management request"}
  }
}

summary:
Sends a management request to a Nostr relay according to NIP-86 specification. Takes a URL endpoint, a management request object containing method and parameters, and a signed authentication event. Returns a promise that resolves to a management response object containing either a result or an error message.

details:
Implementation details:
1. Uses the fetch API to make an HTTP POST request to the specified URL
2. Serializes the request object to JSON in the request body
3. Sets the Content-Type header to "application/nostr+json+rpc" as required by the protocol
4. Adds an Authorization header using the makeHttpAuthHeader function from NIP-98 with the provided signed event
5. Attempts to parse the JSON response from the server
6. Includes error handling that catches any exceptions during the request process and returns a standardized error response
7. Logs errors to the console for debugging purposes

related: ManagementRequest,SignedEvent,ManagementResponse

import/access examples:
import { sendManagementRequest } from '@welshman/util';
import { sendManagementRequest } from '@welshman/util/Nip86';


=========================
workspace: packages/util
file: packages/util/src/Zaps.ts
lines: 8:13
id: 49e1e13d025ed567fa2e5010e1e1d6b2bb284df0ce0488941519df7010de89d2
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Zaps.ts#L8

declaration:
DIVISORS = {
  m: BigInt(1e3),
  u: BigInt(1e6),
  n: BigInt(1e9),
  p: BigInt(1e12),
}

summary:
A constant object mapping currency unit symbols to their respective divisors as BigInt values. Used for converting between different Bitcoin denominations (milli, micro, nano, pico).

details:
This constant defines conversion factors for Bitcoin denominations as BigInt values:
- 'm' (milli): 10^3
- 'u' (micro): 10^6
- 'n' (nano): 10^9
- 'p' (pico): 10^12

These divisors are used in the hrpToMillisat function to convert human-readable Bitcoin amounts with various unit suffixes into millisatoshis.

=========================
workspace: packages/util
file: packages/util/src/Zaps.ts
lines: 15:15
id: 870af415424cf105d9921ed46bea3f171b3d55caf69426da8815fc72d2878230
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Zaps.ts#L15

declaration:
MAX_MILLISATS = BigInt("2100000000000000000")

summary:
A constant representing the maximum value of millisatoshis (msats) allowed in the system, set to 2.1 quadrillion (2,100,000,000,000,000,000). This value corresponds to the maximum possible Bitcoin supply in millisatoshis.

details:
This constant defines an upper bound for millisatoshi values used in Bitcoin Lightning Network operations. The value is stored as a BigInt to handle the large number precisely. It's used in validation checks (e.g., in the hrpToMillisat function) to ensure amounts don't exceed the theoretical maximum Bitcoin supply.

=========================
workspace: packages/util
file: packages/util/src/Zaps.ts
lines: 17:17
id: 16860f5d1556de76a3703d95122c69b19929e9c96315ca3b970afc9486534c8b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Zaps.ts#L17

declaration:
MILLISATS_PER_BTC = BigInt(1e11)

summary:
A constant representing the number of millisatoshis in one Bitcoin (BTC). It is defined as BigInt(1e11), which equals 100,000,000,000 millisatoshis per Bitcoin.

details:
This constant is used in the conversion functions within the Zaps module, particularly in the `hrpToMillisat` function where it helps convert human-readable Bitcoin amounts with various units (m, u, n, p) to millisatoshis. It represents the fundamental conversion rate between the base unit (BTC) and the smallest unit used in Lightning Network transactions (millisatoshis).

=========================
workspace: packages/util
file: packages/util/src/Zaps.ts
lines: 19:19
id: fb50f519e6e0fe98eb4327828ce6c15eb81747bbcef24038ec993d8e4859130b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Zaps.ts#L19

declaration:
toMsats = (sats: number) => sats * 1000

summary:
Converts satoshis to millisatoshis by multiplying the input value by 1000. This function is useful for converting between different Bitcoin value units.

details:
A simple arrow function that takes a number of satoshis as input and returns the equivalent value in millisatoshis by multiplying by 1000. This is a straightforward conversion with no complex implementation details.

import/access examples:
import { toMsats } from '@welshman/util';
import { toMsats } from '@welshman/util/Zaps';


=========================
workspace: packages/util
file: packages/util/src/Zaps.ts
lines: 21:21
id: 77a4ee114b7e5104d6d9c844b4415f45c403062c97d8d4876c31c96b88837152
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Zaps.ts#L21

declaration:
fromMsats = (msats: number) => Math.floor(msats / 1000)

summary:
Converts millisatoshis (msats) to satoshis (sats) by dividing by 1000 and rounding down to the nearest integer. Takes a number of millisatoshis as input and returns the equivalent amount in satoshis.

details:
A simple conversion function that divides the input millisatoshis by 1000 and uses Math.floor() to ensure the result is rounded down to the nearest whole satoshi. This is the inverse operation of the toMsats function defined elsewhere in the file.

import/access examples:
import { fromMsats } from '@welshman/util';
import { fromMsats } from '@welshman/util/Zaps';


=========================
workspace: packages/util
file: packages/util/src/Zaps.ts
lines: 23:50
id: adda2493618b38aedc1612fb156798f63abff517a833ad9457dac4492a13b378
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Zaps.ts#L23

declaration:
hrpToMillisat = (hrpString: string) => {
  let divisor, value
  if (hrpString.slice(-1).match(/^[munp]$/)) {
    divisor = hrpString.slice(-1)
    value = hrpString.slice(0, -1)
  } else if (hrpString.slice(-1).match(/^[^munp0-9]$/)) {
    throw new Error("Not a valid multiplier for the amount")
  } else {
    value = hrpString
  }

  if (!value.match(/^\d+$/)) throw new Error("Not a valid human readable amount")

  const valueBN = BigInt(value)

  const millisatoshisBN = divisor
    ? (valueBN * MILLISATS_PER_BTC) / (DIVISORS as any)[divisor]
    : valueBN * MILLISATS_PER_BTC

  if (
    (divisor === "p" && !(valueBN % BigInt(10) === BigInt(0))) ||
    millisatoshisBN > MAX_MILLISATS
  ) {
    throw new Error("Amount is outside of valid range")
  }

  return millisatoshisBN
}

summary:
Converts a human-readable payment (hrp) string to millisatoshis (the smallest unit of Bitcoin in the Lightning Network). The function accepts a string that may include a multiplier suffix (m, u, n, p) and returns a BigInt representing the equivalent amount in millisatoshis.

details:
The implementation works by:
1. Parsing the input string to extract the value and optional multiplier (divisor)
2. Validating the input format and multiplier
3. Converting the string value to BigInt
4. Calculating millisatoshis based on the value and divisor using predefined constants:
   - MILLISATS_PER_BTC (1e11)
   - DIVISORS for different multipliers (m: 1e3, u: 1e6, n: 1e9, p: 1e12)
5. Performing additional validation to ensure:
   - When using 'p' divisor, the value must be divisible by 10
   - The result doesn't exceed MAX_MILLISATS (2.1 quadrillion)
6. Returning the calculated millisatoshis as a BigInt

import/access examples:
import { hrpToMillisat } from '@welshman/util';
import { hrpToMillisat } from '@welshman/util/Zaps';


=========================
workspace: packages/util
file: packages/util/src/Zaps.ts
lines: 52:56
id: a89af3caadd43fc84d120bdb24c9c4fdde5d6fe059e908e1313e2c6b7fe7a16d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Zaps.ts#L52

declaration:
getInvoiceAmount = (bolt11: string) => {
  const hrp = bolt11.match(/lnbc(\d+\w)/)
  const bn = hrpToMillisat(hrp![1])
  return Number(bn)
}

summary:
Extracts the amount from a Lightning Network BOLT11 invoice. Takes a BOLT11 invoice string as input and returns the amount in millisatoshis as a number.

details:
The function works by:
1. Using a regular expression to extract the human-readable part (hrp) of the BOLT11 invoice that contains the amount information
2. Passing the extracted amount string to the hrpToMillisat function to convert it to millisatoshis
3. Converting the resulting BigInt value to a JavaScript Number before returning it

Note that it assumes the invoice is valid and contains an amount (non-zero invoice). The function doesn't handle error cases where the regex match fails.

import/access examples:
import { getInvoiceAmount } from '@welshman/util';
import { getInvoiceAmount } from '@welshman/util/Zaps';


=========================
workspace: packages/util
file: packages/util/src/Zaps.ts
lines: 58:80
id: 0562c87f5de0a571d0006cfcbb9310051ad3e9bf3c58273ff1b924d3cc98ecc2
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Zaps.ts#L58

declaration:
getLnUrl = (address: string) => {
  address = address.toLowerCase()

  if (address.startsWith("lnurl1")) {
    return address
  }

  // If it's a regular url, just encode it
  if (address.includes("://")) {
    return hexToBech32("lnurl", address)
  }

  // Try to parse it as a lud16 address
  if (address.includes("@")) {
    const [name, domain] = address.split("@")

    if (domain && name) {
      return hexToBech32("lnurl", `https://${domain}/.well-known/lnurlp/${name}`)
    }
  }

  return undefined
}

summary:
Extracts or constructs a Lightning Network URL (LNURL) from different input formats. Takes an address string which can be a bech32-encoded LNURL, a regular URL, or a Lightning Address (user@domain format) and returns the appropriate LNURL or undefined if the input cannot be parsed.

details:
The function handles three different input formats:
1. If the address already starts with 'lnurl1', it's returned as-is since it's already a valid LNURL
2. If the address contains '://' (protocol separator), it's treated as a regular URL and encoded to bech32 format with 'lnurl' prefix
3. If the address contains '@', it's parsed as a Lightning Address (LUD-16 format):
   - Splits the address into username and domain parts
   - Constructs a URL in the format https://domain/.well-known/lnurlp/username
   - Encodes this URL to bech32 format with 'lnurl' prefix

The function returns undefined if none of these formats can be successfully parsed.

import/access examples:
import { getLnUrl } from '@welshman/util';
import { getLnUrl } from '@welshman/util/Zaps';


=========================
workspace: packages/util
file: packages/util/src/Zaps.ts
lines: 82:90
id: 496b08480e03d90c16023dc6224eb472825aa093c99ec60e9117a0e2db35d5f3
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Zaps.ts#L82

declaration:
export type Zapper = {
  lnurl: string
  pubkey?: string
  callback?: string
  minSendable?: number
  maxSendable?: number
  nostrPubkey?: string
  allowsNostr?: boolean
}

summary:
A TypeScript type definition representing a Lightning Network (LN) zapper entity. It contains information needed to interact with a Lightning Address or LNURL service for sending zaps (Lightning Network payments). The type includes fields for the LNURL, public keys, callback URL, and payment limits.

details:
This type definition is part of a Nostr zaps implementation. It captures the essential properties of a Lightning Network payment service:

1. `lnurl`: The bech32-encoded LNURL string used to identify the Lightning service
2. `pubkey`: Optional Nostr public key of the user
3. `callback`: Optional URL endpoint that will be called to request invoices
4. `minSendable`/`maxSendable`: Optional payment limits in millisatoshis
5. `nostrPubkey`: Optional Nostr public key of the zapping service
6. `allowsNostr`: Optional flag indicating if the service supports Nostr zaps

This type is used throughout the module for zap-related operations like creating zap requests and verifying zap responses.

import/access examples:
import type { Zapper } from '@welshman/util';
import type { Zapper } from '@welshman/util/Zaps';


=========================
workspace: packages/util
file: packages/util/src/Zaps.ts
lines: 92:96
id: c712efcd6f22db578a9536e0fc8a8fbffcf67c8c3d0d9f6988271db75932767b
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Zaps.ts#L92

declaration:
export type Zap = {
  request: TrustedEvent
  response: TrustedEvent
  invoiceAmount: number
}

summary:
A TypeScript type alias representing a Zap, which is a Lightning Network payment in the Nostr protocol context. It contains three properties: a request event (TrustedEvent), a response event (TrustedEvent), and the invoice amount (number) of the payment.

details:
This type definition is part of a larger Zaps implementation for handling Lightning Network payments in Nostr. The Zap type serves as a data structure that combines:
1. The zap request event (which contains payment details and metadata)
2. The zap response event (which contains the invoice and confirmation details)
3. The actual invoice amount in millisatoshis

This type is used by functions like `zapFromEvent` which validates and constructs Zap objects from Nostr events.

related: TrustedEvent

import/access examples:
import type { Zap } from '@welshman/util';
import type { Zap } from '@welshman/util/Zaps';


=========================
workspace: packages/util
file: packages/util/src/Zaps.ts
lines: 98:140
id: d8a90e1dc6b17e6fbda2b8aa12229753fd6f1bfe6fe070cbcdf52053983ddb5d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Zaps.ts#L98

declaration:
zapFromEvent = (response: TrustedEvent, zapper: Zapper | undefined) => {
  const responseMeta = fromPairs(response.tags)

  let zap: Zap
  try {
    zap = {
      response,
      invoiceAmount: getInvoiceAmount(responseMeta.bolt11),
      request: JSON.parse(responseMeta.description),
    }
  } catch (e) {
    return undefined
  }

  // Don't count zaps that the user requested for himself
  if (zap.request.pubkey === zapper?.pubkey) {
    return undefined
  }

  const {amount, lnurl} = fromPairs(zap.request.tags)

  // Verify that the zapper actually sent the requested amount (if it was supplied)
  if (amount && parseInt(amount) !== zap.invoiceAmount) {
    return undefined
  }

  // If the recipient and the zapper are the same person, it's legit
  if (responseMeta.p === response.pubkey) {
    return zap
  }

  // If the sending client provided an lnurl tag, verify that too
  if (lnurl && lnurl !== zapper?.lnurl) {
    return undefined
  }

  // Verify that the request actually came from the recipient's zapper
  if (zap.response.pubkey !== zapper?.nostrPubkey) {
    return undefined
  }

  return zap
}

summary:
Validates and extracts a Zap from a Nostr zap response event. Takes a trusted zap response event and an optional zapper configuration, then verifies the zap's authenticity through several checks. Returns a validated Zap object if all checks pass, or undefined if any validation fails.

details:
The implementation performs several validation steps to ensure the zap is legitimate:

1. Parses the zap response metadata and extracts the invoice amount and zap request from the description
2. Rejects self-zaps where the requester is the same as the zapper
3. Verifies the zap amount matches what was requested (if specified)
4. Performs identity verification through multiple checks:
   - Accepts zaps where the recipient and zapper are the same person
   - Verifies the LNURL in the request matches the zapper's LNURL
   - Confirms the response pubkey matches the zapper's Nostr pubkey

The function uses helper functions like `getInvoiceAmount` to parse Lightning invoice amounts and `fromPairs` to convert tag arrays into objects for easier processing.

related: TrustedEvent,Zapper,Zap

import/access examples:
import { zapFromEvent } from '@welshman/util';
import { zapFromEvent } from '@welshman/util/Zaps';


=========================
workspace: packages/util
file: packages/util/src/Zaps.ts
lines: 142:150
id: 3f516834772ddc38e2b08bd994add7fc19c6589affae72bd920d423643a15b20
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Zaps.ts#L142

declaration:
export type ZapRequestParams = {
  msats: number
  zapper: Zapper
  pubkey: string
  relays: string[]
  content?: string
  eventId?: string
  anonymous?: boolean
}

summary:
A TypeScript type alias that defines the parameters required to create a zap request in a Nostr application. It includes properties for the payment amount in millisatoshis, zapper details, recipient's public key, relay information, optional message content, optional event ID being zapped, and an optional flag for anonymous zaps.

details:
This type alias defines a structured object with the following properties:
1. `msats`: number - The amount of millisatoshis to send in the zap
2. `zapper`: Zapper - An object containing information about the zapping service
3. `pubkey`: string - The public key of the recipient
4. `relays`: string[] - An array of relay URLs to broadcast the zap request to
5. `content?`: string - Optional message content to include with the zap
6. `eventId?`: string - Optional ID of the event being zapped
7. `anonymous?`: boolean - Optional flag to indicate if the zap should be anonymous

This type is used as the parameter type for the `makeZapRequest` function that creates zap request events.

related: Zapper

import/access examples:
import type { ZapRequestParams } from '@welshman/util';
import type { ZapRequestParams } from '@welshman/util/Zaps';


=========================
workspace: packages/util
file: packages/util/src/Zaps.ts
lines: 152:177
id: 62ab133439356615cd2272e558e8b3350abc86ff6db004b783df5ed276caf431
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Zaps.ts#L152

declaration:
makeZapRequest = ({
  msats,
  zapper,
  pubkey,
  relays,
  content = "",
  eventId,
  anonymous,
}: ZapRequestParams) => {
  const tags = [
    ["relays", ...relays],
    ["amount", String(msats)],
    ["lnurl", zapper.lnurl],
    ["p", pubkey],
  ]

  if (eventId) {
    tags.push(["e", eventId])
  }

  if (anonymous) {
    tags.push(["anon"])
  }

  return makeEvent(ZAP_REQUEST, {content, tags})
}

summary:
Creates a zap request event for the Nostr protocol. Takes parameters including the amount in millisatoshis, zapper details, recipient's public key, relay list, optional content message, optional event ID to reference, and an anonymous flag. Returns a properly formatted zap request event that can be used to request a Lightning Network payment.

details:
The implementation:
1. Takes a ZapRequestParams object with required fields (msats, zapper, pubkey, relays) and optional fields (content, eventId, anonymous)
2. Constructs an array of tags that are required for a zap request:
   - "relays" tag with the list of relays
   - "amount" tag with the millisatoshi amount as a string
   - "lnurl" tag with the zapper's LNURL
   - "p" tag with the recipient's public key
3. Conditionally adds an "e" tag if an eventId is provided (to reference a specific event being zapped)
4. Conditionally adds an "anon" tag if the anonymous flag is set
5. Uses the makeEvent helper function with ZAP_REQUEST kind to create the final event structure
6. Returns the created event without signing it

related: ZapRequestParams

import/access examples:
import { makeZapRequest } from '@welshman/util';
import { makeZapRequest } from '@welshman/util/Zaps';


=========================
workspace: packages/util
file: packages/util/src/Zaps.ts
lines: 179:182
id: b84ebdcab6702708f95c1cbdfcabc892a56d083ddb20c6f1fb2453fb5a5c060c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Zaps.ts#L179

declaration:
export type RequestInvoiceParams = {
  zapper: Zapper
  event: SignedEvent
}

summary:
A TypeScript type alias that defines the parameters required for requesting a Lightning Network invoice for a zap payment. It contains two properties: `zapper` of type `Zapper` which contains information about the Lightning service provider, and `event` of type `SignedEvent` which represents the signed zap request event.

details:
This type alias is used as the parameter type for the `requestZap` function. It encapsulates the necessary data to generate a Lightning Network invoice request:

1. `zapper`: Contains LNURL and callback information needed to communicate with the Lightning service provider
2. `event`: The signed Nostr event containing zap request details like amount and recipient

The type is part of the Nostr zaps implementation, which enables Lightning Network payments to be integrated with the Nostr protocol.

related: Zapper,SignedEvent

import/access examples:
import type { RequestInvoiceParams } from '@welshman/util';
import type { RequestInvoiceParams } from '@welshman/util/Zaps';


=========================
workspace: packages/util
file: packages/util/src/Zaps.ts
lines: 184:191
id: 9c6991fa5b91e131d9bdbbf358acea707f1233c865886e53d4d9d23b07cbe90c
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Zaps.ts#L184

declaration:
requestZap = async ({zapper, event}: RequestInvoiceParams) => {
  const zapString = encodeURI(JSON.stringify(event))
  const msats = parseInt(getTagValue("amount", event.tags)!)
  const qs = `?amount=${msats}&nostr=${zapString}&lnurl=${zapper.lnurl}`
  const res = await tryCatch(() => fetchJson(zapper.callback + qs))

  return res?.pr ? {invoice: res.pr} : {error: res.reason || "Failed to request invoice"}
}

summary:
Asynchronous function that requests a Lightning Network invoice for a zap payment. It takes a `RequestInvoiceParams` object containing a zapper (Lightning payment provider) and a signed Nostr event. Returns an object with either an `invoice` property containing the payment request string, or an `error` property with failure details.

details:
The implementation:
1. Encodes the event as a URI-safe JSON string
2. Extracts the millisatoshi amount from the event tags
3. Constructs a query string with amount, Nostr event data, and LNURL
4. Makes an HTTP request to the zapper's callback URL with the query string
5. Uses tryCatch for error handling during the fetch operation
6. Returns either a success object with the payment request (pr) or an error object with reason

The function is part of a Lightning Network zap payment flow in a Nostr application, connecting the client-side zap request with the Lightning payment provider.

related: RequestInvoiceParams

import/access examples:
import { requestZap } from '@welshman/util';
import { requestZap } from '@welshman/util/Zaps';


=========================
workspace: packages/util
file: packages/util/src/Zaps.ts
lines: 193:197
id: 028a2b3403346aa35c0f4da049158b5e68a9975a42c26cf4b4e02aaf113e61c5
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Zaps.ts#L193

declaration:
export type ZapResponseFilterParams = {
  zapper: Zapper
  pubkey: string
  eventId?: string
}

summary:
A TypeScript type alias that defines the parameters needed to create a filter for zap response events. It includes properties for the zapper (the entity sending the zap), the recipient's pubkey, and an optional eventId to filter for zaps related to a specific event.

details:
This type alias defines three properties:
1. `zapper`: A Zapper object containing information about the zapping entity, including its nostr pubkey which is essential for filtering zap responses
2. `pubkey`: A string representing the public key of the recipient of the zap
3. `eventId`: An optional string representing a specific event ID to filter for zaps related to that event

This type is used as the parameter type for the `getZapResponseFilter` function which creates a filter for querying zap response events.

related: Zapper

import/access examples:
import type { ZapResponseFilterParams } from '@welshman/util';
import type { ZapResponseFilterParams } from '@welshman/util/Zaps';


=========================
workspace: packages/util
file: packages/util/src/Zaps.ts
lines: 199:216
id: 460eb9ebb5d6295edcc0a93e7682e3a1f16161309da215872dc26fe3b2c1e544
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Zaps.ts#L199

declaration:
getZapResponseFilter = ({zapper, pubkey, eventId}: ZapResponseFilterParams) => {
  if (!zapper.nostrPubkey) {
    throw new Error("Zapper did not have a nostr pubkey")
  }

  const filter: Filter = {
    kinds: [ZAP_RESPONSE],
    authors: [zapper.nostrPubkey],
    since: now() - 30,
    "#p": [pubkey],
  }

  if (eventId) {
    filter["#e"] = [eventId]
  }

  return filter
}

summary:
Creates a filter for zap response events based on the provided parameters. The function takes an object with zapper information, a pubkey, and an optional eventId. It returns a Filter object configured to find zap responses from the zapper's nostr pubkey to the specified pubkey, optionally filtered by a specific event ID. Throws an error if the zapper doesn't have a nostr pubkey.

details:
The implementation:
1. First checks if the zapper has a nostrPubkey property, throwing an error if not
2. Creates a Filter object with:
   - kinds set to ZAP_RESPONSE constant
   - authors limited to the zapper's nostr pubkey
   - since timestamp set to 30 seconds ago (using now() helper)
   - #p tag filter set to the target pubkey
3. Conditionally adds an #e tag filter if eventId is provided
4. Returns the constructed filter object

related: ZapResponseFilterParams,Filter

import/access examples:
import { getZapResponseFilter } from '@welshman/util';
import { getZapResponseFilter } from '@welshman/util/Zaps';


=========================
workspace: packages/util
file: packages/util/src/Profile.ts
lines: 7:19
id: cd30a6040ed0ac28501dc919fe667cf72f492830766494b6924054e00c999752
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Profile.ts#L7

declaration:
export type Profile = {
  name?: string
  nip05?: string
  lud06?: string
  lud16?: string
  lnurl?: string
  about?: string
  banner?: string
  picture?: string
  website?: string
  display_name?: string
  event?: TrustedEvent
}

summary:
A type definition representing a user profile in a Nostr-based application. It includes optional fields for personal information such as name, display name, about text, website, profile picture, banner image, and Lightning Network payment details (lud06, lud16, lnurl). It can also contain a reference to the Nostr event that published this profile.

details:
This type serves as a data structure for storing user profile information in the Nostr protocol context. It includes:
1. Basic profile information (name, display_name, about, picture, banner, website)
2. Nostr verification via nip05
3. Lightning Network payment information through multiple fields (lud06, lud16, lnurl)
4. An optional reference to the TrustedEvent that published this profile

The type is designed to be flexible with all fields being optional, allowing for partial profile information.

related: TrustedEvent

import/access examples:
import type { Profile } from '@welshman/util';
import type { Profile } from '@welshman/util/Profile';


=========================
workspace: packages/util
file: packages/util/src/Profile.ts
lines: 21:23
id: 48e3d1710b2d53104fa31ffe002f7c0e90e511f02766c22d85869e85ea31c611
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Profile.ts#L21

declaration:
export type PublishedProfile = Omit<Profile, "event"> & {
  event: TrustedEvent
}

summary:
PublishedProfile is a TypeScript type that represents a Nostr profile that has been published to the network. It extends the base Profile type by requiring the 'event' property to be a TrustedEvent rather than optional. This type ensures that a profile has been associated with a verified event on the Nostr network.

details:
The PublishedProfile type is defined using TypeScript's utility type Omit<T, K> to take all properties from Profile except 'event', and then adds back 'event' as a required TrustedEvent property. This pattern ensures that a PublishedProfile always has an associated event, which is necessary for profiles that have been published to the Nostr network. This type is used throughout the codebase to distinguish between profiles that are just data structures (Profile) and those that represent actual published content (PublishedProfile).

related: Profile,TrustedEvent

import/access examples:
import type { PublishedProfile } from '@welshman/util';
import type { PublishedProfile } from '@welshman/util/Profile';


=========================
workspace: packages/util
file: packages/util/src/Profile.ts
lines: 25:26
id: b10f6bcdd50b001ca6429c64f87c0a1af2adc74c061d6fb5186e4f8e274dead0
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Profile.ts#L25

declaration:
isPublishedProfile = (profile: Profile): profile is PublishedProfile =>
  Boolean(profile.event)

summary:
A type guard function that checks if a Profile object is a PublishedProfile by verifying if it has an 'event' property. Returns true if the profile has an event, false otherwise.

details:
The implementation is straightforward - it uses the Boolean constructor to convert the profile.event value to a boolean. This effectively checks if profile.event exists and is truthy. The function is used as a type predicate (profile is PublishedProfile) to narrow the type in TypeScript type checking.

related: Profile

import/access examples:
import { isPublishedProfile } from '@welshman/util';
import { isPublishedProfile } from '@welshman/util/Profile';


=========================
workspace: packages/util
file: packages/util/src/Profile.ts
lines: 28:46
id: 4c2dc66d3fb72c015af0f5b20b6deb595f9e7b3b3bf6c78fa427b0bed7a7900a
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Profile.ts#L28

declaration:
makeProfile = (profile: Partial<Profile> = {}): Profile => {
  if (typeof profile.lud06 === "string") {
    const lnurl = getLnUrl(profile.lud06)

    if (lnurl) {
      profile = {...profile, lnurl}
    }
  }

  if (typeof profile.lud16 === "string") {
    const lnurl = getLnUrl(profile.lud16)

    if (lnurl) {
      profile = {...profile, lnurl}
    }
  }

  return profile
}

summary:
Creates a Profile object from a partial Profile input. If the input contains lud06 or lud16 fields (Lightning Network address formats), it attempts to convert them to an lnurl and adds it to the returned profile.

details:
The implementation:
1. Takes a partial Profile object as input (defaulting to an empty object)
2. Processes Lightning Network addresses:
   - For lud06 field (LNURL): Calls getLnUrl() to extract a valid Lightning URL
   - For lud16 field (Lightning Address): Similarly calls getLnUrl() to extract a valid Lightning URL
3. If valid Lightning URLs are found, adds them to the profile under the 'lnurl' property
4. Returns the potentially enhanced profile object

The function maintains immutability by creating new profile objects with spread syntax rather than modifying the original directly.

related: Profile

import/access examples:
import { makeProfile } from '@welshman/util';
import { makeProfile } from '@welshman/util/Profile';


=========================
workspace: packages/util
file: packages/util/src/Profile.ts
lines: 48:51
id: fbd707b5c86924150775a5b721d9bb3d2243d0df49e298369b602c22f1172762
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Profile.ts#L48

declaration:
readProfile = (event: TrustedEvent): PublishedProfile => ({
  ...makeProfile(parseJson(event.content) || {}),
  event,
})

summary:
Reads a Nostr profile from a trusted event. Takes a TrustedEvent object and returns a PublishedProfile object by parsing the event's content as JSON and processing it through makeProfile, while also attaching the original event to the profile.

details:
This function performs the following steps:
1. Takes a TrustedEvent parameter which contains Nostr event data
2. Extracts the content from the event and parses it as JSON using the parseJson utility
3. Falls back to an empty object if parsing fails
4. Passes the parsed content to makeProfile which processes lightning address information
5. Spreads the resulting profile object and adds the original event
6. Returns the complete PublishedProfile object

The function is a key part of the profile handling system, converting raw event data into a structured profile object.

related: TrustedEvent,PublishedProfile

import/access examples:
import { readProfile } from '@welshman/util';
import { readProfile } from '@welshman/util/Profile';


=========================
workspace: packages/util
file: packages/util/src/Profile.ts
lines: 53:57
id: 1d0012e4d9234680c8d2eb4f6d4c05b7677a08c806d93d5dcf7aa650b0878650
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Profile.ts#L53

declaration:
createProfile = ({event, ...profile}: Profile): EventTemplate => ({
  kind: PROFILE,
  content: JSON.stringify(profile),
  tags: [],
})

summary:
Creates an EventTemplate for a new profile. Takes a Profile object as input and returns an EventTemplate with kind set to PROFILE, content as a JSON string of the profile data (excluding the event property), and empty tags array.

details:
This function is responsible for preparing a profile for publication on the Nostr network. It:
1. Destructures the input Profile object to separate the event property from the rest of the profile data
2. Creates an EventTemplate with:
   - kind set to the PROFILE constant (likely kind 0 in Nostr)
   - content field containing the JSON stringified profile data (without the event property)
   - An empty tags array since this is a new profile creation

The function is simple and primarily handles the transformation from a Profile object to the format needed for Nostr event creation.

related: Profile,EventTemplate,EventContent

import/access examples:
import { createProfile } from '@welshman/util';
import { createProfile } from '@welshman/util/Profile';


=========================
workspace: packages/util
file: packages/util/src/Profile.ts
lines: 59:63
id: 71765a201db35598f327a0f0bb9c2a0cb0080f89cae4edbff1edb83c08bf47a3
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Profile.ts#L59

declaration:
editProfile = ({event, ...profile}: PublishedProfile): EventTemplate => ({
  kind: PROFILE,
  content: JSON.stringify(profile),
  tags: event.tags,
})

summary:
Creates an EventTemplate for editing an existing profile. Takes a PublishedProfile object (which includes an event property) and returns an EventTemplate with the profile kind, JSON stringified content, and preserves the tags from the original event.

details:
This function implements profile editing functionality for Nostr profiles. It:
1. Destructures the input PublishedProfile to separate the event from the rest of the profile data
2. Creates a new EventTemplate with:
   - kind set to PROFILE constant
   - content created by JSON stringifying the profile data (excluding the event)
   - tags copied from the original event

The function preserves the existing tags from the original profile event, which is important for maintaining references and metadata across profile updates.

related: PublishedProfile,EventTemplate,EventContent

import/access examples:
import { editProfile } from '@welshman/util';
import { editProfile } from '@welshman/util/Profile';


=========================
workspace: packages/util
file: packages/util/src/Profile.ts
lines: 65:69
id: 413aa058c356d6ac7e0ddd421d6924130f46915ed5c740a94ba78ba85a82d328
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Profile.ts#L65

declaration:
displayPubkey = (pubkey: string) => {
  const d = npubEncode(pubkey)

  return d.slice(0, 8) + "…" + d.slice(-5)
}

summary:
A function that formats a public key for display by encoding it as an npub and truncating it. It takes a string `pubkey` parameter and returns a shortened version of the npub-encoded key with the format 'first8chars…last5chars'.

details:
The implementation:
1. Uses `npubEncode` from the nostr-tools/nip19 library to convert the raw public key to an npub format (a bech32-encoded string starting with 'npub')
2. Takes the first 8 characters of the encoded string using slice(0, 8)
3. Adds an ellipsis character '…' in the middle
4. Appends the last 5 characters of the encoded string using slice(-5)
5. Returns the concatenated string as a shortened, human-readable representation of the public key

import/access examples:
import { displayPubkey } from '@welshman/util';
import { displayPubkey } from '@welshman/util/Profile';


=========================
workspace: packages/util
file: packages/util/src/Profile.ts
lines: 71:79
id: 92f7e5a4261d7af8745f89495585ac5fbd4296daae9ee7efaa972f157d94e217
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Profile.ts#L71

declaration:
displayProfile = (profile?: Profile, fallback = "") => {
  const {display_name, name, event} = profile || {}

  if (name) return ellipsize(name, 60).trim()
  if (display_name) return ellipsize(display_name, 60).trim()
  if (event) return displayPubkey(event.pubkey).trim()

  return fallback.trim()
}

summary:
A function that returns a displayable string representation of a profile. It prioritizes the profile's name, then display_name, then a shortened pubkey, and falls back to a provided fallback string if none are available. All returned strings are trimmed of whitespace and names are ellipsized to 60 characters.

details:
The implementation follows a simple priority-based approach:
1. First extracts display_name, name, and event from the profile (with null coalescing to handle undefined profiles)
2. Returns the first available value in this order of preference:
   - name (trimmed and ellipsized to 60 chars)
   - display_name (trimmed and ellipsized to 60 chars)
   - pubkey from event (displayed in shortened format using displayPubkey)
   - fallback string
3. Uses helper functions: ellipsize for truncating long names and displayPubkey for formatting public keys

related: Profile

import/access examples:
import { displayProfile } from '@welshman/util';
import { displayProfile } from '@welshman/util/Profile';


=========================
workspace: packages/util
file: packages/util/src/Profile.ts
lines: 81:81
id: 0b537863aa11e10cf088d1f01a46eb18803b8c31ab7a82d54f896f1053be45c0
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Profile.ts#L81

declaration:
profileHasName = (profile?: Profile) => Boolean(profile?.name || profile?.display_name)

summary:
A utility function that checks if a Profile object has a name. It returns true if either the 'name' or 'display_name' property exists in the profile, false otherwise.

details:
The implementation is straightforward:
1. Takes an optional Profile parameter
2. Uses the Boolean constructor to convert the result of the OR operation between profile?.name and profile?.display_name to a boolean
3. The optional chaining (?.) ensures the function works even if profile is undefined
4. Returns true if either name or display_name has a truthy value, false otherwise

related: Profile

import/access examples:
import { profileHasName } from '@welshman/util';
import { profileHasName } from '@welshman/util/Profile';


=========================
workspace: packages/util
file: packages/util/src/Room.ts
lines: 12:16
id: 5cd8461348d036c86dffb1a5cdde9be6d8417a074ba0350c098638ae35dd929f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Room.ts#L12

declaration:
export type RoomMeta = {
  id: string
  tags: string[][]
  event?: TrustedEvent
}

summary:
RoomMeta is a type alias that defines the structure for room metadata in the system. It contains an id string to uniquely identify the room, an array of string arrays for tags, and an optional TrustedEvent property.

details:
This type serves as a core data structure for room management in the application. The structure includes:
1. `id`: A string identifier for the room, typically generated using the randomId() function
2. `tags`: A nested array of strings (string[][]) that stores metadata tags associated with the room
3. `event`: An optional TrustedEvent that may contain the event that created or last modified the room

This type is used throughout the room management system and is referenced by several related functions like makeRoomMeta, readRoomMeta, and various event creation functions.

related: TrustedEvent

import/access examples:
import type { RoomMeta } from '@welshman/util';
import type { RoomMeta } from '@welshman/util/Room';


=========================
workspace: packages/util
file: packages/util/src/Room.ts
lines: 18:20
id: 943d0b0dda7baab141a90ec3e9e9d4cfb5c1e424aa235cfd9fd08ba56e751ea9
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Room.ts#L18

declaration:
export type PublishedRoomMeta = Omit<RoomMeta, "event"> & {
  event: TrustedEvent
}

summary:
PublishedRoomMeta is a type that represents a room's metadata after it has been published as an event. It extends the RoomMeta type by requiring the 'event' property to be a TrustedEvent rather than optional.

details:
This type alias is defined as an intersection of:
1. Omit<RoomMeta, "event"> - which takes all properties from RoomMeta except the 'event' property
2. { event: TrustedEvent } - which adds back the 'event' property but makes it required

This transformation ensures that a PublishedRoomMeta always has an associated event, reflecting that it represents room metadata that has been published to the network.

related: RoomMeta,TrustedEvent

import/access examples:
import type { PublishedRoomMeta } from '@welshman/util';
import type { PublishedRoomMeta } from '@welshman/util/Room';


=========================
workspace: packages/util
file: packages/util/src/Room.ts
lines: 22:26
id: 7ee4b149066538345fcb287c7bda3d21d5f155436710a4aeb19be0638eab42ca
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Room.ts#L22

declaration:
makeRoomMeta = (room: Partial<RoomMeta> = {}): RoomMeta => ({
  id: randomId(),
  tags: [],
  ...room,
})

summary:
Creates and returns a new RoomMeta object with default values that can be overridden by the provided partial RoomMeta. If no input is provided, it generates a room with a random ID and empty tags array.

details:
This function initializes a RoomMeta object with:
1. A randomly generated ID using the randomId() utility function
2. An empty tags array ([])
3. Any properties from the optional 'room' parameter spread into the result, which can override the defaults

The implementation uses object spread syntax to merge the default values with any provided values.

related: RoomMeta

import/access examples:
import { makeRoomMeta } from '@welshman/util';
import { makeRoomMeta } from '@welshman/util/Room';


=========================
workspace: packages/util
file: packages/util/src/Room.ts
lines: 28:42
id: 585a17a9d01b0634a93bc7e2c9c9e18d54264afec66f826ec769b620d1436588
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Room.ts#L28

declaration:
readRoomMeta = (event: TrustedEvent): PublishedRoomMeta => {
  if (event.kind !== ROOM_META) {
    throw new Error("Invalid group meta event")
  }

  const id = getIdentifier(event)

  if (!id) {
    throw new Error("Group meta event had no d tag")
  }

  const tags = event.tags.filter(nthNe(0, "d"))

  return {id, tags, event}
}

summary:
Extracts and validates room metadata from a trusted event. Takes a TrustedEvent parameter and returns a PublishedRoomMeta object containing the room's id, tags, and the original event. Throws an error if the event is not of kind ROOM_META or if it doesn't have a valid identifier.

details:
The function performs the following steps:
1. Validates that the input event has the correct kind (ROOM_META)
2. Extracts the room identifier using the getIdentifier helper function
3. Validates that an identifier was found, throwing an error if not
4. Filters the event tags to exclude any with the 'd' tag in the first position
5. Constructs and returns a PublishedRoomMeta object with the extracted id, filtered tags, and the original event

related: TrustedEvent,PublishedRoomMeta

import/access examples:
import { readRoomMeta } from '@welshman/util';
import { readRoomMeta } from '@welshman/util/Room';


=========================
workspace: packages/util
file: packages/util/src/Room.ts
lines: 44:45
id: aeb3916fdcbc8e11adccb64214629cbe9786f3db0e3377e756d1a950a130f1d5
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Room.ts#L44

declaration:
makeRoomCreateEvent = (room: RoomMeta) =>
  makeEvent(ROOM_CREATE, {tags: [["h", room.id]]})

summary:
Creates a room creation event with the specified room metadata. The function takes a RoomMeta object and returns an event of kind ROOM_CREATE that includes the room's ID in the tags.

details:
This function is a simple wrapper around the makeEvent utility. It creates an event with:
1. The ROOM_CREATE kind (imported from Kinds.js)
2. A tags array containing a single tag ['h', room.id] where room.id is the unique identifier of the room

The 'h' tag appears to be used to reference the room in the event system.

related: __function,makeEvent,RoomMeta

import/access examples:
import { makeRoomCreateEvent } from '@welshman/util';
import { makeRoomCreateEvent } from '@welshman/util/Room';


=========================
workspace: packages/util
file: packages/util/src/Room.ts
lines: 47:48
id: 5ebf55ca68635c5519efefcc265d80e120802f98bbe4cf74c898434588e433f3
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Room.ts#L47

declaration:
makeRoomDeleteEvent = (room: RoomMeta) =>
  makeEvent(ROOM_DELETE, {tags: [["h", room.id]]})

summary:
Creates a room deletion event for a given room. This function takes a RoomMeta object and returns an event of kind ROOM_DELETE with a tag referencing the room's ID.

details:
The implementation is straightforward - it uses the makeEvent function to create an event with:
1. The ROOM_DELETE kind (imported from Kinds.js)
2. A configuration object containing a tags array with a single entry: an 'h' tag that contains the room's ID

This creates a properly formatted event that can be used to signal the deletion of a specific room in the system.

related: __function,makeEvent,RoomMeta

import/access examples:
import { makeRoomDeleteEvent } from '@welshman/util';
import { makeRoomDeleteEvent } from '@welshman/util/Room';


=========================
workspace: packages/util
file: packages/util/src/Room.ts
lines: 50:51
id: 504cf89428e73e796b5fb31b8ae2a18fbe22dabd04c864fc7fd766cbd8e18aea
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Room.ts#L50

declaration:
makeRoomEditEvent = (room: RoomMeta) =>
  makeEvent(ROOM_EDIT_META, {tags: [["h", room.id], ...room.tags]})

summary:
Creates an event for editing a room's metadata. Takes a RoomMeta object as input and returns an event of kind ROOM_EDIT_META with tags that include a reference to the room ID and all the room's existing tags.

details:
This function creates a room edit event by:
1. Taking a RoomMeta object as its parameter
2. Calling the makeEvent utility function with:
   - ROOM_EDIT_META as the event kind
   - A tags array that combines:
     - A header tag ['h', room.id] that references the room by its ID
     - All existing tags from the room.tags array using the spread operator

The resulting event can be used to signal changes to a room's metadata in the system.

related: __function,makeEvent,RoomMeta

import/access examples:
import { makeRoomEditEvent } from '@welshman/util';
import { makeRoomEditEvent } from '@welshman/util/Room';


=========================
workspace: packages/util
file: packages/util/src/Room.ts
lines: 53:53
id: 0575cc09e90a426dfbb73a9c6c1b23a838dd268ac2fe0bbd5265df9fc15a1045
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Room.ts#L53

declaration:
makeRoomJoinEvent = (room: RoomMeta) => makeEvent(ROOM_JOIN, {tags: [["h", room.id]]})

summary:
Creates a room join event for a given room. This function takes a RoomMeta object and returns an event of kind ROOM_JOIN with a tag referencing the room's ID.

details:
The implementation is straightforward - it calls the makeEvent function with:
1. The ROOM_JOIN constant as the event kind
2. An options object containing a tags array with a single entry: an 'h' tag that contains the room's ID

This creates an event that signifies a user's intention to join the specified room.

related: __function,makeEvent,RoomMeta

import/access examples:
import { makeRoomJoinEvent } from '@welshman/util';
import { makeRoomJoinEvent } from '@welshman/util/Room';


=========================
workspace: packages/util
file: packages/util/src/Room.ts
lines: 55:56
id: 9a914b2cc5147ef88282d5c142e62ed6d4644ae446ea24c020035a520d7b677d
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Room.ts#L55

declaration:
makeRoomLeaveEvent = (room: RoomMeta) =>
  makeEvent(ROOM_LEAVE, {tags: [["h", room.id]]})

summary:
Creates a room leave event for a given room. This function takes a RoomMeta object and returns a new event of kind ROOM_LEAVE with a tag referencing the room's ID.

details:
The implementation is straightforward - it uses the makeEvent function to create a new event with:
1. The ROOM_LEAVE kind (imported from Kinds.js)
2. A configuration object containing a tags array with a single tag: ['h', room.id] where room.id is the identifier of the room being left

The 'h' tag appears to be used for referencing/linking to the room that the user is leaving.

related: __function,makeEvent,RoomMeta

import/access examples:
import { makeRoomLeaveEvent } from '@welshman/util';
import { makeRoomLeaveEvent } from '@welshman/util/Room';


=========================
workspace: packages/util
file: packages/util/src/Wallet.ts
lines: 1:8
id: b29c23f776ec5042de9a9c718790c574e5efe625af341572a85b19053909b90f
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Wallet.ts#L1

declaration:
export type WebLNInfo = {
  methods?: string[]
  supports?: string[]
  version?: string
  node?: {
    alias: string
  }
}

summary:
A type definition representing information about a WebLN-compatible Lightning wallet. It includes optional properties for supported methods, capabilities, version information, and node details such as the node alias.

import/access examples:
import type { WebLNInfo } from '@welshman/util';
import type { WebLNInfo } from '@welshman/util/Wallet';


=========================
workspace: packages/util
file: packages/util/src/Wallet.ts
lines: 10:16
id: e7cfd6c6fa9c1a697ada948cd6dfbe148600f2efc5209eaa979ca6e39b89188e
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Wallet.ts#L10

declaration:
export type NWCInfo = {
  lud16: string
  secret: string
  relayUrl: string
  walletPubkey: string
  nostrWalletConnectUrl: string
}

summary:
A type definition representing the configuration information needed for a Nostr Wallet Connect (NWC) connection. It includes properties for Lightning Address (lud16), secret key, relay URL, wallet public key, and the complete NWC URL.

details:
This type alias defines the structure of data required to establish and maintain a connection with a Nostr Wallet Connect compatible wallet. The properties include:
1. lud16: A Lightning Address in the format username@domain.com
2. secret: A private key or secret used for authentication
3. relayUrl: The URL of the Nostr relay server to connect to
4. walletPubkey: The public key of the wallet
5. nostrWalletConnectUrl: The complete NWC URL that can be used to establish a connection

import/access examples:
import type { NWCInfo } from '@welshman/util';
import type { NWCInfo } from '@welshman/util/Wallet';


=========================
workspace: packages/util
file: packages/util/src/Wallet.ts
lines: 18:21
id: 9418cb421a6b5e450b6cc1adcb75d294f39922f4b08c09044d08a9233a2f89ee
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Wallet.ts#L18

declaration:
export enum WalletType {
  WebLn = "webln",
  NWC = "nwc",
}

summary:
An enumeration that defines the types of wallets supported by the application. It includes two wallet types: WebLn (for WebLN-compatible wallets) and NWC (for Nostr Wallet Connect).

details:
This is a simple TypeScript enum that serves as a type discriminator in the union type 'Wallet' defined in the same file. The enum values are string literals ('webln' and 'nwc') which are used to identify the wallet type in the application.

import/access examples:
import { WalletType } from '@welshman/util';
import { WalletType } from '@welshman/util/Wallet';


=========================
workspace: packages/util
file: packages/util/src/Wallet.ts
lines: 23:31
id: ad021e4dfb0d16fd01782e675586bebeeb5fd009920cae7d16d183b13fcbc5dc
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Wallet.ts#L23

declaration:
export type Wallet =
  | {
      type: WalletType.WebLn
      info: WebLNInfo
    }
  | {
      type: WalletType.NWC
      info: NWCInfo
    }

summary:
A type alias representing a wallet that can be either a WebLN-compatible wallet or a Nostr Wallet Connect (NWC) wallet. The type uses a discriminated union pattern with the `type` property determining which wallet implementation is being used, and the `info` property containing the corresponding wallet-specific information.

details:
The `Wallet` type is implemented as a TypeScript discriminated union with two possible variants:

1. WebLn wallet: Contains WebLNInfo with optional methods, supports, version, and node information
2. NWC wallet: Contains NWCInfo with required fields for Nostr Wallet Connect including lud16, secret, relayUrl, walletPubkey, and nostrWalletConnectUrl

The type field acts as the discriminant, allowing type-safe access to the appropriate info object based on the wallet type.

related: WebLn,WebLNInfo,NWC,NWCInfo

import/access examples:
import type { Wallet } from '@welshman/util';
import type { Wallet } from '@welshman/util/Wallet';


=========================
type: file
workspace: packages/util
path: packages/util/src/Address.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Address.ts
summary: The Address class represents a Nostr address with kind, pubkey, identifier, and optional relays. It provides methods to create Address instances from string representations, naddr format, or events, as well as conversion methods to string and naddr formats. The module also includes a utility function getAddress to extract an address string from an AddressableEvent.

details: The implementation uses the nostr-tools/nip19 library for encoding and decoding naddr format. The Address class has a simple structure with four readonly properties and several static factory methods:
1. isAddress - validates if a string matches the address pattern
2. from - parses a string address into an Address object
3. fromNaddr - decodes a naddr string into an Address object with error handling
4. fromEvent - extracts address components from an AddressableEvent

The class also includes instance methods toString() and toNaddr() for format conversion. The file defines a local AddressableEvent type to avoid circular dependencies.

=========================
type: file
workspace: packages/util
path: packages/util/src/Blossom.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Blossom.ts
summary: This file provides utilities for interacting with Blossom servers, which handle blob storage in a Nostr context. It exports functions for authentication, checking blob existence, retrieving, uploading, deleting, and listing blobs. It also includes file encryption/decryption utilities using AES-GCM. The main exported functions include makeBlossomAuthEvent, buildBlobUrl, checkBlobExists, getBlob, uploadBlob, deleteBlob, listBlobs, encryptFile, and decryptFile.

details: The implementation revolves around HTTP interactions with Blossom servers:

1. Authentication is handled via makeBlossomAuthEvent which creates a Nostr event with specific tags for authorization.

2. All server interaction functions (checkBlobExists, getBlob, uploadBlob, deleteBlob, listBlobs) follow a similar pattern:
   - They construct appropriate URLs using buildBlobUrl or directly
   - They set up headers, including authorization if provided
   - They use the fetch API to make HTTP requests
   - They handle specific parameters like ranges for partial content retrieval

3. File encryption/decryption uses the Web Crypto API:
   - encryptFile generates an AES-GCM key, encrypts the file, and returns the key, nonce, and ciphertext
   - decryptFile takes the encrypted components and reverses the process
   - Both functions use helper utilities (bytesToHex, hexToBytes) for key/nonce conversion

=========================
type: file
workspace: packages/util
path: packages/util/src/Encryptable.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Encryptable.ts
summary: The Encryptable module provides types and utilities for handling encrypted Nostr events. It exports types like `Encrypt`, `EncryptableUpdates`, and `DecryptedEvent`, along with the `Encryptable` class which allows for creating event templates with encrypted content and tags. The `asDecryptedEvent` function helps convert trusted events into decrypted events with plaintext content.

details: The implementation consists of:
1. Type definitions for encryption-related operations and data structures.
2. The `asDecryptedEvent` utility function that combines a trusted event with its plaintext content.
3. The `Encryptable` class which handles the encryption process through its `reconcile` method. This method:
   - Encrypts content if updates include content
   - Encrypts tags if updates include tags
   - Combines the encrypted data with the original event template
   - Returns a complete event template with encrypted fields

The encryption is performed asynchronously using the provided encrypt function, with Promise.all for parallel processing when needed.

=========================
type: file
workspace: packages/util
path: packages/util/src/Events.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Events.ts
summary: This file provides a comprehensive set of types and utilities for working with Nostr events. It defines a hierarchy of event types (from basic EventContent to SignedEvent), offers functions for event creation, verification, type guards, and attribute manipulation. It also includes utilities for working with event relationships, identifiers, and determining event characteristics based on their kind.

details: The implementation is structured around several key components:

1. Type definitions that form a hierarchy from basic to more complex event types (EventContent → EventTemplate → StampedEvent → OwnedEvent → HashedEvent → SignedEvent/UnwrappedEvent/TrustedEvent).

2. Event verification using WebAssembly when available, with a fallback to pure JavaScript implementation.

3. Type guards (isEventTemplate, isSignedEvent, etc.) that validate if an object conforms to a specific event type.

4. Attribute stripping functions (asEventTemplate, asSignedEvent, etc.) that extract only the relevant properties for each event type.

5. Utility functions for working with event relationships, particularly for handling parent-child relationships between events and extracting identifiers.

6. Integration with other modules like Tags.js, Address.js, and Kinds.js to provide comprehensive event handling capabilities.

=========================
type: file
workspace: packages/util
path: packages/util/src/Filters.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Filters.ts
summary: This file provides utilities for working with Nostr filters. It exports types and functions for creating, matching, combining, and manipulating Filter objects. Key exports include the Filter type definition, matchFilter and matchFilters functions for testing events against filters, and utility functions like unionFilters, intersectFilters, getIdFilters, and getReplyFilters for combining and creating specialized filters. The module also includes helper functions for calculating filter generality, trimming large filters, and handling address-based filtering.

details: The implementation builds on the nostr-tools library's filter matching functionality but extends it with additional features:

1. The Filter type defines the structure of Nostr filters with properties like ids, kinds, authors, etc.

2. matchFilter enhances the base nostr-tools filter matching with search term functionality.

3. Several utility functions handle filter manipulation:
   - getFilterId creates a hash-based identifier for filters
   - calculateFilterGroup groups filters by their properties
   - unionFilters combines multiple filters while handling duplicates
   - intersectFilters combines filter groups with special handling for different property types

4. Specialized filter creation functions:
   - getIdFilters creates filters from a mix of IDs and addresses
   - getReplyFilters creates filters to find replies to events
   - addRepostFilters extends filters to include reposts

5. Filter analysis functions:
   - getFilterGenerality calculates how general/specific a filter is
   - guessFilterDelta estimates time deltas based on filter specificity
   - getFilterResultCardinality estimates result count

6. trimFilter and trimFilters handle large filters by reducing arrays to a maximum of 1000 shuffled items.

=========================
type: file
workspace: packages/util
path: packages/util/src/Handler.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Handler.ts
summary: This module defines the Handler type and provides utility functions for working with handlers in a Nostr-like system. It exports the Handler interface, functions to read handlers from events (readHandlers), generate handler keys (getHandlerKey), display handler names (displayHandler), and extract handler addresses (getHandlerAddress).

details: The implementation revolves around processing TrustedEvent objects and their metadata:

1. The Handler type represents a structured entity with properties like kind, name, about, image, etc.
2. readHandlers extracts handler information from a TrustedEvent by:
   - Parsing the event content as JSON
   - Normalizing metadata fields with fallbacks
   - Filtering out handlers with missing critical information (name/image)
   - Mapping kind tag values to create Handler objects
3. getHandlerKey generates a unique identifier by combining the handler's kind and address
4. displayHandler provides a way to show a handler name with fallback
5. getHandlerAddress extracts address information from event tags, prioritizing tags marked as 'web'

The implementation uses helper functions imported from external libraries and other modules in the project.

=========================
type: file
workspace: packages/util
path: packages/util/src/Kinds.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Kinds.ts
summary: This file defines functions and constants related to Nostr event kinds. It exports functions to check if an event kind is regular, replaceable, ephemeral, or parameterized replaceable. It also provides a comprehensive list of constants representing various Nostr event kinds, such as PROFILE, NOTE, FOLLOWS, and many others, each with their specific numeric value.

details: The implementation consists of:
1. Four main categorization functions that determine the type of event based on its kind number:
   - isRegularKind: Checks if an event is regular (stored by relays)
   - isPlainReplaceableKind: Checks if an event is replaceable (only latest version stored)
   - isEphemeralKind: Checks if an event is ephemeral (not expected to be stored)
   - isParameterizedReplaceableKind: Checks if an event is parameterized replaceable

2. Helper functions:
   - isReplaceableKind: Combines plain and parameterized replaceable checks
   - isDVMKind: Checks if a kind is within the DVM (Decentralized Virtual Machine) range

3. A large collection of exported constants (over 100) that define specific event kinds with their numeric values, organized in ranges according to their categories. These include basic types (0-99), DVM requests/responses (5000-7000), room-related events (9000-9999), user preferences (10000-19999), ephemeral events (20000-29999), and parameterized replaceable events (30000-39999).

4. A few deprecated event kinds are marked at the end of the file.

=========================
type: file
workspace: packages/util
path: packages/util/src/Links.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Links.ts
summary: This file exports two utility functions for handling Nostr URIs: `fromNostrURI` which removes the 'nostr:' prefix from a string, and `toNostrURI` which ensures a string has the 'nostr:' prefix.

details: The implementation is straightforward with two simple string manipulation functions:
1. `fromNostrURI` - Uses regex to remove 'nostr:' or 'nostr://' or 'nostr:/' prefixes from a string
2. `toNostrURI` - Checks if a string already starts with 'nostr:' and if not, prepends it

=========================
type: file
workspace: packages/util
path: packages/util/src/List.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/List.ts
summary: This file provides utilities for managing lists in a Nostr-like system. It exports types like `ListParams`, `List`, and `PublishedList`, along with functions to create, read, update, and manipulate lists. Lists contain public and private tags, and the module provides functionality to add, remove, and filter tags, as well as extract relay information from lists.

details: The implementation revolves around managing encrypted and unencrypted data in lists:

1. Lists contain both public tags (stored in event.tags) and private tags (stored in encrypted event.plaintext.content).
2. The file implements tag validation through `isValidTag` which checks different tag types (p, e, a, t, r, relay).
3. List manipulation functions create new `Encryptable` objects that prepare data for encryption.
4. The module handles selective updates to avoid unnecessary encryption operations.
5. Tag uniqueness is maintained using the `uniqTags` function.
6. Relay extraction is supported with filtering by relay mode.
7. The implementation carefully manages JSON serialization/deserialization for private tags.

=========================
type: file
workspace: packages/util
path: packages/util/src/Nip42.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Nip42.ts
summary: The Nip42.ts file exports a single function `makeRelayAuth` that creates a client authentication event (NIP-42) for Nostr relay authentication. It takes a relay URL and challenge string as parameters and returns an event of kind CLIENT_AUTH with appropriate tags.

details: The implementation is straightforward, using the `makeEvent` function imported from Events.js to create an event with kind CLIENT_AUTH (imported from Kinds.js). The event includes two tags: a 'relay' tag with the provided URL and a 'challenge' tag with the provided challenge string. This follows the NIP-42 specification for relay authentication in the Nostr protocol.

=========================
type: file
workspace: packages/util
path: packages/util/src/Nip86.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Nip86.ts
summary: This file implements NIP-86 (Relay Management), providing an interface for relay management operations. It exports an enum of management methods (ManagementMethod), types for management requests and responses, and a function to send authenticated management requests to a relay.

details: The implementation consists of:
1. An enum (ManagementMethod) listing all supported relay management operations like banning/allowing pubkeys, managing events, changing relay metadata, etc.
2. Type definitions for ManagementRequest (containing method and parameters) and ManagementResponse (containing result or error).
3. A sendManagementRequest function that:
   - Takes a relay URL, request object, and authentication event
   - Makes an HTTP POST request with proper headers including authorization from NIP-98
   - Returns the parsed JSON response or an error object if the request fails

=========================
type: file
workspace: packages/util
path: packages/util/src/Nip98.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Nip98.ts
summary: This file provides functionality for creating Nostr HTTP authentication (NIP-98). It exports two main functions: `makeHttpAuth` for generating HTTP authentication events with URL, method, and optional body hash, and `makeHttpAuthHeader` for converting a signed event into an HTTP Authorization header value in the required format.

details: The implementation uses:
1. Base64 encoding from 'js-base64' library
2. SHA-256 hashing from '@welshman/lib'
3. Event creation utilities from './Events.js'
4. HTTP_AUTH kind constant from './Kinds.js'

The `makeHttpAuth` function creates an event with HTTP_AUTH kind, including tags for URL, HTTP method, and optionally a SHA-256 hash of the request body. The `makeHttpAuthHeader` function takes a signed event and formats it as a Nostr authorization header by Base64-encoding the stringified event.

=========================
type: file
workspace: packages/util
path: packages/util/src/Profile.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Profile.ts
summary: This file provides utilities for handling Nostr user profiles. It exports types like `Profile` and `PublishedProfile`, along with functions to create, read, edit, and display profiles. Key functions include `makeProfile` for creating profiles with Lightning URL processing, `readProfile` for parsing profile data from events, and display utilities like `displayPubkey` and `displayProfile` for user-friendly presentation.

details: The implementation revolves around managing Nostr profile data with Lightning Network payment information support:

1. It defines the `Profile` type with optional fields for user information (name, picture, etc.) and an optional event reference.
2. `PublishedProfile` extends this by requiring the event field, with a type guard `isPublishedProfile`.
3. `makeProfile` processes Lightning addresses (lud06/lud16) to extract and add LNURL payment information.
4. `readProfile` parses profile data from a Nostr event, combining it with LNURL processing.
5. `createProfile` and `editProfile` generate event templates for publishing new or updated profiles.
6. Display utilities include `displayPubkey` for formatting public keys as shortened npub strings and `displayProfile` for showing user-friendly profile names with fallback options.
7. The code uses external utilities from nostr-tools and a custom library for JSON parsing and text formatting.

=========================
type: file
workspace: packages/util
path: packages/util/src/Relay.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Relay.ts
summary: The Relay.ts file exports utilities for handling relay URLs in a Nostr-like system. It defines a RelayMode enum with Read, Write, and Inbox modes, and a RelayProfile type containing metadata about relays. The file provides functions for validating, normalizing, and displaying relay URLs, including special handling for onion addresses, local URLs, and IP addresses.

details: The implementation includes several utility functions:

1. isRelayUrl - Validates if a string is a valid relay URL by checking protocol (must be ws/wss), format constraints, and URL validity
2. isOnionUrl - Detects Tor onion addresses
3. isLocalUrl - Identifies localhost or .local addresses
4. isIPAddress - Checks if URL contains an IP address
5. isShareableRelayUrl - Combines checks to determine if a URL is both valid and shareable (not local)
6. normalizeRelayUrl - Standardizes relay URLs with proper protocol prefixes and formatting
7. displayRelayUrl - Formats URLs for display by removing protocol and trailing slashes
8. displayRelayProfile - Extracts the name from a relay profile or falls back to provided default

The code imports utility functions from an external library (@welshman/lib) for URL manipulation.

=========================
type: file
workspace: packages/util
path: packages/util/src/Room.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Room.ts
summary: This file provides utilities for managing room metadata and creating room-related events in a Nostr-like system. It exports types for room metadata (RoomMeta and PublishedRoomMeta) and functions to create, read, and manipulate room data through various event types (create, delete, edit, join, leave).

details: The implementation revolves around room metadata management and event creation:

1. It imports event kinds constants (ROOM_META, ROOM_CREATE, etc.) from Kinds.js and event utilities from Events.js
2. RoomMeta type defines the core structure with id, tags, and an optional event
3. PublishedRoomMeta is a variant that ensures the event property is required
4. makeRoomMeta creates room metadata with defaults (random ID and empty tags)
5. readRoomMeta extracts room metadata from a TrustedEvent, validating it's a ROOM_META kind
6. Several helper functions (makeRoomCreateEvent, makeRoomDeleteEvent, etc.) create specific event types for room operations
7. All event creation functions use the makeEvent utility and properly format tags with room identifiers

=========================
type: file
workspace: packages/util
path: packages/util/src/Tags.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Tags.ts
summary: The Tags.ts file exports utility functions for working with tags in a Nostr-like protocol. It provides functions to get, filter, and extract values from different types of tags (events, addresses, pubkeys, topics, relays, groups, kinds, comments, replies, emojis). These functions help with parsing and manipulating tag arrays in a standardized way.

details: The implementation consists of numerous small utility functions that follow similar patterns:

1. Most functions filter a tags array (string[][]) based on specific tag types and conditions
2. Many functions come in pairs: one to get the tag arrays and another to extract just the values (usually the second element)
3. The file uses helper functions from an external library (@welshman/lib) like uniqBy, first, nth, etc.
4. More complex tag handling is implemented for comments and replies, which have special logic for determining tag roles (roots, replies, mentions)
5. The implementation handles various Nostr tag types including:
   - Event tags ('e')
   - Address tags ('a')
   - Pubkey tags ('p')
   - Topic tags ('t')
   - Relay tags ('r', 'relay')
   - Group tags ('h', 'group')
   - Kind tags ('k')
   - Comment tags (various types)
   - Emoji tags
6. The file also includes utility functions like uniqTags, tagsFromIMeta, and a tagger factory function

=========================
type: file
workspace: packages/util
path: packages/util/src/Wallet.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Wallet.ts
summary: This file defines TypeScript types for wallet integrations. It exports `WebLNInfo` for WebLN wallet data, `NWCInfo` for Nostr Wallet Connect data, a `WalletType` enum to distinguish between wallet types, and a discriminated union type `Wallet` that combines both wallet types with their respective info structures.

details: The implementation is straightforward with type definitions only:

1. `WebLNInfo` type defines optional properties for WebLN wallets including supported methods, features, version, and node information
2. `NWCInfo` type defines required properties for Nostr Wallet Connect including Lightning address (lud16), secret, relay URL, wallet public key, and connection URL
3. `WalletType` enum provides string literals to identify wallet types
4. `Wallet` is implemented as a discriminated union using the `type` property to determine which info structure is present

=========================
type: file
workspace: packages/util
path: packages/util/src/Zaps.ts
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/Zaps.ts
summary: This file provides utilities for handling Nostr Zaps, a protocol for Lightning Network payments. It exports functions for converting between satoshis and millisatoshis, parsing Lightning Network invoices, handling LNURL addresses, creating and validating zap requests and responses. Key exports include functions for creating zap requests, requesting invoices, validating zaps, and generating filters for zap responses.

details: The implementation includes:
1. Conversion utilities between satoshis and millisatoshis (toMsats, fromMsats)
2. Functions to parse Lightning Network invoice amounts (hrpToMillisat, getInvoiceAmount)
3. LNURL handling with getLnUrl that supports different formats (bech32, URLs, and lud16 addresses)
4. Zap validation logic in zapFromEvent that verifies:
   - Invoice amounts match requested amounts
   - Sender/recipient relationships are valid
   - LNURL tags match expected values
5. Functions to create zap requests (makeZapRequest) with proper tagging
6. An async function (requestZap) that communicates with Lightning payment providers
7. Filter generation for finding zap responses

The code uses BigInt for handling large numbers in millisatoshi calculations and includes validation to prevent invalid amounts.

=========================
type: dir
workspace: packages/util
path: packages/util/src/
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/src/
summary: This directory contains a comprehensive TypeScript implementation of Nostr protocol utilities. It provides classes and functions for working with Nostr events, addresses, filters, profiles, relays, and specialized NIPs (Nostr Implementation Possibilities). Key exports include utilities for event creation and verification, filter manipulation, encryption/decryption, Lightning Network zaps integration, relay management, and HTTP authentication. The codebase implements various Nostr features including blossom blob storage, room management, list handling, and wallet integration. Together, these modules form a cohesive toolkit for building Nostr-compatible applications with type safety and comprehensive protocol support.

=========================
type: dir
workspace: packages/util
path: packages/util/
commit: 80944e64a76c577562875c4e64492df639b42547
link: https://github.com/coracle-social/welshman/blob/80944e64a76c577562875c4e64492df639b42547/packages/util/
summary: This directory contains a comprehensive TypeScript implementation of the Nostr protocol, providing a complete toolkit for building Nostr-compatible applications. It exports utilities for working with Nostr events, addresses, filters, profiles, relays, and implements various Nostr Implementation Possibilities (NIPs). Key features include event creation/verification, encryption/decryption, Lightning Network zaps integration, relay management, HTTP authentication, blossom blob storage, and wallet integration. The library is designed with type safety in mind and offers a cohesive set of tools covering the full spectrum of Nostr protocol functionality.

